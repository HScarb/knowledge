# 现代操作系统 第三章 内存管理

本章讲解内存管理方案

## 1. 无存储器抽象

早先的计算机没有存储器抽象，每一个程序都直接访问物理内存。这种情况下，要想在内存中同时运行两个程序是不可能的。

也有一些办法在无存储器抽象的情况下能够运行多个程序，比如交换功能：把当前内存中所有内容保存到磁盘文件中，然后把下一个程序读入到内存中再运行。

把物理地址暴露给进程的问题：

1. 用户程序可以寻址内存的每个字节，就可以破坏操作系统
2. 想要同时运行多个程序很困难

## 2. 一种存储器抽象：地址空间

### 2.1 地址空间的概念

* 地址空间：一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，且这个地址空间独立于其他进程的地址空间。

地址空间的实现难点在于，如何给每个进程一个独有的地址空间，使得一个进程中的地址 28 所对应的物理地址与另一个程序中的地址 28 所对应的物理地址不同。

#### 基址寄存器与界限寄存器

**动态重定位**是一个简单的解决办法：把每个进程的地址空间映射到物理空间的不同部分。

当一个程序运行时，它的起始物理地址装在到<u>基址寄存器</u>中，长度装载到<u>界限寄存器</u>中。进程访问内存时，CPU 硬件会在把地址发送到内存总线前，自动把<u>基址值</u>加到进程发出的地址值上，同时检查程序提供的地址是否大于等于<u>界限寄存器</u>里的值。如果访问的地址超过界限则会产生错误，终止访问。

<img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202301071702396.png" height="30%" width="30%" />

这个方法的缺点是，每次访问内存都要进行加法和比较运算。其中加法运算会比较慢。

### 2.2 交换技术

把所有进程一直保存在内存中需要巨大的内存，所以前面的方法实际上不太可行。

有两种处理内存超载的通用方法，本节讨论交换技术

1. 交换：把进程完整调入内存运行一段时间，然后存回磁盘。空闲进程主要存储在磁盘上，不运行时不会占用内存。
2. 虚拟内存

---

下图是内存分配情况随着进程进出而变化的图。

其中 (g) 中，进程 A 最后被再次调入。由于 A 的位置发生变化，所以换入时需要通过软件或者在程序运行期间通过硬件对其地址进行重定位。此时就可以用基址寄存器和界限寄存器来处理。

![内存分配情况随着进程进出而变化，阴影区表示未使用的内存](https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202301071705702.png)

#### 内存空洞和内存紧缩

交换会在内存中产生很多空洞，**内存紧缩**技术通过把所有进程的内存尽可能向下移动，把空闲区合成一大块。

通常不进行这个操作，因为会消耗大量 CPU 时间。

#### 进程内存分配

一个问题是，当进程被创建或被换入时应该分配多大的内存。

* 如果进程大小固定不变，则可以按照大小进行分配。
* 如果进程数据段可以增长，如很多语言允许从堆中动态分配内存，那么增长时会出现问题。
  * 进程与空闲区相邻：可以把该空闲区分配给它供其增大
  * 相邻的是另一个进程：
    * 把需要增长的进程移动到内存中另一个足够大的区域
    * 把一个或多个其他相邻进程交换出去，以便生成一个足够大的空闲区
  * 进程在内存中不断增长，且磁盘上的交换区也满了：进程挂起直到有空闲空间 / 结束该进程

#### 额外预留空间

如果大部分进程运行时内存都会增长，为了减少交换和移动产生的开销，可以在换入或者移动进程时为它分配额外的内存。在换出到磁盘上时，只交换进程实际使用的内存中的内容。如下图中 a) 所示。

有的进程会有两个可增长的段，则可以在两者之间预留内存供两个段使用。如下图中 b) 所示。

* 堆：供变量动态分配和释放
* 栈：存档普通局部变量与返回地址

![](https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202301071738187.png)

### 2.3 空闲内存管理

## 3. 虚拟内存

软件大小的增长比存储容器增长更快，交换技术不是一个好的解决方案，因为 SATA 磁盘峰值传输率是几百兆每秒，要好几秒才能换出或者换入一个 1GB 的程序。

虚拟内存的基本思想是：

* 每个程序拥有自己的地址空间，该空间被分割成多块，每块称为一页（page），每页有连续的地址范围。

* 这些页被映射到物理内存，不是所有页都在内存中才能运行程序。

* 当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射
* 当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令

### 3.1 分页

虚拟内存系统中使用分页（paging）技术，程序产生的地址为<u>虚拟地址</u>，它们构成<u>虚拟地址空间</u>。读写操作访问<u>虚拟内存</u>情况下，先将虚拟地址送到<u>内存管理单元（MMU）</u>，MMU 把<u>虚拟地址</u>映射为<u>物理内存地址</u>。如下图所示

<img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202301071801067.png" style="zoom:50%;" />

下图展示这种映射是如何工作的。该计算机能产生 16 位虚拟地址，0~64K-1。只有 32K 物理内存。

虚拟地址空间按固定大小划分成若干<u>页（page）</u>，在物理内存中对应的单元为<u>页框（page frame）</u>。内存与磁盘间的交换总是以整个<u>页</u>为单位进行。

<img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202301071802038.png" style="zoom:50%;" />

MMU 负责将虚拟地址转换成物理地址。在实际硬件中，用一个<u>“在/不在”位（present/absent bit）</u>来记录页在物理内存中是否实际存在。如果不存在，会引发一个 CPU 的<u>缺页中断</u>或<u>缺页错误</u>。

操作系统会找到一个很少使用的 frame，把它的内容写入磁盘，然后把要访问的 page 读到刚才回收的 frame 中，最后重新执行引发中断的指令。

---

下面看一下 MMU 是如何将虚拟地址映射到物理地址的。虚拟地址被分为 4 位的页号和 12 位的偏移量。页号表示页，偏移量表示页内的字节编址。

MMU 通过查询页表的方式，根据页号得出页框号。页表为一个数组，其中存储了虚拟地址的页号对应的物理地址页框号的映射关系，同时也包含<u>“在/不在位”</u>。

如果该位是 1，则从页表中查询出页框号，复制出到输出寄存器的高 3 位，再加上虚拟地址中的低 12 位偏移量，构成了 15 位的物理地址。输出寄存器的内容随即被作为物理地址送到内存总线。

<img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202301080228330.png" style="zoom: 67%;" />

### 3.2 页表

页表项：

<img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202301080234178.png" style="zoom: 50%;" />

## 4. 页面置换算法

<img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202301080249891.png" style="zoom:50%;" />

## 5. 分页系统中的设计问题

讨论使分页系统达到较好的性能，操作系统设计需要考虑的其他问题

### 5.7 内存映射文件

<u>内存映射文件（memory-mapped file）</u>机制的思想：进程可以通过发起一个<u>系统调用</u>，将一个文件映射到其<u>虚拟地址空间</u>的一部分。

* 在映射时共享的<u>页</u>不会实际读入<u>页</u>的内容，而是在访问<u>页</u>时才会被每次一<u>页</u>地读入。
* 进程退出或解除文件映射时，所有改动地页都会写回磁盘文件。

内存映射文件提供了：

* 一种 I/O 的可选模型：可以把一个文件当作内存中的大字符数组来访问，而不用通过读写操作来访问。

* 进程间的高带宽通道：如果多个进程同时映射了同一个文件，它们可以通过共享内存来通信。

