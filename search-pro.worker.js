const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":885,\"nextId\":885,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-4a54ddc6\",\"2\":\"v-4a54ddc6#背景\",\"3\":\"v-4a54ddc6#jmh-的意义\",\"4\":\"v-4a54ddc6#jmh-如何工作\",\"5\":\"v-4a54ddc6#快速开始\",\"6\":\"v-4a54ddc6#安装插件\",\"7\":\"v-4a54ddc6#使用-maven-archtype\",\"8\":\"v-4a54ddc6#引入依赖\",\"9\":\"v-4a54ddc6#编写测试代码\",\"10\":\"v-4a54ddc6#运行测试\",\"11\":\"v-4a54ddc6#查看结果\",\"12\":\"v-4a54ddc6#注释详解\",\"13\":\"v-4a54ddc6#高级用法\",\"14\":\"v-4a54ddc6#将结果图形化\",\"15\":\"v-4a54ddc6#参考资料\",\"16\":\"v-4b50507b\",\"17\":\"v-14c69af4\",\"18\":\"v-7d9c1103\",\"19\":\"v-7d9c1103#顺序编程\",\"20\":\"v-7d9c1103#基本概念\",\"21\":\"v-7d9c1103#erlang-shell\",\"22\":\"v-7d9c1103#整数运算\",\"23\":\"v-7d9c1103#变量\",\"24\":\"v-7d9c1103#浮点数\",\"25\":\"v-7d9c1103#原子\",\"26\":\"v-7d9c1103#元组\",\"27\":\"v-7d9c1103#列表\",\"28\":\"v-7d9c1103#字符串\",\"29\":\"v-7d9c1103#模块与函数\",\"30\":\"v-7d9c1103#模块-module\",\"31\":\"v-7d9c1103#高阶函数-fun\",\"32\":\"v-7d9c1103#实现-for\",\"33\":\"v-7d9c1103#列表处理-sum、map\",\"34\":\"v-7d9c1103#列表推导-f-x-x-l\",\"35\":\"v-7d9c1103#内置函数\",\"36\":\"v-7d9c1103#关卡-when\",\"37\":\"v-7d9c1103#case-表达式\",\"38\":\"v-7d9c1103#if-表达式\",\"39\":\"v-7d9c1103#归集器\",\"40\":\"v-7d9c1103#记录-record-与映射组-map\",\"41\":\"v-7d9c1103#record\",\"42\":\"v-7d9c1103#map\",\"43\":\"v-7d9c1103#顺序程序的错误处理\",\"44\":\"v-7d9c1103#用-try-catch-捕获异常\",\"45\":\"v-7d9c1103#用-catch-捕捉异常错误\",\"46\":\"v-7d9c1103#针对异常的编程样式\",\"47\":\"v-7d9c1103#栈跟踪-erlang-get-stacktrace\",\"48\":\"v-7d9c1103#二进制型与位语法\",\"49\":\"v-7d9c1103#顺序编程补遗\",\"50\":\"v-7d9c1103#apply\",\"51\":\"v-7d9c1103#算数表达式\",\"52\":\"v-7d9c1103#属性\",\"53\":\"v-7d9c1103#预定义模块属性\",\"54\":\"v-7d9c1103#用户定义的模块属性\",\"55\":\"v-7d9c1103#块表达式\",\"56\":\"v-7d9c1103#布尔值-布尔表达式\",\"57\":\"v-7d9c1103#动态代码载入\",\"58\":\"v-7d9c1103#预处理器\",\"59\":\"v-7d9c1103#转义序列\",\"60\":\"v-7d9c1103#函数引用\",\"61\":\"v-7d9c1103#包含文件\",\"62\":\"v-7d9c1103#列表操作-、\",\"63\":\"v-7d9c1103#宏-define\",\"64\":\"v-7d9c1103#宏控制流\",\"65\":\"v-7d9c1103#数字\",\"66\":\"v-7d9c1103#操作符优先级\",\"67\":\"v-7d9c1103#进程字典\",\"68\":\"v-7d9c1103#引用\",\"69\":\"v-7d9c1103#短路布尔表达式\",\"70\":\"v-7d9c1103#比较数据类型\",\"71\":\"v-7d9c1103#类型\",\"72\":\"v-7d9c1103#编译和运行程序\",\"73\":\"v-7d9c1103#改变开发环境\",\"74\":\"v-7d9c1103#运行程序的不同方式\",\"75\":\"v-7d9c1103#makefile-使编译自动化\",\"76\":\"v-7d9c1103#并发和分布式程序\",\"77\":\"v-7d9c1103#现实世界中的并发\",\"78\":\"v-7d9c1103#并发编程\",\"79\":\"v-7d9c1103#基本并发函数\",\"80\":\"v-7d9c1103#客户端-服务器\",\"81\":\"v-7d9c1103#进程很轻巧\",\"82\":\"v-7d9c1103#带超时的接收\",\"83\":\"v-7d9c1103#选择性接收\",\"84\":\"v-7d9c1103#注册进程\",\"85\":\"v-7d9c1103#尾递归的说明\",\"86\":\"v-7d9c1103#分布式编程\",\"87\":\"v-7d9c1103#两种分布式模型\",\"88\":\"v-7d9c1103#编写一个分布式程序\",\"89\":\"v-7d9c1103#编程库与框架\",\"90\":\"v-7d9c1103#接口技术\",\"91\":\"v-7d9c1103#erlang-如何与外部程序通信\",\"92\":\"v-7d9c1103#用端口建立外部-c-程序接口\",\"93\":\"v-7d9c1103#在-erlang-里调用-shell-脚本\",\"94\":\"v-7d9c1103#文件编程\",\"95\":\"v-7d9c1103#套接字编程\",\"96\":\"v-7d9c1103#用-websocket-和-erlang-进行浏览\",\"97\":\"v-7d9c1103#用-ets-和-dets-存储数据\",\"98\":\"v-7d9c1103#表的类型\",\"99\":\"v-7d9c1103#影响-ets-表效率的因素\",\"100\":\"v-7d9c1103#保存元组到磁盘\",\"101\":\"v-7d9c1103#mnesia-erlang-数据库\",\"102\":\"v-7d9c1103#创建初始数据库\",\"103\":\"v-7d9c1103#数据库查询\",\"104\":\"v-7d9c1103#性能分析、调试与跟踪\",\"105\":\"v-7d9c1103#erlang-代码的性能分析工具\",\"106\":\"v-7d9c1103#运行时诊断\",\"107\":\"v-7d9c1103#调试方法\",\"108\":\"v-7d9c1103#io-format-调试\",\"109\":\"v-7d9c1103#转储至文件\",\"110\":\"v-7d9c1103#erlang-调试器\",\"111\":\"v-7d9c1103#跟踪消息与进程执行\",\"112\":\"v-7d9c1103#otp-介绍\",\"113\":\"v-a4b6ad84\",\"114\":\"v-a4b6ad84#arthas-idea-plugin-文档\",\"115\":\"v-a4b6ad84#执行静态方法和-spring-对象方法\",\"116\":\"v-a4b6ad84#spring\",\"117\":\"v-a4b6ad84#直接执行静态方法\",\"118\":\"v-a4b6ad84#使用arthas显式执行代码-避免重启应用-10倍提升本地研发效率\",\"119\":\"v-a4b6ad84#前提\",\"120\":\"v-a4b6ad84#谁拖垮了效率\",\"121\":\"v-a4b6ad84#探索\",\"122\":\"v-a4b6ad84#准备工作\",\"123\":\"v-a4b6ad84#开始起飞\",\"124\":\"v-a4b6ad84#ognl-使用姿势\",\"125\":\"v-85577f20\",\"126\":\"v-85577f20#背景\",\"127\":\"v-85577f20#良药虽好-但也有局限\",\"128\":\"v-85577f20#openchaos-需要解决的本质问题\",\"129\":\"v-85577f20#架构与案例分析\",\"130\":\"v-85577f20#整体架构\",\"131\":\"v-85577f20#检测模型与度量模型\",\"132\":\"v-85577f20#检测模型\",\"133\":\"v-85577f20#度量模型\",\"134\":\"v-85577f20#可靠性案例分析\",\"135\":\"v-85577f20#弹性案例分析\",\"136\":\"v-85577f20#未来规划\",\"137\":\"v-2ccceafc\",\"138\":\"v-2ccceafc#背景\",\"139\":\"v-2ccceafc#显示换行符\",\"140\":\"v-2ccceafc#去除-cr\",\"141\":\"v-e4cb1150\",\"142\":\"v-9b222838\",\"143\":\"v-9b222838#_1-概述\",\"144\":\"v-9b222838#_1-1-为什么要流控\",\"145\":\"v-9b222838#_1-2-rabbitmq-的多种流控机制\",\"146\":\"v-9b222838#_1-2-1-全局流控-内存高水位、磁盘低水位\",\"147\":\"v-9b222838#_1-2-2-进程内流控\",\"148\":\"v-9b222838#_1-2-3-发送方确认\",\"149\":\"v-9b222838#_1-2-4-消费者预取\",\"150\":\"v-9b222838#_2-概要流程\",\"151\":\"v-9b222838#_2-1-信用证配置\",\"152\":\"v-9b222838#_2-2-基于信用证的流控\",\"153\":\"v-9b222838#_3-详细流程\",\"154\":\"v-9b222838#_3-1-流控详细流程\",\"155\":\"v-9b222838#_3-2-如何识别性能瓶颈\",\"156\":\"v-9b222838#_4-源码解析\",\"157\":\"v-9b222838#_4-1-处理消息-减少信用\",\"158\":\"v-9b222838#_4-2-进程阻塞-停止接收信息\",\"159\":\"v-9b222838#_4-3-增加信用值\",\"160\":\"v-9b222838#_4-4-进程解除阻塞\",\"161\":\"v-9b222838#_5-参考资料\",\"162\":\"v-ecdc3a4e\",\"163\":\"v-ecdc3a4e#概述\",\"164\":\"v-ecdc3a4e#使用场景\",\"165\":\"v-ecdc3a4e#federation-种类\",\"166\":\"v-ecdc3a4e#exchange-federation\",\"167\":\"v-ecdc3a4e#queue-federation\",\"168\":\"v-ecdc3a4e#使用前提\",\"169\":\"v-ecdc3a4e#federation-exchange-使用\",\"170\":\"v-ecdc3a4e#upstream-上游集群配置\",\"171\":\"v-ecdc3a4e#downstream-下游集群配置\",\"172\":\"v-ecdc3a4e#测试\",\"173\":\"v-ecdc3a4e#参考资料\",\"174\":\"v-52d766da\",\"175\":\"v-52d766da#_1-erlang-22-x-安装\",\"176\":\"v-52d766da#_1-1-deb-安装包安装\",\"177\":\"v-52d766da#_1-2-apt-安装\",\"178\":\"v-52d766da#_2-安装-rabbitmq\",\"179\":\"v-52d766da#_3-rabbitmq-卸载\",\"180\":\"v-44cd04de\",\"181\":\"v-44cd04de#_1-背景\",\"182\":\"v-44cd04de#_2-镜像队列概述\",\"183\":\"v-44cd04de#_3-使用方法和注意事项\",\"184\":\"v-44cd04de#_3-1-配置方法\",\"185\":\"v-44cd04de#_3-1-1-管理界面配置\",\"186\":\"v-44cd04de#_3-1-2-命令行\",\"187\":\"v-44cd04de#_3-1-3-http-api\",\"188\":\"v-44cd04de#_3-2-镜像队列配置观测\",\"189\":\"v-44cd04de#_3-3-配置参数\",\"190\":\"v-44cd04de#_3-3-1-镜像策略\",\"191\":\"v-44cd04de#_3-3-2-新镜像同步策略\",\"192\":\"v-44cd04de#_3-3-3-从节点晋升策略\",\"193\":\"v-44cd04de#_3-3-4-主队列选择策略\",\"194\":\"v-44cd04de#_3-4-注意事项\",\"195\":\"v-44cd04de#_3-4-1-多少个镜像才是最优的\",\"196\":\"v-44cd04de#_3-4-2-生产者确认和事务\",\"197\":\"v-44cd04de#_3-4-3-流控\",\"198\":\"v-44cd04de#_3-4-4-主节点失效和消费者取消\",\"199\":\"v-44cd04de#_4-镜像队列原理\",\"200\":\"v-44cd04de#_4-1-镜像队列的数据流\",\"201\":\"v-44cd04de#_4-1-1-客户端连接主节点\",\"202\":\"v-44cd04de#_4-1-2-客户端连接从节点\",\"203\":\"v-44cd04de#_4-2-镜像队列的实现原理\",\"204\":\"v-44cd04de#_4-2-1-普通队列结构\",\"205\":\"v-44cd04de#_4-2-2-镜像队列结构\",\"206\":\"v-44cd04de#_4-2-3-gm-guaranteed-multicast\",\"207\":\"v-44cd04de#_4-2-4-消息的广播\",\"208\":\"v-44cd04de#_5-镜像队列实践\",\"209\":\"v-44cd04de#_5-1-镜像队列的缺点\",\"210\":\"v-44cd04de#_5-1-1-设计缺陷-1-broker-离线后重新上线\",\"211\":\"v-44cd04de#_5-1-2-设计缺陷-2-同步阻塞\",\"212\":\"v-44cd04de#参考资料\",\"213\":\"v-e79bef96\",\"214\":\"v-e79bef96#_1-背景\",\"215\":\"v-e79bef96#_2-概述\",\"216\":\"v-e79bef96#_2-1-持久化\",\"217\":\"v-e79bef96#_2-1-1-队列持久化\",\"218\":\"v-e79bef96#_2-1-2-消息的持久化\",\"219\":\"v-e79bef96#_2-2-存储机制\",\"220\":\"v-e79bef96#_2-2-1-存储结构\",\"221\":\"v-e79bef96#_2-2-2-合并机制\",\"222\":\"v-e79bef96#_2-3-队列结构\",\"223\":\"v-e79bef96#rabbitmq中队列的存储状态\",\"224\":\"v-e79bef96#参考资料\",\"225\":\"v-0123c557\",\"226\":\"v-0123c557#镜像队列的设计缺陷\",\"227\":\"v-0123c557#仲裁队列——下一代高可用队列\",\"228\":\"v-0123c557#raft-协议下的消息复制\",\"229\":\"v-0123c557#仲裁队列的优势\",\"230\":\"v-0123c557#仲裁队列的劣势\",\"231\":\"v-0123c557#特性更少\",\"232\":\"v-0123c557#磁盘使用——写入放大\",\"233\":\"v-0123c557#普通队列\",\"234\":\"v-0123c557#仲裁队列\",\"235\":\"v-0123c557#内存使用——所有消息一直保存在内存中\",\"236\":\"v-0123c557#失去多数节点时意味着队列不可用\",\"237\":\"v-0123c557#延迟\",\"238\":\"v-4e9b65d8\",\"239\":\"v-4489d564\",\"240\":\"v-4489d564#概述\",\"241\":\"v-4489d564#优化分析\",\"242\":\"v-4489d564#事务消息日志优化-1\",\"243\":\"v-4489d564#主从复制和同步刷流程中锁的优化-移除-2-4\",\"244\":\"v-4489d564#前置知识-主从复制和同步刷盘中的生产消费模式\",\"245\":\"v-4489d564#优化1-主从复制和同步刷盘中重量级锁synchronized改为自旋锁\",\"246\":\"v-4489d564#优化2-waitnotifyobject-类\",\"247\":\"v-4489d564#消除主从复制中不必要的数组拷贝-5\",\"248\":\"v-4489d564#内存映射文件mmap\",\"249\":\"v-4489d564#主从复制流程概要\",\"250\":\"v-4489d564#优化-减少字节数组拷贝\",\"251\":\"v-4489d564#移除-commitlog-中包含重复代码的-putmessage-putmessages-方法-6\",\"252\":\"v-4489d564#调整消息发送几个参数的默认值-7\",\"253\":\"v-4489d564#消息保存-发送参数优化\",\"254\":\"v-4489d564#事务消息二阶段处理线程大小\",\"255\":\"v-4489d564#开启定时刷盘\",\"256\":\"v-4489d564#优化-putmessage-锁内操作-8-12\",\"257\":\"v-4489d564#优化-asyncputmessage-性能-将准备工作放到锁外\",\"258\":\"v-4489d564#messageid-懒加载\",\"259\":\"v-4489d564#优化消息-header-解析的性能-13-15\",\"260\":\"v-4489d564#去除字符串末尾占位符-节省消息传输大小\",\"261\":\"v-4489d564#优化-string-和-map-互相解析的性能\",\"262\":\"v-4489d564#优化-broker-请求消息头解码性能-15\",\"263\":\"v-4489d564#参考资料\",\"264\":\"v-56a2f3c8\",\"265\":\"v-56a2f3c8#_1-概述\",\"266\":\"v-56a2f3c8#_1-1-consumequeue-是什么\",\"267\":\"v-56a2f3c8#_1-2-consumequeue-的作用\",\"268\":\"v-56a2f3c8#_2-概要设计\",\"269\":\"v-56a2f3c8#_2-1-文件结构\",\"270\":\"v-56a2f3c8#_2-2-构建\",\"271\":\"v-56a2f3c8#_2-3-查询消息\",\"272\":\"v-56a2f3c8#_2-4-刷盘\",\"273\":\"v-56a2f3c8#_2-5-恢复\",\"274\":\"v-56a2f3c8#_3-详细设计\",\"275\":\"v-56a2f3c8#_3-1-文件结构\",\"276\":\"v-56a2f3c8#_3-2-构建\",\"277\":\"v-56a2f3c8#_3-3-查询消息\",\"278\":\"v-56a2f3c8#_3-4-刷盘\",\"279\":\"v-56a2f3c8#_3-5-恢复\",\"280\":\"v-56a2f3c8#_4-源码解析\",\"281\":\"v-56a2f3c8#_4-1-构建\",\"282\":\"v-56a2f3c8#_4-1-1-reputmessageservice-doreput\",\"283\":\"v-56a2f3c8#_4-1-2-defaultmessagestore-dodispatch\",\"284\":\"v-56a2f3c8#_4-1-3-commitlogdispatcherbuildconsumequeue-dispatch\",\"285\":\"v-56a2f3c8#_4-1-4-consumequeue-putmessageposiitoninfo\",\"286\":\"v-56a2f3c8#_4-2-查询消息\",\"287\":\"v-56a2f3c8#_4-2-1-defaultmessagestore-getmessage\",\"288\":\"v-56a2f3c8#_4-3-刷盘\",\"289\":\"v-56a2f3c8#_4-3-1-flushconsumequeueservice-doflush\",\"290\":\"v-56a2f3c8#_4-4-恢复\",\"291\":\"v-56a2f3c8#_4-4-1-consumequeue-recover\",\"292\":\"v-56a2f3c8#_5-更多思考\",\"293\":\"v-56a2f3c8#_5-1-rocketmq-5-x-版本中新的-batch-consume-queue-index\",\"294\":\"v-56a2f3c8#参考资料\",\"295\":\"v-5f598c93\",\"296\":\"v-5f598c93#_1-概述\",\"297\":\"v-5f598c93#_1-1-索引文件是什么\",\"298\":\"v-5f598c93#_1-2-索引文件作用\",\"299\":\"v-5f598c93#_2-概要设计\",\"300\":\"v-5f598c93#_2-1-索引文件结构\",\"301\":\"v-5f598c93#_2-2-如何构建\",\"302\":\"v-5f598c93#_2-3-如何查询消息\",\"303\":\"v-5f598c93#_2-4-刷盘机制\",\"304\":\"v-5f598c93#_3-详细设计\",\"305\":\"v-5f598c93#_3-1-索引文件结构\",\"306\":\"v-5f598c93#_3-1-1-逻辑结构\",\"307\":\"v-5f598c93#_3-1-2-存储结构\",\"308\":\"v-5f598c93#_3-2-索引文件涉及到的类\",\"309\":\"v-5f598c93#indexservice\",\"310\":\"v-5f598c93#indexfile\",\"311\":\"v-5f598c93#_4-源码解析\",\"312\":\"v-5f598c93#_4-1-indexservice\",\"313\":\"v-5f598c93#_4-1-1-创建\",\"314\":\"v-5f598c93#_4-1-2-插入和查询\",\"315\":\"v-5f598c93#_4-1-3-过期删除\",\"316\":\"v-5f598c93#_4-1-4-刷盘\",\"317\":\"v-5f598c93#_4-2-indexfile\",\"318\":\"v-5f598c93#参考资料\",\"319\":\"v-285e1fdf\",\"320\":\"v-285e1fdf#_1-概述\",\"321\":\"v-285e1fdf#_1-1-消息消费方式\",\"322\":\"v-285e1fdf#_1-2-push-消费模式\",\"323\":\"v-285e1fdf#_1-2-1-push-模式原理\",\"324\":\"v-285e1fdf#_1-3-如何进行轮询\",\"325\":\"v-285e1fdf#_1-4-长轮询和短轮询\",\"326\":\"v-285e1fdf#_2-概要流程\",\"327\":\"v-285e1fdf#_3-详细流程\",\"328\":\"v-285e1fdf#_3-1-涉及到的类\",\"329\":\"v-285e1fdf#_3-1-1-pullmessageprocessor\",\"330\":\"v-285e1fdf#_3-1-2-pullrequestholdservice\",\"331\":\"v-285e1fdf#_3-1-3-defaultmessagestore-reputmessageservice\",\"332\":\"v-285e1fdf#_3-2-时序图\",\"333\":\"v-285e1fdf#_3-3-每个类的具体逻辑\",\"334\":\"v-285e1fdf#_3-3-1-pullmessageprocessor\",\"335\":\"v-285e1fdf#_3-3-2-pullrequestholdservice\",\"336\":\"v-285e1fdf#_3-3-3-defaultmessagestore-reputmessageservice\",\"337\":\"v-285e1fdf#_4-源码解析\",\"338\":\"v-285e1fdf#_4-1-pullmessageprocessor\",\"339\":\"v-285e1fdf#_4-1-1-processrequest\",\"340\":\"v-285e1fdf#_4-1-2-executerequestwhenwakeup\",\"341\":\"v-285e1fdf#_4-2-pullrequestholdservice\",\"342\":\"v-285e1fdf#_4-2-1-suspendpullrequest\",\"343\":\"v-285e1fdf#_4-2-2-checkholdrequest\",\"344\":\"v-285e1fdf#_4-2-3-run\",\"345\":\"v-285e1fdf#_4-2-4-notifymessagearriving\",\"346\":\"v-285e1fdf#_4-3-defaultmessagestore-reputmessageservice\",\"347\":\"v-285e1fdf#_4-3-1-doreput\",\"348\":\"v-285e1fdf#_4-3-2-notifymessagearrivinglistener-arriving\",\"349\":\"v-285e1fdf#参考资料\",\"350\":\"v-5ae9d6bb\",\"351\":\"v-5ae9d6bb#_1-概述\",\"352\":\"v-5ae9d6bb#_1-1-定时消息概念\",\"353\":\"v-5ae9d6bb#_1-2-rocketmq中的定时消息支持\",\"354\":\"v-5ae9d6bb#_2-概要流程\",\"355\":\"v-5ae9d6bb#_3-详细流程\",\"356\":\"v-5ae9d6bb#_3-1-定时消息涉及到的类\",\"357\":\"v-5ae9d6bb#_3-2-定时消息时序图\",\"358\":\"v-5ae9d6bb#_3-3-每个类关于定时消息的具体逻辑\",\"359\":\"v-5ae9d6bb#_3-3-1-commitlog\",\"360\":\"v-5ae9d6bb#_3-3-2-schedulemessageservice\",\"361\":\"v-5ae9d6bb#_3-3-3-deliverdelayedmessagetimertask\",\"362\":\"v-5ae9d6bb#_4-源码解析\",\"363\":\"v-5ae9d6bb#_4-1-commitlog\",\"364\":\"v-5ae9d6bb#_4-2-schedulemessageservice\",\"365\":\"v-5ae9d6bb#_4-2-1-deliverdelayedmessagetimertask\",\"366\":\"v-5ae9d6bb#_5-更多思考\",\"367\":\"v-5ae9d6bb#_5-1-为什么不实现任意时间的定时消息\",\"368\":\"v-5ae9d6bb#_5-2-任意时间定时消息实现\",\"369\":\"v-d8040e16\",\"370\":\"v-d8040e16#_1-概述\",\"371\":\"v-d8040e16#_2-改动解析\",\"372\":\"v-d8040e16#_2-1-将多延迟等级延迟消息扫描和投递的任务从单线程执行改为多线程\",\"373\":\"v-d8040e16#_2-2-支持延迟消息异步投递-提升-dledger-模式下的投递性能\",\"374\":\"v-d8040e16#_2-2-1-异步投递的注意点\",\"375\":\"v-d8040e16#_2-2-2-异步投递逻辑\",\"376\":\"v-d8040e16#_3-异步投递详解\",\"377\":\"v-d8040e16#_3-1-定时消息投递线程\",\"378\":\"v-d8040e16#_3-2-投递过程状态更新线程\",\"379\":\"v-d8040e16#_4-源码解析\",\"380\":\"v-d8040e16#_4-1-定时消息投递任务\",\"381\":\"v-d8040e16#_4-2-异步投递过程状态更新任务\",\"382\":\"v-8afca39c\",\"383\":\"v-8afca39c#_1-背景\",\"384\":\"v-8afca39c#_2-概述\",\"385\":\"v-8afca39c#_3-详解\",\"386\":\"v-8afca39c#_3-1-commitlog\",\"387\":\"v-8afca39c#_3-2-consumequeue\",\"388\":\"v-8afca39c#_3-3-indexfile\",\"389\":\"v-8afca39c#_4-源码解析\",\"390\":\"v-8afca39c#_4-1-commitlog\",\"391\":\"v-8afca39c#_4-2-consumequeue\",\"392\":\"v-8afca39c#_4-3-indexfile\",\"393\":\"v-37eec892\",\"394\":\"v-37eec892#背景\",\"395\":\"v-37eec892#实现现高性能-io-的手段\",\"396\":\"v-37eec892#_1-顺序读写\",\"397\":\"v-37eec892#_1-1-顺序写\",\"398\":\"v-37eec892#_1-2-读取消息\",\"399\":\"v-37eec892#_2-页缓存-page-cache\",\"400\":\"v-37eec892#_3-mmap\",\"401\":\"v-37eec892#_4-预分配文件\",\"402\":\"v-37eec892#_5-文件预热\",\"403\":\"v-37eec892#_6-内存级读写分离-transientstorepool\",\"404\":\"v-37eec892#参考资料\",\"405\":\"v-67348692\",\"406\":\"v-67348692#概述\",\"407\":\"v-67348692#性能优化\",\"408\":\"v-67348692#a-移除-messageext-中的反向-dns-查找\",\"409\":\"v-67348692#b-1-优化-rocketmq-通信协议-header-解码性能\",\"410\":\"v-67348692#寻找优化点\",\"411\":\"v-67348692#优化方案\",\"412\":\"v-67348692#b-2-提高编解码性能\",\"413\":\"v-67348692#改动背景\",\"414\":\"v-67348692#优化方法\",\"415\":\"v-67348692#c-缓存-parsechannelremoteaddr-方法的结果\",\"416\":\"v-67348692#寻找优化点-1\",\"417\":\"v-67348692#具体优化方法\",\"418\":\"v-67348692#d-提升-createuniqid-的性能\",\"419\":\"v-67348692#寻找优化点-2\",\"420\":\"v-67348692#优化方法-1\",\"421\":\"v-67348692#e-当没有用到-namespace-时-避免其被多次调用\",\"422\":\"v-67348692#寻找优化点-3\",\"423\":\"v-67348692#优化方法-2\",\"424\":\"v-67348692#f-去除-topic-group-名称的正则匹配检查\",\"425\":\"v-67348692#g-支持发送-batch-消息时支持不同的-topic-queue\",\"426\":\"v-67348692#h-避免无谓的-stringbuilder-扩容\",\"427\":\"v-67348692#i-避免无谓的-stringbuffer-扩容和-string-格式化\",\"428\":\"v-67348692#寻找优化点-4\",\"429\":\"v-67348692#优化方法-3\",\"430\":\"v-67348692#j-在写-consumequeue-和-从节点的-commitlog-时-使用-mmap-而不是-filechannel-提升消息消费-tps\",\"431\":\"v-67348692#寻找优化点-5\",\"432\":\"v-67348692#优化方法-4\",\"433\":\"v-67348692#k-将-notifymessagearriving-的调用从-reputmessageservice-线程移到-pullrequestholdservice-线程\",\"434\":\"v-67348692#寻找优化点-6\",\"435\":\"v-67348692#优化方案-1\",\"436\":\"v-67348692#优化方案-2\",\"437\":\"v-67348692#小结\",\"438\":\"v-6624aa83\",\"439\":\"v-6624aa83#背景\",\"440\":\"v-6624aa83#定时消息和延迟消息是什么\",\"441\":\"v-6624aa83#定时消息的需求和应用场景\",\"442\":\"v-6624aa83#各大消息队列对定时消息支持的现状\",\"443\":\"v-6624aa83#设计和实现\",\"444\":\"v-6624aa83#难点和取舍\",\"445\":\"v-6624aa83#站在巨人的肩膀上\",\"446\":\"v-6624aa83#存储设计\",\"447\":\"v-6624aa83#使用索引文件解决定时消息顺序问题\",\"448\":\"v-6624aa83#消息存储的方案取舍\",\"449\":\"v-6624aa83#存储最终方案\",\"450\":\"v-6624aa83#定时消息投递\",\"451\":\"v-6624aa83#预加载到时间轮\",\"452\":\"v-6624aa83#周期性启动定时任务\",\"453\":\"v-6624aa83#流控\",\"454\":\"v-6624aa83#重投\",\"455\":\"v-6624aa83#定时消息取消\",\"456\":\"v-6624aa83#小结\",\"457\":\"v-6624aa83#华为云-rocketmq-定时消息已经上线\",\"458\":\"v-6624aa83#参考资料\",\"459\":\"v-178be2c0\",\"460\":\"v-178be2c0#_1-概述\",\"461\":\"v-178be2c0#_1-1-nameserver-是什么\",\"462\":\"v-178be2c0#_1-2-nameserver-与-zookeeper\",\"463\":\"v-178be2c0#_2-概要设计\",\"464\":\"v-178be2c0#_2-1-模块\",\"465\":\"v-178be2c0#_2-2-交互\",\"466\":\"v-178be2c0#_3-详细设计\",\"467\":\"v-178be2c0#_3-1-nameserver-启动\",\"468\":\"v-178be2c0#_3-2-路由信息\",\"469\":\"v-178be2c0#_3-2-1-nameserver-端保存的路由信息\",\"470\":\"v-178be2c0#_3-2-2-客户端保存的路由信息\",\"471\":\"v-178be2c0#_3-3-路由注册\",\"472\":\"v-178be2c0#_3-3-1-broker-上报心跳和路由信息\",\"473\":\"v-178be2c0#_3-3-2-nameserver-保存上报的路由信息\",\"474\":\"v-178be2c0#_3-4-路由删除\",\"475\":\"v-178be2c0#_3-5-路由发现-客户端拉取路由信息\",\"476\":\"v-178be2c0#_3-5-1-客户端请求路由信息\",\"477\":\"v-178be2c0#_3-5-2-nameserver-返回路由信息\",\"478\":\"v-178be2c0#_4-源码剖析\",\"479\":\"v-178be2c0#_4-1-nameserver-启动\",\"480\":\"v-178be2c0#_4-1-1-nemesrvstartup\",\"481\":\"v-178be2c0#_4-1-2-namesrvcontroller-启动\",\"482\":\"v-178be2c0#_4-2-路由信息\",\"483\":\"v-178be2c0#_4-2-1-nameserver-路由信息\",\"484\":\"v-178be2c0#topicqueuetable\",\"485\":\"v-178be2c0#brokeraddrtable\",\"486\":\"v-178be2c0#clusteraddrtable\",\"487\":\"v-178be2c0#brokerlivetable\",\"488\":\"v-178be2c0#_4-2-2-客户端路由信息\",\"489\":\"v-178be2c0#_4-3-路由注册\",\"490\":\"v-178be2c0#_4-3-1-broker-上报心跳和路由信息\",\"491\":\"v-178be2c0#_4-3-2-nameserver-保存上报的路由信息\",\"492\":\"v-178be2c0#_4-4-路由删除\",\"493\":\"v-178be2c0#_4-5-路由发现\",\"494\":\"v-178be2c0#参考资料\",\"495\":\"v-0c763d3c\",\"496\":\"v-0c763d3c#_1-背景\",\"497\":\"v-0c763d3c#_2-概述\",\"498\":\"v-0c763d3c#_2-1-基本概念\",\"499\":\"v-0c763d3c#_2-2-基本流程\",\"500\":\"v-0c763d3c#_2-2-1-初始化\",\"501\":\"v-0c763d3c#_2-2-2-发送-处理请求\",\"502\":\"v-0c763d3c#_2-3-使用方法\",\"503\":\"v-0c763d3c#_2-3-1-broker-端配置\",\"504\":\"v-0c763d3c#_2-3-2-生产者使用\",\"505\":\"v-0c763d3c#_2-3-3-消费者使用\",\"506\":\"v-0c763d3c#_3-实现原理\",\"507\":\"v-0c763d3c#_3-1-客户端-aclclientrpchook\",\"508\":\"v-0c763d3c#_3-1-1-注册-aclclientrpchook\",\"509\":\"v-0c763d3c#_3-1-2-aclclientrpchook-的逻辑\",\"510\":\"v-0c763d3c#_3-2-broker-初始化-acl-配置\",\"511\":\"v-0c763d3c#_3-3-broker-权限验证\",\"512\":\"v-0c763d3c#_4-源码解析\",\"513\":\"v-0c763d3c#_4-1-客户端-aclclientrpchook\",\"514\":\"v-0c763d3c#_4-1-1-注册-aclclientrpchook\",\"515\":\"v-0c763d3c#_4-1-2-aclclientrpchook-的逻辑\",\"516\":\"v-0c763d3c#_4-2-broker-初始化-acl-配置\",\"517\":\"v-0c763d3c#_4-2-1-plainpermissonmanager-的字段含义\",\"518\":\"v-0c763d3c#_4-2-2-plainpermissonmanager-load\",\"519\":\"v-0c763d3c#_4-2-3-plainpermissonmanager-watch\",\"520\":\"v-0c763d3c#_4-3-broker-权限验证\",\"521\":\"v-0c763d3c#参考资料\",\"522\":\"v-6175eebc\",\"523\":\"v-6175eebc#_1-背景\",\"524\":\"v-6175eebc#_2-使用示例\",\"525\":\"v-6175eebc#_2-1-broker-端配置\",\"526\":\"v-6175eebc#_2-2-生产者开启消息轨迹\",\"527\":\"v-6175eebc#_2-3-消费者开启消息轨迹\",\"528\":\"v-6175eebc#_2-4-使用-mqadmin-查看消息轨迹\",\"529\":\"v-6175eebc#_2-5-使用-rocketmq-dashboard-查看消息轨迹\",\"530\":\"v-6175eebc#_3-概要设计\",\"531\":\"v-6175eebc#_3-1-主要流程\",\"532\":\"v-6175eebc#_3-2-存储设计\",\"533\":\"v-6175eebc#_4-详细设计\",\"534\":\"v-6175eebc#_4-1-轨迹数据采集\",\"535\":\"v-6175eebc#_4-2-轨迹数据发送\",\"536\":\"v-6175eebc#_5-源码解析\",\"537\":\"v-6175eebc#_5-1-消息轨迹数据模型\",\"538\":\"v-6175eebc#_5-2-消息轨迹数据采集\",\"539\":\"v-6175eebc#_5-2-1-注册消息轨迹采集钩子\",\"540\":\"v-6175eebc#_5-2-2-钩子方法中采集消息轨迹数据\",\"541\":\"v-6175eebc#_5-3-消息轨迹数据发送\",\"542\":\"v-6175eebc#参考资料\",\"543\":\"v-9e6b5c72\",\"544\":\"v-9e6b5c72#_1-背景\",\"545\":\"v-9e6b5c72#_2-概述\",\"546\":\"v-9e6b5c72#_2-1-消息发送方式和特殊消息\",\"547\":\"v-9e6b5c72#_2-1-1-三种消息发送方式\",\"548\":\"v-9e6b5c72#_2-1-2-特殊消息类型\",\"549\":\"v-9e6b5c72#_2-2-路由机制\",\"550\":\"v-9e6b5c72#_2-3-消息发送流程\",\"551\":\"v-9e6b5c72#_2-4-高可用设计\",\"552\":\"v-9e6b5c72#_2-4-1-生产者高可用\",\"553\":\"v-9e6b5c72#_2-4-2-broker-端高可用\",\"554\":\"v-9e6b5c72#_3-详细设计\",\"555\":\"v-9e6b5c72#_3-1-消息\",\"556\":\"v-9e6b5c72#_3-2-生产者类图\",\"557\":\"v-9e6b5c72#_3-3-生产者启动\",\"558\":\"v-9e6b5c72#_3-4-消息发送\",\"559\":\"v-9e6b5c72#_3-4-1-查找-topic-路由信息\",\"560\":\"v-9e6b5c72#_3-4-2-重试机制\",\"561\":\"v-9e6b5c72#_3-4-3-选择消息队列-故障延迟机制\",\"562\":\"v-9e6b5c72#_3-4-4-发送消息\",\"563\":\"v-9e6b5c72#_3-5-broker-处理发送请求\",\"564\":\"v-9e6b5c72#_3-6-batch-消息-批量消息\",\"565\":\"v-9e6b5c72#_4-源码解析\",\"566\":\"v-9e6b5c72#_4-1-生产者启动\",\"567\":\"v-9e6b5c72#_4-1-1-defaultmqproducerimpl-start\",\"568\":\"v-9e6b5c72#_4-1-2-mqclientexception\",\"569\":\"v-9e6b5c72#_4-2-消息发送\",\"570\":\"v-9e6b5c72#_4-2-1-消息发送实现\",\"571\":\"v-9e6b5c72#_4-2-2-查找路由信息\",\"572\":\"v-9e6b5c72#_4-2-3-选择消息队列\",\"573\":\"v-9e6b5c72#_4-2-4-发送消息-api-核心入口\",\"574\":\"v-9e6b5c72#_4-3-broker-处理发送请求\",\"575\":\"v-9e6b5c72#_4-3-1-broker-注册发送消息处理器\",\"576\":\"v-9e6b5c72#_4-3-2-发送消息处理器处理\",\"577\":\"v-9e6b5c72#参考资料\",\"578\":\"v-62f7b2da\",\"579\":\"v-62f7b2da#背景\",\"580\":\"v-62f7b2da#概要设计\",\"581\":\"v-62f7b2da#整体流程\",\"582\":\"v-62f7b2da#详细设计\",\"583\":\"v-62f7b2da#整体流程顺序图\",\"584\":\"v-62f7b2da#类设计\",\"585\":\"v-62f7b2da#memorymessagestore\",\"586\":\"v-62f7b2da#topicconfig\",\"587\":\"v-62f7b2da#brokercontroller\",\"588\":\"v-977ad6b2\",\"589\":\"v-977ad6b2#背景\",\"590\":\"v-977ad6b2#环境准备\",\"591\":\"v-977ad6b2#镜像准备\",\"592\":\"v-977ad6b2#本地构建-rocketmq-docker-镜像\",\"593\":\"v-977ad6b2#拉取远程\",\"594\":\"v-977ad6b2#docker-启动-rocketmq\",\"595\":\"v-977ad6b2#用-docker-compose-以集群模式启动-rocketmq\",\"596\":\"v-977ad6b2#使用-docker-启动-rocketmq-dashboard\",\"597\":\"v-977ad6b2#用-docker-单独启动-rocketmq-dashboard\",\"598\":\"v-977ad6b2#与集群一起用-docker-compose-启动-docker-dashboard\",\"599\":\"v-977ad6b2#docker-启动-dledger-模式的-rocketmq\",\"600\":\"v-977ad6b2#修改内存配置\",\"601\":\"v-977ad6b2#dledger-与-dashboard-同时启动\",\"602\":\"v-977ad6b2#以其他部署形式启动-rocketmq\",\"603\":\"v-977ad6b2#docker-启动单节点-rocketmq\",\"604\":\"v-977ad6b2#docker-启动带-tls-的-rocketmq\",\"605\":\"v-fe397c88\",\"606\":\"v-fe397c88#_1-背景\",\"607\":\"v-fe397c88#_2-概念简述\",\"608\":\"v-fe397c88#_2-1-消费组概念与消费模式\",\"609\":\"v-fe397c88#_2-1-1-消费组\",\"610\":\"v-fe397c88#_2-1-2-广播消费模式-broadcasting\",\"611\":\"v-fe397c88#_2-1-3-集群消费模式-clustering\",\"612\":\"v-fe397c88#_2-2-消费者拉取消息模式\",\"613\":\"v-fe397c88#_2-2-1-pull\",\"614\":\"v-fe397c88#_2-2-2-push\",\"615\":\"v-fe397c88#_2-2-3-pop\",\"616\":\"v-fe397c88#_2-3-队列负载机制与重平衡\",\"617\":\"v-fe397c88#_2-3-1-队列负载机制\",\"618\":\"v-fe397c88#_2-3-2-重平衡-rebalance\",\"619\":\"v-fe397c88#_2-4-消费端高可靠\",\"620\":\"v-fe397c88#_2-4-1-重试-死信机制\",\"621\":\"v-fe397c88#_2-4-2-队列负载机制与重平衡\",\"622\":\"v-fe397c88#_2-5-并发消费与顺序消费\",\"623\":\"v-fe397c88#_2-6-消费进度保存和提交\",\"624\":\"v-fe397c88#_3-消费流程\",\"625\":\"v-fe397c88#参考资料\",\"626\":\"v-d66de8c8\",\"627\":\"v-d66de8c8#_1-背景\",\"628\":\"v-d66de8c8#_2-概要设计\",\"629\":\"v-d66de8c8#_2-1-消费者客户端设计\",\"630\":\"v-d66de8c8#_2-2-消费者客户端启动\",\"631\":\"v-d66de8c8#_2-2-1-新建消费者\",\"632\":\"v-d66de8c8#_2-2-2-消费者启动\",\"633\":\"v-d66de8c8#_3-详细设计\",\"634\":\"v-d66de8c8#_3-1-消费者客户端类设计\",\"635\":\"v-d66de8c8#_3-1-1-整体类图\",\"636\":\"v-d66de8c8#_3-1-2-消费者接口\",\"637\":\"v-d66de8c8#_3-1-3-拉-推模式消费者接口\",\"638\":\"v-d66de8c8#_3-1-4-消费者实现\",\"639\":\"v-d66de8c8#_3-1-5-推模式消费者实现\",\"640\":\"v-d66de8c8#_3-2-消费者启动\",\"641\":\"v-d66de8c8#_4-源码解析\",\"642\":\"v-d66de8c8#_4-1-defaultmqproducerimpl-启动\",\"643\":\"v-d66de8c8#_4-2-mqclientinstance-启动\",\"644\":\"v-a5c93210\",\"645\":\"v-a5c93210#_1-背景\",\"646\":\"v-a5c93210#_1-1-重平衡的含义\",\"647\":\"v-a5c93210#_2-概要设计\",\"648\":\"v-a5c93210#_2-1-重平衡的触发\",\"649\":\"v-a5c93210#_2-2-重平衡类设计\",\"650\":\"v-a5c93210#_2-3-重平衡流程\",\"651\":\"v-a5c93210#_3-详细设计\",\"652\":\"v-a5c93210#_3-1-重平衡实现类-rebalanceimpl\",\"653\":\"v-a5c93210#_3-1-1-域\",\"654\":\"v-a5c93210#_3-1-2-方法\",\"655\":\"v-a5c93210#_3-2-重平衡流程\",\"656\":\"v-a5c93210#_3-2-1-重平衡触发\",\"657\":\"v-a5c93210#_3-2-2-重平衡流程\",\"658\":\"v-a5c93210#_3-3-重平衡队列分配策略\",\"659\":\"v-a5c93210#_4-源码解析\",\"660\":\"v-a5c93210#_4-1-rebalanceservice-重平衡线程\",\"661\":\"v-a5c93210#_4-2-rebalanceimpl-重平衡实现\",\"662\":\"v-a5c93210#_4-2-1-dorebalance-重平衡入口\",\"663\":\"v-a5c93210#_4-2-2-rebalancebytopic-对-topic-进行重平衡\",\"664\":\"v-a5c93210#_4-2-3-updateprocessqueuetableinrebalance-重平衡后更新订阅的队列和处理队列表\",\"665\":\"v-a5c93210#_4-2-4-messagequeuechanged\",\"666\":\"v-041d67ca\",\"667\":\"v-041d67ca#_1-背景\",\"668\":\"v-041d67ca#_2-概要设计\",\"669\":\"v-041d67ca#_2-1-交互流程\",\"670\":\"v-041d67ca#_2-2-客户端拉取流程设计\",\"671\":\"v-041d67ca#_2-2-1-拉模式消费者拉取\",\"672\":\"v-041d67ca#_2-2-2-推模式消费者拉取\",\"673\":\"v-041d67ca#_2-3-broker-端拉取流程设计\",\"674\":\"v-041d67ca#_3-详细设计\",\"675\":\"v-041d67ca#_3-1-相关类设计\",\"676\":\"v-041d67ca#_3-2-整体流程\",\"677\":\"v-041d67ca#_3-2-1-消费者拉取消息\",\"678\":\"v-041d67ca#_3-2-1-1-pullmessageservice\",\"679\":\"v-041d67ca#_3-2-1-2-defaultmqpushconsumerimpl\",\"680\":\"v-041d67ca#_3-2-1-3-pullapiwrapper\",\"681\":\"v-041d67ca#_3-2-1-4-mqclientapiimpl\",\"682\":\"v-041d67ca#_3-2-2-broker-端处理拉取请求\",\"683\":\"v-041d67ca#_3-2-2-1-pullmessageprocessor\",\"684\":\"v-041d67ca#_3-2-2-2-defaultmessagestore\",\"685\":\"v-041d67ca#_3-2-3-消费者拉取成功结果处理\",\"686\":\"v-041d67ca#_4-源码解析\",\"687\":\"v-041d67ca#_4-1-消费者拉取消息\",\"688\":\"v-041d67ca#_4-1-1-pullmessageservice-消息拉取线程\",\"689\":\"v-041d67ca#_4-1-2-pullrequest-消息拉取请求\",\"690\":\"v-041d67ca#_4-1-3-defaultmqpushconsumerimpl\",\"691\":\"v-041d67ca#_4-1-4-pullapiwrapper\",\"692\":\"v-041d67ca#_4-1-5-mqclientinstance\",\"693\":\"v-041d67ca#_4-1-6-pullmessageprocessor\",\"694\":\"v-041d67ca#_4-1-7-defaultmessagestore\",\"695\":\"v-041d67ca#_4-1-8-pullcallback\",\"696\":\"v-c0655cf8\",\"697\":\"v-c0655cf8#_1-背景\",\"698\":\"v-c0655cf8#_2-概要设计\",\"699\":\"v-c0655cf8#_2-1-推模式并发消费交互流程\",\"700\":\"v-c0655cf8#_2-2-重试消费设计\",\"701\":\"v-c0655cf8#_2-3-消费进度管理设计\",\"702\":\"v-c0655cf8#_2-3-1-广播模式消费进度管理\",\"703\":\"v-c0655cf8#_2-3-2-集群模式消费进度管理\",\"704\":\"v-c0655cf8#_2-3-3-消费者更新消费进度\",\"705\":\"v-c0655cf8#_3-详细设计\",\"706\":\"v-c0655cf8#_3-1-推模式并发消费\",\"707\":\"v-c0655cf8#_3-1-1-消息消费类设计\",\"708\":\"v-c0655cf8#_3-1-2-推模式并发消费流程\",\"709\":\"v-c0655cf8#_3-2-消费进度管理\",\"710\":\"v-c0655cf8#_3-2-1-消费进度管理类设计\",\"711\":\"v-c0655cf8#_3-2-2-消费进度更新流程\",\"712\":\"v-c0655cf8#_4-源码解析\",\"713\":\"v-c0655cf8#_4-1-推模式并发消费\",\"714\":\"v-c0655cf8#_4-1-1-并发消费服务提交消费请求\",\"715\":\"v-c0655cf8#_4-1-2-消费请求运行、处理结果\",\"716\":\"v-c0655cf8#_4-2-重试消费\",\"717\":\"v-c0655cf8#_4-2-1-消费者消费失败-将消息发回-broker\",\"718\":\"v-c0655cf8#_4-2-2-broker-端处理客户端发回的消息\",\"719\":\"v-c0655cf8#_4-3-消费进度管理\",\"720\":\"v-c0655cf8#_4-3-1-客户端消费进度管理器持久化消费进度\",\"721\":\"v-c0655cf8#_4-3-2-broker-端消费进度管理器\",\"722\":\"v-495b4ee9\",\"723\":\"v-495b4ee9#_1-背景\",\"724\":\"v-495b4ee9#_2-概要设计\",\"725\":\"v-495b4ee9#_2-1-消费线程池逻辑\",\"726\":\"v-495b4ee9#_2-1-1-消费线程池顺序消费\",\"727\":\"v-495b4ee9#_2-1-2-保证一个队列同时仅被一个消费线程消费\",\"728\":\"v-495b4ee9#_2-2-重平衡时顺序消费\",\"729\":\"v-495b4ee9#_2-2-1-broker-管理的分布式锁\",\"730\":\"v-495b4ee9#_3-详细设计\",\"731\":\"v-495b4ee9#_3-1-broker锁\",\"732\":\"v-495b4ee9#_3-1-1-设计\",\"733\":\"v-495b4ee9#_3-1-2-加解锁时机\",\"734\":\"v-495b4ee9#_3-1-3-加解锁流程\",\"735\":\"v-495b4ee9#_3-1-4-边界条件-消费消息时重平衡\",\"736\":\"v-495b4ee9#_3-2-消费线程池顺序消费逻辑\",\"737\":\"v-495b4ee9#_3-2-1-消费线程池顺序消费设计\",\"738\":\"v-495b4ee9#_3-2-2-消费线程池顺序消费任务流程\",\"739\":\"v-495b4ee9#_3-3-顺序消费流程\",\"740\":\"v-495b4ee9#_4-源码解析\",\"741\":\"v-495b4ee9#_4-1-broker锁\",\"742\":\"v-495b4ee9#_4-1-1-broker锁-管理器\",\"743\":\"v-495b4ee9#_4-1-2-消费者解锁-加锁\",\"744\":\"v-495b4ee9#_4-1-2-1-重平衡后更新处理队列\",\"745\":\"v-495b4ee9#_4-1-2-2-消息队列解锁\",\"746\":\"v-495b4ee9#_4-1-2-3-消息队列加锁\",\"747\":\"v-495b4ee9#_4-2-消息拉取\",\"748\":\"v-495b4ee9#_4-2-1-消息拉取\",\"749\":\"v-495b4ee9#_4-2-2-消息拉取成功\",\"750\":\"v-495b4ee9#_4-3-顺序消费任务\",\"751\":\"v-61f53d7d\",\"752\":\"v-61f53d7d#生产者\",\"753\":\"v-61f53d7d#发送重试\",\"754\":\"v-61f53d7d#延迟故障规避\",\"755\":\"v-61f53d7d#同一进程中多个生产者发送消息到多个集群\",\"756\":\"v-61f53d7d#消费者\",\"757\":\"v-61f53d7d#消费幂等\",\"758\":\"v-61f53d7d#消费组线程数\",\"759\":\"v-61f53d7d#避免订阅关系不一致导致消息丢失\",\"760\":\"v-61f53d7d#避免-clientid-相同\",\"761\":\"v-61f53d7d#消费重试次数\",\"762\":\"v-61f53d7d#broker\",\"763\":\"v-461d8dc0\",\"764\":\"v-461d8dc0#_1-背景\",\"765\":\"v-461d8dc0#_1-1-什么是-pop-消费\",\"766\":\"v-461d8dc0#_1-2-如何使用-pop-消费\",\"767\":\"v-461d8dc0#_1-2-1-使用命令行方式切换\",\"768\":\"v-461d8dc0#_1-2-2-代码切换\",\"769\":\"v-461d8dc0#_1-3-引入-pop-消费模式的原因\",\"770\":\"v-461d8dc0#_2-概要设计\",\"771\":\"v-461d8dc0#_2-1-pop-消费流程\",\"772\":\"v-461d8dc0#_2-2-客户端-服务端交互\",\"773\":\"v-461d8dc0#_2-3-服务端实现\",\"774\":\"v-461d8dc0#_3-详细设计\",\"775\":\"v-461d8dc0#_3-1-broker-端重平衡\",\"776\":\"v-461d8dc0#_3-2-broker-端-pop-消息\",\"777\":\"v-461d8dc0#_3-2-1-请求处理入口\",\"778\":\"v-461d8dc0#_3-2-2-pop-消息方法\",\"779\":\"v-461d8dc0#_3-2-3-保存-checkpoint-用于匹配\",\"780\":\"v-461d8dc0#_3-3-broker-端-ack-消息\",\"781\":\"v-461d8dc0#_3-4-broker-端-checkpoint-与-ackmsg-匹配\",\"782\":\"v-461d8dc0#_3-4-1-内存匹配\",\"783\":\"v-461d8dc0#_3-4-2-store-匹配和消息重试\",\"784\":\"v-461d8dc0#_4-源码解析\",\"785\":\"v-461d8dc0#_4-1-broker-端重平衡\",\"786\":\"v-461d8dc0#_4-1-1-queryassignmentprocessor-doloadbalance\",\"787\":\"v-461d8dc0#_4-1-2-queryassignmentprocessor-allocate4pop\",\"788\":\"v-461d8dc0#_4-2-broker-端-pop-消息\",\"789\":\"v-461d8dc0#_4-2-1-popmessageprocessor-processrequest\",\"790\":\"v-461d8dc0#_4-2-2-popmessageprocessor-popmsgfromqueue\",\"791\":\"v-461d8dc0#_4-2-3-popmessageprocessor-appendcheckpoint\",\"792\":\"v-461d8dc0#_4-3-broker-端-ack-消息\",\"793\":\"v-461d8dc0#_4-3-1-ackmessageprocessor-processrequest\",\"794\":\"v-461d8dc0#_4-4-broker-端-checkpoint-与-ackmsg-匹配\",\"795\":\"v-461d8dc0#_4-4-1-popbuffermergeservice-addck\",\"796\":\"v-461d8dc0#_4-4-2-popbuffermergeservice-addak\",\"797\":\"v-461d8dc0#_4-4-3-popbuffermergeservice-scan\",\"798\":\"v-461d8dc0#_4-4-4-popreviveservice-consumerevivemessage\",\"799\":\"v-461d8dc0#_4-4-5-popreviveservice-mergeandrevive\",\"800\":\"v-461d8dc0#_4-4-6-popreviveservice-重试消息\",\"801\":\"v-461d8dc0#参考资料\",\"802\":\"v-589d225e\",\"803\":\"v-589d225e#_1-背景\",\"804\":\"v-589d225e#_1-1-引入原因\",\"805\":\"v-589d225e#_1-2-使用方法\",\"806\":\"v-589d225e#_1-2-1-broker-启动配置\",\"807\":\"v-589d225e#_1-2-2-生产消息\",\"808\":\"v-589d225e#_1-2-3-消费消息\",\"809\":\"v-589d225e#_2-概要设计\",\"810\":\"v-589d225e#_2-1-当前痛点\",\"811\":\"v-589d225e#_2-1-实现思想\",\"812\":\"v-589d225e#_3-详细设计\",\"813\":\"v-589d225e#_3-1-消息生产和消费\",\"814\":\"v-589d225e#_3-2-commitlog-分发到-lmq\",\"815\":\"v-589d225e#_4-源码解析\",\"816\":\"v-589d225e#_4-1-查询-lmq-偏移量\",\"817\":\"v-589d225e#_4-2-分发-lmq\",\"818\":\"v-589d225e#参考资料\",\"819\":\"v-bdb85802\",\"820\":\"v-bdb85802#write-buffer-water-mark\",\"821\":\"v-18304210\",\"822\":\"v-18304210#_1-背景\",\"823\":\"v-18304210#_1-1-rocketmq-支持的过滤方式\",\"824\":\"v-18304210#_1-2-使用方法\",\"825\":\"v-18304210#_1-2-1-tag-过滤\",\"826\":\"v-18304210#生产者\",\"827\":\"v-18304210#消费者\",\"828\":\"v-18304210#_1-2-2-sql92\",\"829\":\"v-18304210#生产者-1\",\"830\":\"v-18304210#消费者-1\",\"831\":\"v-18304210#_2-概要设计\",\"832\":\"v-18304210#_2-1-过滤信息的注册\",\"833\":\"v-18304210#_2-2-表达式过滤\",\"834\":\"v-18304210#_2-2-1-tag-过滤\",\"835\":\"v-18304210#_2-2-2-sql92-过滤\",\"836\":\"v-18304210#_3-详细设计\",\"837\":\"v-18304210#_3-1-过滤信息注册\",\"838\":\"v-18304210#_3-2-过滤器接口\",\"839\":\"v-18304210#_3-3-tag-过滤\",\"840\":\"v-18304210#_3-4-sql92-过滤\",\"841\":\"v-18304210#_3-4-1-编译-sql-语句\",\"842\":\"v-18304210#_3-4-2-布隆过滤器-bloomfilter\",\"843\":\"v-18304210#_3-4-3-生成布隆过滤器位数组\",\"844\":\"v-18304210#_3-4-4-消息过滤\",\"845\":\"v-18304210#_4-源码解析\",\"846\":\"v-18304210#_4-1-tag-过滤\",\"847\":\"v-18304210#_4-1-1-broker-端过滤\",\"848\":\"v-18304210#_4-1-2-客户端过滤\",\"849\":\"v-18304210#_4-2-sql92-过滤\",\"850\":\"v-18304210#_4-2-1-注册过滤信息\",\"851\":\"v-18304210#_4-2-2-消息生产时构建布隆过滤器数据\",\"852\":\"v-18304210#_4-2-3-消息拉取时过滤\",\"853\":\"v-18304210#参考资料\",\"854\":\"v-a7ffda38\",\"855\":\"v-30f669eb\",\"856\":\"v-30f669eb#背景\",\"857\":\"v-30f669eb#用户态和内核态\",\"858\":\"v-30f669eb#参考资料\",\"859\":\"v-d2480bb6\",\"860\":\"v-d2480bb6#_1-背景\",\"861\":\"v-d2480bb6#_2-概述\",\"862\":\"v-d2480bb6#_2-1-mappedfile-的创建\",\"863\":\"v-d2480bb6#_2-2-mappedfile-的写入\",\"864\":\"v-d2480bb6#_2-3-mappedfile-刷盘\",\"865\":\"v-d2480bb6#_2-4\",\"866\":\"v-d2480bb6#_3-详解\",\"867\":\"v-d2480bb6#_4-代码\",\"868\":\"v-d2480bb6#_5-参考资料\",\"869\":\"v-715e41b9\",\"870\":\"v-715e41b9#_1-背景\",\"871\":\"v-715e41b9#_1-1-概念和应用场景\",\"872\":\"v-715e41b9#_1-2-延迟消息与定时消息\",\"873\":\"v-715e41b9#_1-2-任意时间定时消息的使用\",\"874\":\"v-715e41b9#_2-概述\",\"875\":\"v-715e41b9#_2-1-任意时间定时消息的难点\",\"876\":\"v-715e41b9#_2-1-1-难点1-任意的定时时间\",\"877\":\"v-715e41b9#_2-1-2-难点2-定时消息的存储和老化\",\"878\":\"v-715e41b9#_2-1-3-难点3-大量定时消息的极端情况\",\"879\":\"v-715e41b9#_2-2-设计思路\",\"880\":\"v-715e41b9#_2-2-1-任意时间定时\",\"881\":\"v-715e41b9#_2-2-2\",\"882\":\"v-715e41b9#_3\",\"883\":\"v-715e41b9#参考资料\",\"884\":\"v-40f554de\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,6],\"1\":[4,9],\"2\":[1,48],\"3\":[2,15],\"4\":[3,33],\"5\":[1],\"6\":[1,8],\"7\":[3,37],\"8\":[1,28],\"9\":[1,76],\"10\":[1,17],\"11\":[1,162],\"12\":[1,5],\"13\":[1,3],\"14\":[1],\"15\":[1,29],\"16\":[3,38],\"17\":[1,4],\"18\":[2,10],\"19\":[1],\"20\":[1],\"21\":[2,188],\"22\":[1,14],\"23\":[1,38],\"24\":[1,25],\"25\":[1,13],\"26\":[1,31],\"27\":[1,62],\"28\":[1,63],\"29\":[1],\"30\":[2,86],\"31\":[2,84],\"32\":[2,37],\"33\":[4,20],\"34\":[7,85],\"35\":[1,22],\"36\":[3,61],\"37\":[2,50],\"38\":[2,36],\"39\":[1,25],\"40\":[5,9],\"41\":[1,64],\"42\":[1,61],\"43\":[1,61],\"44\":[4,66],\"45\":[3,50],\"46\":[1,36],\"47\":[5],\"48\":[1],\"49\":[1],\"50\":[1,21],\"51\":[1],\"52\":[1,5],\"53\":[1,18],\"54\":[1,12],\"55\":[1,8],\"56\":[2,9],\"57\":[1,12],\"58\":[1,11],\"59\":[1,2],\"60\":[1,9],\"61\":[1,18],\"62\":[3,13],\"63\":[3,28],\"64\":[1,7],\"65\":[1,25],\"66\":[1],\"67\":[1,32],\"68\":[1,11],\"69\":[1,6],\"70\":[1],\"71\":[1],\"72\":[1],\"73\":[1,11],\"74\":[1,36],\"75\":[2],\"76\":[1],\"77\":[1,6],\"78\":[1,2],\"79\":[1,36],\"80\":[2,78],\"81\":[1,8],\"82\":[1,17],\"83\":[1,6],\"84\":[1,24],\"85\":[1,28],\"86\":[1],\"87\":[1,20],\"88\":[1,8],\"89\":[1],\"90\":[1],\"91\":[2,26],\"92\":[3],\"93\":[5,5],\"94\":[1],\"95\":[1],\"96\":[5],\"97\":[5,29],\"98\":[1,62],\"99\":[3,6],\"100\":[1],\"101\":[3,11],\"102\":[1,36],\"103\":[1,176],\"104\":[2],\"105\":[2,43],\"106\":[1,34],\"107\":[1],\"108\":[3,9],\"109\":[1,22],\"110\":[2],\"111\":[1,59],\"112\":[2,25],\"113\":[2,10],\"114\":[4,8],\"115\":[3,9],\"116\":[1,60],\"117\":[1,16],\"118\":[3,7],\"119\":[1,5],\"120\":[2,12],\"121\":[1,26],\"122\":[1,58],\"123\":[1,47],\"124\":[2,17],\"125\":[1,20],\"126\":[1,70],\"127\":[2,41],\"128\":[2,24],\"129\":[1,1],\"130\":[1,43],\"131\":[1],\"132\":[1,13],\"133\":[1,29],\"134\":[1,42],\"135\":[1,74],\"136\":[1,56],\"137\":[3,10],\"138\":[1,22],\"139\":[1,17],\"140\":[2,9],\"141\":[1,8],\"142\":[5,10],\"143\":[2],\"144\":[3,17],\"145\":[4],\"146\":[6,39],\"147\":[3,52],\"148\":[4,9],\"149\":[4,7],\"150\":[2,7],\"151\":[3,20],\"152\":[2,29],\"153\":[2],\"154\":[3,85],\"155\":[3,73],\"156\":[2,19],\"157\":[4,157],\"158\":[4,88],\"159\":[3,77],\"160\":[2,62],\"161\":[2,32],\"162\":[3,10],\"163\":[1,19],\"164\":[1,4],\"165\":[2,7],\"166\":[2,17],\"167\":[2,8],\"168\":[1,14],\"169\":[3,11],\"170\":[2,8],\"171\":[2,11],\"172\":[1,4],\"173\":[1,16],\"174\":[6,17],\"175\":[5,27],\"176\":[3,127],\"177\":[4,46],\"178\":[3,64],\"179\":[3,25],\"180\":[3,10],\"181\":[2,41],\"182\":[2,15],\"183\":[2],\"184\":[3],\"185\":[3,49],\"186\":[4,29],\"187\":[4,22],\"188\":[3,28],\"189\":[2,3],\"190\":[3,61],\"191\":[3,25],\"192\":[2,55],\"193\":[3,26],\"194\":[3],\"195\":[4,24],\"196\":[4,12],\"197\":[3,17],\"198\":[3,39],\"199\":[2],\"200\":[3],\"201\":[3,72],\"202\":[4,10],\"203\":[3],\"204\":[4,16],\"205\":[3,30],\"206\":[7,33],\"207\":[3,51],\"208\":[2,12],\"209\":[3,2],\"210\":[5,16],\"211\":[5,25],\"212\":[1,18],\"213\":[2,9],\"214\":[2,25],\"215\":[2],\"216\":[3,5],\"217\":[3,11],\"218\":[3,7],\"219\":[2],\"220\":[3,53],\"221\":[2,18],\"222\":[3,11],\"223\":[1,88],\"224\":[1,9],\"225\":[8,46],\"226\":[1,63],\"227\":[2,12],\"228\":[2,42],\"229\":[1,24],\"230\":[1],\"231\":[1,17],\"232\":[2,2],\"233\":[1,33],\"234\":[1,24],\"235\":[2,22],\"236\":[1,14],\"237\":[1,15],\"238\":[1,21],\"239\":[6,13],\"240\":[1,112],\"241\":[1],\"242\":[3,56],\"243\":[5,19],\"244\":[2,34],\"245\":[2,21],\"246\":[3,31],\"247\":[3,13],\"248\":[1,16],\"249\":[1,34],\"250\":[2,12],\"251\":[8,32],\"252\":[3,10],\"253\":[2,54],\"254\":[1,12],\"255\":[1,22],\"256\":[6,81],\"257\":[4,172],\"258\":[2,88],\"259\":[7],\"260\":[2,17],\"261\":[5,82],\"262\":[5,200],\"263\":[1,17],\"264\":[3,9],\"265\":[2],\"266\":[3,21],\"267\":[4,31],\"268\":[2],\"269\":[3,47],\"270\":[2,14],\"271\":[3,24],\"272\":[3,9],\"273\":[3,8],\"274\":[2],\"275\":[3,31],\"276\":[3,48],\"277\":[2,30],\"278\":[3,13],\"279\":[3,14],\"280\":[2,7],\"281\":[3,9],\"282\":[4,73],\"283\":[5,15],\"284\":[5,45],\"285\":[4,153],\"286\":[3,13],\"287\":[5,117],\"288\":[3,10],\"289\":[5,81],\"290\":[2,3],\"291\":[4,87],\"292\":[2],\"293\":[9,23],\"294\":[1,18],\"295\":[3,9],\"296\":[2],\"297\":[2,13],\"298\":[3,12],\"299\":[2],\"300\":[3,28],\"301\":[2,14],\"302\":[3,10],\"303\":[3,4],\"304\":[2],\"305\":[3,5],\"306\":[3,51],\"307\":[4,102],\"308\":[3],\"309\":[1,92],\"310\":[1,28],\"311\":[2],\"312\":[3],\"313\":[3,126],\"314\":[4,140],\"315\":[4,4],\"316\":[3,30],\"317\":[3,175],\"318\":[1,11],\"319\":[4,10],\"320\":[2,5],\"321\":[2,10],\"322\":[4,10],\"323\":[4,15],\"324\":[4,27],\"325\":[3,24],\"326\":[2,64],\"327\":[2],\"328\":[3],\"329\":[3,11],\"330\":[4,7],\"331\":[4,13],\"332\":[3,66],\"333\":[2],\"334\":[3,45],\"335\":[3,69],\"336\":[3,20],\"337\":[2],\"338\":[3],\"339\":[3,83],\"340\":[4,76],\"341\":[3],\"342\":[4,39],\"343\":[3,54],\"344\":[4,52],\"345\":[3,127],\"346\":[4],\"347\":[4,52],\"348\":[5,28],\"349\":[1,13],\"350\":[4,10],\"351\":[2],\"352\":[2,9],\"353\":[3,38],\"354\":[2,45],\"355\":[2,29],\"356\":[3,59],\"357\":[3,13],\"358\":[2],\"359\":[3,29],\"360\":[3,43],\"361\":[2,32],\"362\":[2],\"363\":[3,77],\"364\":[3,66],\"365\":[4,206],\"366\":[2],\"367\":[4,14],\"368\":[4,17],\"369\":[8,14],\"370\":[2,43],\"371\":[2],\"372\":[3,35],\"373\":[5,18],\"374\":[3,19],\"375\":[2,36],\"376\":[2,8],\"377\":[3,47],\"378\":[3,27],\"379\":[2],\"380\":[3,200],\"381\":[3,126],\"382\":[3,11],\"383\":[2,12],\"384\":[2,27],\"385\":[2],\"386\":[3,81],\"387\":[3,17],\"388\":[2,20],\"389\":[2,46],\"390\":[3,207],\"391\":[3,52],\"392\":[3,88],\"393\":[3,10],\"394\":[1,25],\"395\":[3],\"396\":[2,20],\"397\":[2,22],\"398\":[3,26],\"399\":[5,70],\"400\":[2,70],\"401\":[2,22],\"402\":[2,127],\"403\":[3,57],\"404\":[1,18],\"405\":[7,13],\"406\":[1,147],\"407\":[1,16],\"408\":[6,22],\"409\":[7,20],\"410\":[1,73],\"411\":[1,34],\"412\":[3,17],\"413\":[1,35],\"414\":[1,151],\"415\":[4,6],\"416\":[1,31],\"417\":[1,41],\"418\":[4,5],\"419\":[1,29],\"420\":[1,49],\"421\":[5,10],\"422\":[1,24],\"423\":[1,19],\"424\":[5,77],\"425\":[6,13],\"426\":[4,67],\"427\":[6,8],\"428\":[1,13],\"429\":[1,12],\"430\":[13,35],\"431\":[1,11],\"432\":[1,30],\"433\":[8,44],\"434\":[1,20],\"435\":[2,77],\"436\":[2,32],\"437\":[1,51],\"438\":[2,11],\"439\":[1,28],\"440\":[2,26],\"441\":[1,34],\"442\":[1,61],\"443\":[1,17],\"444\":[1,35],\"445\":[1,98],\"446\":[1,10],\"447\":[1,62],\"448\":[1,50],\"449\":[1,6],\"450\":[1,45],\"451\":[1,67],\"452\":[1,46],\"453\":[1,19],\"454\":[1,15],\"455\":[1,31],\"456\":[1,11],\"457\":[3,12],\"458\":[1,12],\"459\":[4,9],\"460\":[2],\"461\":[3,60],\"462\":[5,72],\"463\":[2,8],\"464\":[3,74],\"465\":[2,59],\"466\":[2],\"467\":[4,50],\"468\":[3],\"469\":[5,54],\"470\":[3,52],\"471\":[2,10],\"472\":[4,54],\"473\":[4,32],\"474\":[3,52],\"475\":[5,10],\"476\":[4,17],\"477\":[5,29],\"478\":[2],\"479\":[4],\"480\":[3,188],\"481\":[5,126],\"482\":[3],\"483\":[5,6],\"484\":[1,48],\"485\":[1,22],\"486\":[1,10],\"487\":[1,44],\"488\":[3,58],\"489\":[3],\"490\":[5,111],\"491\":[5,174],\"492\":[2,134],\"493\":[3,95],\"494\":[1,16],\"495\":[5,9],\"496\":[2,37],\"497\":[2],\"498\":[3,76],\"499\":[2,20],\"500\":[3,21],\"501\":[3,16],\"502\":[3],\"503\":[5,88],\"504\":[3,75],\"505\":[3,72],\"506\":[2,13],\"507\":[4,15],\"508\":[4,24],\"509\":[5,16],\"510\":[6,58],\"511\":[3,24],\"512\":[2],\"513\":[4],\"514\":[4,65],\"515\":[5,105],\"516\":[6,109],\"517\":[5,76],\"518\":[4,158],\"519\":[5,131],\"520\":[4,129],\"521\":[1,17],\"522\":[2,9],\"523\":[2,26],\"524\":[2,19],\"525\":[4,20],\"526\":[2,46],\"527\":[3,51],\"528\":[5,49],\"529\":[6,4],\"530\":[2,33],\"531\":[3,7],\"532\":[3,25],\"533\":[2],\"534\":[3,22],\"535\":[3,10],\"536\":[2],\"537\":[3,101],\"538\":[3,1],\"539\":[4,51],\"540\":[3,138],\"541\":[3,223],\"542\":[1,11],\"543\":[3,10],\"544\":[2,20],\"545\":[2,33],\"546\":[3],\"547\":[3,51],\"548\":[3,37],\"549\":[2,27],\"550\":[3,31],\"551\":[3],\"552\":[4,12],\"553\":[4,9],\"554\":[2],\"555\":[3,24],\"556\":[3,44],\"557\":[2,31],\"558\":[3,12],\"559\":[6,49],\"560\":[4,26],\"561\":[4,39],\"562\":[3,35],\"563\":[4,26],\"564\":[6,20],\"565\":[2],\"566\":[3],\"567\":[4,114],\"568\":[4,115],\"569\":[3],\"570\":[4,135],\"571\":[3,33],\"572\":[4,94],\"573\":[5,283],\"574\":[4],\"575\":[5,37],\"576\":[4,169],\"577\":[1,14],\"578\":[3,10],\"579\":[1],\"580\":[1],\"581\":[1,24],\"582\":[1],\"583\":[1],\"584\":[1],\"585\":[1,29],\"586\":[1,4],\"587\":[1,12],\"588\":[10,10],\"589\":[1,18],\"590\":[1,18],\"591\":[1,7],\"592\":[4,54],\"593\":[1,37],\"594\":[3,59],\"595\":[5,152],\"596\":[5,13],\"597\":[5,62],\"598\":[5,43],\"599\":[5,143],\"600\":[1,110],\"601\":[4,41],\"602\":[2],\"603\":[3,11],\"604\":[5,16],\"605\":[4,11],\"606\":[2,23],\"607\":[2],\"608\":[3,10],\"609\":[3,15],\"610\":[5,38],\"611\":[6,18],\"612\":[2],\"613\":[3,6],\"614\":[2,28],\"615\":[3,46],\"616\":[3,7],\"617\":[4,22],\"618\":[5,16],\"619\":[3],\"620\":[5,37],\"621\":[3,6],\"622\":[3,43],\"623\":[3,42],\"624\":[2,70],\"625\":[1,31],\"626\":[5,13],\"627\":[2,7],\"628\":[2],\"629\":[3,28],\"630\":[2,7],\"631\":[3,14],\"632\":[2,16],\"633\":[2],\"634\":[3],\"635\":[3],\"636\":[4,27],\"637\":[4,76],\"638\":[4,31],\"639\":[4,64],\"640\":[3,76],\"641\":[2],\"642\":[4,146],\"643\":[4,81],\"644\":[6,11],\"645\":[2,13],\"646\":[2,14],\"647\":[2,7],\"648\":[3,38],\"649\":[2,20],\"650\":[3,19],\"651\":[2,14],\"652\":[4,3],\"653\":[3,19],\"654\":[4,21],\"655\":[3],\"656\":[4,87],\"657\":[3,65],\"658\":[2,23],\"659\":[2],\"660\":[4,30],\"661\":[4],\"662\":[5,49],\"663\":[6,116],\"664\":[5,149],\"665\":[3,92],\"666\":[6,12],\"667\":[2,24],\"668\":[2],\"669\":[3,17],\"670\":[2],\"671\":[3,6],\"672\":[2,23],\"673\":[4,8],\"674\":[2],\"675\":[3,60],\"676\":[3,14],\"677\":[4],\"678\":[4,15],\"679\":[4,25],\"680\":[4,11],\"681\":[5,6],\"682\":[4],\"683\":[4,23],\"684\":[3,17],\"685\":[3,15],\"686\":[2],\"687\":[3],\"688\":[4,63],\"689\":[5,29],\"690\":[4,246],\"691\":[3,136],\"692\":[4,40],\"693\":[4,438],\"694\":[4,250],\"695\":[4,163],\"696\":[7,12],\"697\":[2,16],\"698\":[2],\"699\":[3,36],\"700\":[2,30],\"701\":[3,15],\"702\":[4,8],\"703\":[3,18],\"704\":[3,4],\"705\":[2],\"706\":[3],\"707\":[3,49],\"708\":[4,129],\"709\":[3],\"710\":[4,35],\"711\":[3,48],\"712\":[2],\"713\":[3],\"714\":[3,73],\"715\":[5,244],\"716\":[3],\"717\":[6,130],\"718\":[4,265],\"719\":[3],\"720\":[4,126],\"721\":[5,86],\"722\":[6,12],\"723\":[2,58],\"724\":[2,8],\"725\":[3],\"726\":[3,18],\"727\":[3,19],\"728\":[2,10],\"729\":[4,32],\"730\":[2],\"731\":[3],\"732\":[3,37],\"733\":[4,9],\"734\":[3,31],\"735\":[5,31],\"736\":[3],\"737\":[4,18],\"738\":[3,33],\"739\":[2,18],\"740\":[2],\"741\":[3],\"742\":[4,81],\"743\":[5],\"744\":[4,157],\"745\":[4,80],\"746\":[5,81],\"747\":[3],\"748\":[4,95],\"749\":[3,77],\"750\":[3,201],\"751\":[2,10],\"752\":[1],\"753\":[1,20],\"754\":[1,29],\"755\":[1,58],\"756\":[1],\"757\":[1,16],\"758\":[1,10],\"759\":[1,9],\"760\":[3,27],\"761\":[1,42],\"762\":[1,6],\"763\":[7,12],\"764\":[2],\"765\":[4,34],\"766\":[5,14],\"767\":[3,51],\"768\":[3,107],\"769\":[5,57],\"770\":[2,17],\"771\":[4,58],\"772\":[3,28],\"773\":[3,78],\"774\":[2],\"775\":[4,48],\"776\":[6],\"777\":[4,45],\"778\":[4,40],\"779\":[5,29],\"780\":[5,24],\"781\":[8,25],\"782\":[4,47],\"783\":[5,62],\"784\":[2],\"785\":[4],\"786\":[4,139],\"787\":[5,103],\"788\":[6],\"789\":[5,148],\"790\":[4,187],\"791\":[5,70],\"792\":[6],\"793\":[5,144],\"794\":[7],\"795\":[4,76],\"796\":[4,104],\"797\":[4,158],\"798\":[3,201],\"799\":[4,105],\"800\":[4,162],\"801\":[1,20],\"802\":[9,11],\"803\":[2],\"804\":[2,43],\"805\":[3],\"806\":[4,14],\"807\":[3,75],\"808\":[4,84],\"809\":[2],\"810\":[3,47],\"811\":[3,36],\"812\":[2],\"813\":[3,24],\"814\":[5,64],\"815\":[2,6],\"816\":[5,100],\"817\":[4,184],\"818\":[1,13],\"819\":[5,98],\"820\":[4,131],\"821\":[7,9],\"822\":[2],\"823\":[3,18],\"824\":[3],\"825\":[4,8],\"826\":[1,34],\"827\":[1,33],\"828\":[3,81],\"829\":[1,39],\"830\":[1,30],\"831\":[2],\"832\":[3,10],\"833\":[2,15],\"834\":[4,33],\"835\":[3,45],\"836\":[2],\"837\":[3,28],\"838\":[3,94],\"839\":[3,47],\"840\":[4],\"841\":[6,70],\"842\":[5,34],\"843\":[3,61],\"844\":[3,23],\"845\":[2],\"846\":[4],\"847\":[4,54],\"848\":[4,61],\"849\":[4],\"850\":[4,95],\"851\":[3,126],\"852\":[4,154],\"853\":[1,15],\"854\":[2,35],\"855\":[5,11],\"856\":[1],\"857\":[1],\"858\":[1,36],\"859\":[6,9],\"860\":[2,4],\"861\":[2],\"862\":[4],\"863\":[3],\"864\":[4],\"865\":[2],\"866\":[2],\"867\":[2],\"868\":[2,20],\"869\":[8,9],\"870\":[2],\"871\":[2,38],\"872\":[3,47],\"873\":[3,42],\"874\":[2],\"875\":[3,10],\"876\":[4,33],\"877\":[4,12],\"878\":[5,13],\"879\":[2],\"880\":[3,23],\"881\":[1],\"882\":[2],\"883\":[1,22],\"884\":[1,71]},\"averageFieldLength\":[2.8158192090395446,42.61410113122352],\"storedFields\":{\"0\":{\"h\":\"\",\"t\":[\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1\":{\"h\":\"Java 性能优化神器 JMH 从入门到精通\",\"t\":[\"原文地址：http://hscarb.github.io/java/20220427-jmh.html\"]},\"2\":{\"h\":\"背景\",\"t\":[\"你在写 Java 高性能程序时有没有这样的场景：\",\"纠结使用 ArrayList 还是 LinkedList 哪个更快？\",\"进行运算时，怎么提高效率？使用 int 还是 long？\",\"读写文件时，使用 FileChannel 还是 MappedByteBuffer 更快？\",\"使用锁还是 synchronized？\",\"使用 AtomicLong 还是 LongAdder 更快？\",\"……\",\"特别是在写性能要求高的程序时，这些问题会更频繁地出现。有时上网查询可以找到答案，但是当遇到更复杂、独特的场景时可能就需要自己进行性能压测。\",\"自己写一个测试方法或者 Main 函数固然也可以，但是有没有更【专业】的工具？我们的神器 JMH 闪亮登场。\",\"JMH 是 Java Microbenchmark Harness 的缩写，官方介绍如下：\",\"JMH 是 OpenJDK 提供的 JVM 基准测试工具，用于测试 Java 和其他跑在 JVM 上语言程序的性能。\"]},\"3\":{\"h\":\"JMH 的意义\",\"t\":[\"当对一个程序的一小部分代码或者一个函数进行基准测试时，JVM 或底层硬件可能对这部分测试代码进行许多优化，但当这部分代码作为较大程序的一部分时可能无法应用这些优化。\",\"自己实现基准测试代码时，编写的测试代码可能有缺陷。比如缺乏预热的步骤。\",\"使用 JMH，你可以使用它提供的一系列注解轻松地编写基准测试代码。并且它通常会阻止 JVM 和硬件在基准测试时执行优化。此外它还能提供简单明了的基准测试结果输出，使用一些工具可以对该结果进行可视化。\"]},\"4\":{\"h\":\"JMH 如何工作？\",\"t\":[\"应用 JMH 注解的代码在编译之后会被编译成多个执行类以进行基准测试结果输出。\",\"JMH 按照如上所示的流程进行基准测试。\",\"Fork 为一个新的进程，如果设置用多个进程执行，则各个线程串行执行。\",\"每个线程中先执行预热（Warmup），然后再执行测试（Measurement）。在预热和测试执行过程中，每一轮测试称为一个迭代（Iteration），一个迭代也是测试数据统计的最小单元。在 @Warmup 和 @Measurement 注解中可以指定执行的迭代次数和每次迭代的执行时常。\",\"每个迭代中会根据基准测试的模式（@BenchmarkMode）来调用（Invoke）测试方法，可能一次也可能多次，并计算该测试模式所关注的指标。\",\"可以看到在每次测试前后、每次迭代前后、甚至每次调用方法前后都可以用 @Setup 和 @TearDown 注解来设置启动和停止的方法。\"]},\"5\":{\"h\":\"快速开始\"},\"6\":{\"h\":\"安装插件\",\"t\":[\"使用 JMH 前最好先安装一下配套的 idea 插件。\",\"它可以帮助解析 JMH 的注解。\"]},\"7\":{\"h\":\"使用 Maven archtype\",\"t\":[\"官方推荐的使用方法是使用 Maven archtype 构建项目，这样可以自动生成基准测试代码，打包之后也自带可以运行基准测试代码的 benchmark.jar 包。由于可能需要在 Linux 上测试，所以这个 jar 包十分有用。\",\"运行如下代码使用 maven archtype 构建项目。\",\"mvn archetype:generate \\\\ -DinteractiveMode=false \\\\ -DarchetypeGroupId=org.openjdk.jmh \\\\ -DarchetypeArtifactId=jmh-java-benchmark-archetype \\\\ -DgroupId=org.sample \\\\ -DartifactId=test \\\\ -Dversion=1.0 \",\"如果使用 idea，可以使用 idea 添加 Archtype 后创建。\"]},\"8\":{\"h\":\"引入依赖\",\"t\":[\"JMH 在 JDK9 之后的版本已经原生支持。在 JDK9 之前的版本需要引入依赖。当前最新的版本为 1.35。如果已经使用 Archtype 方式构建项目，那么无需额外引入依赖。\",\"<dependency> <groupId>org.openjdk.jmh</groupId> <artifactId>jmh-core</artifactId> <version>1.35</version> </dependency> <dependency> <groupId>org.openjdk.jmh</groupId> <artifactId>jmh-generator-annprocess</artifactId> <version>1.35</version> </dependency> \"]},\"9\":{\"h\":\"编写测试代码\",\"t\":[\"使用 Archtype 构建的项目已经写好了 MyBenchmark 类，可以直接运行空测试函数。\",\"我们编写代码来测试一下 ArrayList 和 LinkedList 添加数据的性能。假设需要测试分别向两种列表中添加 1000w 数据。\",\"// 使用一个进程来运行测试，如果大于 1，多进程串行执行 @Fork(1) // 类变量的作用域，这里指 linkedList 和 arrayList 在同一个测试类中共享 @State(Scope.Benchmark) // 预热执行 5 次，每次 1 秒 @Warmup(iterations = 5, time = 1) // 测试执行 5 次，每次 1 秒次 @Measurement(iterations = 5, time = 1) // 测试模式为计算测试方法的吞吐量（每秒执行次数） @BenchmarkMode(Mode.Throughput) // 用例计时和输出的时间单位 @OutputTimeUnit(TimeUnit.MILLISECONDS) public class MyBenchmark { private LinkedList<Integer> linkedList; private ArrayList<Integer> arrayList; // 初始化方法，在每次调用测试方法之前执行，类似 JUnit // Level 表示该方法运行的时机，Iteration 表示每次测试都会执行（包括预热） @Setup(Level.Iteration) public void setup() { linkedList = new LinkedList<>(); arrayList = new ArrayList<>(); } // 测试方法，类似 JUnit @Test。标注了 @Benchmark 的方法会被进行基准测试 @Benchmark public void testArrayList() { arrayList.add(1); } @Benchmark public void testLinkedList() { linkedList.add(1); } } \"]},\"10\":{\"h\":\"运行测试\",\"t\":[\"在 idea 安装插件的情况下可以直接运行测试。\",\"另一种方式，可以通过 Archtype 的 benchmark.jar 来运行测试。\",\"mvn clean verify \",\"java -jar target/benchmarks.jar \"]},\"11\":{\"h\":\"查看结果\",\"t\":[\"# JMH version: 1.35 # Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable) # Warmup: 5 iterations, 1 s each // 预热 5 次，每次 1 秒 # Measurement: 5 iterations, 1 s each // 测试 5 次，每次 1 秒 # Timeout: 10 min per iteration // 每次执行测试方法的超时时间为 10 分钟 # Threads: 1 thread, will synchronize iterations // 单线程执行 # Benchmark mode: Throughput, ops/time // 测试模式：吞吐量，统计每秒操作数 # Benchmark: org.example.MyBenchmark.testArrayList // 本次测试的测试方法 # Run progress: 0.00% complete, ETA 00:00:20 # Fork: 1 of 1 // 第一个进程执行测试 # Warmup Iteration 1: 141579.663 ops/ms // 每次预热耗时 # Warmup Iteration 2: 13048.155 ops/ms # Warmup Iteration 3: 126507.754 ops/ms # Warmup Iteration 4: 127890.530 ops/ms # Warmup Iteration 5: 152379.871 ops/ms Iteration 1: 149509.372 ops/ms // 每次测试执行耗时 Iteration 2: 147695.938 ops/ms Iteration 3: 100544.988 ops/ms Iteration 4: 169084.449 ops/ms Iteration 5: 177057.200 ops/ms Result \\\"org.example.MyBenchmark.testArrayList\\\": 148778.389 ±(99.9%) 114555.755 ops/ms [Average] (min, avg, max) = (100544.988, 148778.389, 177057.200), stdev = 29749.766 CI (99.9%): [34222.635, 263334.144] (assumes normal distribution) # ... # Benchmark: org.example.MyBenchmark.testLinkedList # Run progress: 50.00% complete, ETA 00:00:13 # Fork: 1 of 1 # Warmup Iteration 1: 3997.950 ops/ms # Warmup Iteration 2: 9656.378 ops/ms # Warmup Iteration 3: 9767.753 ops/ms # Warmup Iteration 4: 8815.672 ops/ms # Warmup Iteration 5: 47451.551 ops/ms Iteration 1: 21131.024 ops/ms Iteration 2: 9101.728 ops/ms Iteration 3: 28116.765 ops/ms Iteration 4: 8994.693 ops/ms Iteration 5: 28290.489 ops/ms Result \\\"org.example.MyBenchmark.testLinkedList\\\": 19126.940 ±(99.9%) 37132.831 ops/ms [Average] (min, avg, max) = (8994.693, 19126.940, 28290.489), stdev = 9643.278 CI (99.9%): [≈ 0, 56259.771] (assumes normal distribution) # Run complete. Total time: 00:00:40 // 所有测试执行完毕，耗时 // 测试结果，Mode 表示测试模式，thrpt 表示模式为 Throughput // Score 表示平均耗时，Error 表示误差 Benchmark Mode Cnt Score Error Units MyBenchmark.testArrayList thrpt 5 148778.389 ± 114555.755 ops/ms MyBenchmark.testLinkedList thrpt 5 19126.940 ± 37132.831 ops/ms \"]},\"12\":{\"h\":\"注释详解\",\"t\":[\"这个图片可以帮助快速查阅 JMH 各个注解的含义和用法。\",\"具体的解析可以看 关键注解\"]},\"13\":{\"h\":\"高级用法\",\"t\":[\"详见 基准测试神器JMH —— 详解36个官方例子\"]},\"14\":{\"h\":\"将结果图形化\"},\"15\":{\"h\":\"参考资料\",\"t\":[\"JAVA 拾遗 — JMH 与 8 个测试陷阱\",\"JMH - Java 微基准测试工具（自助性能测试）@Benchmark\",\"顶级Java才懂的，基准测试JMH！\",\"JUC学习笔记 - 08JMH入门\",\"基准测试神器JMH —— 详解36个官方例子\",\"性能调优必备利器之 JMH\",\"JMH - Java Microbenchmark Harness\",\"JMH Cheatsheet\",\"Understanding Java Microbenchmark Harness or JMH Tool\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"16\":{\"h\":\"Java 最强 IO\",\"t\":[\"原文地址：http://hscarb.github.io/java/99991231-java-best-io.html\",\"MappedByteBuffer VS FileChannel 孰强孰弱？\",\"FileChannel, ByteBuffer, Memory-Mapped I/O, Locks [Java Files Tutorial, Part 6]\",\"论最强IO：MappedByteBuffer VS FileChannel\",\"MappedByteBuffer的一点优化\",\"文件 IO 操作的一些最佳实践\",\"天池中间件大赛百万队列存储设计总结【复赛】\",\"MappedByteBuffer vs. FileChannel?\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"17\":{\"h\":\"java\",\"t\":[\"Java 性能优化神器 JMH 从入门到精通\"]},\"18\":{\"h\":\"Erlang 学习笔记\",\"t\":[\"原文地址：http://hscarb.github.io/other/20220614-erlang-note.html\"]},\"19\":{\"h\":\"顺序编程\"},\"20\":{\"h\":\"基本概念\"},\"21\":{\"h\":\"Erlang shell\",\"t\":[\"# 启动 erl # 停止 q() # 对应 init:stop() # 立即停止系统 erlang:halt() \",\"% 注释 \",\"可以挂接一个shell到集群里另一个Erlang节点上运行的Erlang系统，甚至还可以生成一个安全shell（secure shell，即ssh）直接连接远程计算机上运行的Erlang系统。通过它，可以与Erlang节点系统中任何节点上的任何程序进行交互。\",\"f() 命令让shell忘记现有的任何绑定。help() 命令获取帮助。\",\"6> help(). ** shell internal commands ** b() -- display all variable bindings e(N) -- repeat the expression in query <N> f() -- forget all variable bindings f(X) -- forget the binding of variable X h() -- history h(Mod) -- help about module h(Mod,Func)-- help about function in module h(Mod,Func,Arity) -- help about function with arity in module ht(Mod) -- help about a module's types ht(Mod,Type) -- help about type in module ht(Mod,Type,Arity) -- help about type with arity in module hcb(Mod) -- help about a module's callbacks hcb(Mod,CB) -- help about callback in module hcb(Mod,CB,Arity) -- help about callback with arity in module history(N) -- set how many previous commands to keep results(N) -- set how many previous command results to keep catch_exception(B) -- how exceptions are handled v(N) -- use the value of query <N> rd(R,D) -- define a record rf() -- remove all record information rf(R) -- remove record information about R rl() -- display all record information rl(R) -- display record information about R rp(Term) -- display Term using the shell's record information rr(File) -- read record information from File (wildcards allowed) rr(F,R) -- read selected record information from file(s) rr(F,R,O) -- read selected record information with options ** commands in module c ** bt(Pid) -- stack backtrace for a process c(Mod) -- compile and load module or file <Mod> cd(Dir) -- change working directory flush() -- flush any messages sent to the shell help() -- help info h(M) -- module documentation h(M,F) -- module function documentation h(M,F,A) -- module function arity documentation i() -- information about the system ni() -- information about the networked system i(X,Y,Z) -- information about pid <X,Y,Z> l(Module) -- load or reload module lm() -- load all modified modules lc([File]) -- compile a list of Erlang modules ls() -- list files in the current directory ls(Dir) -- list files in directory <Dir> m() -- which modules are loaded m(Mod) -- information about module <Mod> mm() -- list all modified modules memory() -- memory allocation information memory(T) -- memory allocation information of type <T> nc(File) -- compile and load code in <File> on all nodes nl(Module) -- load module on all nodes pid(X,Y,Z) -- convert X,Y,Z to a Pid pwd() -- print working directory q() -- quit - shorthand for init:stop() regs() -- information about registered processes nregs() -- information about all registered processes uptime() -- print node uptime xm(M) -- cross reference check a module y(File) -- generate a Yecc parser ** commands in module i (interpreter interface) ** ih() -- print help for the i module true \"]},\"22\":{\"h\":\"整数运算\",\"t\":[\"1> 2 + 3 * 4. 14 \",\"Erlang可以用任意长度的整数执行整数运算。在Erlang里，整数运算是精确的，因此无需担心运算溢出或无法用特定字长（ word size）来表示某个整数。\"]},\"23\":{\"h\":\"变量\",\"t\":[\"1> X = 123. 2> X. 123 \",\"所有变量名都必须以大写字母开头。\",\"Erlang 中的 = 是一个模式匹配操作符，当关联一个值与一个变量时，所下的是一种断言，也就是事实陈述。这个变量具有那个值，仅此而已。\",\"X 不是一个变量，是一次性赋值变量，只能被赋值一次。\",\"变量的作用域是它定义时所处的语汇单元。不存在全局变量或私有变量的说法。\",\"在Erlang里， =是一次模式匹配操作。 Lhs = Rhs 的真正意思是：计算右侧（ Rhs）的值，然后将结果与左侧（ Lhs）的模式相匹配。 我们第一次说 X = SomeExpression时， Erlang对自己说：“我要做些什么才能让这条语句为真？”因为X还没有值，它可以绑定X到SomeExpression这个值上，这条语句就成立了。\",\"这符合了 Erlang 这种函数式编程语言的不可变状态。\"]},\"24\":{\"h\":\"浮点数\",\"t\":[\"1> 5/3. 1.6666666666666667 % 用 / 给两个整数做除法时，结果会自动转换成浮点数。 2> 4/2. 2.0 % 整除结果仍是浮点数 3> 5 div 3. 1 % N 除以 M 然后舍去余数 4> 5 rem 3. 2 % N 除以 M 后剩下的余数 5> 4 div 2. 2 % 浮点数的程序会存在和C等语言一样的浮点数取整与精度问题 \"]},\"25\":{\"h\":\"原子\",\"t\":[\"表示常量值，也可以视作枚举类型。\",\"原子是全局性的，而且不需要宏定义或包含文件就能实现。\",\"原子以小写字母开头，后接一串字母、数字、下划线（_）或at（@）符号。\",\"也可以放在单引号内，以大写字母开头或包含字母数字以外字符的原子。\",\"原子的值就是它本身\"]},\"26\":{\"h\":\"元组\",\"t\":[\"数量固定的项目归组成单一的实体\",\"元组里的字段没有名字，常用做法是将元组第一个元素设为一个原子，用来表示元组是什么。\",\"{point, 10, 5}. Person = {person, {name, joe}, {height, 1.82}, {footsize, 42}, {eyecolour, brown}}. % 用模式匹配的方式提取元组的值 Point = {point, 10, 45}. {point, X, Y} = Point. % 用_作为占位符 Person = {person, {name, joe, armstrong}, {footsize, 42}}. {_,{_,Who,_},_}=Person. Who. > joe \"]},\"27\":{\"h\":\"列表\",\"t\":[\"[8,hello,0,{cost,apple,10},3] \",\"用来存放任意数量的事物\",\"第一个元素称为列表头，剩下元素是列表尾。\",\"访问列表头是一种非常高效的操作，因此基本上所有的列表处理函数都从提取列表头开始，然后对它做一些操作，接着处理列表尾。\",\"如果T是一个列表，那么[H|T]也是一个列表， 它的头是H，尾是T。竖线（|） 把列表的头与尾分隔开。 []是一个空列表。\",\"% 扩展列表 7> Things = [{apples,10},{pears,6},{milk,3}]. [{apples,10},{pears,6},{milk,3}] 8> Things1=[{oranges,4},{newspaper,1}|Things]. [{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}] % 提取列表元素，[X|Y] = L（ X和Y都是未绑定变量）会提取列表头作为X，列表尾作为Y。 9> [Buy1|Things2]=Things1. [{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}] 10> Buy1. {oranges,4} 11> Things2. [{newspaper,1},{apples,10},{pears,6},{milk,3}] %% 12> [Buy2,Buy3|Things3]=Things2. [{newspaper,1},{apples,10},{pears,6},{milk,3}] 13> Buy2. {newspaper,1} 14> Buy3. {apples,10} 15> Things3. [{pears,6},{milk,3}] \"]},\"28\":{\"h\":\"字符串\",\"t\":[\"严格来说，Erlang 里没有字符串。用整数组成的列表或一个二进制型表示字符串。当用整数列表表示字符串时，列表里的每个元素代表了一个Unicode字符。\",\"16> Name=\\\"Hello\\\". % \\\"Hello\\\"其实只是一个列表的简写，这个列表包含了代表字符串里各个字符的整数字符代码 \\\"Hello\\\" % shell打印某个列表的值时，如果列表内的所有整数都代表可打印字符，它就会将其打印成字符串字面量。否则，打印成列表记法 17> [1,2,3]. [1,2,3] 18> [83,117,114,112,114,105,115,101]. \\\"Surprise\\\" 19> [1,83,117,114,112,114,105,115,101]. [1,83,117,114,112,114,105,115,101] % 如果shell将某个整数列表打印成字符串，而你其实想让它打印成一列整数，那就必须使用格式化的写语句 1> X = [97,98,99]. \\\"abc\\\" 3> io:format(\\\"~w~n\\\",[X]). [97,98,99] % $a实际上就是代表字符a的整数 20> I = $s. 115 22> [$S,117,114,112,114,105,115,101]. \\\"Surprise\\\" % 必须使用特殊的语法才能输入某些字符，在打印列表时也要选择正确的格式惯例。 23> X=\\\"a\\\\x{221e}b\\\". [97,8734,98] 24> io:format(\\\"~ts~n\\\",[X]). a\\\\x{221E}b \"]},\"29\":{\"h\":\"模块与函数\"},\"30\":{\"h\":\"模块：module\",\"t\":[\"模块是Erlang的基本代码单元。模块保存在扩展名为 .erl 的文件里，而且必须先编译才能运行模块里的代码。编译后的模块以 .beam 作为扩展名。\",\"逗号 , 分隔函数调用、数据构造和模式中的参数。\",\"分号 ; 分隔子句。我们能在很多地方看到子句，例如函数定义，以及case、 if、try..catch和receive表达式。\",\"句号 .（后接空白）分隔函数整体，以及shell里的表达式。\",\"% geometry.erl -module(geometry). % 模块声明，模块名必须与存放该模块的主文件名相同 -export([area/1]). % 导出声明，Name/N 指带有 N 个参数的函数 Name。已导出函数相当于公共方法，未导出函数相当于私有方法 % 函数定义，area 函数有两个子句 area({rectangle, Width, Height}) -> Width * Height; % 子句以分号隔开 area({square, Side}) -> Side * Side. % 以句号结尾 \",\"1> c(geometry). % 在 erlang shell 中编译，编译之后产生 geometry.beam 目标代码块 {ok,geometry} 2> geometry:area({rectangle, 10, 5}). % 调用函数，要附上模块名 50 3> geometry:area({square, 3}). 9 \",\"-module(geometry). -export([area/1, test/0]). % 添加测试，测试仅仅需要模式匹配和= test() -> 12 = area({rectangle, 3, 4}), 144 = area({square, 12}), tests_worked. area({rectangle, Width, Height}) -> Width * Height; area({square, Side}) -> Side * Side. \",\"5> c(geometry). {ok,geometry} 6> geometry:test(). tests_worked \",\"% 情况分析函数 total([{What, N} | T]) -> shop:cost(What) * N + total(T); total([]) -> 0. \"]},\"31\":{\"h\":\"高阶函数 fun\",\"t\":[\"Erlang 是函数式编程语言，表示函数可以被用作参数，也可以返回函数。\",\"操作其他函数的函数被称为高阶函数。\",\"代表函数的数据类型是 fun。\",\"1> Double = fun(X) -> 2 * X end. #Fun<erl_eval.44.65746770> 2> Double(2). 4 % fun 可以有多个子句 3> TempConvert = fun({c, C}) -> {f, 32 + C * 9 / 5}; ({f, F}) -> {c, (F - 32) * 5 / 9} end. #Fun<erl_eval.44.65746770> 4> TempConvert({c, 100}). {f,212.0} 5> TempConvert({f, 212}). {c,100.0} \",\"% 标准库高阶函数 %% map 6> L = [1,2,3,4]. [1,2,3,4] 7> lists:map(fun(X) -> 2 * X end, L). [2,4,6,8] %% filter 8> Even = fun(X) -> (X rem 2) =:= 0 end. #Fun<erl_eval.44.65746770> 9> Even(8). true 10> Even(7). false 11> lists:map(Even, [1,2,3,4,5,6,7,8]). [false,true,false,true,false,true,false,true] 12> lists:filter(Even, [1,2,3,4,5,6,7,8]). [2,4,6,8] \",\"% 返回 fun 的函数，括号内的东西就是返回值 13> MakeTest = fun(L) -> (fun(X) -> lists:member(X, L) end) end. #Fun<erl_eval.44.65746770> 15> Fruit = [apple, pear, orange]. [apple,pear,orange] 16> IsFruit = MakeTest(Fruit). #Fun<erl_eval.44.65746770> 17> IsFruit(pear). true 18> IsFruit(dog). false 19> lists:filter(IsFruit, [dog,orange,cat,apple,bear]). [orange,apple] 22> Mult = fun(Times) -> (fun(X) -> X * Times end) end. #Fun<erl_eval.44.65746770> 23> Triple = Mult(3). #Fun<erl_eval.44.65746770> 24> Triple(5). 15 \"]},\"32\":{\"h\":\"实现 for\",\"t\":[\"% Erlang 没有 for 循环，而是需要自己编写控制结构 % 创建列表[F(1), F(2), ..., F(10)] for(Max, Max, F) -> [F(Max)]; for(I, Max, F) -> [F(I) | for(I + 1, Max, F)]. 9> lib_misc:for(1,10,fun(I)->I end). [1,2,3,4,5,6,7,8,9,10] 10> lib_misc:for(1,10,fun(I)->I*I end). [1,4,9,16,25,36,49,64,81,100] \"]},\"33\":{\"h\":\"列表处理（sum、map）\",\"t\":[\"%% 列表求和函数 sum([H | T]) -> H + sum(T); sum([]) -> 0. %% map 函数 map(_, []) -> []; map(F, [H | T]) -> [F(H) | map(F, T)]. total(L) -> sum(map(fun({What, N}) -> shop:cost(What) * N end, L)). \"]},\"34\":{\"h\":\"列表推导（[F(X) || X <- L]）\",\"t\":[\"列表推导（list comprehension）是无需使用fun、 map或filter就能创建列表的表达式。它让程序变得更短，更容易理解。\",\"1> L = [1,2,3,4,5]. [1,2,3,4,5] 2> [2*X||X<-L]. % [F(X) || X <- L]：由 F(X) 组成的列表（X 从列表 L 中提取） [2,4,6,8,10] \",\"列表推导的常规形式\",\"[X || Qualifier1, Qualifier2, ...] \",\"X 是任一表达式，后面的限定符可以是生成器、位串生成器或过滤器。\",\"生成器（generator）的写法是 Pattern <- ListExpr ，其中的 ListExp 必须是一个能够得出列表的表达式。\",\"位串（bitstring）生成器的写法是 BitStringPattern <= BitStringExpr ，其中的 BitStringExpr 必须是一个能够得出位串的表达式。\",\"过滤器（filter）既可以是判断函数（即返回true或false的函数），也可以是布尔表达式。请注意，列表推导里的生成器部分起着过滤器的作用\",\"%% 快速排序 qsort([]) -> []; qsort([Pivot | T]) -> qsort([X || X <- T, X < Pivot]) % 生成器 + 过滤器，生成一个比 Pivot 小的数组成的列表，递归 ++ [Pivot] % ++ 是中缀插入操作符，在中间插入 Pivot ++ qsort([X || X <- T, X >= Pivot]). %% 毕达哥拉斯三元数组 %% 提取1到N的所有A值，1到N的所有B值，1到N的所有C值，条件是A + B + C小于等于N并且A*A + B*B = C*C。 pythag(N) -> [ {A, B, C} || A <- lists:seq(1, N), B <- lists:seq(1, N), C <- lists:seq(1, N), A + B + C =< N, A * A + B * B =:= C * C ]. \"]},\"35\":{\"h\":\"内置函数\",\"t\":[\"built-in function，是那些作为Erlang语言定义一部分的函数。有些内置函数是用Erlang实现的，但大多数是用Erlang虚拟机里的底层操作实现的。最常用的内置函数（例如list_to_tuple）是自动导入的。\",\"4> list_to_tuple([12,cat,\\\"hello\\\"]). {12,cat,\\\"hello\\\"} 5> time(). {22,55,25} \"]},\"36\":{\"h\":\"关卡（when）\",\"t\":[\"关卡（guard）是一种结构，可以用它来增加模式匹配的威力，它通过 when 引入。通过使用关卡，可以对某个模式里的变量执行简单的测试和比较。 \",\"关卡由一系列关卡表达式组成，由 , 分割，都为 true 是值才为 true。（AND）\",\"关卡序列（guard sequence）是指单一或一系列的关卡，用 ; 分割，只要一个为 true，它的值就为 true。（OR）\",\"原子 true 关卡防止在某个 if 表达式的最后。\",\"% Guard 是用于增强模式匹配的结构。 % Guard 可用于简单的测试和比较。 % Guard 可用于函数定义的头部，以`when`关键字开头，或者其他可以使用表达式的地方。 max(X, Y) when X > Y -> X; max(X, Y) -> Y. % guard 可以由一系列 guard 表达式组成，这些表达式以逗号分隔。 % `GuardExpr1, GuardExpr2, ..., GuardExprN` 为真，当且仅当每个 guard 表达式均为真。 is_cat(A) when is_atom(A), A =:= cat -> true; is_cat(A) -> false. is_dog(A) when is_atom(A), A =:= dog -> true; is_dog(A) -> false. % guard 序列 `G1; G2; ...; Gn` 为真，当且仅当其中任意一个 guard 表达式为真。 is_pet(A) when is_dog(A); is_cat(A) -> true; is_pet(A) -> false. \"]},\"37\":{\"h\":\"case 表达式\",\"t\":[\"case Expression of Pattern1 [when Guard1] -> Body1; Pattern2 [when Guard2] -> Body2; ... end % `case` 表达式。 % `filter` 返回由列表`L`中所有满足`P(x)`为真的元素`X`组成的列表。 filter(P, [H|T]) -> case P(H) of true -> [H|filter(P, T)]; false -> filter(P, T) end; filter(P, []) -> []. filter(fun(X) -> X rem 2 == 0 end, [1, 2, 3, 4]). % [2, 4] \",\"Expression 被执行，假设它的值为 Value\",\"Value 轮流与 Pattern1（带有可选的关卡 Guard1）、Pattern2 等模式进行匹配，直到匹配成功。\",\"一旦发现匹配，相应的表达式序列就会执行，而表达式序列执行的结果就是 case 表达式的值。如果所有模式都不匹配，就会发生异常错误（exception）。\"]},\"38\":{\"h\":\"if 表达式\",\"t\":[\"if Guard1 -> Expr_seq1; Guard2 -> Expr_seq2; ... end % `if` 表达式。 max(X, Y) -> if X > Y -> X; X < Y -> Y; true -> nil; end. \",\"执行 Guard1。 如果得到的值为 true，那么if的值就是执行表达式序列 Expr_seq1 所得到的值。\",\"如果 Guard1 不成功，就会执行 Guard2， 以此类推，直到某个关卡成功为止。\",\"if表达式必须至少有一个关卡的执行结果为true， 否则就会发生异常错误。\",\"很多时候， if 表达式的最后一个关卡是原子 true， 确保当其他关卡都失败时表达式的最后部分会被执行。（相当于最后带 else）因为 erlang 的所有表达式都应该有值。\"]},\"39\":{\"h\":\"归集器\",\"t\":[\"只遍历列表一次，返回两个列表。\",\"%% 归集器 odds_and_even(L) -> odds_and_evens_acc(L, [], []). odds_and_evens_acc([H|T], Odds, Evens) -> case (H rem 2) of 1 -> odds_and_evens_acc(T, [H|Odds], Evens); 0 -> odds_and_evens_acc(T, Odds, [H|Evens]) end; odds_and_evens_acc([], Odds, Evens) -> {Odds, Evens}. \"]},\"40\":{\"h\":\"记录（record）与映射组（map）\",\"t\":[\"元组用于保存固定数量的元素，而列表用于保存可变数量的元素。记录其实就是元组的另一种形式。\",\"使用 record：有一大堆元组，并且每个元组都有相同的结构\",\"使用 map：键值对\"]},\"41\":{\"h\":\"record\",\"t\":[\"% Record 可以将元组中的元素绑定到特定的名称。 % Record 定义可以包含在 Erlang 源代码中，也可以放在后缀为`.hrl`的文件中（Erlang 源代码中 include 这些文件）。 -record(todo, { status = reminder, % Default value who = joe, text }). % 在定义某个 record 之前，我们需要在 shell 中导入 record 的定义。 % 我们可以使用 shell 函数`rr` (read records 的简称）。 rr(\\\"records.hrl\\\"). % [todo] % 创建和更新 record。 X = #todo{}. % 创建 todo，所有键都是原子 % #todo{status = reminder, who = joe, text = undefined} X1 = #todo{status = urgent, text = \\\"Fix errata in book\\\"}. % #todo{status = urgent, who = joe, text = \\\"Fix errata in book\\\"} X2 = X1#todo{status = done}. % 创建 X1 的副本，并修改 status 为 done % #todo{status = done,who = joe,text = \\\"Fix errata in book\\\"} % 提取 record 字段 > #todo{who=W, text=Txt} = X2. > W. joe > Txt. \\\"Fix errata in book\\\" % 如果只是想要记录里的单个字段，就可以使用“点语法”来提取该字段。 > X2#todo.text. \\\"Fix errata in book\\\" % 让 shell 忘掉 todo 定义 rf(todo). \"]},\"42\":{\"h\":\"map\",\"t\":[\"映射组在系统内部是作为有序集合存储的，打印时总是使用各键排序后的顺序。\",\"表达式K => V有两种用途，一种是将现有键K的值更新为新值V，另一种是给映射组添加一个全新的K-V对。这个操作总是成功的。\",\"表达式K := V的作用是将现有键K的值更新为新值V。 如果被更新的映射组不包含键K，这个操作就会失败。\",\"映射组在比较时首先会比大小，然后再按照键的排序比较键和值。\",\"% 创建 map > F1 = #{a => 1, b => 2}. #{a => 1,b => 2} % => 更新或设值 11> F3 = F1#{c=>xx}. #{a => 1,b => 2,c => xx} % := 只能更新值 12> F4=F1#{c := 3}. ** exception error: bad key: c in function maps:update/3 called as maps:update(c,3,#{a => 1,b => 2}) *** argument 3: not a map in call from erl_eval:'-expr/5-fun-0-'/2 (erl_eval.erl, line 256) in call from lists:foldl/3 (lists.erl, line 1267) 13> F4 = F3#{c := 3}. #{a => 1,b => 2,c => 3} \"]},\"43\":{\"h\":\"顺序程序的错误处理\",\"t\":[\"exit(Why) \",\"当你确实想要终止当前进程时就用它。如果这个异常错误没有被捕捉到，信号 {'EXIT', Pid,Why} 就会被广播给当前进程链接的所有进程。\",\"throw(Why) \",\"这个函数的作用是抛出一个调用者可能想要捕捉的异常错误。在这种情况下，我们注明了 被调用函数可能会抛出这个异常错误。有两种方法可以代替它使用 \",\"为通常的情形编写代码并且有意忽略异常错误\",\"把调用封装在一个 try...catch 表达式里， 然后对错误进行处理。\",\"error(Why) \",\"这个函数的作用是指示“崩溃性错误”，也就是调用者没有准备好处理的非常严重的问题。它与系统内部生成的错误差不多。\",\"% 当遇到内部错误或显式调用时，会触发异常。 % 显式调用包括 `throw(Exception)`, `exit(Exception)` 和 % `erlang:error(Exception)`. generate_exception(1) -> a; generate_exception(2) -> throw(a); generate_exception(3) -> exit(a); generate_exception(4) -> {'EXIT', a}; generate_exception(5) -> erlang:error(a). % Erlang 有两种捕获异常的方法。其一是将调用包裹在`try...catch`表达式中。 catcher(N) -> try generate_exception(N) of Val -> {N, normal, Val} catch throw:X -> {N, caught, thrown, X}; exit:X -> {N, caught, exited, X}; error:X -> {N, caught, error, X} end. % 另一种方式是将调用包裹在`catch`表达式中。 % 此时异常会被转化为一个描述错误的元组。 catcher(N) -> catch generate_exception(N). \"]},\"44\":{\"h\":\"用 try ... catch 捕获异常\",\"t\":[\"try ... catch 具有一个值\",\"try ... catch 表达式和case表达式之间的相似性，像是它的强化版，基本上是 case 表达式加上最后的 catch 和 after 区块。\",\"首先执行 FuncOrExpessionSeq 。 如果执行过程没有抛出异常错误，那么函数的返回值就会与Pattern1（ 以及可选的关卡Guard1）、 Pattern2等模式进行匹配，直到匹配成功。如果能匹配，那么整个 try...catch 的值就通过执行匹配模式之后的表达式序列得出。 如果 FuncOrExpressionSeq 在执行中抛出了异常错误，那么ExPattern1等捕捉模式就会与它进行匹配，找出应该执行哪一段表达式序列。ExceptionType是一个原子（ throw、exit和error其中之一），告诉我们异常错误是如何生成的。如果省略了ExceptionType， 就会使用默认值throw。\",\"% Erlang 有两种捕获异常的方法。其一是将调用包裹在`try...catch`表达式中。 catcher(N) -> try generate_exception(N) of Val -> {N, normal, Val} catch throw:X -> {N, caught, thrown, X}; exit:X -> {N, caught, exited, X}; error:X -> {N, caught, error, X} end. demo1() -> [catcher(I) || I <- [1, 2, 3, 4, 5]]. % 提供了概括信息 >try_test:demo1(). [{1,normal,a}, {2,caught,thrown,a}, {3,caught,exited,a}, {4,normal,{'EXIT',a}}, {5,caught,error,a}] \"]},\"45\":{\"h\":\"用 catch 捕捉异常错误\",\"t\":[\"catch 和 try ... catch 里的 catch 不是一回事，异常错误如果发生在 catch 语句里， 就会被转换成一个描述此错误的 {'EXIT', ...}元组。\",\"% 另一种方式是将调用包裹在`catch`表达式中。 % 此时异常会被转化为一个描述错误的元组。 catcher2(N) -> catch generate_exception(N). demo2() -> [{I, catcher2(I)} || I <- [1, 2, 3, 4, 5]]. % 提供了详细的栈跟踪信息 > try_test:demo2(). [{1,a}, {2,a}, {3,{'EXIT',a}}, {4,{'EXIT',a}}, {5, {'EXIT',{a,[{try_test,generate_exception,1, [{file,\\\"try_test.erl\\\"},{line,23}]}, {try_test,catcher2,1,[{file,\\\"try_test.erl\\\"},{line,38}]}, {try_test,'-demo2/0-lc$^0/1-0-',1, [{file,\\\"try_test.erl\\\"},{line,41}]}, {try_test,'-demo2/0-lc$^0/1-0-',1, [{file,\\\"try_test.erl\\\"},{line,41}]}, {erl_eval,do_apply,6,[{file,\\\"erl_eval.erl\\\"},{line,689}]}, {shell,exprs,7,[{file,\\\"shell.erl\\\"},{line,686}]}, {shell,eval_exprs,7,[{file,\\\"shell.erl\\\"},{line,642}]}, {shell,eval_loop,3,[{file,\\\"shell.erl\\\"},{line,627}]}]}}}] \"]},\"46\":{\"h\":\"针对异常的编程样式\",\"t\":[\"sqrt(X) when X < 0 -> % 内置函数 error 可以改进错误信息 error({squareRootNegativeArgument, X}); sqrt(X) -> math:sqrt(X). % 函数多半应该返回 {ok, Value} 或 {error, Reason} error_process(X) -> case f(X) of {ok, Val} -> do_some_thing_with(Val); {error, Why} -> %% process this error do_other_thing_with(error) end. % 捕捉一切可能的异常错误 error_process3(X) -> try my_func(X) catch _:_ -> process_error() end. \"]},\"47\":{\"h\":\"栈跟踪（erlang:get_stacktrace()）\"},\"48\":{\"h\":\"二进制型与位语法\"},\"49\":{\"h\":\"顺序编程补遗\"},\"50\":{\"h\":\"apply\",\"t\":[\"内置函数apply(Mod, Func, [Arg1, Arg2, ..., ArgN])会将模块Mod里的Func函数应用到Arg1, Arg2, ... ArgN这些参数上。\",\"> apply(erlang, atom_to_list, [hello]). \\\"hello\\\" \",\"应当尽量避免使用apply。 当函数的参数数量能预先知道时， M:F(Arg1, Arg2, ... ArgN) 这种调用形式要比apply好得多。\"]},\"51\":{\"h\":\"算数表达式\"},\"52\":{\"h\":\"属性\",\"t\":[\"模块属性的语法是 -AtomTag(...) ， 它们被用来定义文件的某些属性。\",\"包含预定义的模块属性和用户定义的属性。\"]},\"53\":{\"h\":\"预定义模块属性\",\"t\":[\"-module(modulename)：模块声明\",\"-import(Mod, [Name/Arity1, Name2/Arity2, ...])：列举了哪些函数要导入到模块中\",\"-compile(Options)：添加 Options 到编译器选项列表中\",\"-vsn(Version)：指定模块的版本号\"]},\"54\":{\"h\":\"用户定义的模块属性\",\"t\":[\"-SomeTag(Value).：SomeTag 必须是一个原子，Value 必须是一个字面数据类型\",\"-author({jeo, armstring}). -purpose(\\\"example of attributes\\\"). \"]},\"55\":{\"h\":\"块表达式\",\"t\":[\"用于以下情形：代码某处的Erlang语法要求单个表达式，但我们想使用一个表达式序列\",\"begin Expr1, ..., ExprN end \"]},\"56\":{\"h\":\"布尔值 布尔表达式\",\"t\":[\"Erlang没有单独的布尔值类型。不过原子true和false具有特殊的含义，可以用来表示布尔值。\",\"not B1\",\"B1 and B2\",\"B1 or B2\",\"B1 xor B2\"]},\"57\":{\"h\":\"动态代码载入\",\"t\":[\"每当调用 someModule:someFunction(...) 时，调用的总是最新版模块里的最新版函数，哪怕当代码在模块里运行时重新编译了该模块也是如此。 Erlang允许一个模块的两个版本同时运行：当前版和旧版。重新编译某个模块时，任何运行旧版代码的进程都会被终止，当前版成为旧版，新编译的版本则成为当前版\"]},\"58\":{\"h\":\"预处理器\",\"t\":[\"Erlang模块在编译前会自动由Erlang的预处理器进行处理。预处理器会展开源文件里所有的宏，并插入必要的包含文件。\",\"如调试某个有问题的宏时，应该保存预处理器的输出。\",\"erlc -P some_module.erl \"]},\"59\":{\"h\":\"转义序列\",\"t\":[\"可以在字符串和带引号的原子里使用转义序列来输入任何不可打印的字符。\"]},\"60\":{\"h\":\"函数引用\",\"t\":[\"引用在当前或外部模块里定义的某个函数。\",\"fun LocalFunc/Arity：引用当前模块的本地函数\",\"fun Mod:RemoteFunc/Arity：引用 Mod 模块的外部函数\"]},\"61\":{\"h\":\"包含文件\",\"t\":[\"许多模块需要共享通用的记录定义，就会把它们放到包含文件里，再由所有需要这些定义的模块包含此文件\",\"-include(Filename).\",\"按照Erlang的惯例，包含文件的扩展名是.hrl。 FileName应当包含一个绝对或相对路径，使预处理器能找到正确的文件。包含库的头文件（ library header file）时可以用下面的语法：\",\"-include_lib(\\\"kernel/include/file.hrl\\\") \"]},\"62\":{\"h\":\"列表操作：++、--\",\"t\":[\"++ 和 -- 是用于列表添加和移除的中缀操作符。\",\"A ++ B 使A和B相加（也就是附加）。\",\"A -- B 从列表A中移除列表B。 移除的意思是B中所有元素都会从A里面去除。 \",\"请注意：如果符号X在B里只出现了K次，那么A只会移除前K个X。\"]},\"63\":{\"h\":\"宏 -define()\",\"t\":[\"% 宏语法模板，erlang预处理器 epp 碰到 ?MacronName 的表达式时会展开这个宏 -define(Constant, Replacement). -define(Func(Var1, Var2, .., Var), Replacement). \",\"-define(macro1(X, Y), {a, X, Y}). foo(A) -> ?macro1(A+10, b) % --- 展开后 --- foo(A) -> {a, A+10, b}. \",\"预制宏\",\"?FILE\",\"?MODULE\",\"?LINE\"]},\"64\":{\"h\":\"宏控制流\",\"t\":[\"-undef(Macro).\",\"-ifdef(Macro).\",\"-ifndef(Macro).\",\"-else.\",\"-endif.\"]},\"65\":{\"h\":\"数字\",\"t\":[\"Erlang里的数字不是整数就是浮点数，整数的运算时精确的。\",\"% K 进制 2#00101010 16#af6bfa23 % $ 写法，代表 ASCII 字符的整数代码 $a % 97的简写 % 浮点数 1.0 3.14159 -2.3e+6 23.56E-27 \"]},\"66\":{\"h\":\"操作符优先级\"},\"67\":{\"h\":\"进程字典\",\"t\":[\"每个Erlang进程都有一个被称为进程字典（ process dictionary）的私有数据存储区域。他是一个 map。\",\"put(Key, Value) -> OldValue.\",\"get(Key) -> Value.\",\"get() -> [{Key, Value}].：返回整个进程字典\",\"get_keys(Value) -> [Key].：返回字典里面所有值为 Value 的键\",\"erase(Key) -> Value.\",\"erase() -> [{Key, Value}].\",\"1> erase(). [] 2> put(x, 20). undefined 3> get(x). 20 4> get(y). undefined 5> put(y, 40). undefined 6> get(y). 40 7> get(). [{y,40},{x,20}] 8> erase(x). 20 9> get(). [{y,40}] \"]},\"68\":{\"h\":\"引用\",\"t\":[\"引用（ reference）是一种全局唯一的Erlang数据类型。它们由内置函数 erlang:make_ref() 创建。 引用的用途是创建独一无二的标签，把它存放在数据里并在后面用于比较是否相等。\"]},\"69\":{\"h\":\"短路布尔表达式\",\"t\":[\"只在必要时才对参数求值\",\"Expr1 orelse Expr2：Expr1 || Expr2\",\"Expr1 andalso Expr2：Expr1 && Expr2\"]},\"70\":{\"h\":\"比较数据类型\"},\"71\":{\"h\":\"类型\"},\"72\":{\"h\":\"编译和运行程序\"},\"73\":{\"h\":\"改变开发环境\",\"t\":[\"code:get_path() 获取当前载入路径值\",\"-spec code:add_patha(Dir) 向载入路径的开头添加一个新目录 Dir\",\"-spec code:add_pathz(Dir) 向载入路径的末端添加一个新目录 Dir\"]},\"74\":{\"h\":\"运行程序的不同方式\",\"t\":[\"% erlang shell erl 1> c(hello). {ok,hello} 2> hello:start(). Hello world ok % 命令行界面直接编译和运行 $ erlc hello.erl % -noshell 不带交互式 shell 的方式启动 Erlang % -s hello start 运行 hello:start() 函数 % -s init stop 在之前的命令完成后执行 init:stop() 函数，从而停止系统 $ erl -noshell -s hello start -s init stop Hello world \",\"#!/usr/bin/env escript main(Args) -> io:format(\\\"Hello world~n\\\"). \"]},\"75\":{\"h\":\"makefile 使编译自动化\"},\"76\":{\"h\":\"并发和分布式程序\"},\"77\":{\"h\":\"现实世界中的并发\",\"t\":[\"Erlang进程没有共享内存，每个进程都有它自己的内存。要改变其他某个进程的内存，必须向它发送一个消息，并祈祷它能收到并理解这个消息。\"]},\"78\":{\"h\":\"并发编程\",\"t\":[\"Erlang 编写并发程序只需要三个基本函数\"]},\"79\":{\"h\":\"基本并发函数\",\"t\":[\"Pid = spawn(Mod, Func, Args)：创建一个并行进程来执行 apply(Mod, Func, Args)\",\"Pid = spawn(Fun)：创建一个新的并发进程来执行 FUn()\",\"Pid ! Message：向 Pid 进程发送消息 Message，消息发送是异步的。Pid1 ! Pid2 ! ... ! Msg 意思是把消息 Msg 发给所有进程\",\"receive ... end：接收发送给某个进程的消息\",\"receive Pattern1 [when Guard1] -> Expressions1; Pattern2 [when Guard2] -> Expressions2; ... end \",\"每个进程都带有一个进程邮箱，与进程同步创建。收到的消息会被放入该进程的邮箱，程序执行一条接收语句时才会读取邮箱。\"]},\"80\":{\"h\":\"客户端-服务器\",\"t\":[\"% Erlang 依赖于 actor并发模型。在 Erlang 编写并发程序的三要素： % 创建进程，发送消息，接收消息 % 启动一个新的进程使用`spawn`函数，接收一个函数作为参数 F = fun() -> 2 + 2 end. % #Fun<erl_eval.20.67289768> spawn(F). % <0.44.0> % `spawn` 函数返回一个pid(进程标识符)，你可以使用pid向进程发送消息。 % 使用 `!` 操作符发送消息。 % 我们需要在进程内接收消息，要用到 `receive` 机制。 -module(caculateGeometry). -compile(export_all). caculateAera() -> receive {rectangle, W, H} -> W * H; {circle, R} -> 3.14 * R * R; _ -> io:format(\\\"We can only caculate area of rectangles or circles.\\\") end. % 编译这个模块，在 shell 中创建一个进程，并执行 `caculateArea` 函数。 c(caculateGeometry). CaculateAera = spawn(caculateGeometry, caculateAera, []). CaculateAera ! {circle, 2}. % 12.56000000000000049738 % shell也是一个进程(process), 你可以使用`self`获取当前 pid self(). % <0.41.0> \"]},\"81\":{\"h\":\"进程很轻巧\",\"t\":[\"% 查看允许的最大进程数量 > erlang:system_info(processlimit). 262144 \"]},\"82\":{\"h\":\"带超时的接收\",\"t\":[\"为避免接收语句因为消息不来而一直等待，可以给接收语句增加一个超时设置，设置进程等待接收消息的最长时间。\",\"receive Pattern1 [when Guard1] -> Expressions1; Pattern2 [when Guard2] -> Expressions2; ... after Time -> Expressions end \"]},\"83\":{\"h\":\"选择性接收\",\"t\":[\"receive 基本函数从进程邮箱中提取消息，做模式匹配，把未匹配的消息加入队列供以后处理，并管理超时。\"]},\"84\":{\"h\":\"注册进程\",\"t\":[\"一般创建进程时，只有父进程知道子进程的 PID。使用注册进程的方法，可以公布进程标识符，让任何进程都能与该进程通信。\",\"% 用 AnAtom 作为名称来注册进程 Pid register(AnAtom, Pid) % 移除与 AnAtom 关联的所有注册信息 unregister(AnAtom) % 检查 AnAtom 是否已被注册 whereis(AnAtom) -> Pid | undefined % 返回包含系统里所有注册进程的列表 registered() -> [AnAtom::atom()] \"]},\"85\":{\"h\":\"尾递归的说明\",\"t\":[\"尾递归：收到消息进行处理之后立即再次调用 loop()\",\"% 并发程序模板 % 接收并打印出任何发给它的消息 -module(ctemplate). -compile(export_all). start() -> spawn(?MODULE, loop, []). rpc(Pid, Request) -> Pid ! {self(), Request}, receive {Pid, Response} -> Response end. loop(X) -> receive Any -> io:format(\\\"Received:~p~n\\\", [Any]), loop(X) end. \"]},\"86\":{\"h\":\"分布式编程\"},\"87\":{\"h\":\"两种分布式模型\",\"t\":[\"分布式 Erlang\",\"程序在 Erlang 节点（node）上运行，节点是一个独立的 Erlang 系统，包含一个自带地址空间和进程组的完整虚拟机。\",\"通常运行在数据同一个局域网的集群上，并受防火墙保护。\",\"基于套接字的分布式模型\",\"用 TCP/IP 套接字来编写运行在不可信环境中的分布式应用程序。不如分布式 Erlang 那样强大，但是更安全。\"]},\"88\":{\"h\":\"编写一个分布式程序\",\"t\":[\"分布式应用程序编写顺序\",\"在常规非分布式会话里编写和测试程序\",\"在运行于同一台计算机上的两个不同 Erlang 节点中测试程序\",\"在运行于两台物理隔离计算机上的两个不同 Erlang 节点里测试程序。\"]},\"89\":{\"h\":\"编程库与框架\"},\"90\":{\"h\":\"接口技术\"},\"91\":{\"h\":\"Erlang 如何与外部程序通信\",\"t\":[\"Erlang 通过端口对象与外部程序通信。端口的行为就像一个 Erlang 进程。\",\"-spec open_port(PortName, [Opt]) -> Port 可以创建端口\",\"% 向端口发送Data Port ! {PicC, {command, Data}} % 把相连进程的 PID 从 PicC 改为 Pid1 Port ! {PicC, {connect, Pid1}} % 关闭端口 Port ! {Pid, close} \"]},\"92\":{\"h\":\"用端口建立外部 C 程序接口\"},\"93\":{\"h\":\"在 Erlang 里调用 shell 脚本\",\"t\":[\"% 运行字符串的命令并捕捉结果 os:cmd(\\\"ifconfig\\\"). \"]},\"94\":{\"h\":\"文件编程\"},\"95\":{\"h\":\"套接字编程\"},\"96\":{\"h\":\"用 WebSocket 和 Erlang 进行浏览\"},\"97\":{\"h\":\"用 ETS 和 DETS 存储数据\",\"t\":[\"ets 和 dets 是两个系统模块，用来高效存储海量的 Erlang 数据。它们都提供大型的键-值查询表。可以被多个进程共享。\",\"ETS（Erlang Term Storage）：常驻内存，查找时间是恒定的。易失。没有垃圾收集机制，不会有垃圾收集的负担。\",\"DETS（Disk ETS）：使用磁盘存储，速度慢于 ETS，内存占用也小很多。非易失。打开时会进行一致性检查，损坏会尝试修复，可能会花很长时间；表中最后一项可能是损坏的会丢失。\"]},\"98\":{\"h\":\"表的类型\",\"t\":[\"ETS 和 DETS 表保存的是元组。元组里的某一个元素（默认是第一个）被称为该表的键。\",\"异键表（set）：表里所有的键都是唯一的\",\"有序异键（ordered set）：元组会被排序\",\"同键表（bag）：允许多个元素拥有相同的键\",\"副本同键（duplicate bag）：可以有多个元组拥有相同的键，而且在同一张表里可以存在多个相同的元组\",\"-module(ets_test). %% API -export([start/0]). start() -> lists:foreach(fun test_ets/1, [set, ordered_set, bag, duplicate_bag]). test_ets(Mode) -> TableId = ets:new(test, [Mode]), ets:insert(TableId, {a, 1}), ets:insert(TableId, {b, 2}), ets:insert(TableId, {a, 1}), ets:insert(TableId, {a, 3}), List = ets:tab2list(TableId), io:format(\\\"~-13w => ~p~n\\\", [Mode, List]), ets:delete(TableId). \",\"λ erl Eshell V12.3.2.1 (abort with ^G) 1> c(ets_test). {ok,ets_test} 2> ets_test:start(). set => [{b,2},{a,3}] ordered_set => [{a,3},{b,2}] bag => [{b,2},{a,1},{a,3}] duplicate_bag => [{b,2},{a,1},{a,1},{a,3}] ok \"]},\"99\":{\"h\":\"影响 ETS 表效率的因素\",\"t\":[\"ETS 表在内部是用散列表表示的，（ordered set）用平衡二叉树表示。\"]},\"100\":{\"h\":\"保存元组到磁盘\"},\"101\":{\"h\":\"Mnesia：Erlang 数据库\",\"t\":[\"Mnesia是一种用Erlang编写的数据库。\",\"Mnesia的速度极快，可以保存任何类型的Erlang数据结构。它还是高度可定制的。数据表既可以保存在内存里（为了速度），也可以保存在磁盘上（为了持久性）。表还可以在不同机器之间进行复制，从而实现容错行为。\"]},\"102\":{\"h\":\"创建初始数据库\",\"t\":[\"$ erl % mnesia:create_schema(NodeList) 会在 Erlang 节点列表的所有节点上都初始化一个新的 Mnesia 数据库，会初始化并且创建一个目录结构来保存 1> mnesia:create_schema([node()]). ok 2> init:stop(). ok $ ls Mnesia.nonode@nohost # 创建名为 joe 的 erlang 节点 $ erl -sname joe # 启动 erlang 时指向一个特定的数据库 $ erl -mnesia dir '\\\"/home/joe/some/path/to/Mnesia.company\\\"' \"]},\"103\":{\"h\":\"数据库查询\",\"t\":[\"-module(test_mnesia). -import(lists, [foreach/2]). -compile(export_all). %% IMPORTANT: The next line must be included %% if we want to call qlc:q(...) -include_lib(\\\"stdlib/include/qlc.hrl\\\"). % Mnesia 里的表是一个包含若干行的**异键或同键表**，其中每一行都是**一个 Erlang 记录**。要在 Mnesia 里表示这些表，需要一些**记录定义**来对表里的行进行定义。 -record(shop, {item, quantity, cost}). -record(cost, {name, price}). -record(design, {id, plan}). %% 初始化数据表 do_this_once() -> mnesia:create_schema([node()]), mnesia:start(), mnesia:create_table(shop, [{attributes, record_info(fields, shop)}]), mnesia:create_table(cost, [{attributes, record_info(fields, cost)}]), mnesia:create_table(design, [{attributes, record_info(fields, design)}]), mnesia:stop(). start() -> mnesia:start(), mnesia:wait_for_tables([shop,cost,design], 20000). %% SQL equivalent %% SELECT * FROM shop; demo(select_shop) -> do(qlc:q([X || X <- mnesia:table(shop)])); %% SQL equivalent %% SELECT item, quantity FROM shop; demo(select_some) -> do(qlc:q([{X#shop.item, X#shop.quantity} || X <- mnesia:table(shop)])); %% SQL equivalent %% SELECT shop.item FROM shop %% WHERE shop.quantity < 250; demo(reorder) -> do(qlc:q([X#shop.item || X <- mnesia:table(shop), X#shop.quantity < 250 ])); %% SQL equivalent %% SELECT shop.item %% FROM shop, cost %% WHERE shop.item = cost.name %% AND cost.price < 2 %% AND shop.quantity < 250 demo(join) -> do(qlc:q([X#shop.item || X <- mnesia:table(shop), X#shop.quantity < 250, Y <- mnesia:table(cost), X#shop.item =:= Y#cost.name, Y#cost.price < 2 ])). do(Q) -> F = fun() -> qlc:e(Q) end, {atomic, Val} = mnesia:transaction(F), Val. example_tables() -> [%% The shop table {shop, apple, 20, 2.3}, {shop, orange, 100, 3.8}, {shop, pear, 200, 3.6}, {shop, banana, 420, 4.5}, {shop, potato, 2456, 1.2}, %% The cost table {cost, apple, 1.5}, {cost, orange, 2.4}, {cost, pear, 2.2}, {cost, banana, 1.5}, {cost, potato, 0.6} ]. add_shop_item(Name, Quantity, Cost) -> Row = #shop{item=Name, quantity=Quantity, cost=Cost}, F = fun() -> mnesia:write(Row) end, mnesia:transaction(F). remove_shop_item(Item) -> Oid = {shop, Item}, F = fun() -> mnesia:delete(Oid) end, mnesia:transaction(F). farmer(Nwant) -> %% Nwant = Number of oranges the farmer wants to buy F = fun() -> %% find the number of apples [Apple] = mnesia:read({shop,apple}), Napples = Apple#shop.quantity, Apple1 = Apple#shop{quantity = Napples + 2*Nwant}, %% update the database mnesia:write(Apple1), %% find the number of oranges [Orange] = mnesia:read({shop,orange}), NOranges = Orange#shop.quantity, if NOranges >= Nwant -> N1 = NOranges - Nwant, Orange1 = Orange#shop{quantity=N1}, %% update the database mnesia:write(Orange1); true -> %% Oops -- not enough oranges mnesia:abort(oranges) end end, mnesia:transaction(F). reset_tables() -> mnesia:clear_table(shop), mnesia:clear_table(cost), F = fun() -> foreach(fun mnesia:write/1, example_tables()) end, mnesia:transaction(F). add_plans() -> D1 = #design{id = {joe,1}, plan = {circle,10}}, D2 = #design{id = fred, plan = {rectangle,10,5}}, D3 = #design{id = {jane,{house,23}}, plan = {house, [{floor,1, [{doors,3}, {windows,12}, {rooms,5}]}, {floor,2, [{doors,2}, {rooms,4}, {windows,15}]}]}}, F = fun() -> mnesia:write(D1), mnesia:write(D2), mnesia:write(D3) end, mnesia:transaction(F). get_plan(PlanId) -> F = fun() -> mnesia:read({design, PlanId}) end, mnesia:transaction(F). \"]},\"104\":{\"h\":\"性能分析、调试与跟踪\"},\"105\":{\"h\":\"Erlang 代码的性能分析工具\",\"t\":[\"cprof 统计各个函数被调用的次数。它是一个轻量级的性能分析器，在活动系统上运行它会增加 5%～ 10% 的系统负载。\",\"fprof显示调用和被调用函数的时间，结果会输出到一个文件。它适用于实验室或模拟系统里的大型系统性能分析，并会显著增加系统负载。\",\"eprof 测量 Erlang 程序是如何使用时间的。它是 fprof 的前身，适用于小规模的性能分析。\",\"(scarb@DESKTOP-72654G4)5> cprof:start(). 9795 (scarb@DESKTOP-72654G4)6> shout:start(). ** exception error: undefined function shout:start/0 (scarb@DESKTOP-72654G4)7> mnesia:stop(). stopped (scarb@DESKTOP-72654G4)8> cprof:pause(). 9795 (scarb@DESKTOP-72654G4)9> cprof:analyse(mnesia). {mnesia,1,[{{mnesia,stop,0},1}]} \"]},\"106\":{\"h\":\"运行时诊断\",\"t\":[\"deliberate_error(A) -> bad_function(A, 12), lists:reverse(A). bad_function(A, _) -> {ok, Bin} = file:open({abc,123}, A), binary_to_list(Bin). \",\"错误消息之后是栈跟踪信息。它以发生错误的函数名开头，后面是当前函数完成后将会返回的各个函数清单（包括函数名、模块名和行号）。由此可知，错误发生在 lib_misc:bad_function/2 里，而此函数将会返回到 lib_misc:deliberate_error/1，以此类推。\"]},\"107\":{\"h\":\"调试方法\"},\"108\":{\"h\":\"io:format 调试\",\"t\":[\"给程序添加打印语句是最常见的调试形式。可以简单地在程序的关键位置添加 io:format(...) 语句来打印出感兴趣的变量值。\",\"调试并行程序时，一种好的做法是在发送消息到别的进程之前先把它打印出来，收到消息之后也要立即打印。\"]},\"109\":{\"h\":\"转储至文件\",\"t\":[\"dump(File, Term) -> Out = File ++ \\\".tmp\\\", io:format(\\\"** dumping to ~s~n\\\",[Out]), {ok, S} = file:open(Out, [write]), io:format(S, \\\"~p.~n\\\",[Term]), file:close(S). \"]},\"110\":{\"h\":\"Erlang 调试器\"},\"111\":{\"h\":\"跟踪消息与进程执行\",\"t\":[\"erlang:trace(PidSpec, How, FlagList) 它会启动跟踪。PidSpec 告诉系统要跟踪什么进程，How 是一个开启或关闭跟踪的布尔值，FlagList 指定了要跟踪的事件（比如，可以跟踪所有的函数调用，跟踪所有正在发送的消息，跟踪垃圾收集何时进行，等等）。 一旦调用了 erlang:trace/3 这个内置函数，调用它的进程就会在跟踪事件发生时收到跟踪消息。跟踪事件本身是通过调用 erlang:trace_pattern/3确定的。\",\"erlang:trace_pattern(MFA, MatchSpec, FlagList)\",\"它用于设置一个跟踪模式。如果模式匹配，请求的操作就会执行。这里的MFA是一个{Module, Function, Args}元组，指定要对哪些代码应用跟踪模式。 MatchSpec是一个模式，会在每次进入MFA指定的函数时进行测试，而FlagList规定了跟踪条件满足时要 做什么。\",\"可以用库模块 dbg 来执行与之前相同的跟踪。\",\"fib(0) -> 1; fib(1) -> 1; fib(N) -> fib(N - 1) + fib(N - 2). test1() -> dbg:tracer(), dbg:tpl(tracer_test, fib, '_', dbg:fun2ms(fun(_) -> return_trace() end)), dbg:p(all, [c]), tracer_test:fib(4). \"]},\"112\":{\"h\":\"OTP 介绍\",\"t\":[\"Open Telecom Platform（开放电信平台），它是一个应用程序操作系统，包含了一组库和实现方式，可以构建大规模、容错和分布式的应用程序。它由瑞典电信公司爱立信开发，在爱立信内部用于构建容错式系统。标准的Erlang分发套装包含OTP库。\",\"OTP 包含了许多强大的工具，例如一个完整的 Web 服务器，一个FTP服务器和一个 CORBAORB 等。\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"113\":{\"h\":\"Arthas 笔记\",\"t\":[\"原文地址：http://hscarb.github.io/other/20230306-arthas-note.html\"]},\"114\":{\"h\":\"Arthas idea plugin 文档\",\"t\":[\"https://www.yuque.com/wangji-yunque/rk4eks/ruradh\"]},\"115\":{\"h\":\"执行静态方法和 Spring 对象方法\",\"t\":[\"https://hicode.club/articles/2022/03/30/1648606091635.html\"]},\"116\":{\"h\":\"Spring\",\"t\":[\"设置输出内容为json\",\"options json-format true \",\"找到 org.springframework.boot.loader.LaunchedURLClassLoader 的 hash\",\"classloader -l \",\"找到 spring 对象并执行方法\",\"# 执行无参数 vmtool -c f2c488 --action getInstances \\\\ --className org.springframework.context.ApplicationContext \\\\ --express 'instances[0].getBean(\\\"globalCtxManager\\\").obtGlobalStatistics()' # 执行带参数的方法，其中参数是普通变量 vmtool -c f2c488 --action getInstances \\\\ --className org.springframework.context.ApplicationContext \\\\ --express 'instances[0].getBean(\\\"globalCtxManager\\\").obtUserAliveStatus(1156083311884992513L)' # 执行带参数的方法，其中参数是对象。如果需要构建对象，可以参考： # https://juejin.cn/post/6844904013859651597#heading-16 vmtool -c f2c488 --action getInstances \\\\ --className org.springframework.context.ApplicationContext \\\\ --express 'instances[0].getBean(\\\"liveCoreService\\\").searchLiveInfo((#demo=new com.uewell.ubirth.bus.live.bo.live.LiveInfoParam(), #demo.setId('12345L'),#demo))' \"]},\"117\":{\"h\":\"直接执行静态方法\",\"t\":[\"ognl -c 54acff7d '@io.netty.buffer.PooledByteBufAllocator@DEFAULT' ognl -c f2c488 '@io.netty.util.internal.PlatformDependent@DIRECT_BUFFER_PREFERRED' \"]},\"118\":{\"h\":\"使用Arthas显式执行代码，避免重启应用，10倍提升本地研发效率\",\"t\":[\"https://github.com/alibaba/arthas/issues/1823\"]},\"119\":{\"h\":\"前提\",\"t\":[\"本方法最适用于 Spring Boot 项目。\"]},\"120\":{\"h\":\"谁拖垮了效率？\",\"t\":[\"本地开发时有两个操作最耗时：\",\"每次代码变更都要重启一次项目，重启的时间相对较长。\",\"代码深层次的一个方法，也需要有类似 HTTP 的触发入口一层一层调用过来，这是非常麻烦的事。\",\"所以我在寻找一种可以不停机的开发方法，所有变更都能随时生效，代码随写随测。\"]},\"121\":{\"h\":\"探索\",\"t\":[\"代码热变更方面，我使用了久负盛名的 IDEA 插件 JRebel。该插件可以做到绝大部分的新增/修改代码，安装使用方式可以在网上搜索。\",\"但有了 JRebel 之后，我发现仍然很难调用看到的方法，如果通过 HTTP 接口调用过来很麻烦，过程很长，并且前后的一些操作的结果也是我不想要的。再比如写着写着突然对某个资源的响应内容不确定。 我希望能随时调用看到的每一个方法。后来看了一些 arthas 的 user case 和文档，大脑中最后几块拼图也终于拼上了。\"]},\"122\":{\"h\":\"准备工作\",\"t\":[\"随意调用方法，其实是指 Spring 上下文中的方法。否则直接写 main 方法或 Tester 代码就可以随写随测。以 Spring 的上下文进行调用才是我们想要的。以下是准备工作：\",\"安装 IDEA Arthas 插件：https://arthas.aliyun.com/doc/idea-plugin.html\",\"项目中增加依赖 Arthas Spring Boot Starter：https://arthas.aliyun.com/doc/spring-boot-starter.html ，担心安全问题的话可以只在本地开启，其他环境配置 spring.arthas.enabled = false\",\"代码中提供获取 Spring ApplicationContext 的变量的方法，参考 https://github.com/WangJi92/arthas-plugin-demo/blob/master/src/main/java/com/wangji92/arthas/plugin/demo/common/ApplicationContextProvider.java，并配置好插件获取 Spring Context 的路径:\",\"截屏2021-06-14 下午1 39 34\"]},\"123\":{\"h\":\"开始起飞\",\"t\":[\"使用 JRebel 的方式启动项目，启动后浏览器打开 Arthas 控制台 http://localhost:8563 ，在要调用的方法上选择复制Static Spring Context Invoke Method Field\",\"随后到 Arthas 控制台粘贴即可：\",\"整个开发过程中 Arthas 控制台不用关，随时想测某个方法时，复制命令 -> 控制台执行 -> 观察 即可。\",\"此方法对以下一些场景有奇效：\",\"XXL-Job 任务执行。本地不希望任务在跑，就可以在启动时关闭任务注册功能。测试时也可以不依赖 xxl-job admin 随时调试任务。\",\"Dubbo 服务。不用模拟客户端或者泛化调用之类的，直接用 arthas 整。Arthas 命令不方便设置复杂的入参，这种情况可以在方法中自行覆盖参数，用 JRebel 热更新一下就行。\"]},\"124\":{\"h\":\"ognl 使用姿势\",\"t\":[\"https://cloud.tencent.com/developer/article/1846725\",\"https://juejin.cn/post/6844904013859651597\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"125\":{\"h\":\"分布式系统韧性架构压舱石OpenChaos\",\"t\":[\"原文地址：http://hscarb.github.io/other/20230306-openchaos.html\",\"Key Takeaways\",\"本文首先以现今分布式系统的复杂性和稳定性的需求引出混沌工程概念，并阐述了OpenChaos在传统混沌工程上的优化与创新。\",\"第二部分中，介绍了OpenChaos的架构，详细讲解了它的可靠性模型和弹性模型的工作原理，并以两个实战案例展示了OpenChaos在实际应用场景中可以发挥的效果。\",\"最后一部分展望未来，提出了OpenChaos后续的发展方向。\"]},\"126\":{\"h\":\"背景\",\"t\":[\"随着Serverless，微服务（含服务网格）与越来越多的容器化架构应用的出现，我们构建、交付与运维系统的方式变的越发复杂。这种复杂性增加了系统状态可观测性的难度。在已有的生产环境中，我们有不同的方式来获取信息，增强系统的可观测性。起始的时候，可能是非常简单的给定一个特定的条件，产生一个特定的指标输出。进一步的，使用结构化和关联日志，或进行分布式跟踪，引入事件总线如Apache EventMesh、EventGrid等。随着Codeless组合式应用快速发展，Serverless设计理念也在不断被一些分布式系统设计者逐步接受。免运维，按需付费，极致弹性，多租共池等等无不在逼迫我们重新审视老式架构的合理性，催生新架构的不断演进。融合架构是这几年被提的最多的一个词，以往支撑在线/离线系统的复杂架构不断被融合，通过可分可合的设计与部署方式去适配各种业务场景。在这样的背景下，我们开始认真审视并思考，是否有一种更为现代化的工具，能够帮助发现并应对分布式云这种底座对架构设计以及上层应用带来的诸如可靠，安全，弹性等一系列韧性架构的挑战。\",\"混沌工程思想给我们带来了一定程度的启发。Netflix最初为了搬迁基础设施上云创建了 Chaos Monkey，由此拉开了混沌工程学的序幕。再到后来，CNCF成立了专门的兴趣小组，希望能够推动这一领域的标准诞生。OpenChaos创始团队早期也和这些社区的先行者进行过多轮交流。可惜的是，2019年随着该兴趣组并入App Delivery SIG后再无太大动静。这几年国家政策大力引导下，企业的数字化升级不断加快，越来越多的CIO、CTO甚至包括CEO开始重视并投入到混沌工程实践中。国内由信通院牵头的混沌工程实验室也在如火如荼地推动该领域的飞速发展，从全链路压测，混沌故障引入到催生未来架构变革的多云多活参考架构的制定。这些无不昭示着这一产业在飞速发展。根据国内外科技媒体调研统计，到2025年，80%的组织将实施混沌工程实践。通过全链路压测，混沌故障，以及多云多活架构等策略的整体导入，可以将意外停机时间减少50%，实现真正意义上的秒级RTO/RPO。让应用、业务创新更加专注。\"]},\"127\":{\"h\":\"良药虽好，但也有局限\",\"t\":[\"混沌工程的最基本流程是在生产环境小规模定期自动化执行试验，为系统随机的注入故障，来观察 \\\"系统边界\\\"。它主要关注系统面对故障所展现出的容错能力，可靠性。目前市面上绝大部分混沌工程工具，倾向于构造以黑盒随机为主的故障类型，对底层基础设施（硬件，操作系统，数据库与中间件）理解与洞察较少。缺少统一的框架标准、成熟的specific度量指标。同时，分析反馈较弱，无法给出全面彻底的诊断建议，尤其通过强化学习，生成式AI等能力可以进一步解决目前随机故障注入，进行自愈风险分析与优化建议。\",\"面向有更多复杂特性的分布式系统，仅通过观察系统应对故障的表现是有局限的，并且依赖于观察是极其主观的，很难形成统一的评测标准，也较难针对表现分析系统缺陷。系统的可观测性，不仅需要模型的全面覆盖，还需要完备的监测系统，并提供全面的结果报告，甚至智能预测，来指导架构提升自身的韧性能力。分布式领域资深技术专家，开源顶级项目Apache RocketMQ，OpenMessaging最初的创始人冯嘉曾表示\\\"云原生分布式架构的演进正在朝着组装式架构，韧性架构进一步发展\\\"。在这样的背景下，他提出并带领团队创造了OpenChaos这一新兴项目。\"]},\"128\":{\"h\":\"OpenChaos 需要解决的本质问题\",\"t\":[\"韧性架构，覆盖高靠性、安全、弹性、不可变基础设施等特性。实现真正的韧性架构毫无疑问是现代分布式系统的演进方向。针对分布式系统韧性能力，OpenChaos借助混沌工程思想，对其定义进行延伸扩展。针对一些分布式系统特有属性，如Pub/Sub系统的投递语义与推送效率，调度编排系统的精准调度、弹性伸缩与冷启效率，streaming系统的流批实时性、反压效率，检索系统的查全率与查准率，分布式系统共识组件的一致性等，设置专用的检测模型。OpenChaos 内置可扩展的模型支持，以便验证在大规模数据请求以及各种故障冲击下的韧性表现，并为架构演进提供进一步优化建议。\"]},\"129\":{\"h\":\"架构与案例分析\",\"t\":[\"图1\"]},\"130\":{\"h\":\"整体架构\",\"t\":[\"OpenChaos的工作原理是这样的：控制面对整个流程进行控制，负责使集群节点组成一个待测试的分布式集群。并会根据需要测试的分布式基础设施找到对应的Driver组件并载入，根据设置的并发数建立相应个数的客户端。控制节点根据 Model 组件定义的执行流程控制客户端对集群进行操作。演练过程中，Detection Model 会对集群节点根据不同的观测特性引入对应的事件。Metrics 模块会在实验中监测被测集群的表现。演练结束后，Checker组件会对实验中的业务和非业务数据进行自动化分析，得出测试结果并输出可视化图表。\",\"如图1所示，OpenChaos的整体架构可以分为管理层，执行层与被测组件层。\",\"最上层为管理层，它包含了用户界面和控制器（Control），控制器负责调度引擎层的组件进行工作。最下层为被测组件，它可以是自部署的分布式系统集群，也可以是容器或者云厂商承载的分布式系统。\",\"中间层是执行层，也是OpenChaos强大能力的秘密所在。模型（Model）是执行的流程的基本单元，它定义了对分布式系统进行操作的基本形式。控制器在模型中载入需要测试的分布式系统的驱动（Driver），并根据配置的并发数创建相应的客户端（Client），最终使用客户端对分布式系统执行操作。**检测模型（Detection Model）**会根据用户关注的不同观测特性引入对应的事件，比如引入故障或者系统的扩缩容。Metrics 模块会在实验中监测被测集群的表现。演练结束后，**度量模型（Measurement Model）**组件会对实验中的业务和非业务数据进行自动化分析，得出测试结果并输出可视化图表。\"]},\"131\":{\"h\":\"检测模型与度量模型\"},\"132\":{\"h\":\"检测模型\",\"t\":[\"传统混沌工程主要关注系统的稳定性，它们的普遍实现是通过黑盒的故障注入来模拟一些常见的通用故障。OpenChaos中的检测模型关注更高维度的属性------韧性，它包含可靠性，还包含如弹性、安全性等特性的检测模型。相较于传统混沌工程，OpenChaos不仅支持普遍的黑盒故障注入，还可恶意针对分布式基础软件如消息或缓存等的主备倒换，网络分区导致的脑裂等问题做定制检测，以观察他们在这种情况下的表现。\"]},\"133\":{\"h\":\"度量模型\",\"t\":[\"由于分布式系统的复杂性，对于分布式系统韧性的观测更需要一个简单直观的分析报告，来让人更方便地发现分布式系统可能存在的缺陷和不足。度量模型会对系统的表现进行分析，以统一的标准化计算输出结果与图表，方便使用者进行对比分析。以消息系统的稳定性评估为例，度量模型会根据实验中故障注入情况与系统表现，计算出系统的 RPO（Recovery Point Objective）和 RTO（Recovery Time Objective）。输出集群的处理语义情况，如是否符合 at least once 或 exactly once；故障恢复情况，故障期间是否出现系统不可用，及不可用的恢复时间；故障下是否满足预期的分区顺序性；系统在整个实验过程中的响应时间等。\"]},\"134\":{\"h\":\"可靠性案例分析\",\"t\":[\"我们使用OpenChaos对ETCD集群进行可靠性测试，发现在主节点网络断开，单独成为一个分区的场景下，ETCD客户端视角下，集群缺乏自动恢复能力。\",\"图2\",\"下面是利用 OpenChaos执行的一个实验结果示例，是一个3节点 ETCD 集群在主节点与从节点网络断开，单独成为一个分区时的表现，模拟的业务流量速率为1000 tps。\",\"图3\",\"从图中可以看出实验持续10分钟，共注入十次主节点网络分区故障，间隔为30秒，故障期间集群表现不一致。下图为更详细的实验结果。\",\"在第1/3/6/8次故障期间，集群无法自行恢复；其他故障期间花费7秒会恢复集群为可用状态，但整个实验中没有出现数据丢失。\",\"图4\",\"通过查看实验过程信息，发现每次主节点被分区时，集群均可在故障期间自行转移主节点。通过分析源码 ，ETCD 客户端在面对ETCD内部错误时，不会进行重试连接其他节点。导致在客户端优先连接的节点为主节点，并发生不可用时，即便主节点已经成功转移，整体集群恢复为可用，业务仍处于未恢复状态。该问题我们也已经report给ETCD社区，等待进一步修复。\"]},\"135\":{\"h\":\"弹性案例分析\",\"t\":[\"弹性也是分布式系统需要重点关注的能力，除可靠性外，OpenChaos支持对系统扩缩容能力的度量与评测。与可靠性不同，分布式系统的弹性能力不能通过编排固定频率的事件以触发检测。OpenChaos可以根据用户设置的操作系统指标或业务指标阈值来触发扩缩容。\",\"例如，你可以指定集群CPU平均占用的预期值为 40%，或系统响应的预期时间为100ms。弹性检测模型会根据指定的预期值与当前系统表现，根据OpenChaos内置的算法来计算出要弹到的目标规模，来触发扩缩容动作。实验结束后，度量模型会计算出集群的\\\"加速比效率\\\"，与\\\"扩缩代价\\\"和对应规模下集群的性能。\",\"注：\\\"加速比效率\\\"和\\\"扩缩代价\\\"为OpenChaos中度量分布式系统弹性能力的指标，前者表示分布式系统并行化的性能和效果，后者表示系统伸缩的速率。\",\"弹性的含义不仅包括实例节点的伸缩能力，同样也包含具体业务（应用）单元的伸缩能力。为了探索Kafka分区的最佳使用实践，我们设计了实验以探索单个topic分区的扩容能力。在实验中我们还会统计在不同分区个数下消息收发的吞吐量，以了解分区数量对消息吞吐量的影响和达到最大吞吐量的最优分区数数量。\",\"图5为三节点集群上的一个 topic 的分区从 1 扩到 9000 时的 tps 和延迟情况。\",\"图5\",\"图6为各指标随着实验时间的变化情况。\",\"图6\",\"图7是具体的弹性评测结果部分截图，展示了在不同规模下，系统表现出的性能以及弹性变更的花销与效率。其中changeCost 和 resilienceEfficienty 为上文描述的扩缩代价与加速比效率结果。\",\"图7\",\"从上述结果能够看出，此实验规格下的 Kafka 集群，新增1个分区的平均时间约20ms。在分区数量达到 26 的时候性能达到最优，该情况下吞吐量达到130万，此时CPU 总体利用率达到 93%。在分区数达到450+时，性能明显下降。当分区数达到 1992 时，吞吐量降到 3.8万，CPU总体利用率达到 97%。\"]},\"136\":{\"h\":\"未来规划\",\"t\":[\"目前 OpenChaos已支持接入大多数分布式系统，如Apache Kafka、Apache RocketMQ、DLedger、 Redis、ETCD等。随着开源之夏2022活动的召开，我们开放了更多分布式系统接入的工作，供广大学生选择与参与[1]。与此同时，我们与混沌工程师实验室紧密合作。助力信通院颁发了国内首个《分布式消息队列稳定性评估标准》。作为该项标准的主要贡献者，华为云中间件消息产品家族也是唯一一个全面通过验收标准的厂商。未来，我们会继续打磨该项目，加快生态建设，努力将它打造成分布式系统韧性架构的压舱石，推动云原生架构不断演进。关键时候方能\\\"任凭风浪起，稳坐钓鱼船\\\"。\",\"作者简介：\",\"思莹，资深研发工程师，对分布式系统一致性算法，韧性架构，模式识别有深刻的理解与研究。\",\"嘉浩，资深中间件研发工程师，负责华为云分布式中间件设计与研发，擅长中间件性能优化，喜欢大道至简的设计理念。\",\"马海，华为云中间件可靠性技术专家，擅长混沌工程、性能测试，事件驱动架构设计。\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\",\"https://summer-ospp.ac.cn/#/org/prodetail/221bf0008↩︎\"]},\"137\":{\"h\":\"Vim 显示、去除换行符\",\"t\":[\"原文地址：http://hscarb.github.io/other/20230316-vim-linebreaker.html\"]},\"138\":{\"h\":\"背景\",\"t\":[\"Dos 和 windows：采用回车+换行（CR/LF）表示下一行\",\"UNIX/Linux：采用换行符（LF）表示下一行\",\"MAC OS：采用回车符（CR）表示下一行\",\"CR用符号\\\\r表示, 十进制ASCII代码是13, 十六进制代码为0x0D\",\"LF用符号\\\\n表示, 十进制ASCII代码是10, 十六制为0x0A.\"]},\"139\":{\"h\":\"显示换行符\",\"t\":[\":set list shows newline ($)\",\":e ++ff=unix shows CR (^M)\",\"if you want to see both, :set list then :e ++ff=unix\"]},\"140\":{\"h\":\"去除 CR\",\"t\":[\":%s/\\\\r//g\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"141\":{\"h\":\"other\",\"t\":[\"Erlang 学习笔记\",\"Arthas 笔记\",\"分布式系统韧性架构压舱石OpenChaos\",\"Vim 显示、去除换行符\"]},\"142\":{\"h\":\"RabbitMQ 进程内流控（Flow Control） 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220131-rabbitmq-flow-control.html\"]},\"143\":{\"h\":\"1. 概述\"},\"144\":{\"h\":\"1.1 为什么要流控？\",\"t\":[\"流控主要是为了防止生产者生产消息速度过快，超过 Broker 可以处理的速度。这时需要暂时限制生产者的生产速度，让 Broker 的处理能够跟上生产速度。\",\"Erlang进程之间不共享内存，每个进程都有自己的进程邮箱，进程间只通过消息来通信。Erlang没有对进程邮箱的大小进行限制，所以当有大量消息持续发往某个进程时，会导致该进程邮箱过大，最终内存溢出并崩溃。如果没有流控，可能会导致内部进程邮箱的大小很快达到内存阈值。\"]},\"145\":{\"h\":\"1.2 RabbitMQ 的多种流控机制\"},\"146\":{\"h\":\"1.2.1 全局流控（内存高水位、磁盘低水位）\",\"t\":[\"RabbitMQ 可以对内存和磁盘使用量设置阈值，当达到阈值后，生产者将被完全阻塞（处于block状态） ，直到对应项恢复正常。\",\"内存和磁盘的流控相当于全局流控，流控时发送消息被完全阻塞，通常会阻塞较长时间（几分钟以上）才恢复。\",\"全局流控时，从Web UI可以观察到 Connection 处于blocked状态。\",\"在 rabbitmq-java-client 中，可以用给 Connection 添加 blockedListener 的方式监听阻塞和阻塞解除的事件，用以在客户端应对可能的阻塞情况。\",\"connection.addBlockedListener( reason -> { try { unblock(); } catch (InterruptedException e) { e.printStackTrace(); } }, () -> latch.countDown() ); \"]},\"147\":{\"h\":\"1.2.2 进程内流控\",\"t\":[\"进程内流控是针对 Erlang 进程的流控，与全局流控不是一个概念。又可称作 Per-Connection Flow Control。\",\"在 RabbitMQ Broker 中使用多种进程来处理消息，进程的处理顺序如下。\",\"A simplified depiction of message flows\",\"A simplified depiction of message flows\",\"reader -> channel -> queue process -> message store \",\"进程内流控指的是这4种进程之间的流控。\",\"进程内流控不会影响到消费端。\",\"某进程处于流控状态时，从 Web UI 可以观察到该进程的状态为黄色flow，此时该进程会暂时阻塞消息的生产。\",\"A queue in flow state\",\"A queue in flow state\",\"进程内流控的阻塞时间通常很短，在1秒之内。但是也有长至几分钟的。\",\"进程内流控是阻塞在 Broker 端的 socket 接收方法中，client 端无法监听和做出处理。\",\"从 RabbitMQ 3.5.5 版本开始，引入了一套基于信用证的流控实现。\",\"本文主要讨论基于信用证的进程内流控实现。\"]},\"148\":{\"h\":\"1.2.3 发送方确认\",\"t\":[\"这其实并不属于流控机制，但是通过生产者确认的方式可以让发送消息不丢失，并且控制发送消息的速度。\",\"未开启发送方确认时，消息可能未达到服务器就发送完毕。\",\"发送方确认开启后，消息在投递到匹配的队列后会给发送方返回一个确认请求，至此发送消息的动作才执行完毕。\"]},\"149\":{\"h\":\"1.2.4 消费者预取\",\"t\":[\"通过Channel#basicQos(int prefetchCount)方法设置消费者允许存在的的最大未Ack消息数量，可以达到预取一批消息到消费者进行消费的目的。\"]},\"150\":{\"h\":\"2. 概要流程\",\"t\":[\"从 RabbitMQ 3.5.5 版本开始，引入了一套基于信用证的流控实现。\"]},\"151\":{\"h\":\"2.1 信用证配置\",\"t\":[\"信用证流控的两个参数可以通过查询环境变量的方式找到\",\"rabbitmqctl eval 'application:get_all_env(rabbit).' # ... {credit_flow_default_credit,{400,200}} # {InitialCredit, MoreCreditAfter} # ... \",\"其中400表示每个进程初始的信用值，200表示下游进程处理200个消息后会一次性给上游进程加200信用值。\",\"这两个参数在老一点的版本中为{200, 50}。\"]},\"152\":{\"h\":\"2.2 基于信用证的流控\",\"t\":[\"Erlang 进程与操作系统的进程不同，是一种轻量级进程。\",\"简单来说，RabbitMQ中有四种进程。\",\"reader -> channel -> queue process -> message store 400 400 400 \",\"在初始化时，会为前三种进程分配信用值，分配的值为InitialCredit，默认400。\",\"当进程处理一条消息并且发给下游进程时，它自己的信用值会减一。\",\"下游进程处理完一条消息时，会给上有进程发一个Ack消息。但是此时并不会直接让上游进程的信用值加一，而是等到处理完MoreCreditAfter条消息（默认200）时，才将上游进程的信用值加200。\",\"当进程的信用值将为1时，就会阻塞上游进程向它发送消息。\"]},\"153\":{\"h\":\"3. 详细流程\"},\"154\":{\"h\":\"3.1 流控详细流程\",\"t\":[\"下图每个橙色组件都是一个 Erlang 进程。\",\"每个RabbitMQ broker在内部都是通过actor模式实现的，不同组件之间通过消息传递(有时是本地的)进行通信。\",\"A simplified depiction of message flows\",\"A simplified depiction of message flows\",\"下面我们把这个模型简化，然后分析基于信用证的流控机制。\",\"rabbit_reader：Connection 的处理进程。负责接收、解析 AMQP 协议数据包，将消息发送到 Channel\",\"rabbit_channel：Channel 的处理进程，负责处理 AMQP 协议的各种方法、进行路由解析；进行安全和协调的处理等\",\"rabbit_amqqueue_process：Queue 的处理进程，负责将消息存入内存、将队列索引持久化\",\"rabbit_msg_store：Store 的处理进程，负责消息的持久化\",\"Credit based flow control with classic queues、\",\"Credit based flow control with classic queues、\",\"信用证初始化时，下游进程分别为前三个进程 reader、channel、queue 分配初始信用值InitialCredit(400)（图中1）\",\"当 reader 进程开始处理一条消息，它会先将自己的信用值-1，然后将消息处理完后发给 channel 进程（图中2）\",\"channel 进程接收 reader 发过来的消息时，会在信用证系统种进行 ack 操作。channel 进程会持续追踪它从 reader 进程 ack 了多少条消息。当累计接收并 ack 的消息数达到MoreCreditAfter(200) 后，会给 reader 分配新的MoreCreditAfter(200)信用值。（图中3）\",\"当进程字典中的信用值降为0时，该进程会被阻塞。它不会接收消息也不会发送消息，直到获得新的信用值。\",\"最终，TCP 读取进程被阻塞，从 socket 读取的操作被停止。\"]},\"155\":{\"h\":\"3.2 如何识别性能瓶颈\",\"t\":[\"在管理 UI 中，你可能看到 Connection、Channel、Queue 处于flow状态，说明它们最近处于流控状态。这意味着它们暂时耗尽了信用值，等待下游进程授予更多信用。进程内流控可能在1秒钟内触发多次。\",\"如何通过flow状态识别进程的性能瓶颈？\",\"简单来说，一个进程的flow状态会导致它的上游进程进入flow状态。而该进程进入flow状态的原因是因为它的下游进程成为了性能瓶颈。\",\"例如，在下图中，Queue 进程成为性能瓶颈：\",\"Credit exhaustion.\",\"Credit exhaustion.\",\"上图中，Queue 处理缓慢，这就意味着 Queue 可能在较长时间内都没有授予 Channel 新的信用值。Channel 处理比 Queue 快，这样 Channel 的信用值就会先一步耗尽。\",\"Channel 信用值耗尽后，Channel 被阻塞，不会接受消息也不会处理消息，这样 Reader 的信用值也将会耗尽。\",\"也就是说，Queue 如果是性能瓶颈，最终会导致它的上游，即 Channel 和 Reader 处于flow状态。\",\"下面可以总结出判断性能瓶颈在何处的结论：\",\"当某个 Connection 处于flow状态，但这个 Connection 中没有一个 Channel 处于flow状态时，这就意味这个 Connection 中有一个或者多个 Channel 出现了性能瓶颈。某些 Channel 进程的运作(比如处理路由逻辑)会使得服务器 CPU 的负载过高从而导致了此种情形。尤其是在发送大量较小的非持久化消息时，此种情形最易显现。\",\"当某个 Connection 处于flow状态 ，并且这个 Connection 中也有若干个 Channel 处于flow状态，但没有任何一个对应的队列处于flow状态时，这就意味着有一个或者多个队列出现了性能瓶颈。这可能是由于将消息存入队列的过程中引起服务器 CPU 负载过高，或者是将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较小的持久化消息时，此种情形最易显现。\",\"当某个 Connection 处于flow状态，同时这个 Connection 中也有若干个 Channel 处于flow状态，井且也有若干个对应的队列处于flow状态时，这就意味着在消息持久化时出现了性能瓶颈。在将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较大的持久化消息时，此种情形最易显现。\"]},\"156\":{\"h\":\"4. 源码解析\",\"t\":[\"在 Erlang 中，每个进程都保存为一个.erl文件。这里的进程与操作系统的进程不同，是一个由 Erlang 系统管理的轻量级进程。而信用证流控的逻辑都位于credit_flow.erl文件中。\",\"下面我们以rabbit_reader（Connection 进程）和rabbit_channel进程为例，看一下源码中如何处理信用的流动和消息的阻塞。\"]},\"157\":{\"h\":\"4.1 处理消息，减少信用\",\"t\":[\"当rabbit_reader处理一个有内容的命令（比如basic.publish)，会执行如下加粗逻辑\",\"% rabbit_reader.erl process_frame(Frame, Channel, State) -> ChKey = {channel, Channel}, case (case get(ChKey) of undefined -> create_channel(Channel, State); Other -> {ok, Other, State} end) of {error, Error} -> handle_exception(State, Channel, Error); {ok, {ChPid, AState}, State1} -> case rabbit_command_assembler:process(Frame, AState) of {ok, NewAState} -> put(ChKey, {ChPid, NewAState}), post_process_frame(Frame, ChPid, State1); {ok, Method, NewAState} -> rabbit_channel:do(ChPid, Method), put(ChKey, {ChPid, NewAState}), post_process_frame(Frame, ChPid, State1); **{ok, Method, Content, NewAState} -> rabbit_channel:do_flow(ChPid, Method, Content), put(ChKey, {ChPid, NewAState}), post_process_frame(Frame, ChPid, control_throttle(State1));** {error, Reason} -> handle_exception(State1, Channel, Reason) end end. \",\"可以看到会先执行rabbit_channel:doflow/3，再看一下这个方法\",\"% rabbit_channel_common.erl do_flow(Pid, Method, Content) -> %% Here we are tracking messages sent by the rabbit_reader %% process. We are accessing the rabbit_reader process dictionary. credit_flow:send(Pid), gen_server2:cast(Pid, {method, Method, Content, flow}). \",\"可以看到在rabbit_channel中会调用credit_flow:send/1方法。这里的Pid是 Channel 的进程号。\",\"这里的逻辑是：rabbit_reader通过credit_flow模块来追踪它已经向rabbit_channel进程发送的消息数，每发一条消息就会将自己的信用值减一。被追踪的信息保存在rabbit_reader的进程字典中。\",\"注意，尽管这里是在rabbit_channel模块中调用credit_flow:send/1方法，但是此处仍处于rabbit_reader进程中，只有在执行完gen_server2:cast/2方法后才会进入到rabbit_channel进程的内存空间。因此，当credit_flow:send/1方法被调用时，信用值减一的操作仍然在rabbit_reader进程中被追踪。\",\"见下面credit_flow:send/2和credit_flow:UPDATE的定义，通过调用get/1和put/2方法获取并更新进程字典的值。\",\"% credit_flow.erl send(From, {InitialCredit, _MoreCreditAfter}) -> ?UPDATE({credit_from, From}, InitialCredit, C, if C == 1 -> block(From), 0; true -> C - 1 end). \",\"% credit_flow.erl %% process dict update macro - eliminates the performance-hurting %% closure creation a HOF would introduce -define(UPDATE(Key, Default, Var, Expr), begin %% We deliberately allow Var to escape from the case here %% to be used in Expr. Any temporary var we introduced %% would also escape, and might conflict. Var = case get(Key) of undefined -> Default; V -> V end, put(Key, Expr) end). \",\"来看一下进程字典中关于信用证的信息\",\"Untitled\",\"用来保存信用值信息的 key 是{credit_from, From}，From表示消息接受者的进程号（这里是rabbit_channel）。当这个 key 对应的值达到 0，拥有该进程字典的进程会被阻塞（调用credit_flow:block/1）方法\"]},\"158\":{\"h\":\"4.2 进程阻塞，停止接收信息\",\"t\":[\"上面说到，当进程字典中的信用值达到 0 时，会调用credit_flow:block/1方法，我们来看看这个方法中做了什么。\",\"% credit_flow.erl block(From) -> ?TRACE_BLOCKED(self(), From), case blocked() of false -> put(credit_blocked_at, erlang:monotonic_time()); true -> ok end, ?UPDATE(credit_blocked, [], Blocks, [From | Blocks]). \",\"这里更新了进程字典中credit_blocked的值，将阻塞这个进程的下游进程ID（这里是rabbit_channel）加入到credit_blocked中。\",\"注意，因为rabbit_reader可能会将消息发送给多个进程，所以它也可能被多个进程阻塞。因此credit_blocked的值是一个进程ID列表。\",\"credit_blocked -> [pid()] \",\"那么进程阻塞之后，如何停止信息接收？我们来分析一下rabbit_reader接收消息的入口，recvloop方法。\",\"% rabbit_reader.erl recvloop(Deb, Buf, BufLen, State = #v1{pending_recv = true}) -> mainloop(Deb, Buf, BufLen, State); recvloop(Deb, Buf, BufLen, State = #v1{connection_state = blocked}) -> mainloop(Deb, Buf, BufLen, State); recvloop(Deb, Buf, BufLen, State = #v1{connection_state = {become, F}}) -> throw({become, F(Deb, Buf, BufLen, State)}); recvloop(Deb, Buf, BufLen, State = #v1{sock = Sock, recv_len = RecvLen}) when BufLen < RecvLen -> case rabbit_net:setopts(Sock, [{active, once}]) of ok -> mainloop(Deb, Buf, BufLen, State#v1{pending_recv = true}); {error, Reason} -> stop(Reason, State) end; \",\"其中mainloop会调用recvloop函数，达成无限循环的效果。\",\"rabbit_reader每接收一个包，就设置套接字属性为{active, once}，若当前连接处于blocked状态，则不设置{active, once}，这个接收进程就阻塞在receive方法上。\"]},\"159\":{\"h\":\"4.3 增加信用值\",\"t\":[\"rabbit_channel每处理一条消息，都会向rabbit_reader进行一次确认（credit_flow:ack）。\",\"当rabbit_channel累计处理的消息数达到MoreCreditAfter值时，会授予rabbit_reader新的MoreCreditAfter点信用值。\",\"我们先来看一下ack函数的实现\",\"% credit_flow.erl ack(To, {_InitialCredit, MoreCreditAfter}) -> ?UPDATE({credit_to, To}, MoreCreditAfter, C, if C == 1 -> grant(To, MoreCreditAfter), MoreCreditAfter; true -> C - 1 end). \",\"rabbit_channel进程会记录它向特定的发送者（rabbit_reader）ack了多少条消息。在进程字典中用来保存ack消息数的 key 是{credit_to, To}，这里To是发送者（rabbit_reader）的进程号。\",\"当MoreCreditAfter条消息被ack，会调用grant方法授予rabbit_reader更多的信用值。\",\"% credit_flow.erl grant(To, Quantity) -> Msg = {bump_credit, {self(), Quantity}}, case blocked() of false -> To ! Msg; true -> ?UPDATE(credit_deferred, [], Deferred, [{To, Msg} | Deferred]) end. \",\"在这里，rabbit_channel将会发送一条{bump_credit, {self(), Quantity}}的消息给rabbit_reader来授予信用。其中self()指向rabbit_channel。\",\"当rabbit_reader进程收到bump_credit消息后，它需要将消息传入并调用credit_flow:handle_bump_msg/1方法来处理新增信用值。\",\"% credit_flow.erl handle_bump_msg({From, MoreCredit}) -> ?UPDATE({credit_from, From}, 0, C, if C =< 0 andalso C + MoreCredit > 0 -> unblock(From), C + MoreCredit; true -> C + MoreCredit end). \",\"我们访问rabbit_reader的进程字典，更新{credit_from, From}这个 key。如果信用值大于0，那么进程会解除阻塞。\"]},\"160\":{\"h\":\"4.4 进程解除阻塞\",\"t\":[\"% credit_flow.erl unblock(From) -> ?TRACE_UNBLOCKED(self(), From), ?UPDATE(credit_blocked, [], Blocks, Blocks -- [From]), case blocked() of false -> case erase(credit_deferred) of undefined -> ok; Credits -> _ = [To ! Msg || {To, Msg} <- Credits], ok end; true -> ok end. \",\"调用credit_flow:unblock/1会更新credit_blocked列表，将其清空。随后进程可以继续发送消息。\",\"同时，credit_flow:unblock/1将负责发送在credit_deferred列表中保存的所有消息。\",\"当unblock/1被调用时，rabbit_channel进程的ID将从credit_blocked的列表中删除。\",\"%% We are operating on process A dictionary. get(credit_blocked) => [B, C]. unblock(B). get(credit_blocked) => [C]. \",\"在这种情况下，A 仍然被阻塞，直到 C 授予它更多信用。当 A 的阻塞解除，它将处理它的 credit_deferred列表，发送bump_credit消息给列表中的进程。\"]},\"161\":{\"h\":\"5. 参考资料\",\"t\":[\"Flow Control\",\"Finding bottlenecks with RabbitMQ 3.3\",\"New Credit Flow Settings on RabbitMQ 3.5.5\",\"RABBITMQ INTERNALS - CREDIT FLOW FOR ERLANG PROCESSES\",\"Quorum Queues and Flow Control - The Concepts\",\"RabbitMQ实战指南\",\"RabbitMQ流量控制机制分析\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"162\":{\"h\":\"RabbitMQ Federation 插件使用\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220313-rabbitmq-federation-plugin.html\"]},\"163\":{\"h\":\"概述\",\"t\":[\"RabbitMQ Federation 插件可以将消息从一个 Exchange 复制到另一个 Exchange，或从一个 Queue 分发到另一个 Queue。\",\"复制的源端被称为 upstream，复制的目的端被称为 downstream。要使用 Federation 插件，需要在两个集群都开启 Federation 插件，并且在 downstream 集群创建 Federation，配置 upstream。\"]},\"164\":{\"h\":\"使用场景\",\"t\":[\"将多个集群的消息收集到一个集群\",\"将一个队列的压力分散到多个集群\",\"在不下线的情况下将数据从一个集群同步到另一个集群\",\"减少消息消费的时延\"]},\"165\":{\"h\":\"Federation 种类\",\"t\":[\"可以创建两种类型的 Federation，分别是 Exchange Federation 和 Queue Federation。\"]},\"166\":{\"h\":\"Exchange Federation\",\"t\":[\"简单说，它可以实现消息在 Exchange 间的复制（同步）。\",\"使用 Exchange Federation 可以将消息发到其他集群。效果是，当消息发送到被联邦的 Exchange 时，消息会被发送到本地的 Exchange 和 下游的集群。这样，你就可以在不同的集群多次消费消息。\"]},\"167\":{\"h\":\"Queue Federation\",\"t\":[\"Queue Federation 的效果是消息的负载均衡，它只会将消息发往有空闲消费者的下游集群。也就是说，消息不会被复制。\",\"常被用于分散压力和集群消息转移。\"]},\"168\":{\"h\":\"使用前提\",\"t\":[\"两个 RabbitMQ 服务器或集群\",\"在两个 RabbitMQ 上开启 Federation 插件\",\"（可选）为 Federation 的组件单独创建用户\",\"上下游 RabbitMQ 网络可以通过 AMQP 协议连接\"]},\"169\":{\"h\":\"Federation Exchange 使用\",\"t\":[\"满足使用前提\",\"在下游节点配置 Federation 的 upstream\",\"在下游节点配置 Policy，指定要被 Federate 的 Exchange 或 Queue\"]},\"170\":{\"h\":\"upstream 上游集群配置\",\"t\":[\"创建 Exchange\",\"1. 创建 Exchange\",\"创建 Queue\",\"2. 创建 Queue\",\"绑定 Exchange 和 Queue\",\"3. 绑定 Exchange 和 Queue\"]},\"171\":{\"h\":\"downstream 下游集群配置\",\"t\":[\"配置 upstream\",\"1. 配置 upstream\",\"创建 Federation policy\",\"2. 创建 Federation 的 policy\",\"检查 Federation 状态\",\"3. 检查 Federation 状态\"]},\"172\":{\"h\":\"测试\",\"t\":[\"在上游集群向 Exchange 发送消息\",\"在上游集群向 Exchange 发送消息\",\"在上下游集群的队列都可以收到消息\",\"在上下游集群的队列都可以收到消息\"]},\"173\":{\"h\":\"参考资料\",\"t\":[\"Federation Plugin\",\"FAQ: What is the RabbitMQ Federation plugin\",\"Setup RabbitMQ Exchange Federation\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"174\":{\"h\":\"RabbitMQ 3.7.x 版本 安装\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220408-rabbitmq-3.7-install.html\",\"本文讲解 Ubuntu 下 RabbitMQ 3.7 版本的安装。\"]},\"175\":{\"h\":\"1. Erlang 22.x 安装\",\"t\":[\"RabbitMQ 3.7 版本依赖 Erlang 21.3 ~ 22.x 版本。\",\"https://www.rabbitmq.com/which-erlang.html#eol-series\",\"首先需要安装 Erlang。\",\"最简单的 Erlang 安装方法是用 Erlang-Solution 提供的安装包。\",\"https://www.erlang-solutions.com/downloads/\"]},\"176\":{\"h\":\"1.1 .deb 安装包安装\",\"t\":[\"进入上述网页，选择 Erlang OTP\",\"在此处选择对应版本的 Erlang 安装包下载，并传到 Ubuntu 服务器目录。\",\"随后执行\",\"dpkg -i esl-erlang_22.3.4.9-1_ubuntu_focal_amd64.deb \",\"第一次执行会报如下错误\",\"Selecting previously unselected package esl-erlang. (Reading database ... 148404 files and directories currently installed.) Preparing to unpack esl-erlang_22.3.4.9-1_ubuntu_focal_amd64.deb ... Unpacking esl-erlang (1:22.3.4.9-1) ... dpkg: dependency problems prevent configuration of esl-erlang: esl-erlang depends on libncurses5; however: Package libncurses5 is not installed. esl-erlang depends on libwxbase2.8-0 | libwxbase3.0-0 | libwxbase3.0-0v5; however: Package libwxbase2.8-0 is not installed. Package libwxbase3.0-0 is not installed. Package libwxbase3.0-0v5 is not installed. esl-erlang depends on libwxgtk2.8-0 | libwxgtk3.0-0 | libwxgtk3.0-0v5 | libwxgtk3.0-gtk3-0v5; however: Package libwxgtk2.8-0 is not installed. Package libwxgtk3.0-0 is not installed. Package libwxgtk3.0-0v5 is not installed. Package libwxgtk3.0-gtk3-0v5 is not installed. esl-erlang depends on libsctp1; however: Package libsctp1 is not installed. dpkg: error processing package esl-erlang (--install): dependency problems - leaving unconfigured Errors were encountered while processing: esl-erlang \",\"这是因为缺少一些依赖包，执行如下命令安装。\",\"# sudo apt-get install -f Reading package lists... Done Building dependency tree Reading state information... Done Correcting dependencies... Done The following additional packages will be installed: libncurses5 libsctp1 libtinfo5 libwxbase3.0-0v5 libwxgtk3.0-gtk3-0v5 Suggested packages: lksctp-tools The following NEW packages will be installed: libncurses5 libsctp1 libtinfo5 libwxbase3.0-0v5 libwxgtk3.0-gtk3-0v5 0 upgraded, 5 newly installed, 0 to remove and 105 not upgraded. 1 not fully installed or removed. Need to get 5,521 kB/5,529 kB of archives. After this operation, 22.2 MB of additional disk space will be used. Do you want to continue? [Y/n] Y \",\"选择 Y 后，系统会自动安装依赖包。\",\"随后再执行\",\"dpkg -i esl-erlang_22.3.4.9-1_ubuntu_focal_amd64.deb \",\"安装 Erlang\"]},\"177\":{\"h\":\"1.2 apt 安装\",\"t\":[\"或者可以根据 Erlang-Solution 提供的 Installation using repository 指引进行安装。\",\"这里如果是 Ubuntu 20 版本，需要在 /etc/apt/sources.list 中添加\",\"deb https://packages.erlang-solutions.com/ubuntu focal contrib \",\"其中 focal 这些是 Ubuntu 的版本代号。\",\"随后更新 apt 缓存，安装 Erlang。注意此时需要指定安装 Erlang 的版本\",\"sudo apt-get update sudo apt-get install erlang=1:22.3.4.9-1 \"]},\"178\":{\"h\":\"2. 安装 RabbitMQ\",\"t\":[\"去 Github 发布页面下载对应的 RabbitMQ 版本的 .deb 安装包\",\"全部安装包列表\",\"https://github.com/rabbitmq/rabbitmq-server/tags\",\"3.7.27 版本\",\"https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.27\",\"下载后复制到服务器上安装\",\"# dpkg -i rabbitmq-server_3.7.27-1_all.deb (Reading database ... 153046 files and directories currently installed.) Preparing to unpack .../rabbitmq-server_3.7.27-1_all.deb ... Unpacking rabbitmq-server (3.7.27-1) over (3.7.27-1) ... dpkg: dependency problems prevent configuration of rabbitmq-server: rabbitmq-server depends on socat; however: Package socat is not installed. \",\"提示缺少 socat 这个包，于是手动安装\",\"apt-get install socat \",\"随后再次执行\",\"dpkg -i rabbitmq-server_3.7.27-1_all.deb \",\"RabbitMQ 被正确安装，运行\",\"rabbitmqctl cluster_status rabbitmqctl status \",\"查看当前节点状态\"]},\"179\":{\"h\":\"3. RabbitMQ 卸载\",\"t\":[\"https://stackoverflow.com/questions/39664283/how-to-remove-rabbitmq-so-i-can-reinstall\",\"sudo apt-get remove --auto-remove rabbitmq-server sudo apt-get purge --auto-remove rabbitmq-server \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"180\":{\"h\":\"RabbitMQ 镜像队列 使用和原理详解\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220409-rabbitmq-mirror-queue.html\"]},\"181\":{\"h\":\"1. 背景\",\"t\":[\"单节点的 RabbitMQ 存在性能上限，可以通过垂直或者水平扩容的方式增加 RabbitMQ 的吞吐量。垂直扩容指的是提高 CPU 和内存的规格；水平扩容指部署 RabbitMQ 集群。\",\"通过将单个节点的队列相对平均地分配到集群的不同节点，单节点的压力被分散，RabbitMQ 可以充分利用多个节点的计算和存储资源，以提升消息的吞吐量。\",\"但是多节点的集群并不意味着有更好的可靠性——每个队列仍只存在于一个节点，当这个节点故障，这个节点上的所有队列都不再可用。\",\"在 3.8 以前的版本，RabbitMQ 通过镜像队列（Classic Queue Mirroring）来提供高可用性。但镜像队列存在很大的局限性，在 3.8 之后的版本 RabbitMQ 推出了 Quorum queues 来替代镜像队列，在之后的版本中镜像队列将被移除。\",\"镜像队列通过将一个队列镜像（消息广播）到其他节点的方式来提升消息的高可用性。当主节点宕机，从节点会提升为主节点继续向外提供服务。\",\"本文将讲解镜像队列的使用方法和原理。\"]},\"182\":{\"h\":\"2. 镜像队列概述\",\"t\":[\"RabbitMQ 以队列维度提供高可用的解决方案——镜像队列。\",\"配置镜像队列规则后，新创建的队列按照规则成为镜像队列。每个镜像队列都包含一个主节点（Leader）和若干个从节点（Follower），其中只有主节点向外提供服务（生产消息和消费消息），从节点仅仅接收主节点发送的消息。\",\"从节点会准确地按照主节点执行命令的顺序执行动作，所以从节点的状态与主节点应是一致的。\"]},\"183\":{\"h\":\"3. 使用方法和注意事项\"},\"184\":{\"h\":\"3.1 配置方法\"},\"185\":{\"h\":\"3.1.1 管理界面配置\",\"t\":[\"使用策略（Policy）来配置镜像策略，策略使用正则表达式来配置需要应用镜像策略的队列名称，以及在参数中配置镜像队列的具体参数。\",\"按此步骤创建镜像策略，该策略为所有 mirror_ 开头的队列创建 3 副本镜像\",\"创建完的策略如下图显示\",\"参数解释：\",\"Name: policy的名称，用户自定义。\",\"Pattern: queue的匹配模式（正则表达式）。^表示所有队列都是镜像队列。\",\"Definition: 镜像定义，包括三个部分ha-sync-mode、ha-mode、ha-params。\",\"ha-mode: 指明镜像队列的模式，有效取值范围为all/exactly/nodes。 \",\"all：表示在集群所有的代理上进行镜像。\",\"exactly：表示在指定个数的代理上进行镜像，代理的个数由ha-params指定。\",\"nodes：表示在指定的代理上进行镜像，代理名称通过ha-params指定。\",\"ha-params: ha-mode模式需要用到的参数。\",\"ha-sync-mode: 表示镜像队列中消息的同步方式，有效取值范围为：automatic，manually。 \",\"automatic：表示自动向master同步数据。\",\"manually：表示手动向master同步数据。\",\"Priority: 可选参数， policy的优先级。\"]},\"186\":{\"h\":\"3.1.2 命令行\",\"t\":[\"rabbitmqctl set_policy [-p vhost] [--priority priority] [--apply-to apply-to] name pattern definition\",\"例如，对队列名称以“queue_”开头的所有队列进行镜像，并在集群的两个节点上完成进行，policy的设置命令为：\",\"rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue \\\"^mirror_\\\" '{\\\"ha-mode\\\":\\\"exactly\\\",\\\"ha-params\\\":3,\\\"ha-sync-mode\\\":\\\"automatic\\\"}' \"]},\"187\":{\"h\":\"3.1.3 HTTP API\",\"t\":[\"https://www.rabbitmq.com/ha.html#examples\",\"PUT /api/policies/%2f/ha-two { \\\"pattern\\\":\\\"^mirror_\\\", \\\"definition\\\": { \\\"ha-mode\\\":\\\"exactly\\\", \\\"ha-params\\\":3, \\\"ha-sync-mode\\\":\\\"automatic\\\" } } \"]},\"188\":{\"h\":\"3.2 镜像队列配置观测\",\"t\":[\"配置完 Policy 后，创建新的队列，或者原有的的队列，如果队列名称符合 Policy 的匹配规则，则该队列会自动创建为镜像队列。\",\"下图中 mirror_queue 匹配之前创建的镜像策略，为镜像队列。normal_queue 为普通队列\",\"镜像队列显示的蓝色 +2 表示同步副本数为 2 个。此处如果用红色显示，则表示为同步副本数\",\"显示的 mirror-policy 为该队列应用的镜像策略。\",\"点击队列名称可以进入查看队列详细信息，从中可以看出队列的主节点、从节点和镜像策略\"]},\"189\":{\"h\":\"3.3 配置参数\",\"t\":[\"镜像队列有许多配置参数，表达了镜像队列的镜像策略和异常后的晋升策略。\",\"下面来详细解释一下这些配置参数的意义\"]},\"190\":{\"h\":\"3.3.1 镜像策略\",\"t\":[\"ha-mode\",\"ha-params\",\"结果\",\"exactly\",\"count\",\"集群中队列副本的数量（主队列加上镜像）。count值为1表示一个副本：只有主节点。如果主节点不可用，则其行为取决于队列是否持久化。count值为2表示两个副本：一个队列主队列和一个队列镜像。换句话说:“镜像数=节点数-1”。如果运行队列主服务器的节点变得不可用，队列镜像将根据配置的镜像提升策略自动提升到主服务器。如果集群中的可用节点数少于count，则将队列镜像到所有节点。如果集群中有多个计数节点，并且一个包含镜像的节点宕机，那么将在另一个节点上创建一个新镜像。使用' exactly '模式和' ha-promot-on-shutdown ': ' always '可能是危险的，因为队列可以跨集群迁移，并在停机时变得不同步。\",\"all\",\"不设置\",\"队列跨集群中的所有节点镜像。当一个新节点被添加到集群中时，队列将被镜像到该节点。这个设置非常保守。建议设置的副本值为大多数节点N / 2 + 1。镜像到所有节点会给所有集群节点带来额外的负担，包括网络I/O、磁盘I/O和磁盘空间的使用。\",\"nodes\",\"节点名称\",\"队列被镜像到节点名中列出的节点。节点名是在rabbitmqctl cluster_status中出现的Erlang节点名；它们的形式通常是“rabbit@hostname”。如果这些节点名中有任何一个不是集群的一部分，则不构成错误。如果在声明队列时列表中的节点都不在线，则将在声明客户机连接的节点上创建队列。\"]},\"191\":{\"h\":\"3.3.2 新镜像同步策略\",\"t\":[\"ha-sync-mode\",\"说明\",\"manual\",\"这是默认模式。新队列镜像将不接收现有消息，它只接收新消息。一旦使用者耗尽了仅存在于主服务器上的消息，新的队列镜像将随着时间的推移成为主服务器的精确副本。如果主队列在所有未同步的消息耗尽之前失败，则这些消息将丢失。您可以手动完全同步队列，详情请参阅未同步的镜像部分。\",\"automatic\",\"当新镜像加入时，队列将自动同步。值得重申的是，队列同步是一个阻塞操作。如果队列很小，或者您在RabbitMQ节点和ha-sync-batch-size之间有一个快速的网络，那么这是一个很好的选择。\"]},\"192\":{\"h\":\"3.3.3 从节点晋升策略\",\"t\":[\"镜像队列主节点出现故障时，最老的从节点会被提升为新的主节点。如果新提升为主节点的这个副本与原有的主节点并未完成数据的同步，那么就会出现数据的丢失，而实际应用中，出现数据丢失可能会导致出现严重后果。\",\"rabbitmq 提供了 ha-promote-on-shutdown，ha-promote-on-failure 两个参数让用户决策是保证队列的可用性，还是保证队列的一致性；两个参数分别控制正常关闭、异常故障情况下从节点是否提升为主节点，其可设置的值为 when-synced 和 always。\",\"ha-promote-on-shutdown/ha-promote-on-failure\",\"说明\",\"when-synced\",\"从节点与主节点完成数据同步，才会被提升为主节点\",\"always\",\"无论什么情况下从节点都将被提升为主节点\",\"这里要注意的是ha-promote-on-failure设置为always，插拔网线模拟网络异常的两个测试场景：当网络恢复后，其中一个会重新变为mirror，具体是哪个变为mirror，受cluster_partition_handling处理策略的影响。\",\"例如两台节点A，B组成集群，并且cluster_partition_handling设置为autoheal，队列的master位于节点A上，具有全量数据，mirror位于节点B上，并且还未完成消息的同步，此时出现网络异常，网络异常后两个节点交互决策：如果节点A节点成为赢家，此时B节点内部会重启，这样数据全部保留不会丢失；相反如果B节点成为赢家，A需要重启，那么由于ha-prromote-on-failure设置为always，B节点上的mirror提升为master，这样就出现了数据丢失。\"]},\"193\":{\"h\":\"3.3.4 主队列选择策略\",\"t\":[\"RabbitMQ中的每个队列都有一个主队列。该节点称为队列主服务器。所有队列操作首先经过主队列，然后复制到镜像。这对于保证消息的FIFO排序是必要的。\",\"通过在策略中设置 queue-master-locator 键的方法可以定义主队列选择策略，这是常用的方法。\",\"此外，也可以用队列参数 x-queue-master-locator 或配置文件中定义 queue_master_locator 的方式指定，此处不再赘述。\",\"下面是该策略的可选参数列表\",\"queue-master-locator\",\"说明\",\"min-masters\",\"选择承载最小绑定主机数量的节点\",\"client-local\",\"选择客户机声明队列连接到的节点\",\"min-masters\",\"随机选择一个节点\"]},\"194\":{\"h\":\"3.4 注意事项\"},\"195\":{\"h\":\"3.4.1 多少个镜像才是最优的\",\"t\":[\"镜像到所有节点会增加所有集群节点的负载，包括网络 I/O、磁盘 I/O 和磁盘空间的使用。\",\"在大多数情况下，在每个节点上都有一个副本是不必要的。对于3个或更多节点的集群，建议复制到（N/2+1）个节点，例如 3 个节点集群中的 2 个节点或 5 个节点集群中的 3 个节点。\",\"由于某些数据可能天生是短暂的或对时间非常敏感，因此对某些队列使用较少的镜像（甚至不使用任何镜像）是完全合理的。\"]},\"196\":{\"h\":\"3.4.2 生产者确认和事务\",\"t\":[\"镜像队列同时支持生产者确认和事务机制。在事务机制中，只有当前事务在全部镜像中执行之后，客户端才会收到 Tx.Commit-OK 的消息。\",\"同样的，在生产者确认机制中，生产者进行当前消息确认的前提是该消息被全部镜像接收。\"]},\"197\":{\"h\":\"3.4.3 流控\",\"t\":[\"RabbitMQ 使用信用证机制限制消息生产的速度。当生产者收到队列的所有镜像授予的信用时，才允许发送新的消息。（这里的信用指的时发送许可。）如果有镜像没有授予生产者信用，会导致生产者生产阻塞。生产者会一直被阻塞，直到所有镜像都授予它信用值，或者有的镜像从集群中断开。\",\"Erlang 通过定时向所有节点发送心跳的方式检测断开的情况。发送心跳的间隔可以用 net_ticktime 来控制。\"]},\"198\":{\"h\":\"3.4.4 主节点失效和消费者取消\",\"t\":[\"从镜像队列中消费的客户端可能希望知道他们所消费的队列已经失败转移。当镜像队列发生故障时，哪些消息被发送到哪个消费者的信息就丢失了，因此所有未被确认的消息都会被重新发送，并设置了 redelivered 的标志。消费者可能希望知道这将会发生。\",\"如果是这样，他们可以使用参数 x-cancel-on-ha-failover 设置为 true。然后，它们的消费将在故障转移时被取消，并发送消费者取消通知。然后消费者就有责任重新发行基本版。消费来重新开始消费。\",\"Channel channel = ...; Consumer consumer = ...; Map<String, Object> args = new HashMap<String, Object>(); args.put(\\\"x-cancel-on-ha-failover\\\", true); channel.basicConsume(\\\"my-queue\\\", false, args, consumer); \",\"这将使用参数集创建一个新的消费者。\"]},\"199\":{\"h\":\"4. 镜像队列原理\"},\"200\":{\"h\":\"4.1 镜像队列的数据流\"},\"201\":{\"h\":\"4.1.1 客户端连接主节点\",\"t\":[\"首先看生产者消费者直接与主节点连接的情况。该情况下队列的主副本所在的节点与生产者/消费者直接连接，效率较高。\",\"生产者，消费者连接到 RabbitMQ 后，在 RabbitMQ 内部会创建对应的 Connection，Channel 进程。\",\"Connecton 进程从 socket 上接收生产者发送的消息后投递到 Channel 进程。\",\"在 Channel 进程中，根据消息发送的 exchange 与消息的 routing-key，在内部数据库的路由表中，查找所有匹配的 Queue 的进程 PID，然后将消息投递到Queue 的进程中。在镜像队列的情况下，Channel 进程除了将消息发送给队列的 Leader 进程外，还会将消息发送给队列所有的 Follower 进程，而 Follower 进程都在远端节点上，因此这里就多了一次集群间的网络交互。\",\"镜像队列的 Leader 进程收到消息后，需要将消息同步给所有的 Follower 进程。RabbitMQ 采用 GM（组播）算法实现，镜像队列中的 Leader 和所有 Follower 都会发送一次消息和接收一次消息，同时还会发送一次对消息的 ACK，和接收一次消息的 ACK。\",\"综上所述，生产者发送一条消息，队列 Leader 进程所在节点会收到两次：一次是生产者发送的，一次是队列 Follower 进程发送的；同样也会将消息对外发送两次：一次是生产者对应的 Channel 进程将消息发送给队列的 Follower 进程；一次是队列的 Leader 进程进行广播同步将消息发送给 Follower 进程。此外，镜像队列的GM算法实现 ，每条消息还会有额外的确认消息在集群间进行发送。\",\"再结合图中的情况，一条消息从生产者到消费，Node1节点是2进3出的流量，Node2节点是2进1出的流量。\"]},\"202\":{\"h\":\"4.1.2 客户端连接从节点\",\"t\":[\"如果生产者和消费者连接的是从节点，根据镜像队列的机制，只有主节点向外提供服务，所以镜像队列的消费需要由 node2 的队列消费消息。\",\"一条消息从生产到消费，生产者消费者连接的节点是3进3出，队列master进程所在的节点是2进2出。\"]},\"203\":{\"h\":\"4.2 镜像队列的实现原理\"},\"204\":{\"h\":\"4.2.1 普通队列结构\",\"t\":[\"通常队列由两部分组成\",\"amqqueue_process ，负责协议相关的消息处理，即接收生产者发布的消息、向消费者投递消息、处理消息 confirm、acknowledge 等等\",\"backing_queue，它提供了相关的接口供 amqqueue_process 调用，完成消息的存储以及可能的持久化工作等。\"]},\"205\":{\"h\":\"4.2.2 镜像队列结构\",\"t\":[\"镜像队列同样由这两部分组成，amqqueue_process 仍旧进行协议相关的消息处理，backing_queue 则是由 Leader 节点和 Follower 节点组成的一个特殊的 backing_queue。Leader 节点和 Follower 节点都由一组进程组成，一个负责消息广播的 GM，一个负责对 GM 收到的广播消息进行回调处理。\",\"在 Leader 节点上回调处理是 coordinator，在 Follower 节点上则是 mirror_queue_slave。mirror_queue_slave 中包含了普通的 backing_queue 进行消息的存储，Leader 节点中 backing_queue 包含在 mirror_queue_master 中由 amqqueue_process 进行调用。\"]},\"206\":{\"h\":\"4.2.3 GM(Guaranteed Multicast)\",\"t\":[\"GM 模块实现的是一种可靠的组播通信协议，该协议能够保证组播消息的原子性，即保证组中活着的节点要么都收到消息要么都收不到。\",\"它的实现大致为：将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上 : 当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。在 Leader 和 Follower 上的这些 GM 形成一个组 (gm_group) ，这个组的信息会记录在 Mnesia 中。不同的镜像队列形成不同的组。操作命令从 Leader 对应的 GM 发出后，顺着链表传送到所有的节点。由于所有节点组成了一个循环链表， Leader 对应的 GM 最终会收到自己发送的操作命令，这个时候 Leader 就知道该操作命令都同步到了所有的 Follower 上。\"]},\"207\":{\"h\":\"4.2.4 消息的广播\",\"t\":[\"消息从 Leader 节点发出，顺着节点链表发送。在这期间，所有的 Follower 节点都会对消息进行缓存，当 Leader 节点收到自己发送的消息后，会再次广播 ack 消息，同样 ack 消息会顺着节点链表经过所有的 Follower 节点，其作用是通知 Follower 节点可以清除缓存的消息，当 ack 消息回到 Leader 节点时对应广播消息的生命周期结束。\",\"下图为一个简单的示意图，A 节点为 Leader 节点，广播一条内容为 test 的消息。1 表示消息为广播的第一条消息；id=A表示消息的发送者为节点 A。右边是Follower 节点记录的状态信息。\",\"为什么所有的节点都需要缓存一份发布的消息呢？\",\"master发布的消息是依次经过所有slave节点，在这期间的任何时刻，有可能有节点失效，那么相邻的节点可能需要重新发送给新的节点。例如，A->B->C->D->A形成的循环链表，A为master节点，广播消息发送给节点B，B再发送给C，如果节点C收到B发送的消息还未发送给D时异常结束了，那么节点B感知后节点C失效后需要重新将消息发送给D。同样，如果B节点将消息发送给C后，B,C节点中新增了E节点，那么B节点需要再将消息发送给新增的E节点。\"]},\"208\":{\"h\":\"5. 镜像队列实践\",\"t\":[\"在 RabbitMQ 3.8 中发布了新的 Quorum Queues，旨在完全代替原有的镜像队列。\",\"在许多情况下，仲裁队列将是比传统队列镜像更好的选择。鼓励读者熟悉仲裁队列，并考虑它们而不是经典的镜像队列\"]},\"209\":{\"h\":\"5.1 镜像队列的缺点\",\"t\":[\"镜像队列最大的问题是其同步算法造成的低性能。镜像队列有如下几个设计缺陷\"]},\"210\":{\"h\":\"5.1.1 设计缺陷 1：broker 离线后重新上线\",\"t\":[\"基本的问题是，当 broker 离线并再次恢复时，它在镜像中的任何数据都将被丢弃。这是关键的设计缺陷。现在，镜像已恢复在线，但为空，管理员需要做出决定:是否同步镜像。“同步”意味着将当前消息从 leader 复制到镜像。\"]},\"211\":{\"h\":\"5.1.2 设计缺陷 2：同步阻塞\",\"t\":[\"此时第二个致命的设计缺陷显露了出来。如果要同步消息，会阻塞整个队列，让这个队列不可用。当队列比较短的时候这通常不是什么问题，但当队列很长或者消息总大小很大的时候，同步将会需要很长时间。不仅如此，同步会导致集群中与内存相关的问题，有时甚至会导致同步卡住，需要重新启动。\",\"默认情况下，所有镜像队列都会自动同步，但也有人用户不同步镜像。这样，所有新消息都将被复制，老消息都不会被复制，这将减少冗余，会使消息丢失的概率加大。\",\"这个问题也引发滚动升级的问题，因为重新启动的 broker 将丢弃其所有数据，并需要同步来恢复全部数据冗余。\"]},\"212\":{\"h\":\"参考资料\",\"t\":[\"RabbitMQ Doc - Classic Queue Mirroring\",\"RabbitMQ——镜像队列的数据流\",\"rabbitmq——镜像队列\",\"RabbitMQ——镜像队列Master故障后的处理\",\"RabbitMQ Mirrored Queues Gotchas\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"213\":{\"h\":\"RabbitMQ 存储机制\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220610-rabbitmq-store.html\"]},\"214\":{\"h\":\"1. 背景\",\"t\":[\"RabbitMQ 的存储设计与 Kafka、RocketMQ 等消息队列有较大的不同。RabbitMQ 在设计上更倾向于消息被及时消费，或者是存储在内存中以达到更高的生产和消费效率，而不是直接存储在磁盘中。\",\"当然，RabbitMQ 也支持通过配置队列和消息都持久化的方式，让消息必须保存在磁盘中，这样消息才会在重启之后仍然存在。但是，即使是保存到磁盘的消息，在内存中也会保留一份备份，以便将消息更快地发给消费者。这样就带来了较大且不稳定的内存消耗。如果希望消息直接被保存到磁盘中，可以设置队列为种惰性队列。\",\"RabbitMQ 的消息以队列维度存储，会随着系统的负载而在几种不同的存储状态中不断地流动。大致会经过从内存到磁盘再到内存的流程。\",\"本文将介绍 RabbitMQ 消息的存储机制。\"]},\"215\":{\"h\":\"2. 概述\"},\"216\":{\"h\":\"2.1 持久化\",\"t\":[\"持久化指的是数据保存在磁盘中，以防止异常关机、重启等情况下的数据丢失。 与存储相关的持久化包括队列的持久化和消息的持久化。\"]},\"217\":{\"h\":\"2.1.1 队列持久化\",\"t\":[\"通过将队列的 durable 属性设置为 true 的方式可以将队列设置为持久化。\",\"队列持久化仅仅指的是队列元数据持久化，即重启之后该队列还会存在，但队列中的消息会消失。\",\"如果队列为非持久化，则重启之后队列也会消失。\"]},\"218\":{\"h\":\"2.1.2 消息的持久化\",\"t\":[\"通过发送时设置消息的 BasicProperties#deliveryMode 的方式可以将消息设置为持久化的。\",\"只有将消息和队列都设置为持久化之后，消息才会在重启之后仍然存在。\"]},\"219\":{\"h\":\"2.2 存储机制\"},\"220\":{\"h\":\"2.2.1 存储结构\",\"t\":[\"RabbitMQ 的存储可以被分为两个部分：队列索引和消息存储。\",\"队列索引（rabbit_queue_index）：每个队列单独存储。负责维护队列中落盘消息的信息，包括消息的存储地点、是否已被交付给消费者、是否已被消费者 ack 等。\",\"消息存储（rabbit_msg_store）：每个 Broker 只有一个，所有队列共同使用。以键值对的形式存储消息。RabbitMQ 将持久化和非持久化的消息在磁盘中区分存储。 \",\"非持久化消息存储（msg_store_transient）：重启后清空\",\"持久化消息存储（msg_store_persistent）：重启后不会清空\",\"在消费消息时，会先查询队列索引，查询到消息在存储中的位置，然后再从消息存储中查询具体的消息。这样就会经历 2 次查询。为了优化消费性能，RabbitMQ 会将较小的消息体直接全量保存到队列索引，而不保存到消息存储中。较大的消息会保存在消息存储中，在队列索引中建立消息索引。这样在消费较小的消息时只需要查询 1 次。\",\"可以通过配置 queue_index_embed_msgs_below 的方式来指定消息整体大小小于某个值时会只保存到队列索引中。该值默认为 4096（byte）。\"]},\"221\":{\"h\":\"2.2.2 合并机制\",\"t\":[\"消息被消费后会被删除。删除消息时并不会直接删除消息所在的文件，而是先标记该消息为垃圾数据。当一个文件中都是垃圾数据是可以将这个文件删除。当检测到前后两个文件中的有效数据可以合并成一个文件，并且（垃圾数据大小/所有文件数据大小）的值超过 garbage_fraction（默认 0.5）时会触发垃圾回收，将这两个文件合并。这两个文件一定是逻辑上相邻的两个文件。\"]},\"222\":{\"h\":\"2.3 队列结构\",\"t\":[\"在RabbitMQ中，队列 主要由两部分组成 \",\"AMQPQueue：实现AMQP协议的逻辑功能，包括接收消息，投递消息，Confirm消息等；\",\"BackingQueue：提供AMQQueue调用的接口，完成消息的存储和持久化工作\"]},\"223\":{\"h\":\"RabbitMQ中队列的存储状态\",\"t\":[\"BackingQueue由Q1,Q2,Delta,Q3,Q4五个子队列构成，在BackingQueue中，消息的生命周期有4个状态：\",\"queue\",\"state\\\\store\",\"message itself\",\"message index(message position)\",\"q1,q4\",\"alpha\",\"RAM\",\"RAM\",\"q2,q3\",\"beta\",\"DISK\",\"RAM\",\"q2,q3\",\"gamma\",\"DISK\",\"RAM&DISK\",\"delta\",\"delta\",\"DISK\",\"DISK\",\"alpha: 消息的内容和消息索引都在RAM中。（Q1，Q4）\",\"beta: 消息的内容保存在Disk上，消息索引保存在RAM中。（Q2，Q3）\",\"gamma: 消息的内容保存在Disk上，消息索引在DISK和RAM上都有。（Q2，Q3）\",\"delta: 消息内容和索引都在Disk上。(Delta）\",\"5个内部队列\",\"q1和q4队列中只有alpha状态的消息；\",\"q2和q3包含beta和gamma状态的消息；\",\"delta队列是消息按序存盘后的一种逻辑队列，只有delta状态的消息。所以delta队列并不在内存中，其他4个队列则是由erlang queue模块实现。\",\"这里以持久化消息为例（可以看到非持久化消息的生命周期会简单很多），从Q1到Q4，消息实际经历了一个RAM->DISK->RAM这样的过程， BackingQueue的设计有点类似于Linux的虚拟内存Swap区，\",\"当队列负载很高时，通过将部分消息放到磁盘上来·节省内存空间`，\",\"当负载降低时，消息又从磁盘回到内存中，让整个队列有很好的弹性。 因此触发消息流动的主要因素是：\",\"消息被消费；\",\"内存不足。\",\"RabbitMQ会根据消息的传输速度来计算当前内存中允许保存的最大消息数量（Traget_RAM_Count），\",\"当内存中保存的消息数量 + 等待ACK的消息数量 > Target_RAM_Count时，RabbitMQ才会把消息写到磁盘上，\",\"所以说虽然理论上消息会按照Q1->Q2->Delta->Q3->Q4的顺序流动，但是并不是每条消息都会经历所有的子队列以及对应的生命周期。\",\"从RabbitMQ的Backing Queue结构来看，当内存不足时，消息要经历多个生命周期，在Disk和RAM之间置换，这实际会降低RabbitMQ的处理性能（后续的流控就是关联的解决方法）。\",\"对于持久化消息，RabbitMQ先将消息的内容和索引保存在磁盘中，然后才处于上面的某种状态（即只可能处于alpha、gamma、delta三种状态之一）。\",\"the term gamma seldom appears.\"]},\"224\":{\"h\":\"参考资料\",\"t\":[\"【RabbitMQ学习记录】- 消息队列存储机制源码分析\",\"RabbitMQ数据读写过程\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"225\":{\"h\":\"RabbitMQ 3.8 特性聚焦：仲裁队列（Quorum Queues）\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220714-rabbitmq-quorum-queues-feature-focus.html\",\"翻译自：https://www.cloudamqp.com/blog/rabbitmq-quorum-queues.html，写于 2019-03-28\",\"RabbitMQ 3.8 版本中最重要的改动那非仲裁队列（Quorum Queues）莫属。它提供队列复制的能力，保障数据的高可用和安全性。使用仲裁队列可以在 RabbitMQ 节点间进行队列数据的复制，从而达到在一个节点宕机时，队列仍然可以提供服务的效果。\",\"其实 RabbitMQ 已经有一个队列复制的实现，那就是镜像队列（Mirror Queues）。在 RabbitMQ 3.8 版本问世之前，镜像队列是实现数据高可用的唯一手段，但是它有一些设计上的缺陷，这也是 RabbitMQ 提供仲裁队列的原因。\"]},\"226\":{\"h\":\"镜像队列的设计缺陷\",\"t\":[\"镜像队列主要的问题是消息同步的性能。由于使用了一种低效的消息复制方法，镜像队列的性能会比较低下。\",\"镜像队列会选择一个主队列和多个从队列，主队列会将自己接收的读、写请求同步给所有从队列。当所有的从队列保存消息之后，主队列才会向生产者发送确认。如果主队列挂掉，其中一个从队列会晋升成主队列，让整个镜像队列仍然保持可用，避免消息丢失。\",\"图 1 - 主队列到从队列的复制\",\"当你有多个镜像队列时，主队列和从队列会分布在集群的不同节点上，每个节点可以承载多个主队列和从队列。\",\"图 2 - 主队列和从队列分布在集群上\",\"所有问题的源头来自于节点的宕机。当一个节点下线，然后恢复上线之后，它保存的所有从队列的镜像数据都会丢失。这就是第一个致命的设计缺陷。此时从队列重新上线，但是它是空的，运维人员必须做出选择，是否要将数据同步到这个队列。如果选择同步，那么就意味着要将当前所有的消息从主队列同步到从队列。\",\"这引出了第二个致命的设计缺陷：同步是阻塞的，它会让整个队列不可用。通常情况下，如果生产和消费的速度能够基本匹配，那么队列应该是没有消息堆积或者堆积非常少的，这样同步只会阻塞很短的时间。但是有时有些队列有时会存在大量堆积，可能是由于故意设计成这样，也可能是因为消费端或者下游服务非常慢或者挂掉，但是上游生产者仍然不停生产消息。\",\"如果队列的堆积少，那么同步的影响就比较小，同步很快结束，然后生产者可以重试之前阻塞的时候生产失败的消息。但是如果队列的消息堆积量很大，同步的影响就会抱很大，可能要消耗几分钟、几小时或者更多时间去同步消息，不仅如此，同步还会消耗内存，导致内存相关的问题，甚至可能造成节点需要重启。\",\"所以运维有时就不会选择进行消息同步，仅仅让新的消息复制到这个重新上线的镜像队列，老的消息不进行同步。但是这样的话会让消息丢失的风险增加。\",\"这个问题同样使节点的滚动升级存在很大的隐患，因为在滚动升级时，节点的重启会丢失所有数据，需要进行数据的同步或者恢复。\"]},\"227\":{\"h\":\"仲裁队列——下一代高可用队列\",\"t\":[\"仲裁队列旨在解决镜像队列的性能和同步问题。但是相对的，它没有包含队列的所有功能，并且有它自己的局限性。所以在仲裁队列和镜像队列之间的选择不是一个容易的事情。\",\"Raft 共识协议逐渐成为了工业上大量使用的分布式共识协议，仲裁队列就是基于 Raft 共识算法的一个变种。它比镜像队列更安全、性能更好。\"]},\"228\":{\"h\":\"Raft 协议下的消息复制\",\"t\":[\"每个仲裁队列都有多个副本，它包含一个主和多个从副本。replication factor 为 5 的仲裁队列将会有 1 个主副本和 4 个从副本。每个副本都在不通的 RabbitMQ 节点上。\",\"客户端（生产者和消费者）只会与主副本进行交互，主副本再将这些命令复制到从副本。与镜像队列类似，从副本不与客户端进行交互，它们仅仅作为一个冗余备份，在节点挂掉或重启时提供高可用的能力。当主副本所在的节点下线，其中一个在另外节点的从副本会被选举成为主副本，继续提供服务。\",\"图 3 - Raft 共识协议\",\"消息复制和主副本选举的操作，需要超过半数的副本同意，所以我管它叫做仲裁队列。当生产者发送一条消息，需要超过半数的队列副本都将消息写入磁盘以后才会向生产者进行确认。这意味着少部分比较慢的副本不会影响整个队列的性能。同样地，主副本的选举也需要超过半数的副本同意才行，这会避免出现网络分区时 2 个主副本，所以说仲裁队列相对于可用性更看重一致性。\"]},\"229\":{\"h\":\"仲裁队列的优势\",\"t\":[\"客户端不需要改变它们生产和订阅的方法，无需考虑队列类型。唯一的区别就是在客户端定义队列的时候需要定义成仲裁队列（代码中添加相关属性）\",\"同步的问题被解决，当节点重新上线时，不会丢数据，主副本会直接从从副本中断的地方开始复制消息。复制的过程是非阻塞的，所以整个队列不会因为新的副本加入而收到影响。唯一的影响是网络使用率。\",\"没有了同步问题，不仅让仲裁队列比镜像队列更可靠，同时，因为写入必须被超过半数的副本接受，所以不会因为脑裂而丢数据。\",\"Raft 协议比镜像队列的算法更有效率，可以提供更好的消息吞吐量。\",\"总结起来，仲裁队列可以提供更高的性能、更好的数据安全性、更容易进行节点的滚动升级。\"]},\"230\":{\"h\":\"仲裁队列的劣势\"},\"231\":{\"h\":\"特性更少\",\"t\":[\"这些特性在仲裁队列的第一个版本中不会提供\",\"非持久化消息\",\"排它队列\",\"队列/消息 TTL（超时时间）\",\"一些规则（Policy）不可用，只有死信队列、队列长度限制可用\",\"优先级\",\"惰性队列\",\"非全局的消息预取（Qos）\"]},\"232\":{\"h\":\"磁盘使用——写入放大\",\"t\":[\"仲裁队列的磁盘和内存配置与普通队列不同。\"]},\"233\":{\"h\":\"普通队列\",\"t\":[\"普通队列使用“共享”存储模型，对于一条要投递到多个队列的消息，只会存储一次，其他队列只会保存这条消息的引用。也就是说，在发布-订阅模型下，一条将要投递到多个队列的消息，它的存储大小不会随着投递到的队列变多而线性增长。\",\"举个例子，我们用一个 fanout 类型的 exchange，绑定 10 个队列。\",\"这 10 个队列每个都设置成 5 副本镜像队列。\",\"最终，发布一条消息后，只有 5 条消息存储到集群中，每个节点存储 1 条。所以在这个情况下的写入放大是 5 倍。\"]},\"234\":{\"h\":\"仲裁队列\",\"t\":[\"仲裁队列使用在内存中“共享”的存储模型，在磁盘中，每条消息都会分别被存储。所以发布-订阅模型会造成更严重的写入放大，可能导致更大的磁盘使用，甚至不得不放弃使用仲裁队列。\",\"还是上面那个例子，当每个队列都变成仲裁队列，并且复制因子为 5 时。\",\"最终集群中的磁盘上存储了 50 条消息，每条消息的写入放大是 50 倍。\",\"因此，把 fanout 交换器和仲裁队列一起使用不太合适。\"]},\"235\":{\"h\":\"内存使用——所有消息一直保存在内存中\",\"t\":[\"仲裁队列的所有消息一直会保存在内存中，这会增加内存的使用量，最终可能导致集群不可用。如果不进行一些检查和监控，队列消息不断堆积，可能会导致生产停止（内存高水位），直到消息被消费或者从内存中删除。所以当使用仲裁队列时，设置队列的长度限制非常重要。此外还有必要用惰性队列作为仲裁队列的死信队列，通过死信交换器将这些消息转发到死信队列中。\",\"因此，队列的规划和监控边得比普通场景下更为重要。下游（消费者和下游服务）的中断或者变慢可能导致多个队列消息堆积，需要有对应的规划和措施。你需要多少个仲裁队列、它们的写入速率时多少，当集群达到内存高水位时其他队列会不会收到影响？\"]},\"236\":{\"h\":\"失去多数节点时意味着队列不可用\",\"t\":[\"如果仲裁队列超过半数的副本永久丢失，那么队列数据就永久丢失了。即便有小部分的副本仍然可用，队列仍然没有办法恢复，只能被强制删除。虽然这种场景出现的可能性较小，但是仍有这样的危险存在。所以，推荐使用可靠的磁盘，并且把复制因子设置为 5 ~ 3。\"]},\"237\":{\"h\":\"延迟\",\"t\":[\"尽管仲裁队列的吞吐量更高，但是延迟也可能更高，这是由于使用了 Raft 协议。在仲裁队列中，所有消息都是持久化的，所有消息都会保存到每个副本的磁盘中。安全性是仲裁队列的主要目标。\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"238\":{\"h\":\"rabbitmq\",\"t\":[\"RabbitMQ 进程内流控（Flow Control） 源码解析\",\"RabbitMQ Federation 插件使用\",\"RabbitMQ 3.7.x 版本 安装\",\"RabbitMQ 镜像队列 使用和原理详解\",\"RabbitMQ 存储机制\",\"RabbitMQ 3.8 特性聚焦：仲裁队列（Quorum Queues）\"]},\"239\":{\"h\":\"RocketMQ 4.9.1 性能优化 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220131-rocketmq-4.9.1-performance-improvement.html\"]},\"240\":{\"h\":\"概述\",\"t\":[\"RocketMQ 4.9.1 版本针对 Broker 做了一些性能优化，这一批 PR 都挂载 ISSUE#2883 下。\",\"和4.9.0版本相比，小消息实时生产的 TPS 提升了约 28%。\",\"I have some commit to Improve produce performance in M/S mode:\",\"Change log level to debug: \\\"Half offset {} has been committed/rolled back\\\"\",\"Optimise lock in WaitNotifyObject\",\"Remove lock in HAService\",\"Remove lock in GroupCommitService\",\"Eliminate array copy in HA\",\"Remove putMessage/putMessages method in CommitLog which has too many duplicated code.\",\"Change default value of some parameters: sendMessageThreadPoolNums/useReentrantLockWhenPutMessage/flushCommitLogTimed/endTransactionThreadPoolNums\",\"Optimise performance of asyncPutMessage (extract some code out of putMessage lock)\",\"extract generation of msgId out of lock in CommitLog (now only for single message processor)\",\"extract generation of topicQueueTable key out of sync code\",\"extract generation of msgId out of lock in CommitLog (for batch)\",\"fix ipv6 problem introduced in commit \\\"Optimise performance of asyncPutMessage (extract some code out of putMessage lock)\\\"\",\"Remove an duplicate MessageDecoder.string2messageProperties for each message, and prevent store \\\"WAIT=true\\\" property (in most case) to save 9 bytes for each message.\",\"Improve performance of string2messageProperties/messageProperties2String, and save 1 byte for each message.\",\"Optimise parse performance for SendMessageRequestHeaderV2\",\"下面会从源码层面来详细分析一下优化点和优化的原因。了解这些优化需要对 RocketMQ 源码比较熟悉，为了方便理解，会在讲解优化点前补充一些前置知识。\"]},\"241\":{\"h\":\"优化分析\"},\"242\":{\"h\":\"事务消息日志优化（1）\",\"t\":[\"Change log level to debug: \\\"Half offset {} has been committed/rolled back\\\"\",\"默认的配置下每条消息都会打出一条日志，改动主要移除了事务消息中的日志打印。\",\"while (true) { if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) { log.info(\\\"Queue={} process time reach max={}\\\", messageQueue, MAX_PROCESS_TIME_LIMIT); break; } if (removeMap.containsKey(i)) { log.~~info~~(\\\"Half offset {} has been committed/rolled back\\\", i); Long removedOpOffset = removeMap.remove(i); doneOpOffset.add(removedOpOffset); } \",\"这个优化比较简单，从这当中可以学到的是在打印日志时需要谨慎，尤其是对于 RocketMQ 这种高性能中间件来说，日志的打印可能会占用较多 CPU 资源。\",\"此外，如果日志中涉及字符串拼接等操作，消耗会更大，应当避免。\"]},\"243\":{\"h\":\"主从复制和同步刷流程中锁的优化/移除（2-4）\",\"t\":[\"Improve produce performance in M/S mode\",\"Optimise lock in WaitNotifyObject\",\"Remove lock in HAService\",\"Remove lock in GroupCommitService\",\"在分析如何优化之前需要学习一些前置指示，看一下 RocketMQ 中主从复制和同步刷盘的原理。这两个操作原理基本相同。\"]},\"244\":{\"h\":\"前置知识：主从复制和同步刷盘中的生产消费模式\",\"t\":[\"在 RocketMQ 内部，主从复制和同步刷盘都是多线程协作处理的。以主从复制为例（GroupTransferService），消息处理线程（多个）不断接收消息，产生待复制的消息，另外有一个 ServiceThread 单线程处理复制结果，可以把前者看做数据生产者，后者看做数据消费者，RocketMQ 使用了双 Buffer 来达到批量处理的目的。\",\"如下图，消费者正在处理数据的同时，生产者可以不受影响的继续添加数据，第一阶段生产者 Buffer 有 3 条数据，消费者 Buffer 有 2 条数据，由于消费者是单线程，没有别的线程跟它竞争，所以它可以批量处理这 2 条数据，完成后它会交换这两个 Buffer 的引用，于是接下来的第二阶段它又可以批量处理 3 条数据。\",\"Untitled\"]},\"245\":{\"h\":\"优化1：主从复制和同步刷盘中重量级锁synchronized改为自旋锁\",\"t\":[\"之前 RocketMQ 在生产者写入 putRequest() 、交换 Buffer 引用 swapRequests() 、以及内部处理中都使用了重量级锁synchronized保证线程安全。\",\"实际 putRequest() 方法中只做了添加数据到列表的操作；swapRequests() 中做了交换操作，耗时都较小，故可以换成自旋锁。每次加解锁都只有 2 次 CAS 操作的开销，而不发生线程切换。\",\"Untitled\"]},\"246\":{\"h\":\"优化2：WaitNotifyObject 类\",\"t\":[\"WaitNotifyObject 被用于做线程之间的异步通知。在主从复制逻辑中被用到。用法类似 synchronized 的 wait() 和 nofityAll()，等待-通知机制。\",\"主从复制线程循环传输数据，如果没有数据则调用 WaitNotifyObject#allWaitForRunning() 方法等待。\",\"在CommitLog保存消息之后，调用 WaitNotifyObject#wakeUpAll() 方法唤醒主从复制线程。\",\"本次优化减少了需要进入同步代码块的次数。\",\"修改点：waitingThreadTable 改为 ConcurrentHashMap，然后可以将 waitingThreadTable 移出同步代码块。\",\"volatile boolean hasNotified 改为 AtomicBoolean hasNotified\",\"Untitled\"]},\"247\":{\"h\":\"消除主从复制中不必要的数组拷贝（5）\",\"t\":[\"Eliminate array copy in HA\",\"了解这个优化之前需要先学习一下前置知识，包括 RocketMQ 中 CommitLog 使用的内存映射文件，和主从复制的流程。\"]},\"248\":{\"h\":\"内存映射文件mmap\",\"t\":[\"RocketMQ 的 CommitLog 是内存映射文件（mmap）。下面这张图对比了普通 IO 和内存映射 IO 之间的区别。\",\"Untitled\",\"mmap 将文件直接映射到用户内存，使得对文件的操作不用再需要拷贝到PageCache，而是转化为对映射地址映射的PageCache的操作，使随机读写文件和读写内存拥有相似的速度（随机地址被映射到了内存）\"]},\"249\":{\"h\":\"主从复制流程概要\",\"t\":[\"RocketMQ 主从复制机制会在消息写入 CommitLog 之后，Master Broker 将消息发送到 Slave，达到消息不丢失。\",\"本次修改点是在主从复制的 Slave 处理过程当中。HAClient 是 Slave 连接 Master 的实现类。\",\"HAClient#run() 方法做了以下这些事：\",\"salve连接到master，向master上报slave当前的offset\",\"master收到后确认给slave发送数据的开始位置\",\"master查询开始位置对应的MappedFIle\",\"master将查找到的数据发送给slave\",\"slave收到数据后保存到自己的CommitLog\",\"其中4、5步，Slave 接收到的数据存在一个 ByteBuffer 里面，把它保存到 CommitLog 的时候，原来的代码会新建一个字节数组，然后把读到的 ByteBuffer 里的数据拷贝进去。\"]},\"250\":{\"h\":\"优化：减少字节数组拷贝\",\"t\":[\"原先在主从复制逻辑中的数组拷贝步骤其实是可以省略的，可以直接把从 Master 读到的 ByteBuffer 传到写 CommitLog 的方法中，并且一并传入数据的开始位置和长度，这样就可以在不重新复制字节数组的情况下传递 ByteBuffer 中的数据。\",\"Untitled\"]},\"251\":{\"h\":\"移除 CommitLog 中包含重复代码的 putMessage/putMessages 方法（6）\",\"t\":[\"Remove putMessage/putMessages method in CommitLog which has too many duplicated code.\",\"该优化主要是减少冗余代码\",\"原本 CommitLog 中有如下这些保存消息的方法\",\"putMessage：同步保存单条消息\",\"asyncPutMessage：异步保存单条消息\",\"putMessages：同步保存批量消息\",\"asyncPutMessages：异步保存批量消息\",\"其实同步保存和异步保存消息的逻辑差不多，但是原本并没有复用代码，而是每个方法都单独实现。这就导致同步和异步方法存在大量重复代码。\",\"这个 Patch 合并了 putMessage & asyncPutMessage 、putMessages & asyncPutMessages 方法，在同步方法中调用异步方法的等待方法，删除了大量重复代码。\",\"Untitled\",\"Untitled\"]},\"252\":{\"h\":\"调整消息发送几个参数的默认值（7）\",\"t\":[\"Change default value of some parameters: sendMessageThreadPoolNums/useReentrantLockWhenPutMessage/flushCommitLogTimed/endTransactionThreadPoolNums\"]},\"253\":{\"h\":\"消息保存/发送参数优化\",\"t\":[\"RocketMQ在保存消息时，由于要保证消息保存到 CommitLog 中是顺序的，写 CommitLog 只能单线程操作，写之前要先获取一个锁，这个锁也就是影响 RocketMQ 性能最关键的一个锁。\",\"最早之前 3.2.X 版本这个锁是 synchronized，从 RocketMQ4.X 开始引入了自旋锁并作为默认值，同时将参数 sendMessageThreadPoolNums（处理Client端发送消息线程池的线程数）改为了 1，这样处理每条消息写 CommitLog 的时候是一个线程在写，可以省下进出重量锁的开销。\",\"不过这个地方单线程处理，任务有点重，处理消息的逻辑并不是往 CommitLog 里面一写（无法并行）就完事的，还有一些 CPU 开销比较大的工作，多线程处理比较好，经过一些实践测试，4 个线程是比较合理的数值，因此这个参数默认值改为 MIN(逻辑处理器数, 4)。\",\"既然有 4 个线程，还用自旋锁可能就不合适了，因为拿不到锁的线程会让 CPU 白白空转。所以改用可重入锁，useReentrantLockWhenPutMessage 参数还是改为 true 比较好。\"]},\"254\":{\"h\":\"事务消息二阶段处理线程大小\",\"t\":[\"endTransactionThreadPoolNums 是事务消息二阶段处理线程大小，sendMessageThreadPoolNums 则指定一阶段处理线程池大小。如果二阶段的处理速度跟不上一阶段，就会造成二阶段消息丢失导致大量回查，所以建议 endTransactionThreadPoolNums 应该大于 sendMessageThreadPoolNums，建议至少 4 倍。\"]},\"255\":{\"h\":\"开启定时刷盘\",\"t\":[\"flushCommitLogTimed 参数表示是否定时刷盘，之前默认为 false，表示实时刷盘。\",\"本次对刷盘相关的参数也进行了调整。默认情况下，RocketMQ 是异步刷盘，但每次处理消息都会触发一个异步的刷盘请求。这次将 flushCommitLogTimed 这个参数改成 true，也就是定时刷盘（默认每 500ms），可以大幅降低对 IO 压力，在主从同步复制的场景下，可靠性也不会降低。\"]},\"256\":{\"h\":\"优化 putMessage 锁内操作 （8-12）\",\"t\":[\"Improve produce performance in M/S mode.\",\"Optimise performance of asyncPutMessage (extract some code out of putMessage lock)\",\"extract generation of msgId out of lock in CommitLog (now only for single message processor)\",\"extract generation of topicQueueTable key out of sync code\",\"extract generation of msgId out of lock in CommitLog (for batch)\",\"fix ipv6 problem introduced in commit \\\"Optimise performance of asyncPutMessage (extract some code out of putMessage lock)\\\"\",\"CommitLog 是 RocketMQ 消息存储文件。单个 Broker 上所有消息都顺序保存在 CommitLog 中。\",\"写 CommitLog 只能单线程操作，写之前要先获取一个锁，这个锁也就是影响 RocketMQ 性能最关键的一个锁。\",\"理论上这里只要往 MappedByteBuffer 写一下就好了，但实践往往要比理论复杂得多，因为各种原因，这个锁里面干的事情非常的多。\",\"由于当前代码的复杂性，这个优化是本批次修改里面改动最大的，但它的逻辑其实很简单，就是把锁内干的事情，尽量的放到锁的外面去做，能先准备好的数据就先准备好。它包括了以下改动：\",\"将 Buffer 的大部分准备工作（编码工作）放到了锁外，提前做好。\",\"将 MessageId 的做成了懒初始化（放到锁外），这个消息 ID 的生成涉及很多编解码和数据复制工作，实际上性能开销相当大。\",\"原来锁内用来查位点哈希表的 Key 是个拼接出来的字符串，这次也改到锁外先生成好。\",\"顺便补上了之前遗漏的关于 IPv6 的处理。\",\"删除了无用的代码。\"]},\"257\":{\"h\":\"优化 asyncPutMessage 性能，将准备工作放到锁外\",\"t\":[\"先看一下代码上的改动，右边绿色新增的代码是原先在锁中的操作，现在都移动到了锁外面。\",\"Untitled\",\"右边新增的的 putMessageThreadLocal.getEncode().encode(msg) 完成了大量预操作，将原先 CommitLog#DefaultAppendMessageCallback#doAppend() 方法中的操作移动到了锁外。\",\"下面的代码第一份是修改前的，doAppend() 方法是锁内操作；第二份是修改后的，encode() 方法抽到了加锁之前。\",\"// CommitLog.java 修改前 public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank, final MessageExtBrokerInner msgInner) { // ... /** * Serialize message */ final byte[] propertiesData = msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8); final int propertiesLength = propertiesData == null ? 0 : propertiesData.length; if (propertiesLength > Short.MAX_VALUE) { log.warn(\\\"putMessage message properties length too long. length={}\\\", propertiesData.length); return new AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED); } final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8); final int topicLength = topicData.length; final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length; final int msgLen = calMsgLength(msgInner.getSysFlag(), bodyLength, topicLength, propertiesLength); // Exceeds the maximum message if (msgLen > this.maxMessageSize) { CommitLog.log.warn(\\\"message size exceeded, msg total size: \\\" + msgLen + \\\", msg body size: \\\" + bodyLength + \\\", maxMessageSize: \\\" + this.maxMessageSize); return new AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED); } // ... Determines whether there is sufficient free space // Initialization of storage space this.resetByteBuffer(msgStoreItemMemory, msgLen); // 1 TOTALSIZE this.msgStoreItemMemory.putInt(msgLen); // 2 MAGICCODE this.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE); // 3 BODYCRC this.msgStoreItemMemory.putInt(msgInner.getBodyCRC()); // 4 QUEUEID this.msgStoreItemMemory.putInt(msgInner.getQueueId()); // 5 FLAG this.msgStoreItemMemory.putInt(msgInner.getFlag()); // 6 QUEUEOFFSET this.msgStoreItemMemory.putLong(queueOffset); // 7 PHYSICALOFFSET this.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position()); // 8 SYSFLAG this.msgStoreItemMemory.putInt(msgInner.getSysFlag()); // 9 BORNTIMESTAMP this.msgStoreItemMemory.putLong(msgInner.getBornTimestamp()); // 10 BORNHOST this.resetByteBuffer(bornHostHolder, bornHostLength); this.msgStoreItemMemory.put(msgInner.getBornHostBytes(bornHostHolder)); // 11 STORETIMESTAMP this.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp()); // 12 STOREHOSTADDRESS this.resetByteBuffer(storeHostHolder, storeHostLength); this.msgStoreItemMemory.put(msgInner.getStoreHostBytes(storeHostHolder)); // 13 RECONSUMETIMES this.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes()); // 14 Prepared Transaction Offset this.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset()); // 15 BODY this.msgStoreItemMemory.putInt(bodyLength); if (bodyLength > 0) this.msgStoreItemMemory.put(msgInner.getBody()); // 16 TOPIC this.msgStoreItemMemory.put((byte) topicLength); this.msgStoreItemMemory.put(topicData); // 17 PROPERTIES this.msgStoreItemMemory.putShort((short) propertiesLength); if (propertiesLength > 0) this.msgStoreItemMemory.put(propertiesData); \",\"// CommitLog.java 修改后 protected PutMessageResult encode(MessageExtBrokerInner msgInner) { /** * Serialize message */ final byte[] propertiesData = msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8); final int propertiesLength = propertiesData == null ? 0 : propertiesData.length; if (propertiesLength > Short.MAX_VALUE) { log.warn(\\\"putMessage message properties length too long. length={}\\\", propertiesData.length); return new PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, null); } final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8); final int topicLength = topicData.length; final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length; final int msgLen = calMsgLength(msgInner.getSysFlag(), bodyLength, topicLength, propertiesLength); // Exceeds the maximum message if (msgLen > this.maxMessageSize) { CommitLog.log.warn(\\\"message size exceeded, msg total size: \\\" + msgLen + \\\", msg body size: \\\" + bodyLength + \\\", maxMessageSize: \\\" + this.maxMessageSize); return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null); } // Initialization of storage space this.resetByteBuffer(encoderBuffer, msgLen); // 1 TOTALSIZE this.encoderBuffer.putInt(msgLen); // 2 MAGICCODE this.encoderBuffer.putInt(CommitLog.MESSAGE_MAGIC_CODE); // 3 BODYCRC this.encoderBuffer.putInt(msgInner.getBodyCRC()); // 4 QUEUEID this.encoderBuffer.putInt(msgInner.getQueueId()); // 5 FLAG this.encoderBuffer.putInt(msgInner.getFlag()); // 6 QUEUEOFFSET, need update later this.encoderBuffer.putLong(0); // 7 PHYSICALOFFSET, need update later this.encoderBuffer.putLong(0); // 8 SYSFLAG this.encoderBuffer.putInt(msgInner.getSysFlag()); // 9 BORNTIMESTAMP this.encoderBuffer.putLong(msgInner.getBornTimestamp()); // 10 BORNHOST socketAddress2ByteBuffer(msgInner.getBornHost() ,this.encoderBuffer); // 11 STORETIMESTAMP this.encoderBuffer.putLong(msgInner.getStoreTimestamp()); // 12 STOREHOSTADDRESS socketAddress2ByteBuffer(msgInner.getStoreHost() ,this.encoderBuffer); // 13 RECONSUMETIMES this.encoderBuffer.putInt(msgInner.getReconsumeTimes()); // 14 Prepared Transaction Offset this.encoderBuffer.putLong(msgInner.getPreparedTransactionOffset()); // 15 BODY this.encoderBuffer.putInt(bodyLength); if (bodyLength > 0) this.encoderBuffer.put(msgInner.getBody()); // 16 TOPIC this.encoderBuffer.put((byte) topicLength); this.encoderBuffer.put(topicData); // 17 PROPERTIES this.encoderBuffer.putShort((short) propertiesLength); if (propertiesLength > 0) this.encoderBuffer.put(propertiesData); encoderBuffer.flip(); return null; } \",\"然后把预编码的数据放到 MessageExtBrokerInner 中的 private ByteBuffer encodedBuff 字段，传到 doAppend() 方法中使用\",\"Untitled\"]},\"258\":{\"h\":\"MessageId 懒加载\",\"t\":[\"使用函数式接口 Supplier，将 MessageId 计算的逻辑放到 Supplier 中。创建结果对象时将 Supplier 传入，而不是直接计算 MessageId。\",\"当结果的 getMsgId() 方法被调用，才会执行 Supplier 中 MessageId 的计算方法。\",\"// CommitLog#DefaultAppendMessageCallback public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank, final MessageExtBrokerInner msgInner, PutMessageContext putMessageContext) { // STORETIMESTAMP + STOREHOSTADDRESS + OFFSET <br> // PHY OFFSET long wroteOffset = fileFromOffset + byteBuffer.position(); Supplier<String> msgIdSupplier = () -> { int sysflag = msgInner.getSysFlag(); int msgIdLen = (sysflag & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8; ByteBuffer msgIdBuffer = ByteBuffer.allocate(msgIdLen); MessageExt.socketAddress2ByteBuffer(msgInner.getStoreHost(), msgIdBuffer); msgIdBuffer.clear();//because socketAddress2ByteBuffer flip the buffer msgIdBuffer.putLong(msgIdLen - 8, wroteOffset); return UtilAll.bytes2string(msgIdBuffer.array()); }; // ... AppendMessageResult result = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgIdSupplier, msgInner.getStoreTimestamp(), queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills); // ... return result; } \",\"// AppendMessageResult.java public String getMsgId() { // msgId懒加载 if (msgId == null && msgIdSupplier != null) { msgId = msgIdSupplier.get(); } return msgId; } \"]},\"259\":{\"h\":\"优化 消息 Header 解析的性能（13-15）\"},\"260\":{\"h\":\"去除字符串末尾占位符，节省消息传输大小\",\"t\":[\"优化字符串格式的属性存储。RocketMQ 在消息传输时用字符串存储一个 Map，接受消息后再解析成Map。\",\"字符串采用这种格式存储 Map：\",\"key1\\\\u0001value1\\\\u0002key2\\\\u0001value2\\\\u0002 \",\"Untitled\",\"该 Patch 优化掉了字符串末尾的\\\\u0002，为每个消息节省了1字节传输大小。\"]},\"261\":{\"h\":\"优化 string 和 map 互相解析的性能\",\"t\":[\"优化前后效果：\",\"Benchmark Mode Cnt Score Error Units(10000 loop in each op) TempTest.messageProperties2String thrpt 2 2257.276 ops/s TempTest.messageProperties2String_old thrpt 2 1464.342 ops/s TempTest.string2messageProperties thrpt 2 1590.499 ops/s TempTest.string2messageProperties_old thrpt 2 605.118 ops/s \",\"Untitled\",\"string 转 map 优化\",\"Untitled\",\"优化点主要是预先计算了需要解析成字符串的长度，然后为 StringBuilder 定义了初始长度。\",\"StringBuilder 是一个可以动态增加自身数据长度的类，其默认长度（capacity属性）为16。它的底层结构实际是 char[]。\",\"在 TPS 很高的场景下， StringBuilder 默认长度是 16，处理一个正常的消息，至少会内部扩展 2 次，白白产生 2 个对象和 2 次数组复制。\",\"所以优化方案就是先算好需要的长度，创建 StringBuffer 的时候直接就指定好。\",\"map 转 string 优化\",\"Untitled\",\"可以看到右边的代码使用了 indexOf 和 substring 方法替换原来的 split 方法\",\"其实 split 方法内部也是使用 indexOf 和 substring 方法的，但它内部新建了一个 ArrayList<String> 用来保存返回结果，在返回时将结果复制到 String[]。\",\"右边方法将切分后的字符串直接存到 map 中，免去了存到 ArrayList<String> 中的过程，减少了复制，也避免了 ArrayList 扩容的损耗。\"]},\"262\":{\"h\":\"优化 Broker 请求消息头解码性能（15）\",\"t\":[\"Optimise parse performance for SendMessageRequestHeaderV2\",\"RocketMQ 的通信协议定义了各种指令，它们的 Header 各不相同，共用了一个通用的解析方法，基于反射来解析和设置消息 Header。\",\"这个解析 Header 方法的效率很低，本次优化单独定义了解析发送消息请求头的方法，直接get Map 中的属性，提升效率。\",\"发送消息的请求header会类似如：\",\"{ \\\"code\\\":310, \\\"extFields\\\":{ \\\"f\\\":\\\"0\\\", \\\"g\\\":\\\"1482158310125\\\", \\\"d\\\":\\\"4\\\", \\\"e\\\":\\\"0\\\", \\\"b\\\":\\\"TopicTest\\\", \\\"c\\\":\\\"TBW102\\\", \\\"a\\\":\\\"please_rename_unique_group_name\\\", \\\"j\\\":\\\"0\\\", \\\"k\\\":\\\"false\\\", \\\"h\\\":\\\"0\\\", \\\"i\\\":\\\"TAGS\\\\u0001TagA\\\\u0002WAIT\\\\u0001true\\\\u0002\\\" }, \\\"flag\\\":0, \\\"language\\\":\\\"JAVA\\\", \\\"opaque\\\":206, \\\"version\\\":79 } \",\"public class SendMessageRequestHeaderV2 implements CommandCustomHeader { @CFNotNull private String a; // producerGroup; @CFNotNull private String b; // topic; @CFNotNull private String c; // defaultTopic; @CFNotNull private Integer d; // defaultTopicQueueNums; @CFNotNull private Integer e; // queueId; @CFNotNull private Integer f; // sysFlag; @CFNotNull private Long g; // bornTimestamp; @CFNotNull private Integer h; // flag; @CFNullable private String i; // properties; @CFNullable private Integer j; // reconsumeTimes; @CFNullable private boolean k; // unitMode = false; private Integer l; // consumeRetryTimes @CFNullable private boolean m; //batch \",\"接收消息时，会将 Header 解码成 SendMessageRequestHeaderV2 类\",\"public CommandCustomHeader decodeCommandCustomHeader(Class<? extends CommandCustomHeader> classHeader) throws RemotingCommandException { CommandCustomHeader objectHeader; try { objectHeader = classHeader.newInstance(); } catch (InstantiationException e) { return null; } catch (IllegalAccessException e) { return null; } if (this.extFields != null) { Field[] fields = getClazzFields(classHeader); for (Field field : fields) { if (!Modifier.isStatic(field.getModifiers())) { String fieldName = field.getName(); if (!fieldName.startsWith(\\\"this\\\")) { try { String value = this.extFields.get(fieldName); if (null == value) { Annotation annotation = getNotNullAnnotation(field); if (annotation != null) { throw new RemotingCommandException(\\\"the custom field <\\\" + fieldName + \\\"> is null\\\"); } continue; } field.setAccessible(true); String type = getCanonicalName(field.getType()); Object valueParsed; if (type.equals(StringCanonicalName)) { valueParsed = value; } else if (type.equals(IntegerCanonicalName1) || type.equals(IntegerCanonicalName2)) { valueParsed = Integer.parseInt(value); } else if (type.equals(LongCanonicalName1) || type.equals(LongCanonicalName2)) { valueParsed = Long.parseLong(value); } else if (type.equals(BooleanCanonicalName1) || type.equals(BooleanCanonicalName2)) { valueParsed = Boolean.parseBoolean(value); } else if (type.equals(DoubleCanonicalName1) || type.equals(DoubleCanonicalName2)) { valueParsed = Double.parseDouble(value); } else { throw new RemotingCommandException(\\\"the custom field <\\\" + fieldName + \\\"> type is not supported\\\"); } field.set(objectHeader, valueParsed); } catch (Throwable e) { } } } } objectHeader.checkFields(); } return objectHeader; } \",\"static SendMessageRequestHeaderV2 decodeSendMessageHeaderV2( RemotingCommand request) throws RemotingCommandException { SendMessageRequestHeaderV2 r = new SendMessageRequestHeaderV2(); HashMap<String, String> fields = request.getExtFields(); if (fields == null) { throw new RemotingCommandException(\\\"the ext fields is null\\\"); } String s = fields.get(\\\"a\\\"); checkNotNull(s, \\\"the custom field <a> is null\\\"); r.setA(s); s = fields.get(\\\"b\\\"); checkNotNull(s, \\\"the custom field <b> is null\\\"); r.setB(s); s = fields.get(\\\"c\\\"); checkNotNull(s, \\\"the custom field <c> is null\\\"); r.setC(s); s = fields.get(\\\"d\\\"); checkNotNull(s, \\\"the custom field <d> is null\\\"); r.setD(Integer.parseInt(s)); s = fields.get(\\\"e\\\"); checkNotNull(s, \\\"the custom field <e> is null\\\"); r.setE(Integer.parseInt(s)); s = fields.get(\\\"f\\\"); checkNotNull(s, \\\"the custom field <f> is null\\\"); r.setF(Integer.parseInt(s)); s = fields.get(\\\"g\\\"); checkNotNull(s, \\\"the custom field <g> is null\\\"); r.setG(Long.parseLong(s)); s = fields.get(\\\"h\\\"); checkNotNull(s, \\\"the custom field <h> is null\\\"); r.setH(Integer.parseInt(s)); s = fields.get(\\\"i\\\"); if (s != null) { r.setI(s); } s = fields.get(\\\"j\\\"); if (s != null) { r.setJ(Integer.parseInt(s)); } s = fields.get(\\\"k\\\"); if (s != null) { r.setK(Boolean.parseBoolean(s)); } s = fields.get(\\\"l\\\"); if (s != null) { r.setL(Integer.parseInt(s)); } s = fields.get(\\\"m\\\"); if (s != null) { r.setM(Boolean.parseBoolean(s)); } return r; } \",\"左边其实是一个通用的解码方法，右边是针对消息生产的指令 SendMessageRequestHeaderV2 优化的解码方法。这里不再使用共同的这个解析器，而是简单粗暴的直接一个一个去 set 每一个属性，这样这个方法获得了大约 4 倍性能的提升。\"]},\"263\":{\"h\":\"参考资料\",\"t\":[\"Apache RocketMQ 4.9.1 高性能优化之路\",\"RocketMQ这样做，离物理极限性能还差多远？\",\"寻找Java中String.split性能更好的方法\",\"RocketMQ——通信协议\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"264\":{\"h\":\"RocketMQ ConsumeQueue 消费队列文件\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220301-rocketmq-consumequeue.html\"]},\"265\":{\"h\":\"1. 概述\"},\"266\":{\"h\":\"1.1 ConsumeQueue 是什么\",\"t\":[\"ConsumeQueue，又称作消费队列，是 RocketMQ 存储系统的一部分，保存在磁盘中。\",\"该文件可以看作 CommitLog 关于消息消费的“索引”文件。\",\"ConsumeQueue 是一个 MappedFileQueue，即每个文件大小相同的内存映射文件队列。每个文件由大小和格式相同的索引项构成。\",\"每一个 Topic 的 Queue，都对应一个 ConsumeQueue。\"]},\"267\":{\"h\":\"1.2 ConsumeQueue 的作用\",\"t\":[\"引入 ConsumeQueue 的目的主要是适应消息的检索需求，提高消息消费的性能。\",\"Broker 中所有 Topic 的消息都保存在 CommitLog 中，所以同一 Topic 的消息在 CommitLog 中不是连续存储的。消费某一 Topic 消息时去遍历 CommitLog 是非常低效的，所以引入了 ConsumeQueue。\",\"一个 ConsumeQueue 保存了一个 Topic 的某个 Queue 下所有消息在 CommitLog 中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。当需要消费这个 Topic 时，只需要找到对应的 ConsumeQueue 开始遍历，根据消息在 CommitLog 中的偏移量即可找到消息保存的位置。\"]},\"268\":{\"h\":\"2. 概要设计\"},\"269\":{\"h\":\"2.1 文件结构\",\"t\":[\"ConsumeQueue 文件保存在 store 目录下的 consumequeue 目录中。\",\"会为每个 Topic 单独创建一个目录，随后为这个 Topic 中的每个 Queue 单独创建一个目录。\",\"storepath ├─commitlog │ 00000000000000000000 │ 00000000000000102400 │ 00000000000000204800 │ 00000000000000307200 │ ├─consumequeue │ └─b4b690a3-63b0-42b7-9c52-9e01a24a24d4 │ └─0 │ 00000000000000000000 │ 00000000000000001040 │ 00000000000000002080 │ 00000000000000003120 │ 00000000000000004160 │ 00000000000000005200 │ 00000000000000006240 │ 00000000000000007280 ...... \",\"ConsumeQueue 是数量可无限扩展的映射文件，每个文件大小固定。\",\"文件中的最小单元是索引项，包含\",\"消息在 CommitLog 中的物理偏移量\",\"消息大小\",\"消息的 Tag Hash 码\",\"可以把 ConsumeQueue 看作是索引项组成的数组\"]},\"270\":{\"h\":\"2.2 构建\",\"t\":[\"消息保存到 CommitLog 之后，会进行重投递。重投递消息的过程就是为了建立消息的索引文件（包括 ConsumeQueue 和 IndexFile）。\",\"重投递线程会扫描是否有新消息被保存到 CommitLog，如果有则将这条消息查出来，执行重投递逻辑，构建该消息的索引。\"]},\"271\":{\"h\":\"2.3 查询消息\",\"t\":[\"由于每个索引项的大小是固定的，所以只要知道消息在 Queue 中的逻辑偏移量，可以马上算出索引在 ConsumeQueue 中的位置。\",\"根据消费的 Topic 和 QueueId 查询出相应的 ConsumeQueue 消费队列。\",\"然后根据位置获取 ConsumeQueue 中的索引项，其中保存有消息在 CommitLog 中的偏移量和消息大小，进而到 CommitLog 中查询出消息。\",\"同时 ConsumeQueue 还支持通过消息存储时间来查询具体消息，内部使用二分查找算法。\"]},\"272\":{\"h\":\"2.4 刷盘\",\"t\":[\"由一个单独的线程进行持久化，每隔 1s 进行一次判断。\",\"当写入的索引数超过阈值，或刷盘间隔时间超过 60s，则进行一次刷盘。\"]},\"273\":{\"h\":\"2.5 恢复\",\"t\":[\"Broker启动时，遍历所有ConsumeQueue目录下的文件，加载这些文件。\",\"对每个ConsumeQueue执行恢复操作。\",\"从倒数第三个文件开始往后遍历，遍历文件的每个索引项进行校验，更新最大可用偏移量。\"]},\"274\":{\"h\":\"3. 详细设计\"},\"275\":{\"h\":\"3.1 文件结构\",\"t\":[\"ConsumeQueue 的文件结构可以看作是一个可以无限扩展的数组，每个数组元素是一个索引项，其格式和大小是固定的。\",\"Consume queue index item structure\",\"Consume queue index item structure\",\"索引项的结构很简单，如上图所示。其中 Tag HashCode 用作消息过滤。\",\"Untitled\",\"上图来自艾瑞克的技术江湖\",\"可以看到，对于同一个 Topic 的消息，首先保存到 CommitLog 中。每个 Topic 的 Queue 都会创建一个 ConsumeQueue，内部保存该 Queue 中所有消息的索引项。\"]},\"276\":{\"h\":\"3.2 构建\",\"t\":[\"https://raw.githubusercontent.com/HScarb/drawio-diagrams/main/rocketmq/store/rocketmq_consume_queue_build_sequence.drawio.svg\",\"消息会被先保存到 CommitLog 中，随后由一个独立线程DefaultMessageStore.ReputMessageService#doreput()对 CommitLog 进行扫描。\",\"当扫描到新消息被保存到 CommitLog 时，会执行 dispatch（转发） 操作，运行所有消息 Dispatcher，来构建 ConsumeQueue 和 IndexFile。\",\"其中 DefaultMessageStore.CommitLogDispatcherBuildConsumeQueue 就是用来创建 ConsumeQueue 的。其 dispatch() 方法将刚刚保存的消息存入 ConsumeQueue 中。\",\"内部调用了 ConsumeQueue#putMessagePositionInfo() 方法，写内存映射文件，将消息真正存入 ConsumeQueue。\"]},\"277\":{\"h\":\"3.3 查询消息\",\"t\":[\"客户端发起消息消费请求，请求码为RequestCode.PULL_MESSAGE，对应的处理类为PullMessageProcessor。Broker 在收到客户端的请求之后，会根据topic和queueId定位到对应的 ConsumeQueue。然后根据这条请求传入的offset消费队列偏移量，定位到对应消息。\",\"在存储层面查询消息的入口是 DefaultMessageStore#getMessage()。\",\"GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset, final int maxMsgNums, final MessageFilter messageFilter) \",\"这个方法中根据topic和queueId查询相应的ConsumeQueue，然后使用offset从ConsumeQueue中获取相应位置的索引信息。\",\"随后使用查出来的phyOffset和size到CommitLog中查询消息并返回。\"]},\"278\":{\"h\":\"3.4 刷盘\",\"t\":[\"由一个单独的线程FlushConsumeQueueService周期性检查和刷盘，检查周期flushIntervalConsumeQueue可配置，默认为 1s。\",\"执行刷盘有两个阈值\",\"flushConsumeQueueThoroughInterval（默认 60s）内如果没有执行过刷盘操作，则会执行一次刷盘\",\"需要刷盘的数据超过getFlushConsumeQueueLeastPages（默认2）个操作系统页\"]},\"279\":{\"h\":\"3.5 恢复\",\"t\":[\"Broker启动时，调用DefaultMessageStore#loadConsumeQueue()遍历所有ConsumeQueue目录下的文件，加载这些文件。\",\"随后进行恢复操作recoverConsumeQueue()遍历每个ConsumeQueue执行恢复recover()。\",\"从倒数第三个文件开始往后遍历，遍历文件的每个索引项进行校验，校验成功则更新当前文件的最大可用偏移量，否则直接退出。最后更新整个队列的可用偏移量，删除多余的文件。\"]},\"280\":{\"h\":\"4. 源码解析\",\"t\":[\"与 ConsumeQueue 相关的类有\",\"ConsumeQueue\",\"ConsumeQueueExt\",\"DefaultMessageStore\",\"下面分析 ConsumeQueue 相关操作的源码实现\"]},\"281\":{\"h\":\"4.1 构建\",\"t\":[\"ConsumeQueue 的构建入口是ReputMessageService#doReput()方法，它会从 CommitLog 中扫描新的消息，然后转发和构建 ConsumeQueue。\"]},\"282\":{\"h\":\"4.1.1 ReputMessageService#doReput\",\"t\":[\"当 CommitLog 可用，一直从上一条消息末尾位置开始循环扫描新消息\",\"如找到消息，将消息封装成DispatchRequest，分发给各个处理器（CommitLogDispatcher）\",\"private void doReput() { // ... // CommitLog可用则一直进行循环扫描 for (boolean doNext = true; this.isCommitLogAvailable() && doNext; ) { // 从上一条消息的结束位置开始获取下一条消息 SelectMappedBufferResult result = DefaultMessageStore.this.commitLog.getData(reputFromOffset); if (result != null) { try { // 更新分发的偏移量为当前分发消息的起始偏移量 this.reputFromOffset = result.getStartOffset(); for (int readSize = 0; readSize < result.getSize() && doNext; ) { // 检查消息，查询并解析消息，构建消息的DispatchRequest DispatchRequest dispatchRequest = DefaultMessageStore.this.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), false, false); int size = dispatchRequest.getBufferSize() == -1 ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize(); if (dispatchRequest.isSuccess()) { if (size > 0) { // 将DispatchRequest分发给所有注册dispatcherList中的CommitLogDispatcher进行处理 DefaultMessageStore.this.doDispatch(dispatchRequest); // 通知消息消费长轮询线程，有新的消息落盘，立即唤醒挂起的消息拉取请求 if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole() && DefaultMessageStore.this.brokerConfig.isLongPollingEnable() && DefaultMessageStore.this.messageArrivingListener != null) { DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(), dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1, dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(), dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap()); } // ... } \"]},\"283\":{\"h\":\"4.1.2 DefaultMessageStore#doDispatch\",\"t\":[\"在doReput方法中被调用\",\"内部遍历所有dispatcherList中的分发器，执行每个分发器的dispatch方法\",\"public void doDispatch(DispatchRequest req) { for (CommitLogDispatcher dispatcher : this.dispatcherList) { dispatcher.dispatch(req); } } \"]},\"284\":{\"h\":\"4.1.3 CommitLogDispatcherBuildConsumeQueue#dispatch\",\"t\":[\"判断消息的事务属性\",\"根据 Topic 和 queueId 查找 ConsumeQueue\",\"调用 ConsumeQueue 的保存方法\",\"public void dispatch(DispatchRequest request) { final int tranType = MessageSysFlag.getTransactionValue(request.getSysFlag()); switch (tranType) { // 非事务消息或Commit类型的事务消息才执行分发 case MessageSysFlag.TRANSACTION_NOT_TYPE: case MessageSysFlag.TRANSACTION_COMMIT_TYPE: // 将请求分发到 ConsumeQueue DefaultMessageStore.this.putMessagePositionInfo(request); break; case MessageSysFlag.TRANSACTION_PREPARED_TYPE: case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: break; } } \",\"/** * 将请求分发到具体的 ConsumeQueue * * @param dispatchRequest 消息的分发请求 */ public void putMessagePositionInfo(DispatchRequest dispatchRequest) { ConsumeQueue cq = this.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId()); cq.putMessagePositionInfoWrapper(dispatchRequest); } \"]},\"285\":{\"h\":\"4.1.4 ConsumeQueue#putMessagePosiitonInfo\",\"t\":[\"被putMessagePositionInfoWrapper调用\",\"用于往ConsumeQueue中写入索引项\",\"该函数的大致逻辑如下\",\"将索引项的三个参数写入 ByteBuffer\",\"计算应该写入 ConsumeQueue 的物理偏移量\",\"将 ByteBuffer 中的数据写入 ConsumeQueue 文件\",\"注意该函数的入参中有一个cqOffset，表示消息在该 ConsumeQueue 中的逻辑偏移量。那么消息索引都还没有被存入 ConsumeQueue，它在 ConsumeQueue 里的逻辑偏移量怎么已经被计算出来了？\",\"其实这个值在消息被保存到 CommitLog 时就已经计算出来并保存到 CommitLog 中了，计算的逻辑在 CommitLog#doAppend 方法中。\",\"具体的实现方法是：CommitLog 中的 topicQueueTable 变量保存着每个 ConsumeQueue 当前的最新逻辑偏移量。当应当保存在该 ConsumeQueue 的新消息被保存到 CommitLog，会从 topicQueueTable 获取最新的偏移量，并且将该偏移量加一。源码不在此处展示。\",\"/** * 往ConsumeQueue中写入索引项，putMessagePositionInfo只有一个线程调用，所以不需要加锁 * * @param offset CommitLog offset * @param size 消息在CommitLog存储的大小 * @param tagsCode 过滤tag的hashcode * @param cqOffset 消息在ConsumeQueue中的逻辑偏移量。在 {@link CommitLog#doAppend} 方法中已经生成并保存 * @return 是否成功 */ private boolean putMessagePositionInfo(final long offset, final int size, final long tagsCode, final long cqOffset) { // CommitLog offset + size 小于ConsumeQueue中保存的最大CommitLog物理偏移量，说明这个消息重复生成ConsumeQueue，直接返回 // 多见于关机恢复的场景。关机恢复从倒数第3个CommitLog文件开始重新转发消息生成ConsumeQueue if (offset + size <= this.maxPhysicOffset) { log.warn(\\\"Maybe try to build consume queue repeatedly maxPhysicOffset={} phyOffset={}\\\", maxPhysicOffset, offset); return true; } // NIO ByteBuffer 写入三个参数 this.byteBufferIndex.flip(); this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE); this.byteBufferIndex.putLong(offset); this.byteBufferIndex.putInt(size); this.byteBufferIndex.putLong(tagsCode); // 计算本次期望写入ConsumeQueue的物理偏移量 final long expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE; // 根据期望的偏移量找到对应的内存映射文件 MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(expectLogicOffset); if (mappedFile != null) { // 纠正MappedFile逻辑队列索引顺序 // 如果MappedFileQueue中的MappedFile列表被删除 // 这时需要保证消息队列的逻辑位置和ConsumeQueue文件的起始文件的偏移量一致，要补充空的消息索引 if (mappedFile.isFirstCreateInQueue() && cqOffset != 0 && mappedFile.getWrotePosition() == 0) { this.minLogicOffset = expectLogicOffset; this.mappedFileQueue.setFlushedWhere(expectLogicOffset); this.mappedFileQueue.setCommittedWhere(expectLogicOffset); // 填充空的消息索引 this.fillPreBlank(mappedFile, expectLogicOffset); log.info(\\\"fill pre blank space \\\" + mappedFile.getFileName() + \\\" \\\" + expectLogicOffset + \\\" \\\" + mappedFile.getWrotePosition()); } if (cqOffset != 0) { // 当前ConsumeQueue被写过的物理offset = 该MappedFile被写过的位置 + 该MappedFile起始物理偏移量 // 注意：此时消息还没从内存刷到磁盘，如果是异步刷盘，Broker断电就会存在数据丢失的情况 // 此时消费者消费不到，所以在重要业务中使用同步刷盘确保数据不丢失 long currentLogicOffset = mappedFile.getWrotePosition() + mappedFile.getFileFromOffset(); // 如果期望写入的位置 < 当前ConsumeQueue被写过的位置，说明是重复写入，直接返回 if (expectLogicOffset < currentLogicOffset) { log.warn(\\\"Build consume queue repeatedly, expectLogicOffset: {} currentLogicOffset: {} Topic: {} QID: {} Diff: {}\\\", expectLogicOffset, currentLogicOffset, this.topic, this.queueId, expectLogicOffset - currentLogicOffset); return true; } // 期望写入的位置应该等于被写过的位置 if (expectLogicOffset != currentLogicOffset) { LOG_ERROR.warn( \\\"[BUG]logic queue order maybe wrong, expectLogicOffset: {} currentLogicOffset: {} Topic: {} QID: {} Diff: {}\\\", expectLogicOffset, currentLogicOffset, this.topic, this.queueId, expectLogicOffset - currentLogicOffset ); } } this.maxPhysicOffset = offset + size; // 将一个ConsumeQueue数据写盘，此时并未刷盘 return mappedFile.appendMessage(this.byteBufferIndex.array()); } return false; } \"]},\"286\":{\"h\":\"4.2 查询消息\",\"t\":[\"客户端发起消息消费请求，请求码为RequestCode.PULL_MESSAGE，对应的处理类为PullMessageProcessor，服务器在收到客户端的请求之后，会根据topic和queueId定位到对应的消费队列。然后根据这条请求传入的offset消费队列偏移量，定位到对应的消费队列文件。\",\"存储层查询消息的入口是 DefaultMessageStore#getMessage。\"]},\"287\":{\"h\":\"4.2.1 DefaultMessageStore#getMessage\",\"t\":[\"该方法的调用关系如下图所示\",\"Untitled\",\"根据 Topic 和 QueueId 查询 ConsumeQueue\",\"根据逻辑偏移量从 ConsumeQueue 中查出索引项\",\"使用索引项中的 CommitLog 物理 offset 和消息的 size，从 CommitLog 查询消息\",\"使用索引项中的 Tag HashCode 处理消息过滤的逻辑\",\"/** * 获取消息 * * @param group Consumer group that launches this query. 消费者组 * @param topic Topic to query. 主题 * @param queueId Queue ID to query. 队列ID * @param offset Logical offset to start from. 消息在队列中的逻辑偏移量 * @param maxMsgNums Maximum count of messages to query. 查询的最大消息数量 * @param messageFilter Message filter used to screen desired messages. 消息过滤器 * @return 查询消息结果 */ public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset, final int maxMsgNums, final MessageFilter messageFilter) { // ... ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId); if (consumeQueue != null) { if (/*...*/) { // ... } else { // 根据逻辑偏移量从 ConsumeQueue 中查出索引项 SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset); if (bufferConsumeQueue != null) { try { // ... // 从消费队列中读取消息，直到读完或者读到查询消息数的最大值 for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { long offsetPy = bufferConsumeQueue.getByteBuffer().getLong(); int sizePy = bufferConsumeQueue.getByteBuffer().getInt(); long tagsCode = bufferConsumeQueue.getByteBuffer().getLong(); maxPhyOffsetPulling = offsetPy; // ... // 消息过滤 if (messageFilter != null && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.NO_MATCHED_MESSAGE; } continue; } // 根据消息的偏移量和消息的大小从 CommitLog 文件中取出一条消息 SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy); if (null == selectResult) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.MESSAGE_WAS_REMOVING; } nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy); continue; } // ... } \"]},\"288\":{\"h\":\"4.3 刷盘\",\"t\":[\"putMessagePositionInfo 中调用 MappedFile#appendMessage，但这并不表示消息会被立刻持久化到磁盘中。\",\"持久化的过程是通过后台服务 FlushConsumeQueueService 来定时持久化的，每隔1s检查一次。\"]},\"289\":{\"h\":\"4.3.1 FlushConsumeQueueService#doFlush\",\"t\":[\"该方法每隔 1s 执行一次。\",\"比较上次刷盘时间与当前时间差距，如果小于等于 60s，则执行刷盘\",\"遍历 ConsumeQueue 执行刷盘，每隔 ConsumeQueue 至少刷 2 个操作系统页\",\"更新 StoreCheckpoint 中的最新刷盘时间\",\"private void doFlush(int retryTimes) { // 变量含义：如果大于0，则标识这次刷盘必须刷多少个page，如果=0，则有多少刷多少。 // 默认为2，表示每次至少刷2个操作系统page int flushConsumeQueueLeastPages = DefaultMessageStore.this.getMessageStoreConfig().getFlushConsumeQueueLeastPages(); // 程序退出时强制刷盘 if (retryTimes == RETRY_TIMES_OVER) { flushConsumeQueueLeastPages = 0; } long logicsMsgTimestamp = 0; // 一定时间内未执行刷盘，会强制刷盘，默认60s int flushConsumeQueueThoroughInterval = DefaultMessageStore.this.getMessageStoreConfig().getFlushConsumeQueueThoroughInterval(); long currentTimeMillis = System.currentTimeMillis(); if (currentTimeMillis >= (this.lastFlushTimestamp + flushConsumeQueueThoroughInterval)) { // 当时间满足flushConsumeQueueThoroughInterval时，即使写入的数量不足flushConsumeQueueLeastPages，也进行flush this.lastFlushTimestamp = currentTimeMillis; flushConsumeQueueLeastPages = 0; logicsMsgTimestamp = DefaultMessageStore.this.getStoreCheckpoint().getLogicsMsgTimestamp(); } ConcurrentMap<String, ConcurrentMap<Integer, ConsumeQueue>> tables = DefaultMessageStore.this.consumeQueueTable; // 遍历ConsumeQueue刷盘 for (ConcurrentMap<Integer, ConsumeQueue> maps : tables.values()) { for (ConsumeQueue cq : maps.values()) { boolean result = false; for (int i = 0; i < retryTimes && !result; i++) { result = cq.flush(flushConsumeQueueLeastPages); } } } // 更新CheckPoint中ConsumeQueue最新刷盘时间 if (0 == flushConsumeQueueLeastPages) { if (logicsMsgTimestamp > 0) { DefaultMessageStore.this.getStoreCheckpoint().setLogicsMsgTimestamp(logicsMsgTimestamp); } DefaultMessageStore.this.getStoreCheckpoint().flush(); } } \"]},\"290\":{\"h\":\"4.4 恢复\",\"t\":[\"在Broker重新启动时会扫描ConsumeQueue的目录，尝试恢复这些文件。\"]},\"291\":{\"h\":\"4.4.1 ConsumeQueue#recover\",\"t\":[\"从倒数第三个文件开始往后遍历，遍历文件的每个索引项进行校验，校验成功则更新当前文件的最大可用偏移量，否则直接退出循环。\",\"最后更新整个队列的可用偏移量，删掉不可用的部分。\",\"public void recover() { final List<MappedFile> mappedFiles = this.mappedFileQueue.getMappedFiles(); if (!mappedFiles.isEmpty()) { // 从倒数第三个文件开始恢复 int index = mappedFiles.size() - 3; if (index < 0) index = 0; int mappedFileSizeLogics = this.mappedFileSize; MappedFile mappedFile = mappedFiles.get(index); ByteBuffer byteBuffer = mappedFile.sliceByteBuffer(); long processOffset = mappedFile.getFileFromOffset(); long mappedFileOffset = 0; long maxExtAddr = 1; while (true) { for (int i = 0; i < mappedFileSizeLogics; i += CQ_STORE_UNIT_SIZE) { long offset = byteBuffer.getLong(); int size = byteBuffer.getInt(); long tagsCode = byteBuffer.getLong(); // 说明当前存储单元有效 if (offset >= 0 && size > 0) { mappedFileOffset = i + CQ_STORE_UNIT_SIZE; this.maxPhysicOffset = offset + size; if (isExtAddr(tagsCode)) { maxExtAddr = tagsCode; } } else { log.info(\\\"recover current consume queue file over, \\\" + mappedFile.getFileName() + \\\" \\\" + offset + \\\" \\\" + size + \\\" \\\" + tagsCode); break; } } // 走到文件末尾，切换至下一个文件 if (mappedFileOffset == mappedFileSizeLogics) { index++; if (index >= mappedFiles.size()) { // 当前分支不可能发生 log.info(\\\"recover last consume queue file over, last mapped file \\\" + mappedFile.getFileName()); break; } else { mappedFile = mappedFiles.get(index); byteBuffer = mappedFile.sliceByteBuffer(); processOffset = mappedFile.getFileFromOffset(); mappedFileOffset = 0; log.info(\\\"recover next consume queue file, \\\" + mappedFile.getFileName()); } } else { log.info(\\\"recover current consume queue queue over \\\" + mappedFile.getFileName() + \\\" \\\" + (processOffset + mappedFileOffset)); break; } } processOffset += mappedFileOffset; this.mappedFileQueue.setFlushedWhere(processOffset); this.mappedFileQueue.setCommittedWhere(processOffset); this.mappedFileQueue.truncateDirtyFiles(processOffset); if (isExtReadEnable()) { this.consumeQueueExt.recover(); log.info(\\\"Truncate consume queue extend file by max {}\\\", maxExtAddr); this.consumeQueueExt.truncateByMaxAddress(maxExtAddr); } } } \"]},\"292\":{\"h\":\"5. 更多思考\"},\"293\":{\"h\":\"5.1 RocketMQ 5.x 版本中新的 Batch Consume Queue index\",\"t\":[\"在 RIP-26 中为了支持 Batch Message，引入了新的 ConsumeQueue 格式。\",\"这种 ConsumeQueue 元素更多（每个索引的大小也更大），支持了 Batch Message，且方便扩展（留了8字节的保留字段）。\",\"Untitled\",\"不出意外的话 RocketMQ 5.0 中将采用这种 ConsumeQueue 的格式。\"]},\"294\":{\"h\":\"参考资料\",\"t\":[\"1 消费队列ConsumeQueue——wuchanming.gitbook.com\",\"rocketmq源码分析_消息存储之概要设计——迦南地\",\"RocketMQ 设计(design)\",\"RocketMQ高性能之底层存储设计\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"295\":{\"h\":\"RocketMQ IndexFile 索引文件\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220301-rocketmq-indexfile.html\"]},\"296\":{\"h\":\"1. 概述\"},\"297\":{\"h\":\"1.1 索引文件是什么\",\"t\":[\"IndexFile，又可以称作索引文件，是 RocketMQ 保存在磁盘上的一种文件，属于 RocketMQ 存储的一部分。它的结构类似于类似 JDK中 HashMap。\",\"可以通过messageIndexEnable属性配置打开或关闭 IndexFile 存储功能。\"]},\"298\":{\"h\":\"1.2 索引文件作用\",\"t\":[\"索引文件的应用场景其实比较局限，是为了提供按照 Message Key 查询消息的能力。索引文件可以通过 Message Key，查询到消息在 CommitLog 中的物理偏移量，进而从 CommitLog 中查询消息。\"]},\"299\":{\"h\":\"2. 概要设计\"},\"300\":{\"h\":\"2.1 索引文件结构\",\"t\":[\"上面说它的逻辑结构类似 HashMap，HashMap 以 Key-Value 形式存储数据，那么索引文件的存储格式也是 Key-Value\",\"Key：Message Key。索引文件的 Key 其实是 Message Key 经过 hash 得到的一个 Integer，\",\"Value：physical offset。索引文件的 Value 主要是消息在 CommitLog 中的绝对物理偏移量。\",\"hash冲突时，Value以链表的方式存储，越新的消息在链表越前面。\",\"它可以包含多个文件，每个文件的大小是固定的。这就意味着每个 IndexFile 包含的最大索引数量是相同的。\"]},\"301\":{\"h\":\"2.2 如何构建\",\"t\":[\"消息保存到 CommitLog 之后，会进行重投递。重投递消息的过程就是为了建立消息的索引文件（包括 ConsumeQueue 和 IndexFile）。\",\"重投递线程会扫描是否有新消息被保存到 CommitLog，如果有则将这条消息查出来，执行重投递逻辑，构建该消息的索引。\"]},\"302\":{\"h\":\"2.3 如何查询消息\",\"t\":[\"索引文件中存储着 Message Key 对应消息在 CommitLog 中的偏移量，首先查询出这些偏移量信息，然后用偏移量从 CommitLog 中查询出消息。\"]},\"303\":{\"h\":\"2.4 刷盘机制\",\"t\":[\"索引文件的刷盘机制并不是采取定时刷盘机制，而是每写满一个索引文件时就新建一个文件，并且将上一个写满的索引文件刷盘。\"]},\"304\":{\"h\":\"3. 详细设计\"},\"305\":{\"h\":\"3.1 索引文件结构\",\"t\":[\"设计 IndexFile 最重要的是设计它的逻辑结构和文件存储结构。首先看一下 IndexFile 详细的逻辑结构\"]},\"306\":{\"h\":\"3.1.1 逻辑结构\",\"t\":[\"上面已经提到 IndexFile 是类似 JDK 的 HashMap 的结构。\",\"Key：由 IndexService#buildKey(String topic, String key)构建而成，具体为 topic + \\\"#\\\" + messageKey 经过hash（IndexFile#indexKeyHashMethod(String Key)）得到。\",\"注意：这里存在 Hash 冲突的可能，两个 Topic 和 Key 不同的消息可能得到相同的 Hash 值，会导致查询结果错误。社区已经提出这个错误 ISSUE#3613，但目前还并未解决。\",\"Untitled\",\"Value：Hash 冲突时变成链表结构，包含：\",\"消息在 CommitLog 中的物理偏移量，用于到 CommitLog 中查询消息\",\"IndexFile#indexKeyHashMethod(String Key)得到的整数 Hash 值\",\"消息保存时间与索引文件最早消息保存时间的差值，用于搜索时间范围内的消息\",\"指向下一条消息位置的指针（在时间上是前一条，越晚到达的消息在链表越前面）\"]},\"307\":{\"h\":\"3.1.2 存储结构\",\"t\":[\"索引文件底层使用 RocketMQ 的 MappedFile 来存储，索引文件可以有多个，可以无限扩展。\",\"每个索引文件以其创建的时间命名，举例：20211209174133951\",\"每个索引文件被设计为定长的，最多可以保存 500万个 Hash 槽和 2000万个索引项。当保存的数据超过上限时，会创建一个新的索引文件来保存。这就意味着同样 Hash 值的消息可能会被保存到不同的索引文件当中。\",\"RocketMQ的存储文件都遵循一种通用的数据存储格式定义实践：Header + Body，通常 Header 部分是定长的，存放一些基本信息，Body 存放数据。\",\"具体存储结构和内容如图所示：\",\"Untitled\",\"Header 固定大小，包含一些基本信息 \",\"beginTimestamp：最早的消息存储时间（消息存储到 CommitLog 的时间）\",\"endTimestamp：最晚的消息存储时间\",\"beginPhyoffset：存储的消息的最小物理偏移量（在 CommitLog 中的偏移量）\",\"endPhyoffset：存储的消息的最大物理偏移量\",\"hashSlotCount：最大可存储的 hash 槽个数\",\"indexCount：当前已经使用的索引条目个数。注意这个值是从 1 开始的\",\"Hash Slot 部分存储固定数量的 Message Key hash槽（500万个，该数值可以通过 Broker 配置项 maxHashSlotNum 来配置） \",\"存储的每个值是在索引文件中 索引的逻辑下标。因为索引文件的 Header 和 Hash Slot 部分长度都是固定的，每个索引的长度也是固定的，所以可以通过逻辑下标计算出索引项在索引文件中的绝对偏移量\",\"Index Item 部分存储固定数量的索引项（2000万个，该数值可以通过 Broker 配置项 maxIndexNum 来配置）。每个索引项包含如下信息 \",\"Key Hash：消息的 Topic 和 Message Key 经过哈希得到的整数\",\"Commit Log Offset：消息在 CommitLog 中的物理偏移量，用于到 CommitLog 中查询消息\",\"Time Diff：从该索引文件到消息保存时间的时间差（精确到秒），用于根据时间范围查询消息\",\"Next Index Offset：链表下一项的逻辑下标（这里的逻辑下标的含义跟 Hash Slot 中存储的逻辑下标含义相同） \",\"每次插入新的消息，都会从链表的头部插入。链表越往后，消息越老。因为一般来说消息队列会更关心新的消息。\"]},\"308\":{\"h\":\"3.2 索引文件涉及到的类\"},\"309\":{\"h\":\"IndexService\",\"t\":[\"索引服务，用于管理和控制所有索引文件。包括索引文件的加载、创建、刷盘、删除等。是索引文件操作的入口。\",\"private final ArrayList<IndexFile> indexFileList：索引文件列表。\",\"buildIndex(DispatchRequest req)：根据消息分发请求构建索引。注意这里会创建 msgId 的索引和消息 Key 的索引\",\"创建或获取最新的索引文件\",\"调用该索引文件的 IndexFile#putKey 方法创建索引\",\"queryOffset(String topic, String key, int maxNum, long begin, long end)：根据topic和message key，从IndexFile中查找消息。按时间查询：查询保存时间在 begin 到 end 内的消息\",\"从后往前遍历 indexFileList 列表中的索引文件，查找索引对应的 message 符合时间的 IndexFile（[beginTimestamp, endTimestamp] 与 [begin, end] 有交集的索引文件）\",\"调用符合条件的索引文件 IndexFile#selectPhyOffset() 方法查找所有 offset\",\"retryGetAndCreateIndexFile()：获取最新的索引文件，如果不存在，则创建一个新的索引文件。\",\"调用 getAndCreateLastIndexFile() 方法创建或者获取最新的索引文件\",\"创建新索引文件时如果创建失败，会重试创建3次\",\"getAndCreateLastIndexFile()：获取最后一个索引文件。如果没有索引文件或者最后一个索引文件满了，那么创建一个新的文件\",\"检查索引文件列表最后一个文件是否存在以及是否满\",\"如果不存在或者已经满了，创建新的文件，并且把上一个索引文件异步刷盘\",\"如果最后一个文件存在并且未满，直接返回该文件\",\"flush()：将一个索引文件强制刷盘，并且刷新 checkpoint 文件中的 indexMsgTimestamp，checkpoint文件刷盘。\",\"如果开启 MessageStoreConfig#messageIndexSafe 配置项，那么下次 Broker 异常恢复时，会从 checkpoint 保存的 indexMsgTimestamp 即索引文件记录的强制刷盘时间来恢复。\",\"当一个索引文件写满后创建新索引文件时调用，强制将写满的文件刷盘\",\"Untitled\"]},\"310\":{\"h\":\"IndexFile\",\"t\":[\"索引文件，包含索引文件的存储结构和一系列操作。\",\"底层使用内存映射文件 MappedFile 存储。\",\"MappedFile mappedFile：底层存储实现\",\"putKey(final String key, final long phyOffset, final long storeTimestamp)：添加一个索引到索引文件\",\"selectPhyOffset(final List<Long> phyOffsets, final String key, final int maxNum, final long begin, final long end, boolean lock)：从该索引文件中根据 Key 查找索引对应的 offset\"]},\"311\":{\"h\":\"4. 源码解析\"},\"312\":{\"h\":\"4.1 IndexService\"},\"313\":{\"h\":\"4.1.1 创建\",\"t\":[\"load：重新加载索引文件\",\"/** * 重新加载索引文件 * * @param lastExitOK 上次是否是正常退出 * @return 加载是否成功 */ public boolean load(final boolean lastExitOK) { File dir = new File(this.storePath); File[] files = dir.listFiles(); if (files != null) { // ascending order, 将索引文件按照创建时间升序排序 Arrays.sort(files); for (File file : files) { // 依次加载每个索引文件 try { IndexFile f = new IndexFile(file.getPath(), this.hashSlotNum, this.indexNum, 0, 0); f.load(); // 如果上一次是异常退出，则删除check point之后的所有索引文件 if (!lastExitOK) { if (f.getEndTimestamp() > this.defaultMessageStore.getStoreCheckpoint().getIndexMsgTimestamp()) { f.destroy(0); continue; } } this.indexFileList.add(f); } catch // ... } } return true; } \",\"getAndCreateLastIndexFile()：获取最后一个索引文件，如果集合为空或者最后一个文件写满了，则新建一个文件 \",\"先判断文件是否存在、是否写满\",\"如果不存在或者最后一个文件写满，则创建一个文件\",\"如果存在，直接返回该文件\",\"如果创建了新文件，启动一个线程将前一个写满的文件异步刷盘。 \",\"刷盘线程会将该文件刷盘\",\"然后更新 StoreCheckpoint#indexMsgTimestamp 为该写满的索引文件中 indexHeader 的 endTimestamp\",\"/** * 获取最后一个索引文件，如果集合为空或者最后一个文件写满了，则新建一个文件<br> * 只有一个线程调用，所以不存在写竟争问题 */ public IndexFile getAndCreateLastIndexFile() { IndexFile indexFile = null; IndexFile prevIndexFile = null; long lastUpdateEndPhyOffset = 0; long lastUpdateIndexTimestamp = 0; // 先尝试使用读锁 { this.readWriteLock.readLock().lock(); // 判断文件列表是否为空 if (!this.indexFileList.isEmpty()) { IndexFile tmp = this.indexFileList.get(this.indexFileList.size() - 1); // 判断最后一个文件是否写满 if (!tmp.isWriteFull()) { indexFile = tmp; } else { lastUpdateEndPhyOffset = tmp.getEndPhyOffset(); lastUpdateIndexTimestamp = tmp.getEndTimestamp(); prevIndexFile = tmp; } } this.readWriteLock.readLock().unlock(); } // 如果文件列表为空或者最后一个文件写满了，使用写锁创建文件 if (indexFile == null) { try { String fileName = this.storePath + File.separator + UtilAll.timeMillisToHumanString(System.currentTimeMillis()); indexFile = new IndexFile(fileName, this.hashSlotNum, this.indexNum, lastUpdateEndPhyOffset, lastUpdateIndexTimestamp); this.readWriteLock.writeLock().lock(); this.indexFileList.add(indexFile); } catch (Exception e) { log.error(\\\"getLastIndexFile exception \\\", e); } finally { this.readWriteLock.writeLock().unlock(); } // 每创建一个新文件，前一个文件异步刷盘 if (indexFile != null) { final IndexFile flushThisFile = prevIndexFile; Thread flushThread = new Thread(new Runnable() { @Override public void run() { IndexService.this.flush(flushThisFile); } }, \\\"FlushIndexFileThread\\\"); flushThread.setDaemon(true); flushThread.start(); } } return indexFile; } \"]},\"314\":{\"h\":\"4.1.2 插入和查询\",\"t\":[\"buildIndex(DispatchRequest req)：根据消息分发请求构建索引。注意这里会创建 msgId 的索引和消息 Key 的索引 \",\"创建或获取最新的索引文件\",\"调用该索引文件的 IndexFile#putKey 方法创建索引 \",\"获取 uniqKey（也就是 msgId），创建索引\",\"获取消息的所有 key，分别创建索引\",\"/** * 根据 DispatchRequest 构建索引 * * @param req 消息存入CommitLog之后重新分发到Index文件的 DispatchRequest */ public void buildIndex(DispatchRequest req) { IndexFile indexFile = retryGetAndCreateIndexFile(); if (indexFile != null) { long endPhyOffset = indexFile.getEndPhyOffset(); DispatchRequest msg = req; String topic = msg.getTopic(); String keys = msg.getKeys(); if (msg.getCommitLogOffset() < endPhyOffset) { return; } // 如果是事务消息的回滚消息，不需要创建索引，直接返回 final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag()); switch (tranType) { case MessageSysFlag.TRANSACTION_NOT_TYPE: case MessageSysFlag.TRANSACTION_PREPARED_TYPE: case MessageSysFlag.TRANSACTION_COMMIT_TYPE: break; case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: return; } if (req.getUniqKey() != null) { // 创建UniqueKey的索引，也就是msgId的索引 indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey())); if (indexFile == null) { log.error(\\\"putKey error commitlog {} uniqkey {}\\\", req.getCommitLogOffset(), req.getUniqKey()); return; } } // 创建消息key的索引，这里key可以有多个 if (keys != null && keys.length() > 0) { String[] keyset = keys.split(MessageConst.KEY_SEPARATOR); for (int i = 0; i < keyset.length; i++) { String key = keyset[i]; if (key.length() > 0) { indexFile = putKey(indexFile, msg, buildKey(topic, key)); if (indexFile == null) { log.error(\\\"putKey error commitlog {} uniqkey {}\\\", req.getCommitLogOffset(), req.getUniqKey()); return; } } } } } else { log.error(\\\"build index error, stop building index\\\"); } } \",\"queryOffset(String topic, String key, int maxNum, long begin, long end)：根据topic和message key，从IndexFile中查找消息\",\"/** * 根据topic和message key，从IndexFile中查找消息 * * @param topic * @param key * @param maxNum 最大查找消息数量 * @param begin 查找消息最小时间 * @param end 查找消息最大时间 * @return */ public QueryOffsetResult queryOffset(String topic, String key, int maxNum, long begin, long end) { List<Long> phyOffsets = new ArrayList<Long>(maxNum); long indexLastUpdateTimestamp = 0; long indexLastUpdatePhyoffset = 0; maxNum = Math.min(maxNum, this.defaultMessageStore.getMessageStoreConfig().getMaxMsgsNumBatch()); try { this.readWriteLock.readLock().lock(); if (!this.indexFileList.isEmpty()) { // 从后往前遍历IndexFile，查找索引对应的message符合时间的IndexFile for (int i = this.indexFileList.size(); i > 0; i--) { IndexFile f = this.indexFileList.get(i - 1); boolean lastFile = i == this.indexFileList.size(); if (lastFile) { indexLastUpdateTimestamp = f.getEndTimestamp(); indexLastUpdatePhyoffset = f.getEndPhyOffset(); } if (f.isTimeMatched(begin, end)) { // 最后一个文件需要加锁 f.selectPhyOffset(phyOffsets, buildKey(topic, key), maxNum, begin, end, lastFile); } // 再往前遍历时间更不符合 if (f.getBeginTimestamp() < begin) { break; } if (phyOffsets.size() >= maxNum) { break; } } } } catch (Exception e) { log.error(\\\"queryMsg exception\\\", e); } finally { this.readWriteLock.readLock().unlock(); } return new QueryOffsetResult(phyOffsets, indexLastUpdateTimestamp, indexLastUpdatePhyoffset); } \"]},\"315\":{\"h\":\"4.1.3 过期删除\",\"t\":[\"deleteExpiredFile(long offset)：删除消息CommitLog偏移量offset之前的所有IndexFile文件\"]},\"316\":{\"h\":\"4.1.4 刷盘\",\"t\":[\"flush()：强制刷盘，会把内存映射文件中的数据强制写到磁盘。在一个索引文件写满后调用\",\"/** * 索引文件刷盘，在一个文件写满后调用 * * @param f 需要刷盘的索引文件 */ public void flush(final IndexFile f) { if (null == f) return; long indexMsgTimestamp = 0; if (f.isWriteFull()) { indexMsgTimestamp = f.getEndTimestamp(); } // 索引文件刷盘 f.flush(); // checkpoint文件刷盘 if (indexMsgTimestamp > 0) { this.defaultMessageStore.getStoreCheckpoint().setIndexMsgTimestamp(indexMsgTimestamp); this.defaultMessageStore.getStoreCheckpoint().flush(); } } \"]},\"317\":{\"h\":\"4.2 IndexFile\",\"t\":[\"putKey(final String key, final long phyOffset, final long storeTimestamp)：向索引文件插入新的索引项\",\"根据 key 的 Hash 值计算出 hash槽绝对位置 absSlotPos\",\"获取当前 hash槽的值，为该 hash槽对应的最新的索引的逻辑下标\",\"在 hash槽对应的链表头部插入索引\",\"hash槽指向最新创建的索引的逻辑下标\",\"更新文件头\",\"/** * 向索引文件插入新的索引项 * 如果返回false，表示需要创建新的索引文件 */ public boolean putKey(final String key, final long phyOffset, final long storeTimestamp) { // 判断当前索引数量是否小于最大索引数量，如果小于则直接退出，说明需要创建新的索引文件 if (this.indexHeader.getIndexCount() < this.indexNum) { // 计算key的hash值 int keyHash = indexKeyHashMethod(key); // 获取hash槽位置（下标）。通过 keyHash % hashSlotNum 的方式再次哈希，这里会加大查询消息错误的概率。 int slotPos = keyHash % this.hashSlotNum; // 通过hash槽下表计算出hash槽的绝对位置 int absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize; FileLock fileLock = null; try { // fileLock = this.fileChannel.lock(absSlotPos, hashSlotSize, // false); // 通过hash槽绝对位置，获取hash槽的值，如果有值说明这个hash key已经存在，如果不存在则需要填入 int slotValue = this.mappedByteBuffer.getInt(absSlotPos); if (slotValue <= invalidIndex || slotValue > this.indexHeader.getIndexCount()) { slotValue = invalidIndex; } long timeDiff = storeTimestamp - this.indexHeader.getBeginTimestamp(); timeDiff = timeDiff / 1000; if (this.indexHeader.getBeginTimestamp() <= 0) { timeDiff = 0; } else if (timeDiff > Integer.MAX_VALUE) { timeDiff = Integer.MAX_VALUE; } else if (timeDiff < 0) { timeDiff = 0; } // 计算放置索引的绝对偏移量 int absIndexPos = IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize + this.indexHeader.getIndexCount() * indexSize; // 在链表头部插入最新的索引项 // 将索引存入文件，最后一个是指针，指向下一个链表元素 this.mappedByteBuffer.putInt(absIndexPos, keyHash); this.mappedByteBuffer.putLong(absIndexPos + 4, phyOffset); this.mappedByteBuffer.putInt(absIndexPos + 4 + 8, (int) timeDiff); this.mappedByteBuffer.putInt(absIndexPos + 4 + 8 + 4, slotValue); // 写入hash槽，每个hash槽的值是最新写入的索引文件的逻辑下标 this.mappedByteBuffer.putInt(absSlotPos, this.indexHeader.getIndexCount()); if (this.indexHeader.getIndexCount() <= 1) { this.indexHeader.setBeginPhyOffset(phyOffset); this.indexHeader.setBeginTimestamp(storeTimestamp); } if (invalidIndex == slotValue) { this.indexHeader.incHashSlotCount(); } // 更新索引文件头，索引项个数+1 this.indexHeader.incIndexCount(); this.indexHeader.setEndPhyOffset(phyOffset); this.indexHeader.setEndTimestamp(storeTimestamp); return true; } catch (Exception e) { log.error(\\\"putKey exception, Key: \\\" + key + \\\" KeyHashCode: \\\" + key.hashCode(), e); } finally { if (fileLock != null) { try { fileLock.release(); } catch (IOException e) { log.error(\\\"Failed to release the lock\\\", e); } } } } else { log.warn(\\\"Over index file capacity: index count = \\\" + this.indexHeader.getIndexCount() + \\\"; index max num = \\\" + this.indexNum); } return false; } \",\"selectPhyOffset(final List<Long> phyOffsets, final String key, final int maxNum, final long begin, final long end, boolean lock)：从该索引文件中根据 Key 查找索引对应的 offset \",\"根据 key 的 Hash值计算 hash槽的绝对位置\",\"通过 hash槽中存储的索引逻辑下标，找到索引链表绝对位置\",\"遍历索引链表中的每个索引，获取索引数据，比较时间信息\",\"将时间信息符合搜索条件的索引加入到结果列表中\",\"/** * 从该索引文件中根据key查找offsets * * @param phyOffsets offsets结果列表 * @param key 查找的key * @param maxNum 最大返回结果数量 * @param begin 查找消息的开始时间 * @param end 查找消息的结束时间 * @param lock 查找时是否加锁（已废弃） */ public void selectPhyOffset(final List<Long> phyOffsets, final String key, final int maxNum, final long begin, final long end, boolean lock) { if (this.mappedFile.hold()) { // 根据key的hash值计算hash槽的绝对位置 int keyHash = indexKeyHashMethod(key); int slotPos = keyHash % this.hashSlotNum; int absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize; FileLock fileLock = null; try { if (lock) { // fileLock = this.fileChannel.lock(absSlotPos, // hashSlotSize, true); } // 获取hash槽的值 int slotValue = this.mappedByteBuffer.getInt(absSlotPos); // if (fileLock != null) { // fileLock.release(); // fileLock = null; // } // 如果该hash槽的值有效则查找，否则查找失败 if (slotValue <= invalidIndex || slotValue > this.indexHeader.getIndexCount() || this.indexHeader.getIndexCount() <= 1) { } else { for (int nextIndexToRead = slotValue; ; ) { if (phyOffsets.size() >= maxNum) { break; } int absIndexPos = IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize + nextIndexToRead * indexSize; int keyHashRead = this.mappedByteBuffer.getInt(absIndexPos); long phyOffsetRead = this.mappedByteBuffer.getLong(absIndexPos + 4); long timeDiff = (long) this.mappedByteBuffer.getInt(absIndexPos + 4 + 8); int prevIndexRead = this.mappedByteBuffer.getInt(absIndexPos + 4 + 8 + 4); if (timeDiff < 0) { break; } timeDiff *= 1000L; long timeRead = this.indexHeader.getBeginTimestamp() + timeDiff; boolean timeMatched = (timeRead >= begin) && (timeRead <= end); if (keyHash == keyHashRead && timeMatched) { phyOffsets.add(phyOffsetRead); } if (prevIndexRead <= invalidIndex || prevIndexRead > this.indexHeader.getIndexCount() || prevIndexRead == nextIndexToRead || timeRead < begin) { break; } nextIndexToRead = prevIndexRead; } } } catch (Exception e) { log.error(\\\"selectPhyOffset exception \\\", e); } finally { if (fileLock != null) { try { fileLock.release(); } catch (IOException e) { log.error(\\\"Failed to release the lock\\\", e); } } this.mappedFile.release(); } } \"]},\"318\":{\"h\":\"参考资料\",\"t\":[\"RocketMQ 文档：设计\",\"RocketMQ存储篇——IndexFile和IndexService\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"319\":{\"h\":\"RocketMQ 消息消费 轮询机制 PullRequestHoldService\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220301-rocketmq-longpolling-pullrequestholdservice.html\"]},\"320\":{\"h\":\"1. 概述\",\"t\":[\"先来看看 RocketMQ 消费过程中的轮询机制是啥。首先需要补充一点消费相关的前置知识。\"]},\"321\":{\"h\":\"1.1 消息消费方式\",\"t\":[\"RocketMQ 支持多种消费方式，包括 Push 模式和 Pull 模式\",\"Pull 模式：用户自己进行消息的拉取和消费进度的更新\",\"Push 模式：Broker 将新的消息自动发送给用户进行消费\"]},\"322\":{\"h\":\"1.2 Push 消费模式\",\"t\":[\"我们一般使用 RocketMQ 时用的是 Push 模式，因为比较方便，不需要手动拉取消息和更新消费进度。\",\"那么你有没有想过 Push 模式是如何做到能够立即消费新的消息？\"]},\"323\":{\"h\":\"1.2.1 Push 模式原理\",\"t\":[\"实际上，在 Push 消费时，消费者是在不断轮询 Broker，询问是否有新消息可供消费。一旦有新消息到达，马上拉取该消息。也就是说 Push 模式内部也用了 Pull 消息的模式，这样就可以立即消费到最新的消息。\"]},\"324\":{\"h\":\"1.3 如何进行轮询？\",\"t\":[\"那么 Push 模式或 Pull 模式如何进行消息的查询？\",\"能够想到的比较笨的方法是，每隔一定的时间（如1ms）就向 Broker 发送一个查询请求，如果没有新消息则立刻返回。可想而知这种方法非常浪费网络资源。\",\"RocketMQ 为了提高网络性能，在拉取消息时如果没有新消息，不会马上返回，而是会将该查询请求挂起一段时间，然后再重试查询。如果一直没有新消息，直到轮询时间超过设定的阈值才会返回。\",\"根据轮询设定的超时阈值大小的不同，RocketMQ 有两种轮询方式，分别为长轮询（默认）和短轮询。\"]},\"325\":{\"h\":\"1.4 长轮询和短轮询\",\"t\":[\"RocketMQ 的 Broker 端参数 longPollingEnable 可以配置轮询方式，默认为 true\",\"短轮询：longPollingEnable=false，轮询时间为 shortPollingTimeMills ，默认为 1s\",\"长轮询：longPollingEnable=true，轮询时间为 5s。拉取请求挂起时间：受 DefaultMQPullConsumer 的 brokerSuspendMaxTimeMillis 控制，默认push模式固定15s，pull模式固定20s。\"]},\"326\":{\"h\":\"2. 概要流程\",\"t\":[\"https://raw.githubusercontent.com/HScarb/drawio-diagrams/main/rocketmq/consume/long_polling_activity.drawio.svg\",\"根据上面的活动图来看一下 RocketMQ 消费时的轮询机制流程\",\"Consumer 发送拉取消息请求\",\"Broker 收到请求后交给请求处理模块处理\",\"尝试从存储的消息中拉取消息\",\"如果能够拉取消息，那么将拉取到的消息直接返回\",\"如果没有拉取到消息，那么根据 Broker 是否支持挂起和是否开启长轮询来判断是否要进行轮询以及进行哪种轮询。 \",\"如果支持挂起，那么会将该拉取请求挂起\",\"长轮询等待 5s\",\"短轮询等待 1s\",\"检查消费队列中是否有新消息到达，如果没有则继续等待，以此循环。如果有新消息，处理挂起的拉取消息请求并返回消费者。\",\"如果没有新消息到达，轮询后会检查每个挂起的拉取请求的挂起时间是否超过挂起时间阈值，如果超过那么也会直接返回消费者，否则继续循环进行轮询操作。\",\"那么按照上述流程，开启长轮询的情况下，如果一次轮询没有找到消息，要等待 5s 才能进行下一次查询。如果这 5s 当中有新的消息存入，如何保证能够立刻消费到？\",\"解决方案不难想到，就是新的消息写入后，主动进行通知，让挂起的拉取请求立刻进行拉取操作。\",\"RocketMQ 就是这么做的，在消息存入 CommitLog 后的 doReput 方法中，会判断是否是长轮询，如果是则会发送一个通知，让挂起的拉取请求立刻进行处理。\"]},\"327\":{\"h\":\"3. 详细流程\"},\"328\":{\"h\":\"3.1 涉及到的类\"},\"329\":{\"h\":\"3.1.1 PullMessageProcessor\",\"t\":[\"该类是 Broker 处理 Consumer 拉取清求的入口类。当 Broker 收到 Consumer 发送的拉取请求时，调用该类的 processRequest 方法\"]},\"330\":{\"h\":\"3.1.2 PullRequestHoldService\",\"t\":[\"长轮询请求管理线程，挂起的拉取请求会在这里进行保存。每等待一段时间（长轮询/短轮询等待时间）会检查挂起的请求中是否有可以进行拉取的数据。\"]},\"331\":{\"h\":\"3.1.3 DefaultMessageStore#ReputMessageService\",\"t\":[\"该线程负责将存储到 CommitLog 的消息重新转发，用以生成 ConsumeQueue 和 IndexFile 索引。在生成索引之后，会向长轮询线程发送提醒，立刻唤醒相应队列的拉取请求，执行消息拉取。\"]},\"332\":{\"h\":\"3.2 时序图\",\"t\":[\"https://raw.githubusercontent.com/HScarb/drawio-diagrams/main/rocketmq/consume/long_polling_sequence.drawio.svg\",\"着重体现了长轮询逻辑，其他逻辑有所省略\",\"消费者调用 pullKernelImpl() 发送拉取请求，调用时用 brokerSuspendMaxTimeMillis 指定了 Broker 挂起的最长时间，默认为 20s\",\"Broker 中 PullMessageProcess 处理拉取请求，从 ConsumeQueue 中查询消息\",\"如果没有查询到消息，判断是否启用长轮询，调用 PullRequestHoldService#suspendPullRequest() 方法将该请求挂起\",\"PullRequestHoldService 线程 run() 方法循环等待轮询时间，然后周期性调用 checkHoldRequest() 方法检查挂起的请求是否有消息可以拉取\",\"如果检查到有新消息可以拉取，调用 notifyMessageArriving() 方法\",\"ReputMessageService 的 doReput() 如果被调用，说明也有新消息到达，需要唤醒挂起的拉取请求。这里也会发送一个 notify，进而调用 notifyMessageArriving() 方法\",\"notifyMessageArriving() 方法中也会查询 ConsumeQueue 的最大 offset，如果确实有新消息，那么将唤醒对应的拉取请求，具体的方法是调用 executeRequestWhenWakeup() 方法\",\"executeRequestWhenWakeup() 方法唤醒拉取请求，调用 processRequest() 方法处理该请求\"]},\"333\":{\"h\":\"3.3 每个类的具体逻辑\"},\"334\":{\"h\":\"3.3.1 PullMessageProcessor\",\"t\":[\"Broker 处理 Consumer 拉取清求的入口类\",\"RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)：处理 Consumer 拉取请求的入口方法，收到 Consumer 拉取请求时调用。该方法主要完成如下操作\",\"校验\",\"消息过滤\",\"从存储中查询消息\",\"返回响应给 Consumer\",\"如果从存储中没有查询到消息，会将响应码设置为 ResponseCode.PULL_NOT_FOUND，并且启动长轮询\",\"void executeRequestWhenWakeup(Channel channel, final RemotingCommand request)：将 Hold 的拉取请求唤醒，再次拉取消息\",\"该方法在长轮询收到新消息时调用，立即唤醒挂起的拉取请求，然后对这些请求调用 processRequest 方法\",\"何时需要提醒长轮询新消息已经到达？上面说到，在长轮询等待时如果有新消息到达，CommitLog 的 doReput 方法中会进行提醒，最终会调用 executeRequestWhenWakeup 方法\"]},\"335\":{\"h\":\"3.3.2 PullRequestHoldService\",\"t\":[\"该服务线程会从 pullRequestTable 本地缓存变量中取PullRequest请求，检查轮询条件“待拉取消息的偏移量是否小于消费队列最大偏移量”是否成立，如果条件成立则说明有新消息达到Broker端，则通过PullMessageProcessor的executeRequestWhenWakeup()方法重新尝试发起Pull消息的RPC请求\",\"pullRequestTable\",\"private ConcurrentMap<String/* topic@queueId */, ManyPullRequest/* 同一队列积累的拉取请求 */> pullRequestTable = new ConcurrentHashMap<>(1024) \",\"上面是挂起的消息拉取请求容器，它是一个 ConcurrentHashMap，key 是拉取请求的队列，value 是该队列挂起的所有拉取请求。其中 ManyPullRequest 底层是一个 ArrayList，它的 add 方法加了锁。\",\"suspendPullRequest(String topic, int queueId, PullRequest pullRequest)：将 Consumer 拉取请求暂时挂起，会将请求加入到 pullRequestTable 中\",\"checkHoldRequest()：检查所有挂起的拉取请求，如果有数据满足要求，就唤醒该请求，对其执行 PullMessageProcessor#processRequest 方法\",\"run()：线程主循环，每等待一段时间就调用 checkHoldRequest() 方法检查是否有请求需要唤醒。等待的时间根据长轮询/短轮询的配置决定，长轮询等待 5s，短轮询默认等待 1s\",\"notifyMessageArriving()：被 checkHoldRequest() 和 ReputMessageService#doReput() 调用，表示新消息到达，唤醒对应队列挂起的拉取请求\"]},\"336\":{\"h\":\"3.3.3 DefaultMessageStore#ReputMessageService\",\"t\":[\"该服务线程 doReput() 方法会在 Broker 端不断地从数据存储对象 CommitLog 中解析数据并分发请求，随后构建出 ConsumeQueue（逻辑消费队列）和 IndexFile（消息索引文件）两种类型的数据。\",\"同时从本地缓存变量 PullRequestHoldService#pullRequestTable 中，取出挂起的拉起请求并执行。\"]},\"337\":{\"h\":\"4. 源码解析\"},\"338\":{\"h\":\"4.1 PullMessageProcessor\"},\"339\":{\"h\":\"4.1.1 processRequest\",\"t\":[\"如果从存储中没有查询到消息，会将响应码设置为 ResponseCode.PULL_NOT_FOUND，并且启动长轮询\",\"以下三种情况会将响应码设置为ResponseCode.PULL_NOT_FOUND：\",\"NO_MESSAGE_IN_QUEUE：消费队列中没有任何消息\",\"OFFSET_FOUND_NULL：offset未找到任何数据\",\"OFFSET_OVERFLOW_ONE：待拉取偏移量等于队列最大偏移量\",\"/** * 处理客户端请求入口 * * @param channel 网络通道，通过该通道向消息拉取客户端发送响应结果 * @param request 消息拉取请求 * @param brokerAllowSuspend Broker端是否允许挂起，默认true。true：如果未找到消息则挂起。false：未找到消息直接返回消息未找到 * @return 响应 * @throws RemotingCommandException 当解析请求发生异常时 */ private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend) throws RemotingCommandException { // ... switch (response.getCode()) { // ... // 如果从消费队列中未找到新的可以拉取的消息，判断并挂起该拉取请求 case ResponseCode.PULL_NOT_FOUND: // 长轮询 if (brokerAllowSuspend && hasSuspendFlag) { long pollingTimeMills = suspendTimeoutMillisLong; if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) { pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills(); } String topic = requestHeader.getTopic(); long offset = requestHeader.getQueueOffset(); int queueId = requestHeader.getQueueId(); PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills, this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter); this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest); response = null; break; } // ... } \"]},\"340\":{\"h\":\"4.1.2 executeRequestWhenWakeup\",\"t\":[\"在PullMessageProcessor的executeRequestWhenWakeup()方法中，通过业务线程池pullMessageExecutor，异步提交重新Pull消息的请求任务，即为重新调了一次PullMessageProcessor业务处理器的processRequest()方法，来实现Pull消息请求的二次处理）。\",\"/** * 将Hold的拉取请求唤醒，再次拉取消息 * 该方法调用线程池，因此，不会阻塞 * * @param channel 通道 * @param request Consumer拉取请求 * @throws RemotingCommandException 当远程调用发生异常 */ public void executeRequestWhenWakeup(final Channel channel, final RemotingCommand request) throws RemotingCommandException { Runnable run = new Runnable() { @Override public void run() { try { // 处理Consumer拉取请求，获取返回体 final RemotingCommand response = PullMessageProcessor.this.processRequest(channel, request, false); if (response != null) { response.setOpaque(request.getOpaque()); response.markResponseType(); try { // 将返回体写入channel，返回给Consumer channel.writeAndFlush(response).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (!future.isSuccess()) { log.error(\\\"processRequestWrapper response to {} failed\\\", future.channel().remoteAddress(), future.cause()); log.error(request.toString()); log.error(response.toString()); } } }); } catch (Throwable e) { log.error(\\\"processRequestWrapper process request over, but response failed\\\", e); log.error(request.toString()); log.error(response.toString()); } } } catch (RemotingCommandException e1) { log.error(\\\"excuteRequestWhenWakeup run\\\", e1); } } }; // 异步执行请求处理和返回 this.brokerController.getPullMessageExecutor().submit(new RequestTask(run, channel, request)); } \"]},\"341\":{\"h\":\"4.2 PullRequestHoldService\"},\"342\":{\"h\":\"4.2.1 suspendPullRequest\",\"t\":[\"/** * 挂起（保存）客户端请求，当有数据的时候触发请求 * * @param topic 主题 * @param queueId 队列编号 * @param pullRequest 拉取消息请求 */ public void suspendPullRequest(final String topic, final int queueId, final PullRequest pullRequest) { // 根据topic和queueId构造map的key String key = this.buildKey(topic, queueId); // map的key如果为空，创建一个空的request队列，填充key和value ManyPullRequest mpr = this.pullRequestTable.get(key); if (null == mpr) { mpr = new ManyPullRequest(); ManyPullRequest prev = this.pullRequestTable.putIfAbsent(key, mpr); if (prev != null) { mpr = prev; } } // 保存该次Consumer拉取请求 mpr.addPullRequest(pullRequest); } \"]},\"343\":{\"h\":\"4.2.2 checkHoldRequest\",\"t\":[\"/** * 检查所有已经挂起的长轮询请求 * 如果有数据满足要求，就触发请求再次执行 */ private void checkHoldRequest() { // 遍历拉取请求容器中的每个队列 for (String key : this.pullRequestTable.keySet()) { String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR); if (2 == kArray.length) { String topic = kArray[0]; int queueId = Integer.parseInt(kArray[1]); // 从store中获取队列的最大偏移量 final long offset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId); try { // 根据store中获取的最大偏移量，判断是否有新消息到达，如果有则执行拉取请求操作 this.notifyMessageArriving(topic, queueId, offset); } catch (Throwable e) { log.error(\\\"check hold request failed. topic={}, queueId={}\\\", topic, queueId, e); } } } } \"]},\"344\":{\"h\":\"4.2.3 run\",\"t\":[\"@Override public void run() { log.info(\\\"{} service started\\\", this.getServiceName()); while (!this.isStopped()) { try { // 等待一定时间 if (this.brokerController.getBrokerConfig().isLongPollingEnable()) { // 开启长轮询，每5s判断一次消息是否到达 this.waitForRunning(5 * 1000); } else { // 未开启长轮询，每1s判断一次消息是否到达 this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills()); } long beginLockTimestamp = this.systemClock.now(); // 检查是否有消息到达，可以唤醒挂起的请求 this.checkHoldRequest(); long costTime = this.systemClock.now() - beginLockTimestamp; if (costTime > 5 * 1000) { log.info(\\\"[NOTIFYME] check hold request cost {} ms.\\\", costTime); } } catch (Throwable e) { log.warn(this.getServiceName() + \\\" service has exception. \\\", e); } } log.info(\\\"{} service end\\\", this.getServiceName()); } \"]},\"345\":{\"h\":\"4.2.4 notifyMessageArriving\",\"t\":[\"这个方法在两个地方被调用，如下图所示\",\"Untitled\",\"这个方法是重新唤醒拉取请求的核心方法。调用这个方法，提醒 PullRequestHoldService 线程有新消息到达\",\"我们来看看这个方法具体做了什么\",\"根据 topic 和 queueId 获取挂起的拉取请求列表\",\"从 store 中获取该队列消息的最大offset\",\"遍历该队列的所有拉取请求，符合以下两种条件之一的拉取请求会被处理并返回 \",\"消费队列最大offset比消费者拉取请求的offset大，说明有新的消息可以被拉取，处理该拉取请求\",\"拉取请求挂起时间超过阈值，直接返回消息未找到\",\"如果不满足以上两个条件，那么该拉取请求会重新放回 pullRequestTable，等待下次检查\",\"/** * 当有新消息到达的时候，唤醒长轮询的消费端请求 * * @param topic 消息Topic * @param queueId 消息队列ID * @param maxOffset 消费队列的最大Offset */ public void notifyMessageArriving(final String topic, final int queueId, final long maxOffset, final Long tagsCode, long msgStoreTime, byte[] filterBitMap, Map<String, String> properties) { // 根据topic和queueId从容器中取出挂起的拉取请求列表 String key = this.buildKey(topic, queueId); ManyPullRequest mpr = this.pullRequestTable.get(key); if (mpr != null) { // 获取挂起的拉取请求列表 List<PullRequest> requestList = mpr.cloneListAndClear(); if (requestList != null) { // 预先定义需要继续挂起的拉取请求列表 List<PullRequest> replayList = new ArrayList<PullRequest>(); for (PullRequest request : requestList) { long newestOffset = maxOffset; // 从store中获取该队列消息的最大offset if (newestOffset <= request.getPullFromThisOffset()) { newestOffset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId); } // 消费队列最大offset比消费者拉取请求的offset大，说明有新的消息可以被拉取 if (newestOffset > request.getPullFromThisOffset()) { // 消息过滤匹配 boolean match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode, new ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap)); // match by bit map, need eval again when properties is not null. if (match && properties != null) { match = request.getMessageFilter().isMatchedByCommitLog(null, properties); } if (match) { try { // 会调用PullMessageProcessor#processRequest方法拉取消息，然后将结果返回给消费者 this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(), request.getRequestCommand()); } catch (Throwable e) { log.error(\\\"execute request when wakeup failed.\\\", e); } continue; } } // 查看是否超时，如果Consumer请求达到了超时时间，也触发响应，直接返回消息未找到 if (System.currentTimeMillis() >= (request.getSuspendTimestamp() + request.getTimeoutMillis())) { try { this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(), request.getRequestCommand()); } catch (Throwable e) { log.error(\\\"execute request when wakeup failed.\\\", e); } continue; } // 当前不满足要求，重新放回Hold列表中 replayList.add(request); } if (!replayList.isEmpty()) { mpr.addPullRequest(replayList); } } } } \"]},\"346\":{\"h\":\"4.3 DefaultMessageStore#ReputMessageService\"},\"347\":{\"h\":\"4.3.1 doReput\",\"t\":[\"private void doReput() { // ... DefaultMessageStore.this.doDispatch(dispatchRequest); // 通知消息消费长轮询线程，有新的消息落盘，立即唤醒挂起的消息拉取请求 if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole() && DefaultMessageStore.this.brokerConfig.isLongPollingEnable() && DefaultMessageStore.this.messageArrivingListener != null) { DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(), dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1, dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(), dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap()); } \",\"这里调用了 NotifyMessageArrivingListener#arriving() 方法，进而调用 PullRequestHoldService.notifyMessageArriving()。\",\"为什么不直接调用 pullRequestHoldService.notifyMessageArriving() ？因为 doReput 所处的类所在的包是 store，存储包，而 PullRequestHoldService 在 broker 包中\",\"所以需要一个桥梁，就是 NotifyMessageArrivingListener。它在 Broker 初始化 DefaultMessageStore 时被写入 DefaultMessageStore\"]},\"348\":{\"h\":\"4.3.2 NotifyMessageArrivingListener#arriving\",\"t\":[\"public class NotifyMessageArrivingListener implements MessageArrivingListener { @Override public void arriving(String topic, int queueId, long logicOffset, long tagsCode, long msgStoreTime, byte[] filterBitMap, Map<String, String> properties) { // 提醒长轮询请求管理容器，新的消息到达，立刻拉取最新消息 this.pullRequestHoldService.notifyMessageArriving(topic, queueId, logicOffset, tagsCode, msgStoreTime, filterBitMap, properties); } } \"]},\"349\":{\"h\":\"参考资料\",\"t\":[\"源码分析RocketMQ消息PULL-长轮询模式\",\"消息中间件—RocketMQ 消息消费（二）（push 模式实现）\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"350\":{\"h\":\"RocketMQ 延迟消息（定时消息）源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220313-rocketmq-scheduled-message.html\"]},\"351\":{\"h\":\"1. 概述\"},\"352\":{\"h\":\"1.1 定时消息概念\",\"t\":[\"定时消息指发送一条消息，消费者不立即能够消费，而是需要在指定时间进行消费\",\"生产者在发送消息时为消息指定发送时间，或者延迟时间\",\"定时消息指消息发送后，不能立即被消费者消费\",\"当到达指定的发送时间或者延迟相应时间后，消费者才可消费\"]},\"353\":{\"h\":\"1.2 RocketMQ中的定时消息支持\",\"t\":[\"截至目前版本，RocketMQ 不支持任意时间的定时消息，而是提供了18个延迟等级。发送消息时可以从18个延迟等级中选一个，然后这条消息会延迟相应的时间发送。\",\"默认支持的延迟等级为：\",\"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h \",\"可在 Broker 端通过 messageDelayLevel 参数进行配置\",\"需要注意的是 RocketMQ 的定时消息受到 CommitLog 保存时间的限制。也就是说如果 CommitLog 最长保存3天，那么延迟时间最长为3天。\"]},\"354\":{\"h\":\"2. 概要流程\",\"t\":[\"下面讲一下RocketMQ中发送定时消息，Broker处理再到消息被消费的流程\",\"生产者 \",\"生产者发送消息时，用户需在消息属性中设置延迟等级\",\"Broker \",\"Broker 初始化时会创建一个 Topic，专门存放延迟消息。该 Topic 默认有18（延迟等级个数）个 Queue\",\"Broker 启动时，为每个延迟等级都创建一个处理线程。该线程扫描对应的延迟等级 Queue。\",\"Broker 收到消息后，查看属性中是否有延迟等级信息。如果有，则将该消息的 Topic 和 QueueId 分别替换成延迟消息对应的 Topic 和延迟等级对应的 QueueId。\",\"然后将消息真正的 Topic 和 QueueId 放到消息的 properties 属性中\",\"最后将消息保存到磁盘。\",\"延迟消息保存后，会在在其 ConsumeQueue 生成索引（上面说过，每个延迟等级都有一个 Queue）\",\"延迟等级处理线程周期性扫描对应的延迟等级 ConsumeQueue 中是否有到期的消息，如果有则将消息真正的 Topic 和 QueueId 恢复，然后重新投递，如果没有则继续循环扫描\",\"消费者 \",\"当延迟消息被延迟等级处理线程重新投递之后，消费者可以消费到该消息\"]},\"355\":{\"h\":\"3. 详细流程\",\"t\":[\"延迟消息在 Producer 端只需要在消息上额外设置延迟等级即可，所以这里只讨论 Broker 端的流程。\",\"// 在Producer端设置消息为定时消息 Message msg = new Message(); msg.setTopic(\\\"TopicA\\\"); msg.setTags(\\\"Tag\\\"); msg.setBody(\\\"this is a delay message\\\".getBytes()); // 设置延迟level为5，对应延迟1分钟 msg.setDelayTimeLevel(5); producer.send(msg); \"]},\"356\":{\"h\":\"3.1 定时消息涉及到的类\",\"t\":[\"我们先来看一下定时消息涉及到的类分别实现了什么功能\",\"SCHEDULE_TOPIC_XXXX：这是一个 RocketMQ 系统 Topic，在 Broker 启动时会自动创建，专门用来保存还没有到投递时间的定时消息。系统级别的 Topic 无法被消费者消费，所以在被重新投递之前，消费者无法消费到未到期的定时消息。 \",\"它默认有 18 个 Queue，对应18个延迟等级。每个 Queue 都保存所有对应延迟等级的定时消息。\",\"这么设计的原因：延迟消息每个消息的投递时间不确定，Broker 端需要将消息根据投递时间排序后投递。只支持指定时间延迟，并为每个延迟等级设计单独的 Queue 就是为了解决消息排序的问题。这样一来，每个 Queue 中的消息都是按照消息产生的时间顺序发送的。\",\"CommitLog：RocketMQ 消息存储的实现，在定时消息功能中，它主要负责在保存消息时将原消息的 Topic 和 QueueId 替换成定时消息对应的 Topic 和 QueueId。\",\"ConsumeQueue：RocketMQ 的消费队列，用于消费者消费消息。每个队列元素是一个消息的索引，该索引主要包含消息在 CommitLog 中的偏移量。 \",\"消费者消费时查询 ConsumeQueue，一旦发现新的索引项，就可以用该项中的偏移量从 CommitLog 中找到消息并消费。\",\"ScheduleMessageService：实现定时消息延迟投递的主要逻辑。为每个延迟等级的 Queue 创建一个线程，该线程循环扫描对应的 Queue，如果发现到投递时间的消息，则把消息的 Topic 和 QueueId 恢复，然后重新投递到 CommitLog 中。\"]},\"357\":{\"h\":\"3.2 定时消息时序图\",\"t\":[\"DefaultMessageStore 调用 putMessage 方法保存消息，内部调用 CommitLog 保存消息\",\"CommitLog 保存消息时检查是否是延迟消息（是否有 DelayLevel 属性） \",\"如果是，则修改消息的\"]},\"358\":{\"h\":\"3.3 每个类关于定时消息的具体逻辑\"},\"359\":{\"h\":\"3.3.1 CommitLog\",\"t\":[\"putMessage() / AsyncPutMessage()：同步和异步的消息存储函数，Broker 收到消息后存储消息时调用。 \",\"在存盘之前，中检查消息属性中delayLevel > 0来判断是否是定时消息\",\"如果是定时消息，将原消息的 Topic 和 QueueId 替换成定时消息对应的 Topic 和 QueueId；然后将消息真正的 Topic 和 QueueId 存放到消息 properties属性中\",\"将消息存储。之后会根据存储的消息构建消息的索引文件 ConsumeQueue 和 IndexFile\",\"重投递时，会计算出消息的真正投递时间，保存到 ConsumeQueue 索引的 tagsCode 位置。\"]},\"360\":{\"h\":\"3.3.2 ScheduleMessageService\",\"t\":[\"这个类扩展了 ConfigManager，ConfigManager 提供了管理一个配置文件的功能，包含配置文件持久化的函数和重新加载配置文件到内存的函数。\",\"ConcurrentMap<Integer /* level */, Long/* offset */> offsetTable：每个延迟等级扫描的逻辑 offset，会被作为配置文件保存，在启动时从磁盘中加载。\",\"start()：Broker 不为 SLAVE 时，在 Broker 启动时运行。 \",\"从磁盘中加载offsetTable\",\"为每个延迟等级创建一个DeliverDelayedMessageTimerTask，用于周期性扫描延迟等级的消息，将到期的消息重新投递\",\"创建一个周期性定时任务，定时将offsetTable持久化\",\"Timer timer：最初 RocketMQ 使用 Java 的 Timer 来执行定时任务，但是由于 Timer 内部只有一个线程同步执行，无法同时投递多个延迟等级的消息。在 PR#3287 中替换成了 ScheduledExecutorService，用以提高定时消息重投递的性能。\"]},\"361\":{\"h\":\"3.3.3 DeliverDelayedMessageTimerTask\",\"t\":[\"ScheduleMessageService的内部类，扩展了 TimerTask，用以被 Timer 定时调用。（后改成 Runnable，用以被ScheduledExecutorService定时调用）\",\"每个该类对应一个延迟等级的 Queue，负责周期性扫描该 Queue 中是否有到期消息，如果有则将到期消息都投递到 CommitLog，如果没有则等待 0.1s 继续下次扫描。\",\"run()：执行入口，这里没有用 while 循环或者是周期性定时任务来周期执行，而是每次 run() 里面都会执行一个新的定时任务（DeliverDelayedMessageTimerTask），以此来达到周期性执行该任务的效果。\",\"executeOnTimeup()：扫描消息并且检查是否到投递时间的主要逻辑都在这个函数里面，由run()调用\"]},\"362\":{\"h\":\"4. 源码解析\"},\"363\":{\"h\":\"4.1 CommitLog\",\"t\":[\"asyncPutMessage：消息异步保存\",\"在存盘之前，中检查消息属性中delayLevel > 0来判断是否是定时消息\",\"如果是定时消息，将原消息的 Topic 和 QueueId 替换成定时消息对应的 Topic 和 QueueId；然后将消息真正的 Topic 和 QueueId 存放到消息 properties属性中\",\"public CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) { // ... String topic = msg.getTopic(); int queueId = msg.getQueueId(); final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag()); if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) { // Delay Delivery // 判断是否是定时消息 if (msg.getDelayTimeLevel() > 0) { if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) { msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()); } // 替换消息的Topic和QueueId为定时消息Topic和延迟等级对应的QueueId topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC; queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel()); // Backup real topic, queueId // 把真正的 Topic 和 QueueId 放到消息属性中 MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic()); MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId())); msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties())); msg.setTopic(topic); msg.setQueueId(queueId); } } // ...消息存储逻辑 } \",\"同步保存消息的方法即是异步方法调用get()，不再赘述\"]},\"364\":{\"h\":\"4.2 ScheduleMessageService\",\"t\":[\"start：延迟消息服务启动\",\"从磁盘中加载offsetTable\",\"为每个延迟等级创建一个DeliverDelayedMessageTimerTask，用于周期性扫描延迟等级的消息，将到期的消息重新投递\",\"创建一个周期性定时任务，定时将offsetTable持久化\",\"public void start() { if (started.compareAndSet(false, true)) { super.load(); this.timer = new Timer(\\\"ScheduleMessageTimerThread\\\", true); for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) { Integer level = entry.getKey(); Long timeDelay = entry.getValue(); Long offset = this.offsetTable.get(level); if (null == offset) { offset = 0L; } if (timeDelay != null) { this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME); } } this.timer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { try { if (started.get()) { ScheduleMessageService.this.persist(); } } catch (Throwable e) { log.error(\\\"scheduleAtFixedRate flush exception\\\", e); } } }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval()); } } \"]},\"365\":{\"h\":\"4.2.1 DeliverDelayedMessageTimerTask\",\"t\":[\"executeOnTimeup：延迟到期执行\",\"先获延迟等级取对应的 ConsumeQueue，然后根据 offsetTable 中获取的延迟等级对应的 offset（记录这个队列扫描的偏移量）开始扫描后面的消息\",\"从 ConsumeQueue 获取 tagsCode，这里面存的是真正投递时间，跟现在的时间戳比较，来判断该消息是否要投递 \",\"如果现在已经到了投递时间点，投递消息\",\"如果现在还没到投递时间点，继续创建一个定时任务，countdown 秒之后执行，然后 return\",\"等待 0.1s，执行一个新的 DeliverDelayedMessageTimerTask\",\"public void executeOnTimeup() { // 根据delayLevel查找对应的延迟消息ConsumeQueue ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel2QueueId(delayLevel)); long failScheduleOffset = offset; if (cq != null) { // 根据ConsumeQueue的有效延迟消息逻辑offset，获取所有有效的消息 SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset); if (bufferCQ != null) { try { long nextOffset = offset; int i = 0; ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit(); // 遍历ConsumeQueue中的所有有效消息 for (; i < bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { // 获取ConsumeQueue索引的三个关键属性 long offsetPy = bufferCQ.getByteBuffer().getLong(); int sizePy = bufferCQ.getByteBuffer().getInt(); long tagsCode = bufferCQ.getByteBuffer().getLong(); if (cq.isExtAddr(tagsCode)) { if (cq.getExt(tagsCode, cqExtUnit)) { tagsCode = cqExtUnit.getTagsCode(); } else { //can't find ext content.So re compute tags code. log.error(\\\"[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}\\\", tagsCode, offsetPy, sizePy); long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy); tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime); } } // ConsumeQueue里面的tagsCode实际是一个时间点（投递时间点） long now = System.currentTimeMillis(); long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode); nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); long countdown = deliverTimestamp - now; // 如果现在已经到了投递时间点，投递消息 // 如果现在还没到投递时间点，继续创建一个定时任务，countdown秒之后执行 if (countdown <= 0) { MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset( offsetPy, sizePy); if (msgExt != null) { try { MessageExtBrokerInner msgInner = this.messageTimeup(msgExt); if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) { log.error(\\\"[BUG] the real topic of schedule msg is {}, discard the msg. msg={}\\\", msgInner.getTopic(), msgInner); continue; } // 重新投递消息到CommitLog PutMessageResult putMessageResult = ScheduleMessageService.this.writeMessageStore .putMessage(msgInner); // 投递成功 if (putMessageResult != null && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) { continue; // 投递失败 } else { // XXX: warn and notify me log.error( \\\"ScheduleMessageService, a message time up, but reput it failed, topic: {} msgId {}\\\", msgExt.getTopic(), msgExt.getMsgId()); ScheduleMessageService.this.timer.schedule( new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_PERIOD); ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset); return; } } catch (Exception e) { /* * XXX: warn and notify me * msgExt里面的内容不完整 * ，如没有REAL_QID,REAL_TOPIC之类的 * ，导致数据无法正常的投递到正确的消费队列，所以暂时先直接跳过该条消息 */ log.error( \\\"ScheduleMessageService, messageTimeup execute error, drop it. msgExt=\\\" + msgExt + \\\", nextOffset=\\\" + nextOffset + \\\",offsetPy=\\\" + offsetPy + \\\",sizePy=\\\" + sizePy, e); } } } else { // 该条ConsumeQueue索引对应的消息如果未到投递时间，那么创建一个定时任务，到投递时间时执行 // 如果有还未投递的消息，创建定时任务后直接返回 ScheduleMessageService.this.timer.schedule( new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), countdown); ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset); return; } } // end of for // 如果所有消息都已经被投递，那么等待0.1s后重新执行该检查任务 nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask( this.delayLevel, nextOffset), DELAY_FOR_A_WHILE); ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset); return; } finally { bufferCQ.release(); } } // end of if (bufferCQ != null) else { /* * 索引文件被删除，定时任务中记录的offset已经被删除，会导致从该位置中取不到数据， * 这里直接纠正下一次定时任务的offset为当前定时任务队列的最小值 */ long cqMinOffset = cq.getMinOffsetInQueue(); if (offset < cqMinOffset) { failScheduleOffset = cqMinOffset; log.error(\\\"schedule CQ offset invalid. offset=\\\" + offset + \\\", cqMinOffset=\\\" + cqMinOffset + \\\", queueId=\\\" + cq.getQueueId()); } } } // end of if (cq != null) ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE); } \"]},\"366\":{\"h\":\"5. 更多思考\"},\"367\":{\"h\":\"5.1 为什么不实现任意时间的定时消息？\",\"t\":[\"实现有一定难度 \",\"受到 CommitLog 保存时间限制：现在的延迟消息机制基于 CommitLog，消息到期之后会从 CommitLog 把定时消息查出来重新投递，如果 CommitLog 被删除，那么无法重新投递。\",\"不愿意开源 \",\"为了提供差异化服务（云服务竞争力体现）\"]},\"368\":{\"h\":\"5.2 任意时间定时消息实现？\",\"t\":[\"社区有一个PR，可以实现在 CommitLog 保存时间之内任意时间的延迟消息实现。其实现了一个新的定时消息 Index 文件，用来根据投递时间查询该时间需要投递的消息，解决了定时消息排序的问题。\",\"PR#2290\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"369\":{\"h\":\"RocketMQ 延迟消息（定时消息）4.9.3 版本优化 异步投递支持\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220320-rocketmq-scheduled-message-4.9.3-improve.html\"]},\"370\":{\"h\":\"1. 概述\",\"t\":[\"在 RocketMQ 4.9.3 版本中，@Git-Yang 对延迟消息做了很大的优化，大幅度提升了延迟消息的性能。\",\"其中，PR#3287 将原先用来启动周期性任务的 Timer 改为使用 ScheduledExecutorService，将多延迟等级下同时发送延迟消息的性能提升了 3+ 倍。\",\"本文主要讲解的是另一个改动 PR#3458：支持延迟消息的异步投递。老版本中，延迟消息到期投递到 CommitLog 的动作是同步的，在 Dledger 模式下性能很差。新的改动将延迟消息的到期投递模式改为可配置，使用 BrokerConfig 的 enableScheduleAsyncDeliver 属性进行配置。改成异步投递后，在 Dledger 下的性能提升了 3 倍左右。\",\"本文着重讲解定时消息异步投递的逻辑，老版本的延迟消息流程和源码解析可以看这篇文章：RocketMQ 延迟消息（定时消息）\"]},\"371\":{\"h\":\"2. 改动解析\"},\"372\":{\"h\":\"2.1 将多延迟等级延迟消息扫描和投递的任务从单线程执行改为多线程\",\"t\":[\"这个改动将延迟消息的任务调度器从 Timer 改为 ScheduledExecutorService。\",\"在老版本中，所有 18 个延迟等级的定时消息扫描和投递任务都是由一个 Timer 启动定时任务执行的。Timer 中所有定时任务都是由一个工作线程单线程处理的，如果某个任务处理慢了，后续有新的任务进来，会导致新的任务需要等待前一个任务执行结束。\",\"改为 ScheduledExecutorService 线程池之后多线程处理任务，可以大幅度提高延迟消息处理速度，并且避免多延迟等级消息同时发送时造成的阻塞。\",\"改动后的性能变化，出处：https://github.com/apache/rocketmq/issues/3286\",\"改动前，同时向 4 个延迟等级发送延迟消息，TPS: 657 ​ \",\"改动后，同时向4个延迟等级发送延迟消息，TPS: 2453\",\"改动后，同时向4个延迟等级发送延迟消息\"]},\"373\":{\"h\":\"2.2 支持延迟消息异步投递，提升 Dledger 模式下的投递性能\",\"t\":[\"原本的定时消息投递为单线程同步投递，在 DLedger 模式下存在性能瓶颈。\",\"因为在 DLedger 模式下，主节点的角色会变为 SYNC_MASTER，同步复制。即需要足够多的从节点存储了该消息后，才会向主节点返回写入成功。\",\"本次改动将延迟消息的写入改成可配置同步或异步写入，异步写入在 DLedger 模式下性能提升了 3 倍左右。\"]},\"374\":{\"h\":\"2.2.1 异步投递的注意点\",\"t\":[\"异步投递的两个主要缺点是\",\"无法保证消息投递的顺序\",\"消息可能重复投递\",\"异步投递的注意点\",\"需要做流控，当写入 TPS 过高时，页缓存可能会繁忙；甚至节点内存会被打爆。\",\"可能存在消息可能丢失的情况，比如投递时页缓存繁忙或者其他原因导致一次投递失败。这时候的处理是对失败消息进行重新投递，重试 3 次失败后，阻塞当前延迟等级对应的线程，直到重新投递成功。\"]},\"375\":{\"h\":\"2.2.2 异步投递逻辑\",\"t\":[\"首先回顾一下同步投递的逻辑：每个延迟等级都分配一个线程，不断启动任务去扫描该等级对应的消费队列中是否有到期的消息。如果有则将到期的消息一个个同步投递，投递成功后更新该等级对应的 offset，下个任务从该 offset 开始扫描新的消息。\",\"异步投递的逻辑相比于同步投递有一些不同：\",\"异步投递采用了生产-消费模式，生产和消费的对象是异步投递的任务。生产者线程负责将到期的消息创建投递任务，消费者消费这些任务，根据任务的执行状态来更新 offset 或者重试。 这里引入了一个阻塞队列作为异步投递任务的容器，阻塞队列的大小可以配置，表示可以同时投递的消息数。当队列中投递任务满时触发流控。\",\"将对应延迟等级的消息异步投递时，需要将异步投递的任务放入处理队列。此时，可能由于流控等原因，投递任务未能放入队列，那么等待一会后再次执行扫描-投递逻辑。\",\"消息并不会直接投递成功，所以需要消费者线程从队列中消费并判断这些异步投递任务的状态。如果投递任务已完成，则更新 offset；如果投递异常，则等待一会后重新同步投递；投递成功则更新 offset，投递失败则继续重试。\"]},\"376\":{\"h\":\"3. 异步投递详解\",\"t\":[\"延迟消息的投递逻辑全部在 ScheduleMessageService 类中。\",\"下面以一个延迟等级的处理为例，用图展示一下消息投递线程和任务更新线程的工作流程。\",\"左边是定时消息到期投递线程，右边是投递过程状态更新线程。\"]},\"377\":{\"h\":\"3.1 定时消息投递线程\",\"t\":[\"延迟消息投递服务中维护了一个 offset 表offsetTable，表示每个延迟等级当前投递的消息在 ConsumeQuque 中的逻辑 offset。 它用来在关机恢复时标明扫描开始位置，所以这个表会定期持久化到磁盘中，并且从节点会定期从主节点拉去该表的最新值。\",\"延迟消息处理服务启动时会在 deliverExecutorService 线程池为每个延迟等级创建并执行一个 DeliverDelayedMessageTimerTask 任务，这个任务并不是周期性任务，而是在一个任务的末尾执行下一个任务。这个任务的 executeOnTimeup() 方法即消息投递的逻辑。上图展示的就是该方法中的逻辑。\",\"获取该等级的 ConsumeQueue，依次扫描消息是否到期\",\"如果消息到期，从 CommitLog 中查出该消息的完整信息，从属性中恢复它的真实 Topic 和 QueueId，然后投递。（根据配置同步或者异步投递，这里按异步讲解）\",\"异步消息投递后，投递的过程被放入阻塞队列 deliverPendingTable\",\"如果放入队列失败，表示此时出现流控或者阻塞，需要等待一会然后重新投递\",\"如果全部投递成功，将 offset 更新为当前投递消息的 offset + 1，表示下一次从下一个 offset 开始扫描\"]},\"378\":{\"h\":\"3.2 投递过程状态更新线程\",\"t\":[\"每个延迟等级在 handleExecutorService 线程池中启动了一个状态更新线程，每个线程执行 HandlePutResultTask 任务。同样，这个任务不是周期性任务，而是一个任务末尾启动一个新的任务。\",\"HandlePutResultTask 任务不断从阻塞队列头部获取异步投递过程对象，判断其状态\",\"如果投递成功，更新 offset 和统计数据，并从队列中移除投递任务\",\"如果投递中，无动作\",\"如果投递错误，根据是否配置自动重试来执行重试或者直接跳过\",\"重试投递时采用同步投递，投递成功则更新 offset 和统计数据，然后移除；否则继续重新投递\",\"全部任务扫描完毕后等待一会，执行新的HandlePutResultTask 任务。\"]},\"379\":{\"h\":\"4. 源码解析\"},\"380\":{\"h\":\"4.1 定时消息投递任务\",\"t\":[\"public void executeOnTimeup() { // 根据delayLevel查找对应的延迟消息ConsumeQueue ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel2QueueId(delayLevel)); if (cq == null) { this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_WHILE); return; } // 根据ConsumeQueue的有效延迟消息逻辑offset，获取所有有效的消息 SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset); if (bufferCQ == null) { long resetOffset; if ((resetOffset = cq.getMinOffsetInQueue()) > this.offset) { log.error(\\\"schedule CQ offset invalid. offset={}, cqMinOffset={}, queueId={}\\\", this.offset, resetOffset, cq.getQueueId()); } else if ((resetOffset = cq.getMaxOffsetInQueue()) < this.offset) { log.error(\\\"schedule CQ offset invalid. offset={}, cqMaxOffset={}, queueId={}\\\", this.offset, resetOffset, cq.getQueueId()); } else { resetOffset = this.offset; } this.scheduleNextTimerTask(resetOffset, DELAY_FOR_A_WHILE); return; } long nextOffset = this.offset; try { int i = 0; ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit(); // 遍历ConsumeQueue中的所有有效消息 for (; i < bufferCQ.getSize() && isStarted(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { // 获取ConsumeQueue索引的三个关键属性 long offsetPy = bufferCQ.getByteBuffer().getLong(); int sizePy = bufferCQ.getByteBuffer().getInt(); long tagsCode = bufferCQ.getByteBuffer().getLong(); if (cq.isExtAddr(tagsCode)) { if (cq.getExt(tagsCode, cqExtUnit)) { tagsCode = cqExtUnit.getTagsCode(); } else { //can't find ext content.So re compute tags code. log.error(\\\"[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}\\\", tagsCode, offsetPy, sizePy); long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy); tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime); } } // ConsumeQueue里面的tagsCode实际是一个时间点（投递时间点） long now = System.currentTimeMillis(); long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode); nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); // 如果现在已经到了投递时间点，投递消息 // 如果现在还没到投递时间点，继续创建一个定时任务，countdown秒之后执行 long countdown = deliverTimestamp - now; if (countdown > 0) { this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE); return; } MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy); if (msgExt == null) { continue; } MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt); if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) { log.error(\\\"[BUG] the real topic of schedule msg is {}, discard the msg. msg={}\\\", msgInner.getTopic(), msgInner); continue; } // 重新投递消息到CommitLog boolean deliverSuc; if (ScheduleMessageService.this.enableAsyncDeliver) { // 异步投递 deliverSuc = this.asyncDeliver(msgInner, msgExt.getMsgId(), offset, offsetPy, sizePy); } else { // 同步投递 deliverSuc = this.syncDeliver(msgInner, msgExt.getMsgId(), offset, offsetPy, sizePy); } // 投递失败（流控、阻塞、投递异常等原因），等待0.1s再次执行投递任务 if (!deliverSuc) { this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE); return; } } nextOffset = this.offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); } catch (Exception e) { log.error(\\\"ScheduleMessageService, messageTimeup execute error, offset = {}\\\", nextOffset, e); } finally { bufferCQ.release(); } // 该条ConsumeQueue索引对应的消息如果未到投递时间，那么创建一个定时任务，到投递时间时执行 // 如果有还未投递的消息，创建定时任务后直接返回 this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE); } \",\"private boolean asyncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy, int sizePy) { Queue<PutResultProcess> processesQueue = ScheduleMessageService.this.deliverPendingTable.get(this.delayLevel); //Flow Control 流控，如果阻塞队列中元素数量大于阈值则触发流控 int currentPendingNum = processesQueue.size(); int maxPendingLimit = ScheduleMessageService.this.defaultMessageStore.getMessageStoreConfig() .getScheduleAsyncDeliverMaxPendingLimit(); if (currentPendingNum > maxPendingLimit) { log.warn(\\\"Asynchronous deliver triggers flow control, \\\" + \\\"currentPendingNum={}, maxPendingLimit={}\\\", currentPendingNum, maxPendingLimit); return false; } //Blocked 阻塞，如果有一个投递任务重试 3 次以上，阻塞该延迟等级的消息投递，直到该任务投递成功 PutResultProcess firstProcess = processesQueue.peek(); if (firstProcess != null && firstProcess.need2Blocked()) { log.warn(\\\"Asynchronous deliver block. info={}\\\", firstProcess.toString()); return false; } PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, true); processesQueue.add(resultProcess); return true; } \"]},\"381\":{\"h\":\"4.2 异步投递过程状态更新任务\",\"t\":[\"public void run() { LinkedBlockingQueue<PutResultProcess> pendingQueue = ScheduleMessageService.this.deliverPendingTable.get(this.delayLevel); PutResultProcess putResultProcess; // 循环获取队列中第一个投递任务，查看其执行状态并执行对应操作 while ((putResultProcess = pendingQueue.peek()) != null) { try { switch (putResultProcess.getStatus()) { case SUCCESS: // 消息投递成功，从队列中移除该投递任务 ScheduleMessageService.this.updateOffset(this.delayLevel, putResultProcess.getNextOffset()); pendingQueue.remove(); break; case RUNNING: // 正在投递，不做操作 break; case EXCEPTION: // 投递出错 if (!isStarted()) { log.warn(\\\"HandlePutResultTask shutdown, info={}\\\", putResultProcess.toString()); return; } log.warn(\\\"putResultProcess error, info={}\\\", putResultProcess.toString()); // onException 方法执行重试 putResultProcess.onException(); break; case SKIP: // 跳过，直接从队列中移除 log.warn(\\\"putResultProcess skip, info={}\\\", putResultProcess.toString()); pendingQueue.remove(); break; } } catch (Exception e) { log.error(\\\"HandlePutResultTask exception. info={}\\\", putResultProcess.toString(), e); putResultProcess.onException(); } } // 等待0.01s，继续下一次扫描 if (isStarted()) { ScheduleMessageService.this.handleExecutorService .schedule(new HandlePutResultTask(this.delayLevel), DELAY_FOR_A_SLEEP, TimeUnit.MILLISECONDS); } } \",\"private void resend() { log.info(\\\"Resend message, info: {}\\\", this.toString()); // Gradually increase the resend interval. try { Thread.sleep(Math.min(this.resendCount++ * 100, 60 * 1000)); } catch (InterruptedException e) { e.printStackTrace(); } try { // 从 CommitLog 中查询消息完整信息 MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(this.physicOffset, this.physicSize); // 如果查询失败，检查重试次数，如果到达 6 次则打印日志并跳过该消息 if (msgExt == null) { log.warn(\\\"ScheduleMessageService resend not found message. info: {}\\\", this.toString()); this.status = need2Skip() ? ProcessStatus.SKIP : ProcessStatus.EXCEPTION; return; } MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt); // 同步投递 PutMessageResult result = ScheduleMessageService.this.writeMessageStore.putMessage(msgInner); // 根据结果更新状态 this.handleResult(result); if (result != null && result.getPutMessageStatus() == PutMessageStatus.PUT_OK) { log.info(\\\"Resend message success, info: {}\\\", this.toString()); } } catch (Exception e) { this.status = ProcessStatus.EXCEPTION; log.error(\\\"Resend message error, info: {}\\\", this.toString(), e); } } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"382\":{\"h\":\"RocketMQ 过期文件删除机制 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220328-rocketmq-expired-file-delete.html\"]},\"383\":{\"h\":\"1. 背景\",\"t\":[\"RocketMQ 的存储文件主要分三种：CommitLog、ConsumeQueue、IndexFile RocketMQ 的过期文件删除机制会定期删除已经过期的存储文件。当磁盘容量告急时，会立刻执行删除，释放磁盘空间。 本文详细分析一下三种存储文件的过期删除机制，避免一些坑。\"]},\"384\":{\"h\":\"2. 概述\",\"t\":[\"CommitLog、ConsumeQueue 和 IndexFile 的过期文件删除逻辑由一个线程统一处理。 这个线程每 10s 进行一次检查，如果符合删除条件，那么会删除这些文件。\",\"ConsumeQueue 和 IndexFile 的检查每 10s 都会进行，会删除 CommitLog 投递的偏移量之前的文件。\",\"CommitLog 的删除比较复杂，当到达每天的删除时间（4 点）或者磁盘空间告急（超过 75%）才会启动删除过期文件；磁盘空间超过 85% 时会强制删除文件，平时不会启动。\"]},\"385\":{\"h\":\"3. 详解\"},\"386\":{\"h\":\"3.1 CommitLog\",\"t\":[\"CommitLog 是一个由多个 1G 大小的内存映射文件组成的文件队列。\",\"CommitLog 每个文件有一个过期时间，由 broker.conf 文件中的 fileReservedTime 控制，默认是 72 小时，即 CommitLog 最后一次写入后 72 小时就过期。\",\"CommitLog 文件删除的条件有以下几种，符合任意一种都会执行删除逻辑\",\"时间到达 Broker 机器时间的 4 点，在 4 点 ~ 5 点这一小时中每 10s 都会进行检查和删除，删除过期的文件。\",\"这里的 4 点指的是 Broker 机器的时间，一些虚机的时间与现实时间不一致，或者时区不一致，导致删除时间并不是现实时间 4 点开始，需要注意。\",\"在磁盘容量达到 75% 时，开启文件删除。此时会删除过期的 CommitLog。一次最多删 10 个，如果删了之后磁盘容量小于 75%，那么等下次到达 75% 时删。\",\"磁盘容量达到 85% 时，开启强制删除，会把没有过期文件也删掉。同样一次最多删 10 个。 \",\"这里的强制删除并不会马上删除未过期的文件，而是先把 CommitLog 队列的第一个文件 shutdown，shutdown 之后的文件如果引用计数大于 0（被其他线程占用），则仍需要等待 intervalForcibly 时间（默认 2 分钟）后才会被删除。也就是说每 2 分钟才会强制删除 1 个文件。\",\"当磁盘容量达到 90% 时，将设置磁盘为不可写，此时会拒绝写入新的消息。\",\"手动删除。设计上预留了手动删除的接口，但实际没有命令能调用。\"]},\"387\":{\"h\":\"3.2 ConsumeQueue\",\"t\":[\"ConsumeQueue 是消费队列文件。每个 Topic 的每个 Queue 都会有一个消费队列（可能包含多个文件），用作保存消息在 CommitLog 中的位置以便消费。\",\"每隔 10s，文件删除线程就会检查所有 ConsumeQueue，删除该 ConsumeQueue 已经投递过的那些文件。\"]},\"388\":{\"h\":\"3.3 IndexFile\",\"t\":[\"IndexFile是消息索引文件，仅仅用于消息的查询。索引文件可以通过 Message Key，查询到消息在 CommitLog 中的物理偏移量，进而从 CommitLog 中查询消息。\",\"每隔 10s，文件删除线程会检查所有的 IndexFile，比较它的最大 offset 和当前已经投递的 CommitLog offset，把消息全部已经投递的 IndexFile 删除。\"]},\"389\":{\"h\":\"4. 源码解析\",\"t\":[\"清理 CommitLog 方法的类是 DefaultMessageStore#CleanCommitLogService，清理 ConsumeQueue 和 IndexFile 共用一个类 DefaultMessageStore#CleanConsumeQueueService，都是 DefaultMessageStore 的内部类。\",\"DefaultMessageStore 启动时调用 start() 方法，会启动过期文件清理的定时任务\",\"private void addScheduleTask() { // 启动定时清理过期文件线程 this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { DefaultMessageStore.this.cleanFilesPeriodically(); } // 初始延迟 60s，之后默认每 10s 执行一次 }, 1000 * 60, this.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS); // ... } \",\"其中 run() 方法调用 CommitLog 和 ConsumeQueue 的清理方法\",\"private void cleanFilesPeriodically() { this.cleanCommitLogService.run(); this.cleanConsumeQueueService.run(); } \"]},\"390\":{\"h\":\"4.1 CommitLog\",\"t\":[\"先来看一下删除 CommitLog 的条件检查逻辑，触发 CommitLog 清理的条件比较多，满足 3 个条件之一就会触发删除。\",\"且删除分\",\"非强制删除：只删除过期的文件（默认过期时间 72h，该文件最后一次写入过后 72h 过期）\",\"强制删除：会删除未过期的文件\",\"一次最多删除 10 个文件，也就是说每 10s 最多删除 10 个文件。 4 点 ~ 5 点这个小时都是删除文件的时间窗，并不是仅在 4 点删一次。\",\"private void deleteExpiredFiles() { // 本次删除的文件数量 int deleteCount = 0; // 文件保留时间，默认72h。如果超出该时间，则认为是过期文件，可以被删除 long fileReservedTime = DefaultMessageStore.this.getMessageStoreConfig().getFileReservedTime(); // 删除物理文件的时间间隔，默认100ms。在一次删除过程中，删除两个文件的间隔时间 int deletePhysicFilesInterval = DefaultMessageStore.this.getMessageStoreConfig().getDeleteCommitLogFilesInterval(); // 第一次拒绝删除之后能保留文件的最大时间，默认120s。 // 在删除文件时，如果该文件被其他线程占用，会阻止删除，同时在第一次试图删除该文件时记录当前时间戳。 // 在保留时间内，文件可以拒绝删除，超过该时间后，会将引用次数设置为负数，文件将被强制删除。 int destroyMapedFileIntervalForcibly = DefaultMessageStore.this.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly(); // 是满足删除文件的时间（4点） boolean timeup = this.isTimeToDelete(); // 磁盘空间是否不足（75%） boolean spacefull = this.isSpaceToDelete(); // 手动删除是否被触发（触发则会设manualDeleteFileSeveralTimes为20，每执行一次删除方法减少一次） boolean manualDelete = this.manualDeleteFileSeveralTimes > 0; // 满足下列条件之一将继续删除 // 1. 到了设置的每天固定删除时间（4点） // 2. 磁盘空间不充足，默认为75% // 3. executeDeleteFilesManually方法被调用，手工删除文件 if (timeup || spacefull || manualDelete) { if (manualDelete) this.manualDeleteFileSeveralTimes--; // 是否立即强制删除文件（磁盘空间大于85%为true） boolean cleanAtOnce = DefaultMessageStore.this.getMessageStoreConfig().isCleanFileForciblyEnable() && this.cleanImmediately; log.info(\\\"begin to delete before {} hours file. timeup: {} spacefull: {} manualDeleteFileSeveralTimes: {} cleanAtOnce: {}\\\", fileReservedTime, timeup, spacefull, manualDeleteFileSeveralTimes, cleanAtOnce); // 文件保留时间，默认 72，这里转换成小时 fileReservedTime *= 60 * 60 * 1000; // 删除成功的文件数量 deleteCount = DefaultMessageStore.this.commitLog.deleteExpiredFile(fileReservedTime, deletePhysicFilesInterval, destroyMapedFileIntervalForcibly, cleanAtOnce); if (deleteCount > 0) { // 危险情况：磁盘满了，但是又无法删除文件 } else if (spacefull) { log.warn(\\\"disk space will be full soon, but delete file failed.\\\"); } } } \",\"其中 commitLog.deleteExpiredFile() 方法调用了 MappedFileQueue#deleteExpiredFileByTime() 方法\",\"/** * 根据文件过期时间来删除文件 * * @param expiredTime 文件过期时间（过期后保留的时间） * @param deleteFilesInterval 删除两个文件的间隔 * @param intervalForcibly 关闭文件过后多久才能强制删除，默认为2分钟 * @param cleanImmediately 是否强制删除文件 * @return 删除文件数量 */ public int deleteExpiredFileByTime(final long expiredTime, final int deleteFilesInterval, final long intervalForcibly, final boolean cleanImmediately) { Object[] mfs = this.copyMappedFiles(0); if (null == mfs) return 0; int mfsLength = mfs.length - 1; int deleteCount = 0; List<MappedFile> files = new ArrayList<MappedFile>(); if (null != mfs) { for (int i = 0; i < mfsLength; i++) { MappedFile mappedFile = (MappedFile) mfs[i]; // 计算文件应该被删除的时间，等于文件最后修改的时间 + 文件过期时间 long liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime; // 如果文件过期，或开启强制删除，则删除文件 if (System.currentTimeMillis() >= liveMaxTimestamp || cleanImmediately) { if (mappedFile.destroy(intervalForcibly)) { files.add(mappedFile); deleteCount++; // 一次最多删除10个文件 if (files.size() >= DELETE_FILES_BATCH_MAX) { break; } // 每个文件删除间隔 if (deleteFilesInterval > 0 && (i + 1) < mfsLength) { try { Thread.sleep(deleteFilesInterval); } catch (InterruptedException e) { } } } else { break; } } else { //avoid deleting files in the middle break; } } } // 将删除的文件从mappedFiles中移除 deleteExpiredFile(files); return deleteCount; } \",\"其中，真正删除文件是调用了 MappedFile#destroy() 方法\",\"这个方法会先释放 MappedFile 上的引用，再关闭内存映射，然后关闭 fileChannel，最后才能删除该文件。\"]},\"391\":{\"h\":\"4.2 ConsumeQueue\",\"t\":[\"CleanConsumeQueueService 处理 ConsumeQueue 文件的过期删除\",\"先查出当前 CommitLog 的投递 Offset，然后遍历每个 ConsumeQueue，删除小于该 Offset 的 文件。\",\"private void deleteExpiredFiles() { int deleteLogicsFilesInterval = DefaultMessageStore.this.getMessageStoreConfig().getDeleteConsumeQueueFilesInterval(); long minOffset = DefaultMessageStore.this.commitLog.getMinOffset(); if (minOffset > this.lastPhysicalMinOffset) { this.lastPhysicalMinOffset = minOffset; // 删除逻辑队列文件 ConcurrentMap<String, ConcurrentMap<Integer, ConsumeQueue>> tables = DefaultMessageStore.this.consumeQueueTable; for (ConcurrentMap<Integer, ConsumeQueue> maps : tables.values()) { for (ConsumeQueue logic : maps.values()) { int deleteCount = logic.deleteExpiredFile(minOffset); if (deleteCount > 0 && deleteLogicsFilesInterval > 0) { try { Thread.sleep(deleteLogicsFilesInterval); } catch (InterruptedException ignored) { } } } } // 清理 IndexFile // ... } } \"]},\"392\":{\"h\":\"4.3 IndexFile\",\"t\":[\"IndexFile 的过期文件清理也由 CleanConsumeQueueService 处理，删除 CommitLog 偏移量 offset 之前的所有 IndexFile 文件\",\"private void deleteExpiredFiles() { int deleteLogicsFilesInterval = DefaultMessageStore.this.getMessageStoreConfig().getDeleteConsumeQueueFilesInterval(); long minOffset = DefaultMessageStore.this.commitLog.getMinOffset(); if (minOffset > this.lastPhysicalMinOffset) { // 清理 ConsumeQueue // ... // 清理 IndexFile DefaultMessageStore.this.indexService.deleteExpiredFile(minOffset); } } \",\"/** * 删除消息CommitLog偏移量offset之前的所有IndexFile文件 * * @param offset CommitLog偏移量 */ public void deleteExpiredFile(long offset) { Object[] files = null; try { this.readWriteLock.readLock().lock(); if (this.indexFileList.isEmpty()) { return; } // 比较第一个 IndexFile 的最大 offset， 如果小于 offset，说明不需要删除任何文件 long endPhyOffset = this.indexFileList.get(0).getEndPhyOffset(); if (endPhyOffset < offset) { files = this.indexFileList.toArray(); } } catch (Exception e) { log.error(\\\"destroy exception\\\", e); } finally { this.readWriteLock.readLock().unlock(); } // 有文件需要被删除，遍历所有文件，删除所有最大 offset 小于 CommitLog offset 的文件 if (files != null) { List<IndexFile> fileList = new ArrayList<IndexFile>(); for (int i = 0; i < (files.length - 1); i++) { IndexFile f = (IndexFile) files[i]; if (f.getEndPhyOffset() < offset) { fileList.add(f); } else { break; } } this.deleteExpiredFile(fileList); } } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"393\":{\"h\":\"RocketMQ 如何实现高性能消息读写？\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220410-rocketmq-high-performance-io.html\"]},\"394\":{\"h\":\"背景\",\"t\":[\"RocketMQ 是一个低延迟、金融级稳定的高性能消息队列。它的性能处于消息队列的第一梯队，拥有接近 Kafka 的性能表现，每秒可以处理数十万的消息。那么 RocketMQ 是如何做到这么高的性能的呢？\",\"一方面，RocketMQ 借鉴了 Kafka 的实现，运用顺序读写、页缓存等方案加速了 IO 读写。另一方面，RocketMQ 也有许多不同于 Kafka 的设计，比如使用了内存映射文件的方案进行读写。\",\"下面来详细分析一下 RocketMQ 实现高性能 IO 的几种设计和原理。\"]},\"395\":{\"h\":\"实现现高性能 IO 的手段\"},\"396\":{\"h\":\"1. 顺序读写\",\"t\":[\"磁盘的顺序读写性能要远好于随机读写。因为每次从磁盘读数据时需要先寻址，找到数据在磁盘上的物理位置。对于机械硬盘来说，就是移动磁头，会消耗时间。 顺序读写相比于随机读写省去了大部分的寻址时间，它只需要寻址一次就可以连续读写下去，所以性能比随机读写好很多。\",\"RocketMQ 利用了这个特性。它所有的消息数据都存放在一个无限增长的文件队列 CommitLog 中，CommitLog 是由一组 1G 内存映射文件队列组成的。 写入时就从一个固定位置一直写下去，一个文件写满了就开启一个新文件顺序读写下去。\"]},\"397\":{\"h\":\"1.1 顺序写\",\"t\":[\"为了防止消息存储发生混乱，在多线程写 CommitLog 时会上锁，于是写 CommitLog 就变成了一个串行化的操作，对 CommitLog 完全是顺序写。\",\"RocketMQ 的 ConsumeQueue 按 Topic 和 Queue 维度来保存消息在 CommitLog 中的偏移量，由 CommitLog 文件异步生成。每一个 ConsumeQueue 也是顺序写。\"]},\"398\":{\"h\":\"1.2 读取消息\",\"t\":[\"消费消息时，先查询对应 Topic 和 Queue 的 ConsumeQueue，通过 ConsumeQueue 中保存的消息在 CommitLog 中的位置去 CommitLog 中查询消息。\",\"对于每个 ConsumeQueue 来说，消费的过程都是顺序读。\",\"对于 CommitLog 来说，由于它里面保存的每个 Topic 的消息不是连续的，实际上消费时是一个随机读的过程。\",\"虽然是随机读，但整体还是从旧到新有序读，只要随机的那块区域还在Page Cache的热点范围内，还是可以充分利用Page Cache。\",\"Image\"]},\"399\":{\"h\":\"2. 页缓存（Page Cache）\",\"t\":[\"Page Cache 是操作系统的特性，用于加速文件 I/O。通俗地说，Page Cache 就是操作系统在内存中给磁盘上的文件建立的缓存。无论我们使用什么语言编写的程序，在调用系统的 API 读写文件的时候，并不会直接去读写磁盘上的文件，应用程序实际操作的都是 Page Cache，也就是文件在内存中缓存的副本。\",\"Page Cache 使程序对文件的顺序读写速度几乎接近于内存，因为操作系统会将一部分物理内存用作 Page Cache。\",\"应用程序在写入文件的时候，操作系统会先把数据写入到内存中的 Page Cache，然后通过异步的方式由 pdflush 内核线程将 Cache 内的数据刷盘至物理磁盘上。\",\"读取文件的时候，也是从 Page Cache 中来读取数据，这时候会出现两种可能情况。\",\"Page Cache 中有数据，那就直接读取，这样就节省了从磁盘上读取数据的时间\",\"Page Cache 中没有数据，这时候操作系统会引发一个缺页中断，应用程序的读取线程会被阻塞，操作系统把数据从文件中复制到 Page Cache 中，然后应用程序再从 Page Cache 中继续把数据读出来，这时会真正读一次磁盘上的文件，这个读的过程就会比较慢。\",\"用户的应用程序在使用完某块 Page Cache 后，操作系统并不会立刻就清除这个 Page Cache，而是尽可能地利用空闲的物理内存保存这些 Page Cache，除非系统内存不够用，操作系统才会清理掉一部分 Page Cache。清理的策略一般是 LRU 或它的变种算法，它保留 Page Cache 的逻辑是：优先保留最近一段时间最常使用的那些 Page Cache。\",\"RocketMQ 充分利用了 Page Cache，它 CommitLog 和 ConsumeQueue 在整体上看都是顺序读写。这样，读和写的区域都是被OS智能Cache过的热点区域，不会产生大量缺页（Page Fault）中断而再次读取磁盘，文件的IO几乎等同于内存的IO。\",\"在一台真实的MQ上查看网络和磁盘，即使消息端一直从MQ读取消息，也几乎看不到RMQ进程从磁盘read数据，数据直接从Page Cache经由Socket发送给了Consumer。\"]},\"400\":{\"h\":\"3. MMap\",\"t\":[\"Page Cache 属于内核空间，在用户空间的应用程序无法直接访问，因此数据还需要从内核空间拷贝到用户空间才可以被应用程序访问。\",\"MMap 指内存映射文件，将磁盘上的物理文件直接映射到用户态的内存地址中。使用 MMap 可以减少传统 IO 将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销。\",\"程序虚拟页面直接映射到页缓存上，这样就无需有内核态再往用户态的拷贝，而且也避免了重复数据的产生。并且也不必再通过调用read或write方法对文件进行读写，可以通过映射地址加偏移量的方式直接操作。\",\"Java NIO 中的 FileChannel 提供了 map() 方法可以实现 mmap。FileChannel (文件通道)和 mmap (内存映射) 读写性能比较可以参照这篇文章。\",\"RocketMQ 中，CommitLog 和 ConsumeQueue 的底层都是 MappedFile，内存映射文件。\",\"// MappedFile.java private void init(final String fileName, final int fileSize) throws IOException { // ... try { // 创建 FileChannel this.fileChannel = new RandomAccessFile(this.file, \\\"rw\\\").getChannel(); // 内存映射 this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize); TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize); TOTAL_MAPPED_FILES.incrementAndGet(); // ... } // ... } \"]},\"401\":{\"h\":\"4. 预分配文件\",\"t\":[\"每个 CommitLog 文件的大小默认是 1G，当超过大小限制的时候需要准备新的文件，而 RocketMQ 起了一个后台线程 AllocateMappedFileService，该线程应用了生产-消费模式，不断的消费 AllocateRequest。AllocateRequest 其实就是文件预分配的请求。\",\"AllocateMappedFileService 会提前准备好下一个文件的分配，包括预热该文件。防止在消息写入的过程中分配文件，产生抖动。其每次最多预分配 2 个文件。\"]},\"402\":{\"h\":\"5. 文件预热\",\"t\":[\"在预分配的 MappedFile 文件创建后，会对其进行预热。为什么需要预热该文件？ 因为通过 mmap 映射，只是建立了进程虚拟内存地址与物理内存地址之间的映射关系，并没有将 Page Cache 加载至内存。读写数据时如果没有命中写 Page Cache 则发生缺页中断，从磁盘重新加载数据至内存，这样会影响读写性能。为了防止缺页异常，阻止操作系统将相关的内存页调度到交换空间（swap space），RocketMQ 通过对文件预热。\",\"// org.apache.rocketmq.store.MappedFile::warmMappedFile public void warmMappedFile(FlushDiskType type, int pages) { ByteBuffer byteBuffer = this.mappedByteBuffer.slice(); int flush = 0; //通过写入 1G 的字节 0 来让操作系统分配物理内存空间，如果没有填充值，操作系统不会实际分配物理内存，防止在写入消息时发生缺页异常 for (int i = 0, j = 0; i < this.fileSize; i += MappedFile.OS_PAGE_SIZE, j++) { byteBuffer.put(i, (byte) 0); // force flush when flush disk type is sync if (type == FlushDiskType.SYNC_FLUSH) { if ((i / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE) >= pages) { flush = i; mappedByteBuffer.force(); } } //prevent gc if (j % 1000 == 0) { Thread.sleep(0); } } //force flush when prepare load finished if (type == FlushDiskType.SYNC_FLUSH) { mappedByteBuffer.force(); } ... // 通过jna将内存页锁定在物理内存中，防止被放入swap分区 this.mlock(); } // org.apache.rocketmq.store.MappedFile::mlock // LibC继承自com.sun.jna.Library，通过jna方法访问一些native的系统调用 public void mlock() { final long beginTime = System.currentTimeMillis(); final long address = ((DirectBuffer) (this.mappedByteBuffer)).address(); Pointer pointer = new Pointer(address); //通过系统调用 mlock 锁定该文件的 Page Cache，防止其被交换到 swap 空间 int ret = LibC.INSTANCE.mlock(pointer, new NativeLong(this.fileSize)); //通过系统调用 madvise 给操作系统建议，说明该文件在不久的将来要被访问 int ret = LibC.INSTANCE.madvise(pointer, new NativeLong(this.fileSize), LibC.MADV_WILLNEED); } \",\"MappedFile.warmMappedFile() 方法即实现文件预热的功能，每个 OS_PAGE 写入一个任意值(这里为0)，也就是说在初始化状态下，这样操作会给每个页产生恰好一次的缺页中断，这样操作系统会分配物理内存并且将物理地址与逻辑地址简历映射关系。\",\"最后配合 jna 方法，传入 mappedByteBuffer 的地址及文件长度，告诉内核即将要访问这部分文件，希望能将这些页面都锁定在物理内存中，不换进行 swapout，从而在后续实际使用这个文件时提升读写性能。\"]},\"403\":{\"h\":\"6. 内存级读写分离 TransientStorePool\",\"t\":[\"为了降低 Page Cache 的压力，RocketMQ 引入了 TransientStorePool 机制，实现了消息读写在内存级别的读写分离（写消息时写堆外内存，读消息时读 Page Cache）。TransientStorePool 作为一个配置开关，默认关闭，由用户配置开启。\",\"默认情况下 TransientStorePool 关闭，消息读写都通过 Page Cache，这样在高并发时 Page Cache 的压力会比较大，容易出现繁忙。\",\"开启 TransientStorePool 后，消息写入时将写入 ByteBuffer.allocateDirect 方式调用直接申请堆外内存中，由异步刷盘线程写入 fileChannel 中（Page Cache），最后进行进行刷盘。消息读取时，因为堆外内存中的数据未提交，被认为是不可信数据，所以只会从 Page Cache 读取。\",\"这样就实现了内存级别的读写分离，写入消息时主要面对堆外内存，读取消息时主要面对 Page Cache。\",\"优点 \",\"因为消息是先写入堆外内存，然后异步写入 Page Cache，此时就可以实现批量化写入\",\"写数据是完全写内存，速度相较于写文件对应的 Page Cache 更快\",\"减少锁的占用，提升效率\",\"缺点 \",\"在 Broker 出问题，异常退出时，已经放入 Page Cache 的数据不会丢失，存储在堆外内存的数据会丢失。所以该特性增大数据丢失的风险。\"]},\"404\":{\"h\":\"参考资料\",\"t\":[\"RocketMQ 官方文档\",\"RocketMQ高性能之底层存储设计\",\"Kafka 和 RocketMQ 底层存储之那些你不知道的事\",\"消息队列高手课——Kafka如何实现高性能IO？\",\"RocketMQ存储实现分析\",\"《RocketMQ 技术内幕：RocketMQ 架构设计与实现原理 第2版》\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"405\":{\"h\":\"RocketMQ 4.9.3 版本 性能优化 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220412-rocketmq-4.9.3-performance-improvement.html\"]},\"406\":{\"h\":\"概述\",\"t\":[\"RocketMQ 4.9.1 版本 针对 Broker 做了一系列性能优化，提升了消息发送的 TPS。前文曾就 4.9.1 版本的优化做了深入分析。\",\"在 2022 年的 2 月底，RocketMQ 4.9.3 版本 发布，其对 Broker 做了更进一步的性能优化，本次优化中也包含了生产和消费性能的提升。\",\"本文将会详解 4.9.3 版本中的性能优化点。在 4.9.3 版本中对延迟消息的优化已经在另一篇文章中详解。\",\"本次和上次的性能优化主要由快手的黄理老师提交，在 ISSUE#3585 中集中记录。先来看一下本次性能优化的所有优化项\",\"We have some performance improvements based on 4.9.2\",\"[Part A] eliminate reverse DNS lookup in MessageExt\",\"[Part B] Improve header encode/decode performance\",\"[Part B] Improve RocketMQSerializable performance with zero-copy\",\"[Part C] cache result for parseChannelRemoteAddr()\",\"[Part D] improve performance of createUniqID()\",\"[Part E] eliminate duplicated getNamespace() call when where is no namespace\",\"[Part F] eliminate regex match in topic/group name check\",\"[Part G] [Work in progress] support send batch message with different topic/queue\",\"[Part H] eliminate StringBuilder auto resize in PullRequestHoldService.buildKey() when topic length is greater than 14, this method called twice for each message.\",\"[Part I] Avoid unnecessary StringBuffer resizing and String Formatting\",\"[Part J] Use mmap buffer instead of FileChannel when writing consume queue and slave commit log, which greatly speed up consume tps.\",\"Part K move execution of notifyMessageArriving() from ReputMessageService thread to PullRequestHoldService thread.\",\"These commits almost eliminate bad performance methods in the cpu flame graph in producer side.\",\"下面来逐条剖析\"]},\"407\":{\"h\":\"性能优化\",\"t\":[\"想要优化性能，首先需要找到 RocketMQ 的 Broker 在处理消息时性能损耗的点。使用火焰图可以清晰地看出当前耗时比较多的方法，从耗时较多的方法想办法入手优化，可以更大程度上提升性能。\",\"具体的做法是开启 Broker 的火焰图采样，然后对其进行压测（同时生产和消费），然后观察其火焰图中方法的时间占用百分比，优化占用时间高且可以优化的地方。\"]},\"408\":{\"h\":\"A. 移除 MessageExt 中的反向 DNS 查找\",\"t\":[\"eliminate reverse DNS lookup in MessageExt\",\"#3586\",\"image-20220411212011338\",\"inetAddress.getHostName() 方法中会有反向 DNS 查找，可能耗时较多。于是优化成没有反向 DNS 查找的 getHostString() 方法\",\"（MessageExt#getBornHostNameString() 方法在一个异常流程中被调用，优化此方法其实对性能没有什么提升）\"]},\"409\":{\"h\":\"B.1. 优化 RocketMQ 通信协议 Header 解码性能\",\"t\":[\"[Part B] Improve header encode/decode performance\",\"#3588\",\"（该提交未合入 4.9.3 版本，将于 4.9.4 版本发布）\",\"PartB 有两个提交，其实作用不同，但是由于第二个提交依赖第一个所以只能放到一起\"]},\"410\":{\"h\":\"寻找优化点\",\"t\":[\"RocketMQ 的通信协议定义了各种指令（消息发送、拉取等等）。其中 Header 是协议头，数据是序列化后的json。json 的每个 key 字段都是固定的，不同的通讯请求字段不一样，但是其中有一个 extField 是完全自定义的，每个指令都不一样。所有指令当前共用了一个通用的解析方法 RemotingCommand#decodeCommandCustomHeader，基于反射来解析和设置消息 Header。\",\"// SendMessageRequestHeaderV2 { \\\"code\\\":310, \\\"extFields\\\":{ \\\"f\\\":\\\"0\\\", \\\"g\\\":\\\"1482158310125\\\", \\\"d\\\":\\\"4\\\", \\\"e\\\":\\\"0\\\", \\\"b\\\":\\\"TopicTest\\\", \\\"c\\\":\\\"TBW102\\\", \\\"a\\\":\\\"please_rename_unique_group_name\\\", \\\"j\\\":\\\"0\\\", \\\"k\\\":\\\"false\\\", \\\"h\\\":\\\"0\\\", \\\"i\\\":\\\"TAGS\\\\u0001TagA\\\\u0002WAIT\\\\u0001true\\\\u0002\\\" }, \\\"flag\\\":0, \\\"language\\\":\\\"JAVA\\\", \\\"opaque\\\":206, \\\"version\\\":79 } \",\"上面是一个发送消息的请求 Header。由于各种指令对应的 Header 的 extField 不同，这个解析 Header 方法内部大量使用反射来设置属性，效率很低。而且这个解码方法应用广泛，在 RocketMQ 网络通信时都会用到（如发送消息、拉取消息），所以很有优化的必要。\"]},\"411\":{\"h\":\"优化方案\",\"t\":[\"优化的方案是尽量减少反射的使用，将常用的指令解码方法抽象出来。\",\"这里引入了 FastCodesHeader 接口，只要实现这个接口，解码时就走具体的实现类而不用反射。\",\"然后为生产消息和消费消息的协议单独实现解码方法，内部可以不用反射而是直接进行字段赋值，这样虽然繁琐但是执行速度最快。\",\"// SendMessageRequestHeaderV2.java @Override public void decode(HashMap<String, String> fields) throws RemotingCommandException { String str = getAndCheckNotNull(fields, \\\"a\\\"); if (str != null) { a = str; } str = getAndCheckNotNull(fields, \\\"b\\\"); if (str != null) { b = str; } str = getAndCheckNotNull(fields, \\\"c\\\"); if (str != null) { c = str; } str = getAndCheckNotNull(fields, \\\"d\\\"); if (str != null) { d = Integer.parseInt(str); } // ...... } \"]},\"412\":{\"h\":\"B.2. 提高编解码性能\",\"t\":[\"[Part B] Improve RocketMQSerializable performance with zero-copy\",\"#3588\",\"（该提交未合入 4.9.3 版本，将于 4.9.4 版本发布）\"]},\"413\":{\"h\":\"改动背景\",\"t\":[\"RocketMQ 的协议 Header 序列化协议有俩\",\"RemotingSerializable：内部用 fastjson 进行序列化反序列化，为当前版本使用的序列化协议。\",\"RocketMQSerializable：RocketMQ 实现的序列化协议，性能对比 fastjson 没有决定性优势，当前默认没有使用。\",\"// RemotingCommand.java private static SerializeType serializeTypeConfigInThisServer = SerializeType.JSON; private byte[] headerEncode() { this.makeCustomHeaderToNet(); if (SerializeType.ROCKETMQ == serializeTypeCurrentRPC) { return RocketMQSerializable.rocketMQProtocolEncode(this); } else { return RemotingSerializable.encode(this); } } \"]},\"414\":{\"h\":\"优化方法\",\"t\":[\"这个提交优化了 RocketMQSerializable 的性能，具体的方法是消除了 RocketMQSerializable 中多余的拷贝和对象创建，使用 Netty 的 ByteBuf 替换 Java 的 ByteBuffer，性能更高。\",\"对于写字符串：Netty 的 ByteBuf 有直接 put 字符串的方法 writeCharSequence(CharSequence sequence, Charset charset)，少一次内存拷贝，效率更高。\",\"对于写 Byte：Netty 的 writeByte(int value) 传入一个 int，Java 传入一个字节 put(byte b)。当前 CPU 都是 32 位、64 位的，对 int 处理更高效。\",\"（该改动要在 Producer 和 Consumer 设置使用 RocketMQ 序列化协议才能生效）\",\"System.setProperty(RemotingCommand.SERIALIZE_TYPE_PROPERTY, SerializeType.ROCKETMQ.name()); \",\"提交说明上的 zero-copy 说的不是操作系统层面上的零拷贝，而是对于 ByteBuf 的零拷贝。\",\"在 NettyEncoder 中用 fastEncodeHeader 替换原来的 encodeHeader 方法，直接传入 ByteBuf 进行操作，不需要用 Java 的 ByteBuffer 中转一下，少了一次拷贝。\",\"public void fastEncodeHeader(ByteBuf out) { int bodySize = this.body != null ? this.body.length : 0; int beginIndex = out.writerIndex(); // skip 8 bytes out.writeLong(0); int headerSize; // 如果是 RocketMQ 序列化协议 if (SerializeType.ROCKETMQ == serializeTypeCurrentRPC) { if (customHeader != null && !(customHeader instanceof FastCodesHeader)) { this.makeCustomHeaderToNet(); } // 调用 RocketMQ 序列化协议编码 headerSize = RocketMQSerializable.rocketMQProtocolEncode(this, out); } else { this.makeCustomHeaderToNet(); byte[] header = RemotingSerializable.encode(this); headerSize = header.length; out.writeBytes(header); } out.setInt(beginIndex, 4 + headerSize + bodySize); out.setInt(beginIndex + 4, markProtocolType(headerSize, serializeTypeCurrentRPC)); } \",\"rocketMQProtocolEncode 中直接操作 ByteBuf，没有拷贝和新对象的创建。\",\"public static int rocketMQProtocolEncode(RemotingCommand cmd, ByteBuf out) { int beginIndex = out.writerIndex(); // int code(~32767) out.writeShort(cmd.getCode()); // LanguageCode language out.writeByte(cmd.getLanguage().getCode()); // int version(~32767) out.writeShort(cmd.getVersion()); // int opaque out.writeInt(cmd.getOpaque()); // int flag out.writeInt(cmd.getFlag()); // String remark String remark = cmd.getRemark(); if (remark != null && !remark.isEmpty()) { writeStr(out, false, remark); } else { out.writeInt(0); } int mapLenIndex = out.writerIndex(); out.writeInt(0); if (cmd.readCustomHeader() instanceof FastCodesHeader) { ((FastCodesHeader) cmd.readCustomHeader()).encode(out); } HashMap<String, String> map = cmd.getExtFields(); if (map != null && !map.isEmpty()) { map.forEach((k, v) -> { if (k != null && v != null) { writeStr(out, true, k); writeStr(out, false, v); } }); } out.setInt(mapLenIndex, out.writerIndex() - mapLenIndex - 4); return out.writerIndex() - beginIndex; } \"]},\"415\":{\"h\":\"C. 缓存 parseChannelRemoteAddr() 方法的结果\",\"t\":[\"cache the result of parseChannelRemoteAddr()\",\"#3589\"]},\"416\":{\"h\":\"寻找优化点\",\"t\":[\"image-20220411213226971\",\"从火焰图中可以看到，parseChannelRemoteAddr() 这个方法占用了 5% 左右的总耗时。\",\"这个方法被客户端在发送消息时调用，每次发送消息都会调用到这个方法，这也是他占用如此高 CPU 耗时百分比的原因。\",\"那么这个方法做了什么？Netty 的 Channel 相当于一个 HTTP 连接，这个方法试图从 Channel 中获取远端的地址。\",\"从火焰图上看出，该方法的 toString占用大量时间，其中主要包含了复杂的 String 拼接和处理方法。\",\"那么想要优化这个方法最直接的方式就是——缓存其结果，避免多次调用。\"]},\"417\":{\"h\":\"具体优化方法\",\"t\":[\"Netty 提供了 AttributeKey 这个类，用于将 HTTP 连接的状态保存在 Channel 上。AttributeKey 相当于一个 Key-Value 对，用来存储状态。\",\"要使用 AttributeKey，需要先初始化它的 Key，这样它就可以预先计算 Key 的 HashCode，查询该 Key 的时候效率就很高了。\",\" private static final AttributeKey<String> REMOTE_ADDR_KEY = AttributeKey.valueOf(\\\"RemoteAddr\\\"); \",\"然后优化该方法，第一次调用该方法时尝试从 Channel 上获取属性RemoteAddr，如果获取不到，则调用原来的逻辑去获取并且缓存到该 AttributeKey 中。\",\"image-20220411215152793\",\"修改过后在火焰图上已经几乎看不到该方法的用时。\"]},\"418\":{\"h\":\"D. 提升 createUniqID() 的性能\",\"t\":[\"Improve performance of createUniqID().\",\"#3590\"]},\"419\":{\"h\":\"寻找优化点\",\"t\":[\"image-20220411222721408\",\"createUniqID() 这个方法用于创建消息的全局唯一 ID，在客户端每次发送消息时会调用，为每个消息创建全局唯一 ID。\",\"RocketMQ 中包含两个消息 ID，分别为全局唯一 ID（UNIQUE_ID，消息发送时由客户端生产）和偏移量 ID（offsetMsgId，Broker 保存消息时由保存的偏移量生成），关于这两个 ID 的生成方法和使用可以看丁威老师的 RocketMQ msgId与offsetMsgId释疑。\",\"原本生成全局 ID 的方法将客户端 IP、进程 ID 等信息组合计算生成一个字符串。方法逻辑里面包含了大量字符串和 ByteBuffer 操作，所以耗时较高。\"]},\"420\":{\"h\":\"优化方法\",\"t\":[\"原先的方法实现中，每次调用都会创建 StringBuilder 、ByteBuffer、多个字符串……包含大量字符串操作，字符串操作的 CPU 耗时开销很大。\",\"优化的方法主要通过字符数组运算替代字符串操作，避免多余的字符串对象产生；使用缓存，避免每次调用都重新计算和创建字符串对象。\",\"将原来的 FIX_STRING 字符串换成 char[] 字符数组，然后可以使用 System.arraycopy 替换原来的 StringBuilder 操作，避免多余对象产生。\",\"image-20220411221546009\",\"新增了 void writeInt(char[] buffer, int pos, int value) 和 writeShort(char[] buffer, int pos, int value) 方法，用于写入字符串数组。\",\"image-20220411222306938\",\"原先的 byte2string 方法创建了 char[] 对象和 String 对象，并且 String 对象构造时需要拷贝一遍 char[]。优化之后完全没有新对象产生。\",\"image-20220411222509675\"]},\"421\":{\"h\":\"E. 当没有用到 namespace 时，避免其被多次调用\",\"t\":[\"eliminate duplicated getNamespace() call when where is no namespace\",\"#3591\"]},\"422\":{\"h\":\"寻找优化点\",\"t\":[\"image-20220411223612434\",\"客户端在发送消息时会调用 getNamespace 方法。Namespace 功能在 RocketMQ 中用的很少，它在 4.5.1 版本中被引进，具体可以看 #1120。它的作用是引入 Namespace 的概念，相同名称的 Topic 如果 Namespace 不同，那么可以表示不同的 Topic。\"]},\"423\":{\"h\":\"优化方法\",\"t\":[\"由于大部分情况下都用不到 Namespace，所以可以增加一个判断，如果不用 Namespace，就不走 Namespace 的一些验证和匹配逻辑。\",\"具体的方法很简单，在 ClientConfig 设一个布尔值，用来表示 Namespace 是否初始化（是否使用），如果不使用，则跳过 getNamespace() 方法中后面的逻辑。\",\"image-20220411224424160\"]},\"424\":{\"h\":\"F. 去除 Topic/Group 名称的正则匹配检查\",\"t\":[\"eliminate regex match in topic/group name check\",\"#3594\",\"每次发消息时，无论是客户端还是服务端都需要检查一次这个消息的 Topic/Group 是否合法。检查通过正则表达式匹配来进行，匹配规则很简单，就是检查这个名称的字符是否在一些字符范围内 String VALID_PATTERN_STR = \\\"^[%|a-zA-Z0-9_-]+$\\\"。那么就可以把这个正则表达式匹配给优化掉，使用字符来匹配，将正则匹配简化成位图查表的过程，优化性能。\",\"因为正则表达式匹配的字符编码都在 128 范围内，所以先创建一个位图，大小为 128。\",\"public static final boolean[] VALID_CHAR_BIT_MAP = new boolean[128]; \",\"然后用位图匹配的方式替换正则匹配：检查的字符串的每一个字符是否在位图中。\",\"image-20220411231805018\",\"注意这里有一句\",\"// 将位图从堆复制到栈里（本地变量），提高下面循环的变量访问速度 boolean[] bitMap = VALID_CHAR_BIT_MAP; \",\"将静态变量位图复制到局部变量中，这样做的用意是将堆中的变量复制到栈上（因为局部变量都位于栈），提高下面循环中访问该位图的速度。\",\"栈上存储的数据，很大机会会被虚拟机分配至物理机器的高速寄存器中存储。因而读写效率比从堆内存中读写高很多。\",\"栈上分配的数据，释放时只需要通过移动栈顶指针，就可以随着栈帧出栈而自动销毁。而堆内存的释放由垃圾回收器负责完成，这一过程中整理和回收内存都需要消耗更多的时间。\",\"栈操作可以被 JIT 优化，得到 CPU 指令的加速\",\"栈没有碎片，寻址间距短，可以被 CPU 预测行为\",\"栈无需释放内存和进行随机寻址\"]},\"425\":{\"h\":\"G. 支持发送 batch 消息时支持不同的 Topic/Queue\",\"t\":[\"support send batch message with different topic/queue\",\"该改动依赖 Part.B ，还未提交 PR\"]},\"426\":{\"h\":\"H. 避免无谓的 StringBuilder 扩容\",\"t\":[\"eliminate StringBuilder auto resize in PullRequestHoldService.buildKey() when topic length is greater than 14, this method called twice for each message\",\"#3612\",\"在 Broker 处理消息消费逻辑时，如果长轮询被启用，PullRequestHoldService#buildKey 每条消息会被调用 2 次。长轮询相关逻辑请移步之前的分析\",\"该方法中初始化一个 StringBuilder，默认长度为 16。StringBuilder 会将 Topic 和 QueueId 进行拼接，如果 Topic 名称过长，会造成 StringBuilder 的扩容，内部包含字符串的拷贝。在比较坏的情况下，扩容可能会发生多次。\",\"那么既然已经直到 Topic 的长度，为什么不在 StringBuilder 初始化的时候就设定长度呢？这就是这个优化的改动。\",\"image-20220411232605135\",\"为什么这里是 toipic.length() + 5？因为一般 QueueId 不会超过 4 位数（一个 Topic 下面不会超过 9999 个队列），再加上一个分隔符，得到 5。\"]},\"427\":{\"h\":\"I. 避免无谓的 StringBuffer 扩容和 String 格式化\",\"t\":[\"Avoid unnecessary StringBuffer resizing and String Formatting\",\"#3619\"]},\"428\":{\"h\":\"寻找优化点\",\"t\":[\"从火焰图上看出，在 Broker 处理消息消费消息请求时，有许多 String.format 方法开销非常大，这些方法都是数据统计用的，用来拼接数据统计字典的 Key。可以想办法进行优化。\"]},\"429\":{\"h\":\"优化方法\",\"t\":[\"首先这里面有使用 StringBuffer 拼接的逻辑，也没有预先设定长度，存在扩容可能性。这里也没有多线程的情况，所以改成 StringBuilder，并且先计算好长度，避免扩容。\",\"image-20220411234502755\"]},\"430\":{\"h\":\"J. 在写 ConsumeQueue 和 从节点的 CommitLog 时，使用 MMap 而不是 FileChannel，提升消息消费 TPS\",\"t\":[\"Use MappedByteBuffer instead of FileChannel to write consume queue and slave commitlog.\",\"#3657\",\"当消费的 Queue 数量特别多时（ 600 个），消费的 TPS 跟不上。即在 Queue 比较少时（72 个）消费速度可以跟上生产速度（20W），但是当 Queue 比较多时，消费速度只有 7W。\",\"这个修改可以提升 Queue 特别多时的消费速度。\",\"72 个 Queue，消费速度从 7W 提升到 20W\",\"600 个 Queue，消费速度从 7W 提升到 11W\"]},\"431\":{\"h\":\"寻找优化点\",\"t\":[\"对 Broker 进行采样，发现创建消费索引的 reput 线程中有较大的耗时占比。\",\"从火焰图上可以看出，FileChannel 写数据的耗时占比比较大，有没有办法来优化一下？\"]},\"432\":{\"h\":\"优化方法\",\"t\":[\"我们知道 RocketMQ 写 CommitLog 是利用 MMap 来提升写入速度。但是在写 ConsumeQueue 时原先用的是 FileChannel 来写，于是这里改成也使用 MMap 来写入。\",\"MappedFile.java\",\"image-20220411235301250\",\"image-20220411235759752\",\"具体修改如上两图所示，这样修改之后会影响两个地方：ConsumeQueue （消费索引）的写入和 Slave 节点 CommitLog 的写入\",\"image-20220411235323472\",\"image-20220411235923338\",\"优化过后构建 ConsumeQueue 的时间占比大大减少\"]},\"433\":{\"h\":\"K. 将 notifyMessageArriving() 的调用从 ReputMessageService 线程移到 PullRequestHoldService 线程\",\"t\":[\"move execution of notifyMessageArriving() from ReputMessageService thread to PullRequestHoldService thread\",\"This commit speed up consume qps greatly, in our test up to 200,000 qps.\",\"#3659\",\"（该提交未合入 4.9.3 版本，当前仍未合入）\",\"这一部分其实也是为了优化 Part.J 中所说的消费速度所做的另一个改动。经过 Part.J 的修改，600 队列下的消费 TPS 能够达到 10w（生产 20w）。这个修改将消费 TPS 提升到 20w。\"]},\"434\":{\"h\":\"寻找优化点\",\"t\":[\"依然是通过查看火焰图的方法，查看到构造消费索引的方法中包含了 notifyMessageArriving() 这样一个方法，占用较大快的 CPU 时间。\",\"这个方法具体在 轮询机制 这篇文章中有详细解释。消息消费的轮询机制指的是在 Push 消费时，如果没有新消息不会马上返回，而是挂起一段时间再重试查询。\",\"notifyMessageArriving() 的作用是在收到消息时提醒消费者，有新消息来了可以消费了，这样消费者会马上解除挂起状态开始消费消息。\",\"这里的优化点就是想办法把这个方法逻辑从构建消费索引的逻辑中抽离出去。\"]},\"435\":{\"h\":\"优化方案 1\",\"t\":[\"首先想到的方法是将 notifyMessageArriving() 用一个单独的线程异步调用。于是在 PullRequestHoldService 里面采用生产-消费模式，启动了一个新的工作线程，将 notify 任务扔到一个队列中，让工作线程去处理，主线程直接返回。\",\"工作线程每次从队列中 poll 一批任务，批量进行处理（1000 个）。经过这个改动，TPS 可以上升到 20w，但这带来了另一个问题——消息消费的延迟变高，达到 40+ms。\",\"循环等待 0.1s 直到新消息来唤醒线程\",\"新消息来了创建异步任务并唤醒线程\",\"延迟变高的原因是—— RocketMQ 中 ServiceThread 工作线程的 wakeup() 和 waitForRunning() 是弱一致的，没有加锁而是采用 CAS 的方法，造成多线程情况下可能会等待直到超时。\",\"public void wakeup() { if (hasNotified.compareAndSet(false, true)) { waitPoint.countDown(); // notify } } protected void waitForRunning(long interval) { if (hasNotified.compareAndSet(true, false)) { this.onWaitEnd(); return; } //entry to wait waitPoint.reset(); try { waitPoint.await(interval, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { log.error(\\\"Interrupted\\\", e); } finally { hasNotified.set(false); this.onWaitEnd(); } } \"]},\"436\":{\"h\":\"优化方案 2\",\"t\":[\"这个方案是实际提交的优化方案，方案比较复杂。主要的思想就是将原先的每条消息都通知一次转化为批通知，减少通知次数，减少通知开销以提升性能。\",\"同样用生产-消费模式，为了同时保证低延迟和高吞吐引入了 PullNotifyQueue。生产者和消费者仍然是操作通知任务\",\"生产者线程将消息 put 到队列中，消费者调用 drain 方法消费。\",\"drain 方法中根据消费 TPS 做了判断\",\"如果 TPS 小于阈值，则拉到一个任务马上进行处理\",\"如果 TPS 大于阈值（默认 10w），批量拉任务进行通知。一批任务只需要一次 notify（原先每个消息都会通知一次）。此时会略微增加消费时延，换来的是消费性能大幅提升。\"]},\"437\":{\"h\":\"小结\",\"t\":[\"本文介绍了 RocketMQ 4.9.3 版本中的性能优化，主要优化了消息生产的速度和大量队列情况下消息消费的速度。\",\"优化的步骤是根据 CPU 耗时进行采样形成火焰图，观察火焰图中时间占比较高的方法进行针对性优化。\",\"总结一下用到的优化方法主要有\",\"代码硬编码属性，用代码复杂度换性能\",\"对字符串和字节数组操作时减少创建和拷贝\",\"对于要多次计算的操作，缓存其结果\",\"锁内的操作尽量移动到锁外进行，提前进行计算或者用函数式接口懒加载\",\"使用更高效的容器，如 Netty ByteBuf\",\"使用容器时在初始化时指定长度，避免动态扩容\",\"主流程上的分支操作，使用异步而非同步\",\"对于磁盘 I/O，MMap 和 FileChannel 的选择，需要实际压测，大部分情况下 MMap 速度更快且更稳定；每次写入较大数据长度时（4k 左右） FileChannel 速度才更快。具体压测结果请看 java-io-benchmark\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"438\":{\"h\":\"RocketMQ 实现高性能定时消息\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220412-rocketmq-flexable-scheduled-message.html\"]},\"439\":{\"h\":\"背景\",\"t\":[\"RocketMQ 是阿里孵化的 Apache 顶级开源分布式高可用消息队列。在开源版本中支持延迟消息的功能，但是仅支持几个固定的延迟时间（1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h）。本文介绍如何在 RocketMQ 基础上实现高性能的、任意时间的定时消息。\"]},\"440\":{\"h\":\"定时消息和延迟消息是什么？\",\"t\":[\"定时消息和延迟消息是消息队列中对于消息的基本概念。\",\"定时消息：生产者将消息发送到消息队列服务端，但不期望这条消息马上被投递，而是在当前时间之后的某个时间投递，此时消费者才可以消费到这条消息。\",\"延迟消息：生产者将消息发送到消息队列服务端，但不期望这条消息马上被投递，而是延迟一定时间后投递。\",\"这两个概念虽然感觉起来不同，但是在实际使用中效果是完全相同的：消息到达消息队列服务端后不会马上投递，而是到达某个时间才投递给消费者。也就是说，实现其中一个，就可以达到另一个的效果。\",\"使用定时消息，将消息定时设置为当前时间往后的 X 时间，可以实现延迟消息的效果。 使用延迟消息，如果想要固定时间投递，可以计算投递时间到当前时间的时间差 X，然后设置这条消息延迟 X 时间。\",\"所以本文中所实现的定时消息效果也可以用作延迟消息使用。\"]},\"441\":{\"h\":\"定时消息的需求和应用场景\",\"t\":[\"定时消息在当前的互联网环境中有非常大的需求。\",\"例如电商/网约车等业务中都会出现的订单场景，客户下单后并不会马上付款，但是这个订单也不可能一直开着，因为订单会占用商品/网约车资源。这时候就需要一个机制，在比如 5 分钟后进行一次回调，回调关闭订单的方法。 这个回调的触发可以用分布式定时任务来处理，，但是更好的方法可以是使用消息队列发送一个延迟消息，因为一条消息会比一个分布式定时任务轻量得多。 开启一个消费者消费订单取消 Topic 的消息，收到消息后关闭订单，简单高效。\",\"当用户支付了订单，那么这个订单不再需要被取消，刚才发的延迟消息也不再需要被投递。当然，你可以在消费消息时判断一下订单的状态以确定是否需要关闭，但是这样做会有一次额外的数据库操作。如果可以取消定时消息，那么只要发送一条定时消息取消的命令就可以取消之前发送的定时消息投递。\",\"除此之外，定时消息还能用于更多其他场景，如定时任务触发、等待重试、事件预订等等。\"]},\"442\":{\"h\":\"各大消息队列对定时消息支持的现状\",\"t\":[\"当前各大消息队列和云厂商都对定时消息和延迟消息有一定程度上的支持，但是往往在精度、延迟时间、性能等方面无法都达到完美。\",\"消息队列 / 功能\",\"延迟时间\",\"精度\",\"性能\",\"是否支持取消\",\"Kafka\",\"×\",\"×\",\"×\",\"×\",\"RabbitMQ\",\"一个队列只支持一个延迟时间\",\"低于 RocketMQ\",\"×\",\"Pulser\",\"支持跨度很大的延迟消息\",\"1s\",\"无法支持大规模使用\",\"×\",\"RocketMQ\",\"仅支持固定等级的延迟消息，最大 2 h\",\"1s\",\"接近于 RocketMQ 普通消息性能\",\"×\",\"Amazon SQS\",\"15 分钟内\",\"？\",\"？\",\"×\",\"阿里云 RocketMQ\",\"40 天\",\"1s~2s的延迟误差\",\"接近于 RocketMQ 普通消息性能\",\"×\",\"腾讯云 CMQ\",\"1 小时内\",\"1s\",\"单队列处于飞行状态的消息数限制为2万条\",\"×\",\"华为云 RocketMQ\",\"1 年\",\"0.1s\",\"接近于 RocketMQ 普通消息性能\",\"√\",\"可以看到，4 大主流开源消息队列对定时消息的实现都有局限性，无法达到任意时间定时。\",\"各大云厂商将该功能作为一个竞争力项，支持比较灵活的延迟消息。其中华为云 RocketMQ 支持最长 1 年的延迟消息，且延迟精度能够达到 0.1s 内，同时还具备基本等同于普通消息的性能表现。此外，还支持延迟消息的取消，功能领先所有开源消息队列和云化消息队列。\",\"下面我们将揭开华为云 RocketMQ 任意时间定时消息的面纱，看一看它究竟是怎么实现的。\"]},\"443\":{\"h\":\"设计和实现\",\"t\":[\"在设计定时消息的实现方案前，我的设计目标是——构建定时消息底座，不仅能让业务使用，也能在其之上构建其他服务，如定时任务调度服务；甚至作为 RocketMQ 一些特性的基础，基于定时消息实现如消息重投等功能。作为一个底座，其必须有如下的特点：支持任意时间的定时、高精度、高性能、高可靠。\"]},\"444\":{\"h\":\"难点和取舍\",\"t\":[\"各大开源消息队列和云厂商没有实现完美的定时消息，因为在每个指标上要达到完美，都涉及到其他方面的一些取舍。\",\"延迟时间：一般来说，保存的消息数据都有一个过期时间，如 3 天过期清除，也就是说定时消息延迟时间最大也不能超过这个清除时间。支持更大的延迟时间意味着延迟消息更长的保存时间，也意味着需要单独对定时消息进行存储。\",\"精度：定时消息如何投递？势必会用到类似定时任务地机制。比如每 1s 执行一次定时任务投递这 1s 内的定时消息。定时消息的精度越高就意味着定时任务执行越频繁，计算压力越大，I/O 越频繁。\",\"性能和可靠性：这两个指标往往不能兼得。更高的可靠性意味着消息同步投递、主从同步，那么消息的 TPS 就不可避免地变低。\",\"对于这些取舍，我想说的是：我全都要！\"]},\"445\":{\"h\":\"站在巨人的肩膀上\",\"t\":[\"在实现“全都要” 的定时消息之前，我们先来看一下开源版本 RocketMQ 定时消息的实现，从中可以学习和借鉴需多东西。\",\"开源版本 RocketMQ 的定时消息也是取舍之后的产物。对于单队列支持任意时间定时消息的难点是消息的顺序问题。比如用户先发了一条延迟 1 分钟的消息，随后马上发一条延迟 3 秒的消息，显然延迟 3 秒的消息需要先被投递出去，那么服务端在收到消息后需要对消息进行排序再投递。在 RocketMQ 中，为了保证可靠性，消息是需要落盘的，且对性能和延迟的要求，决定了在服务端对消息进行排序是完全不可接受的。\",\"如何解决排序问题？开源版本的做法是：通过固定几个延迟等级的方式，绕过排序。开源 RocketMQ 设定了 18 个固定延迟时间的延迟等级：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h。这样，对于每个延迟等级，他们之中的消息顺序就是固定的：先来先投递，后来后投递，从而绕过了排序这个问题。\",\"下面是开源 RocketMQ 延迟消息的流程图\",\"RocketMQ 延迟消息的流程图\",\"RocketMQ 为延迟消息创建了一个内部 Topic，下有 18 个 Queue，对应 18 个延迟等级。收到延迟消息后，不会立即投递到它本该去的 Topic 中，而是投递到延迟消息 Topic 中的对应 Queue。然后的实现十分简单粗暴：为每个 Queue 创建一个线程，循环扫描这个 Queue 里面的消息是否到达投递时间，如果到达则投递到它本该去的 Topic 中。由于每个 Queue 里面消息的延迟等级相同，那么他们的投递就是按顺序的，避免了对延迟消息重新排序。\",\"开源的延迟消息实现经过 4.9.3 版本的优化，已经支持了异步投递，拥有了不错的性能。\",\"但是它仍存在一个致命的问题：不支持 18 个等级之外的延迟时间。日益增长的客户诉求促使我们探究任意时间定时消息的实现。站在开源 RocketMQ 实现的肩膀上，只要能将 18 个等级改为定时任意时间，就可以实现高性能高可靠的定时消息，因为高可靠和高性能都可以依赖 RocketMQ 本身的机制达到。\"]},\"446\":{\"h\":\"存储设计\",\"t\":[\"想要实现任意时间的定时消息，存储设计是最重要的。存储设计面临的两个最大的问题就是\",\"定时消息的顺序：先发送的不一定先投递。\",\"消息存储过期：如果定时消息和普通消息存在一起，那么最大延迟时间还是会受到普通消息文件过期时间的限制。\",\"这两个问题可以通过精心的设计存储方案来解决。\"]},\"447\":{\"h\":\"使用索引文件解决定时消息顺序问题\",\"t\":[\"回想 RocketMQ 的索引文件 IndexFile，它提供了按照消息 Key 查找消息的能力。具体的做法是：它用类似 HashMap 的形式存储了每个消息 Key 下的消息的位置信息，当查询某个 Key 的消息时，可以马上定位到这个 Key 下存储的消息位置信息链表，然后通过位置信息从消息存储文件 CommitLog 中将消息全部信息查出来。\",\"对于定时消息，也可以构建这样一个索引文件，用来快速查找某一时刻需要投递的消息。这样一来，投递消息时只需要借助索引文件就可以查找所有该时刻需要投递的消息，免去了排序的步骤，解决了定时消息顺序问题。\",\"参照 IndexFile，定时消息索引的存储方案设计就变得很简单。索引文件的 Key 即投递的时间段，Value 即该时间段内要投递的所有消息位置信息。\",\"特别提需要确定的几个关键值\",\"索引每个 Key 的时间跨度：1s 的精度我认为太差，一些秒杀场景可能慢 1 秒就没货了，于是决定降低一个数量级—— 0.1s\",\"容量和时间跨度：RocketMQ 中文件存储为内存映射文件，最大不超过 2G，所以每个索引文件不应超过 2G。如果按 TPS 1w 来算，1 小时的索引文件大小就会达到 700M 左右。所以时间跨度定为 1 小时，容量为 3600w。如果超过 3600w 怎么办？把这个文件做成可扩展的文件队列即可。\"]},\"448\":{\"h\":\"消息存储的方案取舍\",\"t\":[\"想要摆脱消息默认过期时间的限制，达到更长的延迟时间，那么只能把定时消息单独存储，投递前永不删除。\",\"如果要单独存储，也有几个选择：使用第三方 K-V 数据库如 RocksDB，或者自研存储。下面来分析一下这几个方案的优缺点\",\"优点\",\"缺点\",\"与普通消息共用存储\",\"无需额外开发\",\"延迟时间受限\",\"RocksDB\",\"延迟时间不限。性能高，开发量较小\",\"引入第三方组件，增加维护成本\",\"自研存储\",\"延迟时间不限。性能高，易于管理，侵入小\",\"开发量大\",\"由前文所说，我们希望实现一个定时消息的底座，不希望将其他第三方组件引入开源 RocketMQ，于是毅然选择自研存储。\",\"自研的存储的目的是为了能够长期保存定时消息，但是一直存着不删也不行。很明显，已经投递的定时消息文件可以被删除，但是如何删除已经投递的定时消息成为一个问题：因为定时消息定时的时间不固定，一个消息文件中可能包含延迟 1s 的和延迟 1 年的消息，那这个文件的删除时间需要在延迟最大的消息投递之后，这显然不是一个好办法。\",\"借鉴之前索引文件的涉及，我们把定时消息存储文件也按投递时间段拆分，例如每一天需要投递的消息保存为一个文件队列，这样就可以在投递完后的第二天把整个文件队列删除。\"]},\"449\":{\"h\":\"存储最终方案\",\"t\":[\"经过上面的分析，最终的存储方案就很明确了：需要新增两种存储，分别是定时消息数据和定时消息索引，如图所示。\"]},\"450\":{\"h\":\"定时消息投递\",\"t\":[\"定时消息的处理逻辑主要分为两个部分：存储和投递。存储已经搞定了，下面我们看看投递的设计。\",\"投递即在定时消息到期后把消息重新投递到 RocketMQ 的普通消息存储 CommitLog 中，让消费者可以消费。为了追求更高的性能，定时消息的投递默认使用异步刷盘的方式。\",\"容易想到使用一个单独的线程来处理投递逻辑，整个流程如下图所示，其中 Scheduled Replay 即定时消息投递线程。\",\"其实在最初还实现了另一种方案：将定时消息直接投递到 ConsumeQueue 中，让其保存消息在定时消息存储中的位点。这样的好处是免去了一次 CommitLog 的存储，减少磁盘占用、性能也更好。但是这种方案在主从同步时会有消息顺序不同的问题：RocketMQ 主从同步只按顺序同步 CommitLog 中的消息，然后依靠 CommitLog 生成的索引顺序就会与 CommitLog 中消息顺序一致。如果直接投递到 ConsumeQueue，从节点上想要同步 ConsumeQueue 就需要在从节点也启动一个 Scheduled Replay 投递线程，在异步投递的情况下顺序可能与主节点不一致，这样就可能造成主从切换后丢失消息。\",\"投递一条消息的逻辑很简单：拿到一个索引项后从中获取定时消息存储位置，从定时消息存储中查出消息，然后保存到 CommitLog 中。但是要实现高性能的定时消息投递，如何处理索引的加载和投递的触发就成为需要深思熟虑的问题。\"]},\"451\":{\"h\":\"预加载到时间轮\",\"t\":[\"对于定时消息的投递，网络上的很多资料都指向一个方案——时间轮。\",\"箭头按顺时针方向以固定频率移动（我们要达到的定时精度为 0.1s，所以频率就是 0.1s 一次），每一次移动称为一个 tick。每个 tick 保存了一个链表，里面是该 tick 需要触发的所有任务。\",\"时间轮常被用做定时器的实现，它最大的优势就是，任务的新增和取消都是 O(1) 时间复杂度，而且只需要一个线程就可以驱动时间轮进行工作。\",\"有了时间轮，我们就可以把每个定时消息的投递作为一个任务，将该 tick 需要投递的消息都查出来放到时间轮里面，随着时间轮跳动就不断地触发投递任务。\",\"时间轮保存在内存里面，这么多消息要投递存不下怎么办？每小时加载下一个小时要投递的消息索引就好了！\",\"0.1s 一个 tick，需要的格子数太多怎么办？用分层时间轮或者哈希时间轮就好了！\",\"这样看来，时间轮看似一个完美的解决方案。那它真的完美吗？它在高性能和大量定时消息的情况下可能引发灾难。\",\"让我们来设想这两个场景\",\"发送了 1000w 某一时刻的定时消息，要同时投递\",\"定时消息和普通消息同时大量投递，导致 Page Cache 繁忙，定时消息投递失败。\",\"第一个场景下，如果按照上述方案，会将 1000w 个索引项加载进内存，内存无法承受会导致程序崩溃。\",\"第二个场景就需要对定时消息的投递做流控和失败重试。\",\"流控和重试意味着任务暂时等待，过一 tick 再执行。也就是说，要把这一 tick 中的任务拿出来放到下一 tick，如果此时流控还没有解除，那要继续进行任务的转移，这样就会造成很多额外的出入队操作。\",\"如果继续优化时间轮的方案未尝不可，但是会有很多工作量。有没有其他可取的方案？\"]},\"452\":{\"h\":\"周期性启动定时任务\",\"t\":[\"开源 RocketMQ 的定时消息实现为我们提供了很好的参照：在 4.9.3 版本的优化后不仅支持高性能异步投递，且实现了流控和投递失败的重投。\",\"在扫描每个延迟等级的队列时具体的逻辑是：\",\"有一个表记录每个队列当前的投递位移\",\"每次启动一个定时任务，从投递位移之后开始扫描消息，如果消息到期则直接投递，如果还未到期则该任务结束。在 0.1s 后会启动一个新的定时任务进行下一次扫描\",\"借鉴这个方法，对于任意时间定时消息的投递，也可以每 0.1s 启动一个新的定时任务，投递这 0.1s 内要投递的消息。这样就可以免去将投递任务加入到时间轮这个操作。对于流控也不需要重新投递这么多任务，而是只需要从上一次投递的时间和偏移量开始一个新的投递任务即可。\",\"如何解决某一时刻投递消息量太大导致的内存问题？限制每个投递任务投递的消息量即可。投递不完则到下个任务继续投。\",\"于是投递的逻辑变成这样：\",\"用[已投递时间]和[已投递位移]两个参数来记录当前投递状态\",\"如果投递速度能跟上，那么下任务会在上个任务 0.1s 后执行\",\"如果投递速度跟不上（某一时刻要投递的定时消息太多，0.1s 内投不完），则不等待直接进行第二个任务\",\"至此，还剩下最后的问题是流控和消息的重投。\"]},\"453\":{\"h\":\"流控\",\"t\":[\"这里需要引入第二个线程：投递任务状态更新线程。对于异步投递，实际上投递方法执行后可以抽象成一个投递任务，在内存中异步投递。那么这里就还需要一个投递任务状态更新线程，扫描投递任务的状态，当投递任务结束时进行一些状态更新。消息投递线程和任务状态更新线程是生产-消费模式的一个实现。\",\"异步投递任务由一个阻塞队列来承载，这个阻塞队列的长度就代表着同时可以的进行异步投递任务的数量。我们可以人为地为阻塞队列设置一个长度上限，当达到上限时说明有过多的异步投递任务还在执行，需要流控。此时，跳出该投递任务，等待一会再开始新一个投递任务。\"]},\"454\":{\"h\":\"重投\",\"t\":[\"如果消息投递失败了且不做任何处理，这条定时消息就会丢失。在 RocketMQ 这样高可靠的消息队列中，消息的丢失是不能被接收的，所以异常消息的重投就十分重要。\",\"当前的做法是在投递任务状态更新线程扫描到状态为失败的任务时就开始重新投递该消息，如果多次投递失败会阻塞其他消息的投递，不断重试重投，直到该消息投递成功。\",\"至此，我们完成了任意时间定时消息的设计旅程。在遇见和解决一个一个坑之后实现了高性能高可靠的任意时间定时消息。\"]},\"455\":{\"h\":\"定时消息取消\",\"t\":[\"支持定时也要支持取消，这样才是一个完整的功能。定时消息由于其延迟投递的特性，是有机会在其投递之前“反悔”的。\",\"对比定时消息的实现，取消功能的难度没有那么大，但也要考虑大消息量和高 TPS 下的影响。\",\"实现定时消息取消的实现要点是保存一个需要取消的定时消息 ID 的信息集，每次投递时查询该集来判断是否要投递该消息。这个集合保存在内存中可能会造成内存泄漏，所以保存在磁盘中为妙。但是为取消消息专门创建一个文件来存储又太多余，能不能在现有的消息存储中存储？\",\"当然可以！在每条消息中有一个字段来存储消息的 Flag，可以把取消消息的状态更新到该字段中存储。\",\"最后是取消的触发方式。\",\"在消息队列中，万物皆消息，任何功能都可以用消息来触发。\",\"于是最终决定采用发送一条“取消消息”的方式来触发定时消息的取消。\"]},\"456\":{\"h\":\"小结\",\"t\":[\"本文第一节从定时消息的定义和需求出发，说明了当今企业对消息队列定时消息能力的强烈需求和当下主流消息队列对定时消息能力支持不完美现状。\",\"在第二节中，首先分析了任意时间定时消息实现的难点，然后站在开源 RocketMQ 延迟消息实现的基础上，从存储和投递两个方面详解了华为云 RocketMQ 任意时间定时消息的设计和实现。最后讲解了定时消息取消的设计和实现。\"]},\"457\":{\"h\":\"华为云 RocketMQ 定时消息已经上线\",\"t\":[\"华为云已经上线分布式消息服务 RocketMQ 版任意时间定时消息特性。\",\"任意时间定时消息特性提供领先业界的定时消息体验：\",\"任意时间的定时消息或延迟消息，最长延迟可达 1 年\",\"支持取消已经发送的定时消息\",\"消息投递毫秒级精度\",\"请点击使用。\"]},\"458\":{\"h\":\"参考资料\",\"t\":[\"如何在MQ中实现支持任意延迟的消息？\",\"任意时间延时消息原理讲解：设计与实现\",\"如果有人再问你怎么实现分布式延时消息，这篇文章丢给他\",\"延时消息常见实现方案\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"459\":{\"h\":\"RocketMQ NameServer 详解 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220502-rocketmq-nameserver.html\"]},\"460\":{\"h\":\"1. 概述\"},\"461\":{\"h\":\"1.1 NameServer 是什么\",\"t\":[\"NameServer 是组成 RocketMQ 的重要组件之一，是除了 Broker 之外另一个需要部署的服务。设想这样一个问题：RocketMQ 的 Topic 分布在不同的 Broker 上，作为消息的生产者和消费者，如何知道要从哪个 Broker 地址生产或消费消息？如果连接的 Broker 宕机了，如何在不重启的情况下感知？NameServer 就是为了解决这些问题设计的。\",\"NameServer 是一个简单的 Topic 路由注册中心，类似 Kafka、Dubbo 中的 Zookeeper，支持 Broker 的动态注册与发现。主要包含两个功能\",\"Broker 管理：NameServer 接受 Broker 集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查 Broker 是否还存活。\",\"路由信息管理：每个 NameServer 将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后 Producer 和 Conumser 通过 NameServer 就可以知道整个 Broker 集群的路由信息，从而进行消息的投递和消费。\",\"NameServer 通常以集群的方式部署，各实例间相互不进行信息通讯，只是互为备份，达到高可用的效果。RocketMQ 典型的双主双从部署方式如下图所示：\",\"Broker 定期向 NameServer 发送心跳，上报路由信息。客户端（生产者、消费者）定期请求 NameServer 获取最新的路由信息。\"]},\"462\":{\"h\":\"1.2 NameServer 与 Zookeeper\",\"t\":[\"Kafka 在老版本中使用 Zookeeper 作为路由中心，在 3.0 之后的版本也将 Zookeeper 的依赖移除。在早期版本的 RocketMQ 中据说也是使用 Zookeeper 作为路由中心，为什么主流消息队列都抛弃了 Zookeeper 选择自研路由中心呢？\",\"主要原因是 Zookeeper 运行机制复杂、对于 RocketMQ 来说依赖太重，维护和定位问题较困难；而 NameServer 的实现非常轻量级，且具备很高的可靠程度，用于路由发现的场景非常合适。此外还有以下一些原因：\",\"根据 CAP 理论，同时最多只能满足两个点，而 zookeeper 满足的是 CP，也就是说 zookeeper 并不能保证服务的可用性，zookeeper 在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。\",\"基于性能的考虑，NameServer 本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而 zookeeper 的写是不可扩展的，而zookeeper 要解决这个问题只能通过划分领域，划分多个zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。\",\"持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。\",\"消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从 NameServer 获取到Broker地址后缓存到本地，如果 NameServer 整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。\"]},\"463\":{\"h\":\"2. 概要设计\",\"t\":[\"NameServer 仅仅处理其他模块的请求，而不会主动向其他模块发起请求。正如其名字 Server，它其实本质上就是一个 NettyServer。\"]},\"464\":{\"h\":\"2.1 模块\",\"t\":[\"NameServer 的代码并不多，如下所示\",\"它主要有 3 个模块：Topic 路由管理模块（RouteInfoManager）、通信模块（DefaultRequestProcessor、ClusterTestRequestProcessor）、KV 数据存储模块（KVConfigManager)。\",\"RouteInfoManager 中存储 5 个 HashMap，这就是 NameServer 中主要存储的数据。它们仅存在于内存中，并不会持久化。其中数据内容如下：\",\"topicQueueTable：保存 Topic 的队列信息，也是真正的路由信息。队列信息中包含了其所在的 Broker 名称和读写队列数量。\",\"brokerAddrTable：保存 Broker 信息，包含其名称、集群名称、主备 Broker 地址。\",\"clusterAddrTable：保存 Cluster信息，包含每个集群中所有的 Broker 名称列表。\",\"brokerLiveTable：Broker 状态信息，包含当前所有存活的 Broker，和它们最后一次上报心跳的时间。\",\"filterServerTable：Broker 上的 FilterServer 列表，用于类模式消息过滤，该机制在 4.4 版本后被废弃。\",\"RequestProcessor 继承了 AsyncNettyRequestProcessor。作为 NameServer 的请求处理器，根据不同种类的请求做不同类型的处理。 其中 KV_CONFIG 类型的请求用于 KVConfig 模块，当前不会用到。其他请求类型由 Broker 和 Producer、Consumer 发起。\",\"KVConfigManager 内部保存了一个二级 HashMap： configTable，并且会将该对象进行持久化。\"]},\"465\":{\"h\":\"2.2 交互\",\"t\":[\"上图为 NameServer 与其他组件交互的示意图。可以看到 Producer、Consumer、Broker 均每 30s 向 NameServer 发起一次请求，NameServer 中也有定时器，定期扫描和更新内部数据。\",\"Client\",\"生产者或消费者启动时，向 Broker 发送心跳，将客户端信息、生产者和消费者信息上报给 Broker。\",\"生产者第一次发送消息时，向 NameServer 拉取该 Topic 的路由信息。\",\"消费者启动过程中会向 NameServer 请求 Topic 路由信息。\",\"每隔 30s 向 NameServer 发送请求，获取它们要生产/消费的 Topic 的路由信息。\",\"Broker\",\"每隔 30s 向 NameServer 集群的每台机器都发送心跳包，包含自身 Topic 队列的路由信息。\",\"当有 Topic 改动（创建/更新），Broker 会立即发送 Topic 增量信息到 NameServer，同时触发 NameServer 的数据版本号发生变更（+1）。\",\"NameServer\",\"将路由信息保存在内存中。它只被其他模块调用（被 Broker 上传，被客户端拉取），不会主动调用其他模块。\",\"启动一个定时任务线程，每隔 10s 扫描 brokerAddrTable 中所有的 Broker 上次发送心跳时间，如果超过 120s 没有收到心跳，则从存活 Broker 表中移除该 Broker。\"]},\"466\":{\"h\":\"3. 详细设计\"},\"467\":{\"h\":\"3.1 NameServer 启动\",\"t\":[\"上图为 NameServer 启动流程的示意图。\",\"由启动脚本调用 NamesrvStartup#main 函数触发启动流程\",\"NamesrvStartup#createNamesrvController 函数中先解析命令行参数，然后初始化 NameServer 和 Netty remote server 配置，最后创建 NamesrvController 的实例。\",\"NamesrvStartup#start 初始化 NamesrvController；调用 NamesrvController#start() 方法，启动 Netty remoting server；最后注册关闭钩子函数，在 JVM 线程关闭之前，关闭 Netty remoting server 和处理线程池，关闭定时任务线程。\",\"NamesrvController 实例是 NameServer 的核心控制器，它的初始化方法 initialize() 先加载 KVConfig manager，然后初始化 Netty remoting server。最后添加 2 个定时任务：一个每 10s 打印一次 KV 配置，一个每 10s 扫描 Broker 列表，移除掉线的 Broker。\"]},\"468\":{\"h\":\"3.2 路由信息\"},\"469\":{\"h\":\"3.2.1 NameServer 端保存的路由信息\",\"t\":[\"NameServer 中的路由信息主要指的是前面说到的 RouteInfoManager 中的 5 个 HashMap。它们只会保存在内存中，不会被持久化。下面看一下它们的具体结构。\",\"// Topic 中 Queue 的路由表，消息发送时根据路由表进行 Topic 内的负载均衡 HashMap<String/* topic */, List<QueueData>> topicQueueTable; // Broker 基础信息表，包含 brokerName、所属集群名称、主备 Broker 地址 HashMap<String/* brokerName */, BrokerData> brokerAddrTable; // Broker 集群信息，存储集群中所有 Broker 的名称 HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable; // Broker 状态信息，NameServer 每次收到心跳包时会替换该信息 HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable; // Broker 上的 FilterServer 列表，用于类模式的消息过滤。（在 4.4 之后的版本被废弃） HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable; \"]},\"470\":{\"h\":\"3.2.2 客户端保存的路由信息\",\"t\":[\"客户端中的路由信息保存在 MQClientInstance 中，也仅保存在内存，不会持久化。\",\"MQClientInstance 是用来与 NameServer、Broker 交互的客户端实例，同时缓存了路由信息。\",\"/** * Topic 路由信息 * 从NameServer更新 */ ConcurrentMap<String/* Topic */, TopicRouteData> topicRouteTable = new ConcurrentHashMap<String, TopicRouteData>(); \",\"其中包含该 Topic 的队列列表、Broker 信息列表等数据。\",\"/** * Topic 路由信息，NameServer 返回给客户端 */ public class TopicRouteData extends RemotingSerializable { // 顺序消息的配置，来自 KvConfig private String orderTopicConf; // Topic 队列元数据 private List<QueueData> queueDatas; // Topic 分布的 Broker 元数据 private List<BrokerData> brokerDatas; // Topic 上 FilterServer 的地址列表 private HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable; // ... } \"]},\"471\":{\"h\":\"3.3 路由注册\",\"t\":[\"路由注册包含两个方面：Broker 上报路由信息，和 NameServer 处理 Broker 的请求，将 Broker 上报的路由信息存起来。\"]},\"472\":{\"h\":\"3.3.1 Broker 上报心跳和路由信息\",\"t\":[\"Broker 发送心跳包的定时任务在 BrokerController#start() 方法中启动，每隔 30s 调用 registerBrokerAll 方法发送一次心跳包（REGISTER_BROKER 请求），并将自身的 Topic 队列路由信息发送给 NameServer。主节点和从节点都会发送心跳和路由信息。 Broker 会遍历 NameServer 列表，向每个 NameServer 发送心跳包。\",\"另外一个触发 Broker 上报 Topic 配置的操作是修改 Broker 的 Topic 配置（创建/更新），由 TopicConfigManager 触发上报。\",\"心跳包的请求头中包含\",\"Broker 地址\",\"BrokerId，0 表示主节点，大于 0 表示从节点\",\"Broker 名称\",\"集群名称\",\"主节点地址\",\"请求体中包含\",\"topicConfigTable：包含了每个 Topic 的所有队列信息。\",\"dataVersion：Broker 中 Topic 配置的版本号，每当配置更新一次，版本号 +1\",\"上报的心跳包请求类型是:RequestCode.REGISTER_BROKER\"]},\"473\":{\"h\":\"3.3.2 NameServer 保存上报的路由信息\",\"t\":[\"NameServer 的 DefaultRequestProcessor 接收到 REGISTER_BROKER 类型的请求后，将上报的路由信息调用 RouteInfoManager#registerBroker() 写入内存中的路由表。\",\"写入过程首先会获取写锁，然后依次写入 RouteInfoManager 中的几个路由信息表。\",\"RouteInfoManager 加写锁\",\"更新 clusterAddrTable，更新集群信息\",\"更新 brokerAddrTable，更新 Broker 信息\",\"更新 topicQueueTable，更新 Topic 队列信息\",\"更新 brokerLiveTable，更新 Broker 存活状态\",\"更新 filterServerTable，注册 Broker 的过滤器 Server 地址列表\",\"释放写锁\"]},\"474\":{\"h\":\"3.4 路由删除\",\"t\":[\"如果 Broker 宕机，则无法向 NameServer 发送心跳包。NameServer 中有一个定时任务线程，每隔 10s 检查 Broker 存活状态，如果 Broker 已经 120s 没有上报心跳，则关闭与 Broker 的连接，同时更新路由信息表，将该 Broker 相关信息移除。\",\"每次扫描，都会遍历 brokerLiveTable，取每个 Broker 的 lastUpdateTimestamp 与当前时间对比，如果相差大于 120s，则执行路由删除逻辑 RouteInfoManager#onChannelDestroy()。 另一个触发路由删除逻辑的是 Broker 正常关闭，会调用 unregisterBroker 方法，删除 NameServer 上的 Broker 信息。\",\"路由删除逻辑如下\",\"RouteInfoManager 加写锁\",\"从 brokerAddrTable 找到对应的 Broker，移除\",\"从 clusterAddrTable 找到对应 Broker，移除\",\"根据 BrokerName，从 topicQueueTable 中移除该 Broker 的队列\",\"释放写锁\"]},\"475\":{\"h\":\"3.5 路由发现（客户端拉取路由信息）\",\"t\":[\"NameServer 不会主动将路由信息推送给客户端，客户端需要自己定时从 NameServer 拉取路由信息。客户端中会启动一个定时任务，每 30s 向 NameServer 发送请求获取最新的路由信息。\"]},\"476\":{\"h\":\"3.5.1 客户端请求路由信息\",\"t\":[\"客户端中注册定时任务的方法是 MQClientInstance#startScheduledTask()，每隔 30s 调用 updateTopicRouteInfoFromNameServer() 方法，更新路由信息。\",\"客户端只会获取它生产或者消费的 Topic 路由信息，更新之后保存到 MQClientInstance.topicRouteTable 中，它也仅保存在内存中。\"]},\"477\":{\"h\":\"3.5.2 NameServer 返回路由信息\",\"t\":[\"NameServer 收到客户端获取路由信息请求后，调用 DefaultRequestProcessor#getRouteInfoByTopic() 方法，返回 Topic 路由信息。该方法逻辑如下\",\"调用 RouteInfoManager#pickupTopicRouteData() 方法，从路由表 topicQueueTable、brokerAddrTable、filterServerTable 中获取信息，填充 TopicRouteData 对象。\",\"如果该主题为顺序消息，从 KVConfig 中获取顺序消息相关的配置，填充进 TopicRouteData 对象。\",\"将 TopicRouteData 对象编码，并返回给客户端。\"]},\"478\":{\"h\":\"4. 源码剖析\"},\"479\":{\"h\":\"4.1 NameServer 启动\"},\"480\":{\"h\":\"4.1.1 NemesrvStartup\",\"t\":[\"NamesrvStartup 类是 NameServer 的启动类，它会调用 NamesrvController 类的初始化和启动方法，执行 NameServer 具体模块的初始化和启动。\",\"NamesrvStartup#createNamesrvController 函数中先解析命令行参数，然后初始化 NameServer 和 Netty remote server 配置，最后启动 NamesrvController 的初始化\",\"public static NamesrvController createNamesrvController(String[] args) throws IOException, JoranException { System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION)); //PackageConflictDetect.detectFastjson(); // 解析命令行参数 Options options = ServerUtil.buildCommandlineOptions(new Options()); commandLine = ServerUtil.parseCmdLine( \\\"mqnamesrv\\\", args, buildCommandlineOptions(options), new PosixParser()); if (null == commandLine) { System.exit(-1); return null; } // 初始化 Name server 配置参数 final NamesrvConfig namesrvConfig = new NamesrvConfig(); // 初始化 Name server 网络配置（Netty 服务端配置） final NettyServerConfig nettyServerConfig = new NettyServerConfig(); nettyServerConfig.setListenPort(9876); // 使用 -c 指定配置文件路径 if (commandLine.hasOption('c')) { String file = commandLine.getOptionValue('c'); if (file != null) { InputStream in = new BufferedInputStream(new FileInputStream(file)); properties = new Properties(); properties.load(in); MixAll.properties2Object(properties, namesrvConfig); MixAll.properties2Object(properties, nettyServerConfig); namesrvConfig.setConfigStorePath(file); System.out.printf(\\\"load config properties file OK, %s%n\\\", file); in.close(); } } // 使用 -p 打印当前加载配置属性 if (commandLine.hasOption('p')) { InternalLogger console = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME); MixAll.printObjectProperties(console, namesrvConfig); MixAll.printObjectProperties(console, nettyServerConfig); System.exit(0); } // 加载命令行中指定的属性，形如 --listenPort 9876 MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig); if (null == namesrvConfig.getRocketmqHome()) { System.out.printf(\\\"Please set the %s variable in your environment to match the location of the RocketMQ installation%n\\\", MixAll.ROCKETMQ_HOME_ENV); System.exit(-2); } // 初始化 Logback LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory(); JoranConfigurator configurator = new JoranConfigurator(); configurator.setContext(lc); lc.reset(); configurator.doConfigure(namesrvConfig.getRocketmqHome() + \\\"/conf/logback_namesrv.xml\\\"); log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME); // 打印 Name server 配置参数 MixAll.printObjectProperties(log, namesrvConfig); MixAll.printObjectProperties(log, nettyServerConfig); // 初始化 Name server 控制器 final NamesrvController controller = new NamesrvController(namesrvConfig, nettyServerConfig); // remember all configs to prevent discard controller.getConfiguration().registerConfig(properties); return controller; } \",\"NamesrvStartup#start 初始化 NamesrvController；调用 NamesrvController#start() 方法，启动 Netty remoting server；最后注册关闭钩子函数，在 JVM 线程关闭之前，关闭 Netty remoting server 和处理线程池，关闭定时任务线程。\",\"public static NamesrvController start(final NamesrvController controller) throws Exception { if (null == controller) { throw new IllegalArgumentException(\\\"NamesrvController is null\\\"); } // 初始化 NamesrvController：加载 KVConfig，初始化 Netty remoting server，添加定时任务 boolean initResult = controller.initialize(); if (!initResult) { controller.shutdown(); System.exit(-3); } // 注册 JVM 钩子函数，在 JVM 完全关闭之前，执行该方法，关闭 Name server Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable<Void>() { @Override public Void call() throws Exception { controller.shutdown(); return null; } })); // 启动 NamesrvController，主要是启动 Netty remoting server controller.start(); return controller; } \"]},\"481\":{\"h\":\"4.1.2 NamesrvController 启动\",\"t\":[\"初始化方法 initialize() 先加载 KVConfig manager，然后初始化 Netty remoting server。最后添加 2 个定时任务：一个每 10s 打印一次 KV 配置，一个每 10s 扫描 Broker 列表，移除掉线的 Broker。\",\"public boolean initialize() { // 加载 KV 配置 this.kvConfigManager.load(); // 初始化通信层 this.remotingServer = new NettyRemotingServer(this.nettyServerConfig, this.brokerHousekeepingService); // 初始化线程池 this.remotingExecutor = Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), new ThreadFactoryImpl(\\\"RemotingExecutorThread_\\\")); this.registerProcessor(); // 增加定时任务，每 10s 扫描一次 Broker，移除未激活状态的 Broker this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { NamesrvController.this.routeInfoManager.scanNotActiveBroker(); } }, 5, 10, TimeUnit.SECONDS); // 增加定时任务，每 10min 打印一次 KV 配置 this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { NamesrvController.this.kvConfigManager.printAllPeriodically(); } }, 1, 10, TimeUnit.MINUTES); if (TlsSystemConfig.tlsMode != TlsMode.DISABLED) { // Register a listener to reload SslContext try { fileWatchService = new FileWatchService( new String[] { TlsSystemConfig.tlsServerCertPath, TlsSystemConfig.tlsServerKeyPath, TlsSystemConfig.tlsServerTrustCertPath }, new FileWatchService.Listener() { boolean certChanged, keyChanged = false; @Override public void onChanged(String path) { if (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) { log.info(\\\"The trust certificate changed, reload the ssl context\\\"); reloadServerSslContext(); } if (path.equals(TlsSystemConfig.tlsServerCertPath)) { certChanged = true; } if (path.equals(TlsSystemConfig.tlsServerKeyPath)) { keyChanged = true; } if (certChanged && keyChanged) { log.info(\\\"The certificate and private key changed, reload the ssl context\\\"); certChanged = keyChanged = false; reloadServerSslContext(); } } private void reloadServerSslContext() { ((NettyRemotingServer) remotingServer).loadSslContext(); } }); } catch (Exception e) { log.warn(\\\"FileWatchService created error, can't load the certificate dynamically\\\"); } } return true; } \",\"start() 和 shutdown() 方法，分别是启动和关闭 Netty remoting server、fileWatchService。\",\"其中 fileWatchService 是用来监听文件变化执行回调函数的，这里的作用是：当文件变化时，重新加载 SslContext。\",\"public void start() throws Exception { this.remotingServer.start(); if (this.fileWatchService != null) { this.fileWatchService.start(); } } public void shutdown() { this.remotingServer.shutdown(); this.remotingExecutor.shutdown(); this.scheduledExecutorService.shutdown(); if (this.fileWatchService != null) { this.fileWatchService.shutdown(); } } \"]},\"482\":{\"h\":\"4.2 路由信息\"},\"483\":{\"h\":\"4.2.1 NameServer 路由信息\",\"t\":[\"下面以单个 Broker 上报的路由信息为例展示 NameServer 中路由信息的结构。\"]},\"484\":{\"h\":\"topicQueueTable\",\"t\":[\"HashMap<String/* topic */, Map<String /* brokerName */ , QueueData>> topicQueueTable; \",\"QueueData \",\"brokerName：所属 Broker 名\",\"readQueueNums：读队列数量\",\"writeQueueNums：写队列数量\",\"perm：读写权限\",\"topicSysFlag：Topic 同步标记\",\"当前没有注册自定义 Topic，只注册了默认 Topic\",\"{ \\\"RMQ_SYS_TRANS_HALF_TOPIC\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } }, \\\"SCHEDULE_TOPIC_XXXX\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":18, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":18 } }, \\\"SELF_TEST_TOPIC\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } }, \\\"broker-local\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":7, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } }, \\\"TBW102\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":7, \\\"readQueueNums\\\":8, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":8 } }, \\\"BenchmarkTest\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1024, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1024 } }, \\\"DefaultCluster\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":7, \\\"readQueueNums\\\":16, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":16 } }, \\\"DefaultCluster_REPLY_TOPIC\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } }, \\\"OFFSET_MOVED_EVENT\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } } } \"]},\"485\":{\"h\":\"brokerAddrTable\",\"t\":[\"HashMap<String/* brokerName */, BrokerData> brokerAddrTable; \",\"brokerAddrs \",\"key：brokerId，0 表示 MASTER，大于 0 表示 SLAVE\",\"value：broker 地址\",\"{ \\\"broker-local\\\":{ \\\"brokerAddrs\\\":{ \\\"0\\\":\\\"127.0.0.1:10911\\\" }, \\\"brokerName\\\":\\\"broker-local\\\", \\\"cluster\\\":\\\"DefaultCluster\\\" } } \"]},\"486\":{\"h\":\"clusterAddrTable\",\"t\":[\"HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable; \",\"{ \\\"DefaultCluster\\\":[ \\\"broker-local\\\" ] } \"]},\"487\":{\"h\":\"brokerLiveTable\",\"t\":[\"HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable; \",\"BrokerLiveInfo：Broker 状态信息，由 Broker 心跳上报 \",\"lastUpdateTimestamp：上次更新时间戳\",\"dataVersion：元数据被更新的次数，在 Broker 中统计，每次更新 +1\",\"channel：Netty Channel\",\"haServerAddr：HA 服务器地址\",\"{ \\\"127.0.0.1:10911\\\":{ \\\"channel\\\":{ \\\"active\\\":true, \\\"inputShutdown\\\":false, \\\"open\\\":true, \\\"outputShutdown\\\":false, \\\"registered\\\":true, \\\"shutdown\\\":false, \\\"writable\\\":true }, \\\"dataVersion\\\":{ \\\"counter\\\":1, \\\"timestamp\\\":1651564857610 }, \\\"haServerAddr\\\":\\\"10.0.0.2:10912\\\", \\\"lastUpdateTimestamp\\\":1651564899813 } } \"]},\"488\":{\"h\":\"4.2.2 客户端路由信息\",\"t\":[\"ConcurrentMap<String/* Topic */, TopicRouteData> topicRouteTable = new ConcurrentHashMap<String, TopicRouteData>(); \",\"public class TopicRouteData extends RemotingSerializable { // 顺序消息的配置，来自 KvConfig private String orderTopicConf; // Topic 队列元数据 private List<QueueData> queueDatas; // Topic 分布的 Broker 元数据 private List<BrokerData> brokerDatas; // Topic 上 FilterServer 的地址列表 private HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable; // ... } \",\"{ \\\"%RETRY%benchmark_consumer\\\":{ \\\"brokerDatas\\\":[ { \\\"brokerAddrs\\\":{ \\\"0\\\":\\\"127.0.0.1:10911\\\" }, \\\"brokerName\\\":\\\"broker-local\\\", \\\"cluster\\\":\\\"DefaultCluster\\\" } ], \\\"filterServerTable\\\":{ }, \\\"queueDatas\\\":[ { \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } ] }, \\\"TBW102\\\":{ \\\"brokerDatas\\\":[ { \\\"brokerAddrs\\\":{ \\\"0\\\":\\\"127.0.0.1:10911\\\" }, \\\"brokerName\\\":\\\"broker-local\\\", \\\"cluster\\\":\\\"DefaultCluster\\\" } ], \\\"filterServerTable\\\":{ }, \\\"queueDatas\\\":[ { \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":7, \\\"readQueueNums\\\":8, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":8 } ] } } \"]},\"489\":{\"h\":\"4.3 路由注册\"},\"490\":{\"h\":\"4.3.1 Broker 上报心跳和路由信息\",\"t\":[\"BrokerController 最终会调用 BrokerOuterAPI#registerBrokerAll 上报心跳和路由信息。\",\"// BrokerOuterAPI.java /** * 向所有 Name server 发送心跳包 * @return 心跳包发送的响应列表 */ public List<RegisterBrokerResult> registerBrokerAll( final String clusterName, final String brokerAddr, final String brokerName, final long brokerId, final String haServerAddr, final TopicConfigSerializeWrapper topicConfigWrapper, final List<String> filterServerList, final boolean oneway, final int timeoutMills, final boolean compressed) { final List<RegisterBrokerResult> registerBrokerResultList = new CopyOnWriteArrayList<>(); List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList(); if (nameServerAddressList != null && nameServerAddressList.size() > 0) { // 为所有心跳请求构造统一的请求头 final RegisterBrokerRequestHeader requestHeader = new RegisterBrokerRequestHeader(); requestHeader.setBrokerAddr(brokerAddr); requestHeader.setBrokerId(brokerId); requestHeader.setBrokerName(brokerName); requestHeader.setClusterName(clusterName); // 主节点地址，初次请求时为空，从节点向 Name server 注册后更新 requestHeader.setHaServerAddr(haServerAddr); requestHeader.setCompressed(compressed); // 构造统一的请求体 RegisterBrokerBody requestBody = new RegisterBrokerBody(); // Topic 配置，存储 Broker 启动时的一些默认 Topic requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper); // 消息过滤服务器列表 requestBody.setFilterServerList(filterServerList); final byte[] body = requestBody.encode(compressed); final int bodyCrc32 = UtilAll.crc32(body); requestHeader.setBodyCrc32(bodyCrc32); final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size()); // 遍历所有 Name server 地址，发送心跳请求 for (final String namesrvAddr : nameServerAddressList) { brokerOuterExecutor.execute(new Runnable() { @Override public void run() { try { RegisterBrokerResult result = registerBroker( namesrvAddr, oneway, timeoutMills, requestHeader, body); if (result != null) { registerBrokerResultList.add(result); } log.info(\\\"register broker[{}]to name server {} OK\\\", brokerId, namesrvAddr); } catch (Exception e) { log.warn(\\\"registerBroker Exception, {}\\\", namesrvAddr, e); } finally { countDownLatch.countDown(); } } }); } try { countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { } } return registerBrokerResultList; } \"]},\"491\":{\"h\":\"4.3.2 NameServer 保存上报的路由信息\",\"t\":[\"RouteInfoManager#registerBroker 将 Broker 上报的路由信息保存到 NameServer 上。\",\"RouteInfoManager 加写锁\",\"更新 clusterAddrTable，更新集群信息\",\"更新 brokerAddrTable，更新 Broker 信息\",\"更新 topicQueueTable，更新 Topic 队列信息\",\"更新 brokerLiveTable，更新 Broker 存活状态\",\"更新 filterServerTable，注册 Broker 的过滤器 Server 地址列表\",\"释放写锁\",\"/** * 处理 Broker 心跳信息，存到本地路由表 * 如果是 SLAVE，则返回 MASTER 的 HA 地址 */ public RegisterBrokerResult registerBroker( final String clusterName, final String brokerAddr, final String brokerName, final long brokerId, final String haServerAddr, final TopicConfigSerializeWrapper topicConfigWrapper, final List<String> filterServerList, final Channel channel) { RegisterBrokerResult result = new RegisterBrokerResult(); try { try { // 路由注册需要加写锁，防止并发修改 RouteInfoManager 中的路由表 this.lock.writeLock().lockInterruptibly(); // 更新集群信息表。判断 Broker 所属集群是否存在，不存在则创建集群，然后将 Broker 名加入集群信息表 Set<String> brokerNames = this.clusterAddrTable.get(clusterName); if (null == brokerNames) { brokerNames = new HashSet<String>(); this.clusterAddrTable.put(clusterName, brokerNames); } brokerNames.add(brokerName); boolean registerFirst = false; // 更新 Broker 地址表，更新主备信息 BrokerData brokerData = this.brokerAddrTable.get(brokerName); if (null == brokerData) { // 该 Broker 首次注册 registerFirst = true; brokerData = new BrokerData(clusterName, brokerName, new HashMap<Long, String>()); this.brokerAddrTable.put(brokerName, brokerData); } Map<Long, String> brokerAddrsMap = brokerData.getBrokerAddrs(); //Switch slave to master: first remove <1, IP:PORT> in namesrv, then add <0, IP:PORT> //The same IP:PORT must only have one record in brokerAddrTable Iterator<Entry<Long, String>> it = brokerAddrsMap.entrySet().iterator(); while (it.hasNext()) { Entry<Long, String> item = it.next(); if (null != brokerAddr && brokerAddr.equals(item.getValue()) && brokerId != item.getKey()) { it.remove(); } } String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr); registerFirst = registerFirst || (null == oldAddr); // 更新 Topic 信息表。只有主节点 Topic 配置信息发生变化或第一次注册才会更新 if (null != topicConfigWrapper && MixAll.MASTER_ID == brokerId) { if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || registerFirst) { ConcurrentMap<String, TopicConfig> tcTable = topicConfigWrapper.getTopicConfigTable(); if (tcTable != null) { for (Map.Entry<String, TopicConfig> entry : tcTable.entrySet()) { this.createAndUpdateQueueData(brokerName, entry.getValue()); } } } } // 更新 Broker 存活状态信息，包含最后更新时间 BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr, new BrokerLiveInfo( System.currentTimeMillis(), topicConfigWrapper.getDataVersion(), channel, haServerAddr)); if (null == prevBrokerLiveInfo) { log.info(\\\"new broker registered, {} HAServer: {}\\\", brokerAddr, haServerAddr); } // 更新 Broker 的 FilterServer 列表，一个 Broker 可能有多个 Filter Server if (filterServerList != null) { if (filterServerList.isEmpty()) { this.filterServerTable.remove(brokerAddr); } else { this.filterServerTable.put(brokerAddr, filterServerList); } } if (MixAll.MASTER_ID != brokerId) { String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID); if (masterAddr != null) { BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr); if (brokerLiveInfo != null) { result.setHaServerAddr(brokerLiveInfo.getHaServerAddr()); result.setMasterAddr(masterAddr); } } } } finally { this.lock.writeLock().unlock(); } } catch (Exception e) { log.error(\\\"registerBroker Exception\\\", e); } return result; } \"]},\"492\":{\"h\":\"4.4. 路由删除\",\"t\":[\"路由删除逻辑如下\",\"RouteInfoManager 加写锁\",\"从 brokerAddrTable 找到对应的 Broker，移除\",\"从 clusterAddrTable 找到对应 Broker，移除\",\"根据 BrokerName，从 topicQueueTable 中移除该 Broker 的队列\",\"释放写锁\",\"/** * Channel 被关闭，或者 Channel Idle 时间超限 * 关闭与 Broker 的连接，删除它的路由信息 */ public void onChannelDestroy(String remoteAddr, Channel channel) { String brokerAddrFound = null; if (channel != null) { try { try { this.lock.readLock().lockInterruptibly(); Iterator<Entry<String, BrokerLiveInfo>> itBrokerLiveTable = this.brokerLiveTable.entrySet().iterator(); while (itBrokerLiveTable.hasNext()) { Entry<String, BrokerLiveInfo> entry = itBrokerLiveTable.next(); if (entry.getValue().getChannel() == channel) { brokerAddrFound = entry.getKey(); break; } } } finally { this.lock.readLock().unlock(); } } catch (Exception e) { log.error(\\\"onChannelDestroy Exception\\\", e); } } if (null == brokerAddrFound) { brokerAddrFound = remoteAddr; } else { log.info(\\\"the broker's channel destroyed, {}, clean it's data structure at once\\\", brokerAddrFound); } if (brokerAddrFound != null && brokerAddrFound.length() > 0) { try { try { // 加写锁，删除该 Broker 的路由信息 this.lock.writeLock().lockInterruptibly(); this.brokerLiveTable.remove(brokerAddrFound); this.filterServerTable.remove(brokerAddrFound); // 移除 Broker 基础信息表中的该 Broker 信息 String brokerNameFound = null; boolean removeBrokerName = false; Iterator<Entry<String, BrokerData>> itBrokerAddrTable = this.brokerAddrTable.entrySet().iterator(); while (itBrokerAddrTable.hasNext() && (null == brokerNameFound)) { BrokerData brokerData = itBrokerAddrTable.next().getValue(); Iterator<Entry<Long, String>> it = brokerData.getBrokerAddrs().entrySet().iterator(); while (it.hasNext()) { Entry<Long, String> entry = it.next(); Long brokerId = entry.getKey(); String brokerAddr = entry.getValue(); if (brokerAddr.equals(brokerAddrFound)) { brokerNameFound = brokerData.getBrokerName(); it.remove(); log.info(\\\"remove brokerAddr[{}, {}] from brokerAddrTable, because channel destroyed\\\", brokerId, brokerAddr); break; } } if (brokerData.getBrokerAddrs().isEmpty()) { removeBrokerName = true; itBrokerAddrTable.remove(); log.info(\\\"remove brokerName[{}] from brokerAddrTable, because channel destroyed\\\", brokerData.getBrokerName()); } } // 从集群信息表中移除该 Broker if (brokerNameFound != null && removeBrokerName) { Iterator<Entry<String, Set<String>>> it = this.clusterAddrTable.entrySet().iterator(); while (it.hasNext()) { Entry<String, Set<String>> entry = it.next(); String clusterName = entry.getKey(); Set<String> brokerNames = entry.getValue(); boolean removed = brokerNames.remove(brokerNameFound); if (removed) { log.info(\\\"remove brokerName[{}], clusterName[{}] from clusterAddrTable, because channel destroyed\\\", brokerNameFound, clusterName); if (brokerNames.isEmpty()) { log.info(\\\"remove the clusterName[{}] from clusterAddrTable, because channel destroyed and no broker in this cluster\\\", clusterName); it.remove(); } break; } } } // 移除 TopicQueue 表中该 Broker 的队列 if (removeBrokerName) { Iterator<Entry<String, List<QueueData>>> itTopicQueueTable = this.topicQueueTable.entrySet().iterator(); while (itTopicQueueTable.hasNext()) { Entry<String, List<QueueData>> entry = itTopicQueueTable.next(); String topic = entry.getKey(); List<QueueData> queueDataList = entry.getValue(); Iterator<QueueData> itQueueData = queueDataList.iterator(); while (itQueueData.hasNext()) { QueueData queueData = itQueueData.next(); if (queueData.getBrokerName().equals(brokerNameFound)) { itQueueData.remove(); log.info(\\\"remove topic[{} {}], from topicQueueTable, because channel destroyed\\\", topic, queueData); } } if (queueDataList.isEmpty()) { itTopicQueueTable.remove(); log.info(\\\"remove topic[{}] all queue, from topicQueueTable, because channel destroyed\\\", topic); } } } } finally { this.lock.writeLock().unlock(); } } catch (Exception e) { log.error(\\\"onChannelDestroy Exception\\\", e); } } } \"]},\"493\":{\"h\":\"4.5 路由发现\",\"t\":[\"NameServer 收到客户端获取路由信息请求后，调用 DefaultRequestProcessor#getRouteInfoByTopic() 方法，返回 Topic 路由信息。该方法逻辑如下\",\"调用 RouteInfoManager#pickupTopicRouteData() 方法，从路由表 topicQueueTable、brokerAddrTable、filterServerTable 中获取信息，填充 TopicRouteData 对象。\",\"如果该主题为顺序消息，从 KVConfig 中获取顺序消息相关的配置，填充进 TopicRouteData 对象。\",\"将 TopicRouteData 对象编码，并返回给客户端。\",\"/** * 处理客户端拉取路由信息请求，返回包含 TopicRouteData 的返回体 */ public RemotingCommand getRouteInfoByTopic(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { final RemotingCommand response = RemotingCommand.createResponseCommand(null); final GetRouteInfoRequestHeader requestHeader = (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class); // 根据请求的主题获取该主题的路由信息 TopicRouteData topicRouteData = this.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic()); // 如果该主题为顺序消息，则从 NameServer KvConfig 中获取顺序消息相关配置 if (topicRouteData != null) { if (this.namesrvController.getNamesrvConfig().isOrderMessageEnable()) { String orderTopicConf = this.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG, requestHeader.getTopic()); topicRouteData.setOrderTopicConf(orderTopicConf); } byte[] content = topicRouteData.encode(); response.setBody(content); response.setCode(ResponseCode.SUCCESS); response.setRemark(null); return response; } response.setCode(ResponseCode.TOPIC_NOT_EXIST); response.setRemark(\\\"No topic route info in name server for the topic: \\\" + requestHeader.getTopic() + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)); return response; } \"]},\"494\":{\"h\":\"参考资料\",\"t\":[\"官方文档——架构设计\",\"深入剖析RocketMQ源码-NameServer\",\"Namesrv nearby route\",\"《RocketMQ 技术内幕 第2版》\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"495\":{\"h\":\"RocketMQ ACL 权限控制 详解 & 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220515-rocketmq-acl.html\"]},\"496\":{\"h\":\"1. 背景\",\"t\":[\"很多网站、软件、应用都有自己的权限控制系统。一般来说用户会有自己的角色（用户组），每个角色有相应的权限集，只有拥有某种权限才能进行某些操作。随着消息队列的使用场景越来越广泛，消息队列的权限控制需求也也越来越迫切。\",\"RocketMQ 再 4.4.0 版本引入了 ACL 模块，开始支持访问权限控制。ACL（Access Control List），即访问控制列表。RocketMQ 的 ACL 模块实现了一套简单访问控制功能，它包含用户、角色、权限、资源的概念，还支持按客户端 IP 段进行白名单控制。\",\"如此一来，我们可以通过 ACL 来实现\",\"本文介绍 RocketMQ ACL 模块的使用和实现原理，最后进行源码的解析。\"]},\"497\":{\"h\":\"2. 概述\"},\"498\":{\"h\":\"2.1 基本概念\",\"t\":[\"先来了解一下 RocketMQ ACL 中的概念。\",\"我们设想这样一个场景：某公司运维团队维护了一个 RocketMQ 集群，为了保证集群的安全性，业务团队无法直接创建和修改 Topic，只能往自己申请的 Topic 上生产和消费。新建 Topic 需要提交申请由运维团队审批。这个简单的场景涉及了几个概念：用户（运维人员、开发人员）、角色（管理员、普通用户）、资源（Topic）、权限（修改 Topic 的权限、在 Topic 发送、接收消息的权限）\",\"由此可以引出 RocketMQ ACL 中支持的 4 种概念：\",\"用户：访问控制的基本要素，包含用户名（AccessKey）、密码（SecretKey）\",\"角色：用户权限的集合，RocketMQ ACL 中定义了 2 中角色：管理员 / 非管理员\",\"资源：需要进行访问控制的对象。RocketMQ 中的 Topic 和 ConsumerGroup。\",\"权限：针对资源能进行的操作。RocketMQ 中主要指对 Topic 和 ConsumserGroup 的操作，包含如下 4 种。\",\"权限\",\"含义\",\"DENY\",\"拒绝\",\"ANY\",\"PUB 或者 SUB 权限\",\"PUB\",\"发送权限\",\"SUB\",\"订阅权限\",\"此外，还包含白名单概念\",\"白名单：客户端 IP 地址白名单，有全局和用户 2 种作用域。如果 Broker 接收到来自白名单中 IP 的请求，则直接放行，不进行后续的其他权限校验。\"]},\"499\":{\"h\":\"2.2 基本流程\",\"t\":[\"RocketMQ 的权限控制由客户端和 Broker 端共同完成。\",\"Broker：Broker 端需要先在配置文件（conf/plain_acl.yml）中设置该 Broker 的访问权限配置。接收到客户端请求后根据配置的权限匹配，进行权限判断。\",\"客户端：客户端需要标明每个请求的用户，具体的方法是通过 RPCHook 指定用户名和密码。\",\"下面是 RocketMQ 进行权限控制的流程\"]},\"500\":{\"h\":\"2.2.1 初始化\",\"t\":[\"Broker 初始化\",\"Broker 初始化前，用户手动修改和配置 ACL 配置文件\",\"加载访问验证器 PlainAccessValidator\",\"读取配置文件，加载配置到内存。\",\"注册钩子函数，用作请求处理前的权限校验\",\"注意 Broker 会观察配置文件改动并且自动重新加载\",\"客户端初始化\",\"用户需手动配置一个 AclClientRPCHook，并指定用户名和密码参数。客户端初始化时注册该 AclClientRPCHook，用于在发送请求前在请求中加入验证信息。\"]},\"501\":{\"h\":\"2.2.2 发送 / 处理请求\",\"t\":[\"客户端发送请求\",\"创建请求\",\"发送请求前执行 AclClientRPCHook 钩子函数的 before 方法 \",\"对请求、用户名和密码进行签名\",\"将用户名和签名加入请求\",\"发送请求\",\"服务端处理请求 \",\"处理请求前执行注册的钩子函数，执行权限判断\",\"判断成功则正常返回，否则返回异常信息\"]},\"502\":{\"h\":\"2.3 使用方法\"},\"503\":{\"h\":\"2.3.1 Broker 端配置\",\"t\":[\"首先需要在 broker.conf 中启动 Broker 的 ACL 功能。\",\"aclEnable=true \",\"ACL 默认的配置文件名：plain_acl.yml，需要放在{ROCKETMQ_HOME}/store/config目录下。当前支持多配置文件，可以把不同业务的权限配置分别放在多个文件中。\",\"下面为示例配置文件\",\"globalWhiteRemoteAddresses: - 10.10.103.* - 192.168.0.* accounts: - accessKey: RocketMQ secretKey: 12345678 whiteRemoteAddress: admin: false defaultTopicPerm: DENY defaultGroupPerm: SUB topicPerms: - topicA=DENY - topicB=PUB|SUB - topicC=SUB groupPerms: # the group should convert to retry topic - groupA=DENY - groupB=PUB|SUB - groupC=SUB - accessKey: rocketmq2 secretKey: 12345678 whiteRemoteAddress: 192.168.1.* # if it is admin, it could access all resources admin: true \",\"可以看到配置文件主要分两个大项：\",\"globalWhiteRemoteAddresses：用于配置全局客户端 IP 白名单\",\"accounts：用来配置用户和用户权限\",\"下面是配置的具体取值\",\"字段\",\"取值\",\"含义\",\"globalWhiteRemoteAddresses\",\";192.168..*;192.168.0.1\",\"全局IP白名单\",\"accessKey\",\"字符串\",\"Access Key\",\"secretKey\",\"字符串\",\"Secret Key\",\"whiteRemoteAddress\",\";192.168..*;192.168.0.1\",\"用户IP白名单\",\"admin\",\"true;false\",\"是否管理员账户\",\"defaultTopicPerm\",\"DENY;PUB;SUB;PUB|SUB\",\"默认的Topic权限\",\"defaultGroupPerm\",\"DENY;PUB;SUB;PUB|SUB\",\"默认的ConsumerGroup权限\",\"topicPerms\",\"topic=权限\",\"各个Topic的权限\",\"groupPerms\",\"group=权限\",\"各个ConsumerGroup的权限\"]},\"504\":{\"h\":\"2.3.2 生产者使用\",\"t\":[\"生产者和消费者使用 ACL，都需要用用户名和密码新建一个 AclClientRPCHook 对象，然后注册到客户端中。\",\"public class ACLProducerTest { private static final String ACL_ACCESS_KEY = \\\"RocketMQ\\\"; private static final String ACL_SECRET_KEY = \\\"12345678\\\"; public static void main(String[] args) throws MQClientException { // 将 AclClientHook 注册到客户端 DefaultMQProducer producer = new DefaultMQProducer(\\\"ProducerGroupName\\\", getAclRPCHook()); producer.setNamesrvAddr(\\\"127.0.0.1:9876\\\"); producer.start(); for (int i = 0; i < 128; i++) try { { Message msg = new Message(\\\"topic0607\\\", \\\"TagA\\\", \\\"OrderID188\\\", \\\"Hello world\\\".getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg); System.out.printf(\\\"%s%n\\\", sendResult); } } catch (Exception e) { e.printStackTrace(); } producer.shutdown(); } // 新建 AclClientHook，配置用户名和密码 static RPCHook getAclRPCHook() { return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY, ACL_SECRET_KEY)); } } \"]},\"505\":{\"h\":\"2.3.3 消费者使用\",\"t\":[\"public class ACLConsumerTest { private static final String ACL_ACCESS_KEY = \\\"RocketMQ\\\"; private static final String ACL_SECRET_KEY = \\\"12345678\\\"; public static void main(String[] args) throws MQClientException { // 将 AclClientHook 注册到客户端 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\\\"testGroup02\\\", getAclRPCHook(), new AllocateMessageQueueAveragely()); consumer.setNamesrvAddr(\\\"127.0.0.1:9876\\\"); consumer.subscribe(\\\"topic0607\\\", \\\"*\\\"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) { System.out.printf(\\\"%s Receive New Messages: %s %n\\\", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); consumer.start(); System.out.printf(\\\"Consumer Started.%n\\\"); } // 新建 AclClientHook，配置用户名和密码 static RPCHook getAclRPCHook() { return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY)); } } \"]},\"506\":{\"h\":\"3. 实现原理\",\"t\":[\"这部分开始讲解 RocketMQ ACL 模块的实现原理，将会按照请求处理的先后顺序分为\",\"客户端 AclClientRPCHook\",\"Broker 初始化 ACL 配置\",\"Broker 权限验证\",\"这几个部分。\"]},\"507\":{\"h\":\"3.1 客户端 AclClientRPCHook\",\"t\":[\"客户端使用 ACL 功能时必须用 AccessKey 和 SecretKey 新建一个 AclClientRPCHook，这个 RPCHook 用于在发送请求前将该账号的用户名和密码信息放入请求中，以便 Broker 获取账号信息进行权限判断。\"]},\"508\":{\"h\":\"3.1.1 注册 AclClientRPCHook\",\"t\":[\"我们首先看一下客户端如何注册 AclClientRPCHook，让他能够在发送请求时起作用。\",\"在 NettyRemotingClient 和 NettyRemotingServer 的抽象基类 NettyRemotingAbstract 中有一个 rpcHooks 列表，用于存放所有的 RPCHook。它会在处理请求的前后分别执行 RPCHook 的 before 和 after 方法。\",\"注册 AclClientRPCHook 的逻辑会把这个 RPCHook 加入到 rpcHooks 列表里面。\"]},\"509\":{\"h\":\"3.1.2 AclClientRPCHook 的逻辑\",\"t\":[\"这个类仅定义了 before 逻辑。它会将请求的参数（header）和用户名密码参数打包，排序，然后进行签名。\",\"相对应地，服务端收到请求后也会对请求参数进行排序，以同样的方法签名，通过比较签名的方式进行验证，防止请求数据被篡改。\",\"随后会将签名和用户名加入到请求扩展属性中，然后发送请求。\"]},\"510\":{\"h\":\"3.2 Broker 初始化 ACL 配置\",\"t\":[\"介绍 Broker 这边的 ACL 逻辑前，看一下 Broker ACL 相关的类。\",\"其中红色线为初始化的方法调用链。\",\"Broker 启动时会由 BrokerController 初始化 ACL 模块，加载所有的验证器。具体的方法是用 SPI 机制，读取 METAINF/service/org.apache.rocketmq.acl.AccessValidator 文件，加载 AccessValidator 的所有实现类。当前只有一个默认实现 PlainAccessValidator，用户也可以自己实现其他验证器。\",\"PlainAccessValidator 初始化时会创建 PlainPermissionManager 对象，用它来解析权限配置文件（plain_acl.yml）。\",\"PlainPermissionManager 会在初始化时加载目录中的所有配置文件，将权限配置信息加载到内存。同时，它会开启一个 FileWatchService 线程，用于每 0.5s 检测配置文件的变更，及时将变更加载到内存。\",\"最后 Broker 将注册一个 RPCHook，在请求处理前后增加方法。在请求之前注册 PlainAccessValidator 的 validate 方法。这个 validate 方法中就包含了权限验证的逻辑。\"]},\"511\":{\"h\":\"3.3 Broker 权限验证\",\"t\":[\"权限验证的逻辑在 PlainAccessValidator 的 validate 方法中，它会调用 PlainPermissionManager 的 validate 方法，传入的参数是客户端发送请求时指定的用户信息。下面是权限验证的步骤\",\"判断客户端 IP 是否在全局白名单中，如果匹配则直接放行\",\"判断该用户是否配置在权限控制列表中，如果不在则返回错误\",\"获取请求用户的访问控制权限，判断客户端 IP 是否在用户维度的白名单中，如果匹配则放行\",\"对请求参数验计算签名，验证与客户端计算的签名是否一致，不一致则返回异常\",\"验证资源访问权限，判断该用户是否有客户端请求的资源的相应操作权限\"]},\"512\":{\"h\":\"4. 源码解析\"},\"513\":{\"h\":\"4.1 客户端 AclClientRPCHook\"},\"514\":{\"h\":\"4.1.1 注册 AclClientRPCHook\",\"t\":[\"在 NettyRemotingClient 和 NettyRemotingServer 的抽象基类 NettyRemotingAbstract 中有一个 rpcHooks 列表，用于存放所有的 RPCHook。它会在处理请求的前后分别执行 RPCHook 的 before 和 after 方法。\",\"注册 AclClientRPCHook 的逻辑会把这个 RPCHook 加入到 rpcHooks 列表里面。\",\"// NettyRemotingAbstract.java protected List<RPCHook> rpcHooks = new ArrayList<RPCHook>(); \",\"// NettyRemotingClient.java @Override public void registerRPCHook(RPCHook rpcHook) { if (rpcHook != null && !rpcHooks.contains(rpcHook)) { rpcHooks.add(rpcHook); } } \",\"Producer 端调用底层 API 发送命令的前后，调用 RPCHook 上面的 doBeforeRequest 和 doAfterRequest 方法，便于在发送命令的前后拦截\",\"// NettyRemotingClient.java @Override public RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis) { doBeforeRpcHooks(addr, request); // ... doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(channel), request, response); } protected void doBeforeRpcHooks(String addr, RemotingCommand request) { if (rpcHooks.size() > 0) { for (RPCHook rpcHook: rpcHooks) { rpcHook.doBeforeRequest(addr, request); } } } protected void doAfterRpcHooks(String addr, RemotingCommand request, RemotingCommand response) { if (rpcHooks.size() > 0) { for (RPCHook rpcHook: rpcHooks) { rpcHook.doAfterResponse(addr, request, response); } } } \"]},\"515\":{\"h\":\"4.1.2 AclClientRPCHook 的逻辑\",\"t\":[\"仅定义了 before 逻辑。它会将请求的参数（header）和用户名密码参数打包，排序，然后进行签名。\",\"首先 parseRequestContent 方法使用 SortedMap 将客户端的 AccessKey、SecurityToken 以及请求中 header 的属性进行排序\",\"然后 combineRequestContent 方法会将上一步返回的 map 以及请求合并成一个 byte 数组\",\"calSignature方法会根据客户端的 AccessKey 以及上一步返回的 byte 数组生成一个签名\",\"将生成的签名添加到请求的扩展属性中\",\"将 AccessKey 添加到请求的扩展属性中\",\"@Override public void doBeforeRequest(String remoteAddr, RemotingCommand request) { byte[] total = AclUtils.combineRequestContent(request, parseRequestContent(request, sessionCredentials.getAccessKey(), sessionCredentials.getSecurityToken())); String signature = AclUtils.calSignature(total, sessionCredentials.getSecretKey()); request.addExtField(SIGNATURE, signature); request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey()); // The SecurityToken value is unneccessary,user can choose this one. if (sessionCredentials.getSecurityToken() != null) { request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken()); } } protected SortedMap<String, String> parseRequestContent(RemotingCommand request, String ak, String securityToken) { CommandCustomHeader header = request.readCustomHeader(); // Sort property SortedMap<String, String> map = new TreeMap<String, String>(); map.put(ACCESS_KEY, ak); if (securityToken != null) { map.put(SECURITY_TOKEN, securityToken); } try { // Add header properties if (null != header) { Field[] fields = fieldCache.get(header.getClass()); if (null == fields) { fields = header.getClass().getDeclaredFields(); for (Field field : fields) { field.setAccessible(true); } Field[] tmp = fieldCache.putIfAbsent(header.getClass(), fields); if (null != tmp) { fields = tmp; } } for (Field field : fields) { Object value = field.get(header); if (null != value && !field.isSynthetic()) { map.put(field.getName(), value.toString()); } } } return map; } catch (Exception e) { throw new RuntimeException(\\\"incompatible exception.\\\", e); } } \"]},\"516\":{\"h\":\"4.2 Broker 初始化 ACL 配置\",\"t\":[\"Broker 启动时会由 BrokerController 初始化 ACL 模块，加载所有的验证器。具体的方法是用 SPI 机制，读取 METAINF/service/org.apache.rocketmq.acl.AccessValidator 文件，加载 AccessValidator 的所有实现类。当前只有一个默认实现 PlainAccessValidator，用户也可以自己实现其他验证器。\",\"/** * ACL（访问控制列表）初始化 */ private void initialAcl() { if (!this.brokerConfig.isAclEnable()) { log.info(\\\"The broker dose not enable acl\\\"); return; } // 使用SPI机制加载配置的AccessValidator实现类 // 读取METAINF/service/org.apache.rocketmq.acl.AccessValidator文件中配置的访问验证器PlainAccessValidator List<AccessValidator> accessValidators = ServiceProvider.load(ServiceProvider.ACL_VALIDATOR_ID, AccessValidator.class); if (accessValidators == null || accessValidators.isEmpty()) { log.info(\\\"The broker dose not load the AccessValidator\\\"); return; } for (AccessValidator accessValidator: accessValidators) { final AccessValidator validator = accessValidator; accessValidatorMap.put(validator.getClass(),validator); // 向Broker处理服务启注册钩子函数 this.registerServerRPCHook(new RPCHook() { /** * 在服务端接收到请求并解码后、执行处理请求前被调用 */ @Override public void doBeforeRequest(String remoteAddr, RemotingCommand request) { //Do not catch the exception validator.validate(validator.parse(request, remoteAddr)); } /** * 在处理完请求后调用 */ @Override public void doAfterResponse(String remoteAddr, RemotingCommand request, RemotingCommand response) { } }); } } \",\"PlainAccessValidator 初始化时会创建 PlainPermissionManager 对象，用它来解析权限配置文件（plain_acl.yml）。\",\"PlainPermissionManager 会在初始化时加载目录中的所有配置文件，将权限配置信息加载到内存。同时，它会开启一个 FileWatchService 线程，用于每 0.5s 检测配置文件的变更，及时将变更加载到内存\",\"public PlainPermissionManager() { // 解析 yaml 文件，将配置加载到内存 load(); // 监听配置文件变化，如发生变化，重新加载配置 watch(); } \"]},\"517\":{\"h\":\"4.2.1 PlainPermissonManager 的字段含义\",\"t\":[\"其中红色线为初始化的方法调用链。下面看一下 PlainPermissonManager 中字段的含义，由于支持了从多文件加载权限配置，所以这些配置大多为 Map 类型，Key 是文件路径，Value 是文件中包含的权限配置。\",\"// PlainPermissionManager.java // 权限映射配置表，用来缓存所有ACL配置文件的权限数据 private Map<String/** fileFullPath **/, Map<String/** AccessKey **/, PlainAccessResource>> aclPlainAccessResourceMap = new HashMap<>(); // 用来缓存 AccessKey 和 ACL 配置文件的映射关系 private Map<String/** AccessKey **/, String/** fileFullPath **/> accessKeyTable = new HashMap<>(); // 用来缓存所有 ACL 配置文件的全局白名单 private List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategy = new ArrayList<>(); // 远程 IP 解析策略工厂，用于解析白名单 IP 地址 private RemoteAddressStrategyFactory remoteAddressStrategyFactory = new RemoteAddressStrategyFactory(); // 缓存 ACL 配置文件和全局白名单的映射关系 private Map<String/** fileFullPath **/, List<RemoteAddressStrategy>> globalWhiteRemoteAddressStrategyMap = new HashMap<>(); // 是否监听 acl 配置文件。如果开启监听，一旦文件内容改变，可以在不重启服务的情况下自动生效 private boolean isWatchStart; // 配置文件版本号表 private Map<String/** fileFullPath **/, DataVersion> dataVersionMap = new HashMap<>(); \",\"aclPlainAccessResourceMap\",\"aclPlainAccessResourceMap是个Map类型，用来缓存所有ACL配置文件的权限数据，其中key表示ACL配置文件的绝对路径， value表示相应配置文件中的权限数据，需要注意的是value也是一个Map类型，其中key是String类型表示AccessKey，value是PlainAccessResource类型。\",\"accessKeyTable\",\"accessKeyTable是个Map类型，用来缓存AccessKey和ACL配置文件的映射关系，其中key表示AccessKey，value表示ACL配置文件的绝对路径。\",\"globalWhiteRemoteAddressStrategy\",\"globalWhiteRemoteAddressStrategy用来缓存所有ACL配置文件的全局白名单。\",\"globalWhiteRemoteAddressStrategyMap\",\"globalWhiteRemoteAddressStrategyMap是个Map类型，用来缓存ACL配置文件和全局白名单的映射关系\",\"dataVersionMap\",\"dataVersionMap是个Map类型，用来缓存所有ACL配置文件的DataVersion，其中key表示ACL配置文件的绝对路径，value表示该配置文件对应的DataVersion。\"]},\"518\":{\"h\":\"4.2.2 PlainPermissonManager#load\",\"t\":[\"它有两个 load 方法，分别用于重新加载全部文件，和重载一个文件的配置。\",\"load()\",\"load() 方法会获取 RocketMQ安装目录/conf 目录（包括该目录的子目录）和 rocketmq.acl.plain.file 下所有ACL配置文件，然后遍历这些文件读取权限数据和全局白名单。\",\"load(String aclFilePath)\",\"load(String aclFilePath) 方法完成加载指定ACL配置文件内容的功能，将配置文件中的全局白名单 globalWhiteRemoteAddresses 和用户权限 accounts 加载到缓存中， 这里需要注意以下几点：\",\"判断缓存中该配置文件的全局白名单 globalWhiteRemoteAddresses 和用户权限accounts 数据是否为空，如果不为空则需要注意删除文件原有数据\",\"相同的 accessKey 只允许存在在一个ACL配置文件中\",\"/** * 解析所有 ACL 配置文件，将 ACL 配置规则加载到内存 */ public void load() { if (fileHome == null || fileHome.isEmpty()) { return; } // 定义临时变量，用于暂存解析出来的 ACL 配置。这里没有直接覆盖全局配置，是为了防止全局配置在未解析完全的情况下被读取 Map<String, Map<String, PlainAccessResource>> aclPlainAccessResourceMap = new HashMap<>(); Map<String, String> accessKeyTable = new HashMap<>(); List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategy = new ArrayList<>(); Map<String, List<RemoteAddressStrategy>> globalWhiteRemoteAddressStrategyMap = new HashMap<>(); Map<String, DataVersion> dataVersionMap = new HashMap<>(); // 获取所有 ACL 配置文件 fileList = getAllAclFiles(defaultAclDir); if (new File(defaultAclFile).exists() && !fileList.contains(defaultAclFile)) { fileList.add(defaultAclFile); } // 遍历 ACL 配置文件，解析配置 for (int i = 0; i < fileList.size(); i++) { JSONObject plainAclConfData = AclUtils.getYamlDataObject(fileList.get(i), JSONObject.class); if (plainAclConfData == null || plainAclConfData.isEmpty()) { throw new AclException(String.format(\\\"%s file is not data\\\", fileList.get(i))); } log.info(\\\"Broker plain acl conf data is : \\\", plainAclConfData.toString()); // 解析全局 IP 白名单配置 List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategyList = new ArrayList<>(); JSONArray globalWhiteRemoteAddressesList = plainAclConfData.getJSONArray(\\\"globalWhiteRemoteAddresses\\\"); if (globalWhiteRemoteAddressesList != null && !globalWhiteRemoteAddressesList.isEmpty()) { for (int j = 0; j < globalWhiteRemoteAddressesList.size(); j++) { globalWhiteRemoteAddressStrategyList.add(remoteAddressStrategyFactory. getRemoteAddressStrategy(globalWhiteRemoteAddressesList.getString(j))); } } if (globalWhiteRemoteAddressStrategyList.size() > 0) { globalWhiteRemoteAddressStrategyMap.put(fileList.get(i), globalWhiteRemoteAddressStrategyList); globalWhiteRemoteAddressStrategy.addAll(globalWhiteRemoteAddressStrategyList); } // 解析账号权限配置 JSONArray accounts = plainAclConfData.getJSONArray(AclConstants.CONFIG_ACCOUNTS); Map<String, PlainAccessResource> plainAccessResourceMap = new HashMap<>(); if (accounts != null && !accounts.isEmpty()) { List<PlainAccessConfig> plainAccessConfigList = accounts.toJavaList(PlainAccessConfig.class); for (PlainAccessConfig plainAccessConfig : plainAccessConfigList) { PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig); //AccessKey can not be defined in multiple ACL files if (accessKeyTable.get(plainAccessResource.getAccessKey()) == null) { plainAccessResourceMap.put(plainAccessResource.getAccessKey(), plainAccessResource); accessKeyTable.put(plainAccessResource.getAccessKey(), fileList.get(i)); } else { log.warn(\\\"The accesssKey {} is repeated in multiple ACL files\\\", plainAccessResource.getAccessKey()); } } } if (plainAccessResourceMap.size() > 0) { aclPlainAccessResourceMap.put(fileList.get(i), plainAccessResourceMap); } // 解析数据版本 JSONArray tempDataVersion = plainAclConfData.getJSONArray(AclConstants.CONFIG_DATA_VERSION); DataVersion dataVersion = new DataVersion(); if (tempDataVersion != null && !tempDataVersion.isEmpty()) { List<DataVersion> dataVersions = tempDataVersion.toJavaList(DataVersion.class); DataVersion firstElement = dataVersions.get(0); dataVersion.assignNewOne(firstElement); } dataVersionMap.put(fileList.get(i), dataVersion); } if (dataVersionMap.containsKey(defaultAclFile)) { this.dataVersion.assignNewOne(dataVersionMap.get(defaultAclFile)); } // 刷新全局配置 this.dataVersionMap = dataVersionMap; this.globalWhiteRemoteAddressStrategyMap = globalWhiteRemoteAddressStrategyMap; this.globalWhiteRemoteAddressStrategy = globalWhiteRemoteAddressStrategy; this.aclPlainAccessResourceMap = aclPlainAccessResourceMap; this.accessKeyTable = accessKeyTable; } \"]},\"519\":{\"h\":\"4.2.3 PlainPermissonManager#watch\",\"t\":[\"watch() 方法用来监控 RocketMQ安装目录/conf 目录下所有ACL配置文件和 rocketmq.acl.plain.file 是否发生变化。\",\"变化考虑两种情况：\",\"ACL 配置文件的数量发生变化， 此时会调用 load() 方法重新加载所有配置文件的数据\",\"一种是配置文件的内容发生变化，调用 load(String aclFilePath) 加载单个文件的配置。\",\"具体完成监控ACL配置文件变化的是 AclFileWatchService 服务， 该服务是一个线程，当启动该服务后它会以 WATCH_INTERVAL（该参数目前设置为5秒，目前还不能在Broker配置文件中设置）的时间间隔来执行其核心逻辑。\",\"在该服务中会记录其监控的ACL配置文件目录 aclPath、 ACL配置文件的数量 aclFilesNum、所有ACL配置文件绝对路径 fileList 以及每个ACL配置文件最近一次修改的时间 fileLastModifiedTime （Map类型，key为ACL配置文件的绝对路径，value为其最近一次修改时间）。\",\"该服务的核心逻辑如下：\",\"获取ACL配置文件数量并和 aclFilesNum 进行比较是否相等 \",\"不相等则更新 aclFilesNum和fileList 并调用 load() 方法重新加载所有配置文件\",\"相等则遍历每个ACL配置文件，获取其最近一次修改的时间，并将该时间与 fileLastModifiedTime中记录的时间进行比较 \",\"不相等则表示该文件发生过修改， 此时调用 load(String aclFilePath) 方法重新加载该配置文件。\",\"// PlainPermissionManager.java /** * 监听ACL配置文件变化，重新load */ private void watch() { try { AclFileWatchService aclFileWatchService = new AclFileWatchService(defaultAclDir, defaultAclFile, new AclFileWatchService.Listener() { @Override public void onFileChanged(String aclFileName) { load(aclFileName); } @Override public void onFileNumChanged(String path) { load(); } }); aclFileWatchService.start(); log.info(\\\"Succeed to start AclFileWatchService\\\"); this.isWatchStart = true; } catch (Exception e) { log.error(\\\"Failed to start AclWatcherService\\\", e); } } \",\"// AclFileWatchService.java @Override public void run() { log.info(this.getServiceName() + \\\" service started\\\"); while (!this.isStopped()) { try { this.waitForRunning(WATCH_INTERVAL); if (fileList.size() > 0) { fileList.clear(); } getAllAclFiles(aclPath); if (new File(defaultAclFile).exists() && !fileList.contains(defaultAclFile)) { fileList.add(defaultAclFile); } int realAclFilesNum = fileList.size(); if (aclFilesNum != realAclFilesNum) { log.info(\\\"aclFilesNum: \\\" + aclFilesNum + \\\" realAclFilesNum: \\\" + realAclFilesNum); aclFilesNum = realAclFilesNum; log.info(\\\"aclFilesNum: \\\" + aclFilesNum + \\\" realAclFilesNum: \\\" + realAclFilesNum); Map<String, Long> fileLastModifiedTime = new HashMap<>(realAclFilesNum); for (int i = 0; i < realAclFilesNum; i++) { String fileAbsolutePath = fileList.get(i); fileLastModifiedTime.put(fileAbsolutePath, new File(fileAbsolutePath).lastModified()); } this.fileLastModifiedTime = fileLastModifiedTime; listener.onFileNumChanged(aclPath); } else { for (int i = 0; i < aclFilesNum; i++) { String fileName = fileList.get(i); Long newLastModifiedTime = new File(fileName).lastModified(); if (!newLastModifiedTime.equals(fileLastModifiedTime.get(fileName))) { fileLastModifiedTime.put(fileName, newLastModifiedTime); listener.onFileChanged(fileName); } } } } catch (Exception e) { log.warn(this.getServiceName() + \\\" service has exception. \\\", e); } } log.info(this.getServiceName() + \\\" service end\\\"); } \"]},\"520\":{\"h\":\"4.3 Broker 权限验证\",\"t\":[\"Broker 权限验证主要逻辑都在 PlainPermissionManager#validate 方法中\",\"判断客户端 IP 是否在全局白名单中，如果匹配则直接放行\",\"判断该用户是否配置在权限控制列表中，如果不在则返回错误\",\"获取请求用户的访问控制权限，判断客户端 IP 是否在用户维度的白名单中，如果匹配则放行\",\"对请求参数验计算签名，验证与客户端计算的签名是否一致，不一致则返回异常\",\"验证资源访问权限，判断该用户是否有客户端请求的资源的相应操作权限\",\"public void validate(PlainAccessResource plainAccessResource) { // Check the global white remote addr for (RemoteAddressStrategy remoteAddressStrategy : globalWhiteRemoteAddressStrategy) { if (remoteAddressStrategy.match(plainAccessResource)) { return; } } if (plainAccessResource.getAccessKey() == null) { throw new AclException(String.format(\\\"No accessKey is configured\\\")); } if (!accessKeyTable.containsKey(plainAccessResource.getAccessKey())) { throw new AclException(String.format(\\\"No acl config for %s\\\", plainAccessResource.getAccessKey())); } // Check the white addr for accesskey String aclFileName = accessKeyTable.get(plainAccessResource.getAccessKey()); PlainAccessResource ownedAccess = aclPlainAccessResourceMap.get(aclFileName).get(plainAccessResource.getAccessKey()); if (ownedAccess.getRemoteAddressStrategy().match(plainAccessResource)) { return; } // Check the signature String signature = AclUtils.calSignature(plainAccessResource.getContent(), ownedAccess.getSecretKey()); if (!signature.equals(plainAccessResource.getSignature())) { throw new AclException(String.format(\\\"Check signature failed for accessKey=%s\\\", plainAccessResource.getAccessKey())); } // Check perm of each resource checkPerm(plainAccessResource, ownedAccess); } \",\"checkPerm(PlainAccessResource needCheckedAccess, PlainAccessResource ownedAccess) 方法完成验证账号是否有该资源访问权限的逻辑。\",\"/** * 验证是否有某资源的访问权限 * * @param needCheckedAccess 客户端请求需要的资源权限 * @param ownedAccess 该账号拥有的资源权限 */ void checkPerm(PlainAccessResource needCheckedAccess, PlainAccessResource ownedAccess) { if (Permission.needAdminPerm(needCheckedAccess.getRequestCode()) && !ownedAccess.isAdmin()) { throw new AclException(String.format(\\\"Need admin permission for request code=%d, but accessKey=%s is not\\\", needCheckedAccess.getRequestCode(), ownedAccess.getAccessKey())); } Map<String, Byte> needCheckedPermMap = needCheckedAccess.getResourcePermMap(); Map<String, Byte> ownedPermMap = ownedAccess.getResourcePermMap(); // 本次操作无需权限验证，直接通过 if (needCheckedPermMap == null) { // If the needCheckedPermMap is null,then return return; } // 该账号未设置任何访问规则，且用户是管理员，直接通过 if (ownedPermMap == null && ownedAccess.isAdmin()) { // If the ownedPermMap is null and it is an admin user, then return return; } // 遍历需要的权限与拥有的权限进行对比 for (Map.Entry<String, Byte> needCheckedEntry : needCheckedPermMap.entrySet()) { String resource = needCheckedEntry.getKey(); Byte neededPerm = needCheckedEntry.getValue(); boolean isGroup = PlainAccessResource.isRetryTopic(resource); if (ownedPermMap == null || !ownedPermMap.containsKey(resource)) { // Check the default perm byte ownedPerm = isGroup ? ownedAccess.getDefaultGroupPerm() : ownedAccess.getDefaultTopicPerm(); if (!Permission.checkPermission(neededPerm, ownedPerm)) { throw new AclException(String.format(\\\"No default permission for %s\\\", PlainAccessResource.printStr(resource, isGroup))); } continue; } if (!Permission.checkPermission(neededPerm, ownedPermMap.get(resource))) { throw new AclException(String.format(\\\"No default permission for %s\\\", PlainAccessResource.printStr(resource, isGroup))); } } } \"]},\"521\":{\"h\":\"参考资料\",\"t\":[\"权限控制——官网文档\",\"RocketMQ_Multiple_ACL_Files_设计\",\"RocketMQ ACL使用指南\",\"源码分析RocketMQ ACL实现机制\",\"RocketMQ 源码分析之 ACL\",\"RocketMQ ACL 权限控制\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"522\":{\"h\":\"RocketMQ 消息轨迹\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220521-rocketmq-trace.html\"]},\"523\":{\"h\":\"1. 背景\",\"t\":[\"发往消息队列中的消息存在一些可观测性上的问题。由于消息队列需要高性能、大量地处理消息，而在 Broker 端记录消息的方式（使用日志等）势必会对性能造成非常大的损耗，所以对于消息是否成功发送到 Broker、Broker 又是否成功将消息投递给消费者这些动作，缺乏观测手段。这样就会造成生产方和消费方互相“扯皮”的现象：一条消息没有被成功消费，到底是生产方没有发送，还是消费方没有消费成功。\",\"RocketMQ 在 4.4.0 版本正式引入了消息轨迹功能，它可以用来记录消息发送、消息消费的信息，详细记录消息各个处理环节的日志。\"]},\"524\":{\"h\":\"2. 使用示例\",\"t\":[\"要使用消息轨迹，在 Broker 端和客户端都需要进行一些配置。更详细的消息轨迹使用方法请参考官方文档。\",\"rocketmq-spring 开启消息轨迹的文档。\",\"物理 IO 隔离模式\",\"对于消息轨迹数据量较大的场景，可以在RocketMQ集群中选择其中一个Broker节点专用于存储消息轨迹，使得用户普通的消息数据与消息轨迹数据的物理IO完全隔离，互不影响。在该模式下，RockeMQ集群中至少有两个Broker节点，其中一个Broker节点定义为存储消息轨迹数据的服务端。\"]},\"525\":{\"h\":\"2.1 Broker 端配置\",\"t\":[\"在 broker.conf 中启用消息轨迹功能，该功能默认关闭。\",\"### if msg tracing is open,the flag will be true traceTopicEnable=true \",\"注意需要重启 Broker 才可以应用改动。\"]},\"526\":{\"h\":\"2.2 生产者开启消息轨迹\",\"t\":[\"// 构建生产者。第二个参数即启用消息轨迹，第三个参数（可选）可以指定保存消息轨迹的 Topic DefaultMQProducer producer = new DefaultMQProducer(\\\"ProducerGroupName\\\", true); producer.setNamesrvAddr(\\\"XX.XX.XX.XX1\\\"); producer.start(); try { { // 建议为消息指定 Key，便于对消息进行高性能查询。这里的 OrderID188 即消息的 Key Message msg = new Message(\\\"TopicTest\\\", \\\"TagA\\\", \\\"OrderID188\\\", \\\"Hello world\\\".getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg); System.out.printf(\\\"%s%n\\\", sendResult); } } catch (Exception e) { e.printStackTrace(); } \"]},\"527\":{\"h\":\"2.3 消费者开启消息轨迹\",\"t\":[\"// 构建消费者。第二个参数即启用消息轨迹，第三个参数（可选）可以指定保存消息轨迹的 Topic DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\\\"CID_JODIE_1\\\", true); consumer.subscribe(\\\"TopicTest\\\", \\\"*\\\"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.setConsumeTimestamp(\\\"20181109221800\\\"); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) { System.out.printf(\\\"%s Receive New Messages: %s %n\\\", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); consumer.start(); System.out.printf(\\\"Consumer Started.%n\\\"); \"]},\"528\":{\"h\":\"2.4 使用 mqadmin 查看消息轨迹\",\"t\":[\"查询轨迹\",\"./mqadmin QueryMsgTraceById -n 127.0.0.1:9876 -i \\\"message-id\\\" \",\"查询轨迹结果\",\"RocketMQLog:WARN No appenders could be found for logger (io.netty.util.internal.PlatformDependent0). RocketMQLog:WARN Please initialize the logger system properly. #Type #ProducerGroup #ClientHost #SendTime #CostTimes #Status Pub 1623305799667 xxx.xxx.xxx.xxx 2021-06-10 14:16:40 131ms success \"]},\"529\":{\"h\":\"2.5 使用 rocketmq-dashboard 查看消息轨迹\",\"t\":[\"RocketMQ 的官方 DashBoard 支持消息轨迹的查询\"]},\"530\":{\"h\":\"3. 概要设计\",\"t\":[\"在设计消息轨迹功能时，能想到的要点主要有如下几点\",\"如何采集轨迹数据\",\"采集的轨迹数据要包含哪些数据\",\"如何存储轨迹数据\",\"如何将轨迹数据发送至存储，而尽可能不影响正常消息发送的性能\",\"首先是如何采集数据。消息轨迹关注是否被生产和消费，以及消息生产、消费相关的数据，所以需要在消息生产和消费时采集一些数据。\",\"RocketMQ 提供了消息生产和消费的钩子，可以在消息生产、消费前后添加自定义的逻辑，于是轨迹数据的采集可以放在钩子函数中进行。\",\"对于消息的存储，处于不添加额外依赖的考虑，存储在 Broker 是最佳的选择。消息轨迹的数据可以封装成消息，与普通消息公用存储，存在 Broker 中。\",\"那么如何在发送普通消息的同时发送消息轨迹消息？为了保证普通消息发送的性能，势必使用异步发送。此外，由于消息轨迹数据没有普通消息那样强的实时性要求，所以可以通过批量发送的方式减少性能损耗。\"]},\"531\":{\"h\":\"3.1 主要流程\",\"t\":[\"这里以生产者为例，生产者在发送消息前后的钩子函数中分别添加消息轨迹采集逻辑，随后将轨迹信息交给一个异步线程池处理。\",\"这个异步线程池批量将轨迹信息打包发送给 Broker，完成消息轨迹的保存。\"]},\"532\":{\"h\":\"3.2 存储设计\",\"t\":[\"默认情况下，消息轨迹保存在一个默认的 Topic 中，RMQ_SYS_TRACE_TOPIC，这个 Topic 只有一个队列，所以只会存在一个 Broker。在使用时可以在生产者和消费者上指定消息轨迹发送的自定义 Topic。\",\"官方将消息轨迹存储的模式分为两种：普通模式和物理 IO 隔离模式。\",\"普通模式即集群中每个 Broker 都可以存储消息轨迹数据。\",\"物理 IO 隔离模式即单独选一个 Broker 只作为消息轨迹接收的节点，这样就不会增加其他 Broker 的负载。\"]},\"533\":{\"h\":\"4. 详细设计\"},\"534\":{\"h\":\"4.1 轨迹数据采集\",\"t\":[\"前面说到，采集消息轨迹数据的最佳方法就是在发送和消费时在钩子函数中进行。\",\"所以如果客户端创建时开启了消息轨迹功能，那么将新建处理轨迹的钩子，注册到生产者或消费者实例中去。\",\"生产者的钩子类是 SendMessageTraceHookImpl，消费者的钩子类是 ConsumeMessageTraceHookImpl。\",\"在 before 方法中，会构建一个轨迹上下文，将数据采集到该上下文中。\",\"在 after 方法中，采集数据并将该上下文信息交给轨迹数据异步发送线程池 AsyncTraceDispatcher 处理，将会保存到一个 BlockingQueue 中由工作线程消费。\"]},\"535\":{\"h\":\"4.2 轨迹数据发送\",\"t\":[\"发送逻辑采用生产-消费模式，由 AsyncTraceDispatcher处理。 一个工作线程负责消费客户端实例提交过来的轨迹数据。\",\"工作线程每次消费一批轨迹数据，将轨迹数据打包后提交给发送线程池。发送线程池将这些轨迹消息发送给指定的 Broker。\"]},\"536\":{\"h\":\"5. 源码解析\"},\"537\":{\"h\":\"5.1 消息轨迹数据模型\",\"t\":[\"消息轨迹的模型类是 TraceContext，其中的 traceBeans 列表保存着具体消息的轨迹信息。\",\"该列表在消息生产时永远只有 1 条数据，即生产发送的消息。\",\"在消费时可能由多条数据，因为消费者每次会消费多条消息。\",\"/** * The context of Trace */ public class TraceContext implements Comparable<TraceContext> { // 轨迹类型。Pub：消息发送，SubBefore：消费者消费前，SubAfter：消费者消费后 private TraceType traceType; // 时间戳 private long timeStamp = System.currentTimeMillis(); // Broker 所在区域 ID，取自 BrokerConfig#regionId private String regionId = \\\"\\\"; private String regionName = \\\"\\\"; // 生产者或消费者组名称 private String groupName = \\\"\\\"; // 耗时 private int costTime = 0; // 发送/消费成功 private boolean isSuccess = true; // 在消费时使用，消费端的请求 ID private String requestId = MessageClientIDSetter.createUniqID(); // 消费状态码 private int contextCode = 0; // 消息的轨迹数据 private List<TraceBean> traceBeans; } \",\"public class TraceBean { private static final String LOCAL_ADDRESS = UtilAll.ipToIPv4Str(UtilAll.getIP()); private String topic = \\\"\\\"; private String msgId = \\\"\\\"; // 消息偏移量 ID，包含了 Broker 的 IP 和消息存储在 Broker 上的偏移量 private String offsetMsgId = \\\"\\\"; private String tags = \\\"\\\"; private String keys = \\\"\\\"; // 生产者采集时为 Broker 的 IP，消费者采集时为消费者 IP private String storeHost = LOCAL_ADDRESS; // 客户端 IP。生产者采集时为生产者的 IP，消费者采集时为消费者 IP private String clientHost = LOCAL_ADDRESS; // 存储时间 private long storeTime; private int retryTimes; // 消息体长度 private int bodyLength; // 消息类型 private MessageType msgType; private LocalTransactionState transactionState; private String transactionId; private boolean fromTransactionCheck; } \"]},\"538\":{\"h\":\"5.2 消息轨迹数据采集\",\"t\":[\"这里以消费者为例\"]},\"539\":{\"h\":\"5.2.1 注册消息轨迹采集钩子\",\"t\":[\"public DefaultMQPushConsumer(final String namespace, final String consumerGroup, RPCHook rpcHook, AllocateMessageQueueStrategy allocateMessageQueueStrategy, boolean enableMsgTrace, final String customizedTraceTopic) { this.consumerGroup = consumerGroup; this.namespace = namespace; this.allocateMessageQueueStrategy = allocateMessageQueueStrategy; defaultMQPushConsumerImpl = new DefaultMQPushConsumerImpl(this, rpcHook); // 如果开启消息轨迹 if (enableMsgTrace) { try { // 创建消息轨迹异步发送者 AsyncTraceDispatcher dispatcher = new AsyncTraceDispatcher(consumerGroup, TraceDispatcher.Type.CONSUME, customizedTraceTopic, rpcHook); dispatcher.setHostConsumer(this.getDefaultMQPushConsumerImpl()); traceDispatcher = dispatcher; // 注册消息轨迹采集钩子 this.getDefaultMQPushConsumerImpl().registerConsumeMessageHook( new ConsumeMessageTraceHookImpl(traceDispatcher)); } catch (Throwable e) { log.error(\\\"system mqtrace hook init failed ,maybe can't send msg trace data\\\"); } } } \"]},\"540\":{\"h\":\"5.2.2 钩子方法中采集消息轨迹数据\",\"t\":[\"// ConsumeMessageTraceHookImpl.java /** * 消息消费前调用 * 收集将要消费消息的轨迹信息，存入调用上下文 * * @param context */ @Override public void consumeMessageBefore(ConsumeMessageContext context) { if (context == null || context.getMsgList() == null || context.getMsgList().isEmpty()) { return; } // 创建消息轨迹上下文 TraceContext traceContext = new TraceContext(); context.setMqTraceContext(traceContext); // 设置消息轨迹类型 traceContext.setTraceType(TraceType.SubBefore);// // 设置消费组名 traceContext.setGroupName(NamespaceUtil.withoutNamespace(context.getConsumerGroup()));// // 将消费到的消息构建 TraceBean 列表，采集每条消息的轨迹数据 List<TraceBean> beans = new ArrayList<TraceBean>(); for (MessageExt msg : context.getMsgList()) { if (msg == null) { continue; } String regionId = msg.getProperty(MessageConst.PROPERTY_MSG_REGION); String traceOn = msg.getProperty(MessageConst.PROPERTY_TRACE_SWITCH); if (traceOn != null && traceOn.equals(\\\"false\\\")) { // If trace switch is false ,skip it continue; } TraceBean traceBean = new TraceBean(); traceBean.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic()));// traceBean.setMsgId(msg.getMsgId());// traceBean.setTags(msg.getTags());// traceBean.setKeys(msg.getKeys());// traceBean.setStoreTime(msg.getStoreTimestamp());// traceBean.setBodyLength(msg.getStoreSize());// traceBean.setRetryTimes(msg.getReconsumeTimes());// traceContext.setRegionId(regionId);// beans.add(traceBean); } // 将消息轨迹交给异步发送者处理 if (beans.size() > 0) { traceContext.setTraceBeans(beans); traceContext.setTimeStamp(System.currentTimeMillis()); localDispatcher.append(traceContext); } } /** * 消息消费后调用 * 采集消费完成的消息轨迹数据，存入轨迹上下文，然后发送 * * @param context */ @Override public void consumeMessageAfter(ConsumeMessageContext context) { if (context == null || context.getMsgList() == null || context.getMsgList().isEmpty()) { return; } // 从轨迹上下文获取消费前的轨迹数据 TraceContext subBeforeContext = (TraceContext) context.getMqTraceContext(); if (subBeforeContext.getTraceBeans() == null || subBeforeContext.getTraceBeans().size() < 1) { // If subBefore bean is null ,skip it return; } // 构建消费后的轨迹数据 TraceContext subAfterContext = new TraceContext(); subAfterContext.setTraceType(TraceType.SubAfter);// subAfterContext.setRegionId(subBeforeContext.getRegionId());// subAfterContext.setGroupName(NamespaceUtil.withoutNamespace(subBeforeContext.getGroupName()));// subAfterContext.setRequestId(subBeforeContext.getRequestId());// subAfterContext.setSuccess(context.isSuccess());// // Calculate the cost time for processing messages int costTime = (int) ((System.currentTimeMillis() - subBeforeContext.getTimeStamp()) / context.getMsgList().size()); subAfterContext.setCostTime(costTime);// subAfterContext.setTraceBeans(subBeforeContext.getTraceBeans()); Map<String, String> props = context.getProps(); if (props != null) { String contextType = props.get(MixAll.CONSUME_CONTEXT_TYPE); if (contextType != null) { subAfterContext.setContextCode(ConsumeReturnType.valueOf(contextType).ordinal()); } } // 发给异步发送者处理 localDispatcher.append(subAfterContext); } \"]},\"541\":{\"h\":\"5.3 消息轨迹数据发送\",\"t\":[\"AsyncTraceDispatcher 是专门用来异步发送轨迹消息的异步转发器，负责消息轨迹消息的转发。前面说到消息轨迹数据也以消息的形式发送到 Broker 中进行存储。\",\"AsyncTraceDispatcher 中有 1 个线程池 traceExecutor，负责异步发送轨迹数据，消息生产者 traceProducer 处理生产逻辑，1 个工作线程 worker 负责将 客户端采集到的轨迹上下文提交给线程池处理。\",\"/** * 消息轨迹异步转发器，异步实现消息轨迹数据的发送 */ public class AsyncTraceDispatcher implements TraceDispatcher { // 异步转发队列长度，默认 2048 private final int queueSize; // 一次发送的请求包含数据条数，默认 100 private final int batchSize; // 一次发送最大消息大小，默认 128k private final int maxMsgSize; // 发送消息轨迹的消息生产者 private final DefaultMQProducer traceProducer; // 异步发送线程池 private final ThreadPoolExecutor traceExecutor; // 丢弃的消息个数 // The last discard number of log private AtomicLong discardCount; // 工作线程，从追加队列中获取一批待发送的消息轨迹数据，提交到线程池中执行 private Thread worker; // 消息轨迹待发送数据队列，存储每个消息轨迹的上下文 private final ArrayBlockingQueue<TraceContext> traceContextQueue; // 线程池内部队列，存储线程池发送任务 private ArrayBlockingQueue<Runnable> appenderQueue; private volatile Thread shutDownHook; private volatile boolean stopped = false; private DefaultMQProducerImpl hostProducer; // 消费者信息，记录消费时的轨迹 private DefaultMQPushConsumerImpl hostConsumer; private volatile ThreadLocalIndex sendWhichQueue = new ThreadLocalIndex(); private String dispatcherId = UUID.randomUUID().toString(); // 消息轨迹存放的 Topic private String traceTopicName; private AtomicBoolean isStarted = new AtomicBoolean(false); private AccessChannel accessChannel = AccessChannel.LOCAL; private String group; private Type type; } \",\"worker 工作线程用一个死循环，不停地尝试从消息轨迹队列中获取一批数据，封装成一个发送任务提交给消息发送线程池处理。\",\"/** * 批量从待处理消息轨迹队列中取数据，封装成一个 {@link AsyncAppenderRequest} 异步发送请求，提交给发送线程池执行 * 批量发送机制是为了提高效率 */ class AsyncRunnable implements Runnable { private boolean stopped; @Override public void run() { while (!stopped) { List<TraceContext> contexts = new ArrayList<TraceContext>(batchSize); // 批量从等待处理的消息轨迹队列中获取数据，将一批数据封装成一个发送请求，提交给异步发送线程池执行 synchronized (traceContextQueue) { for (int i = 0; i < batchSize; i++) { TraceContext context = null; try { //get trace data element from blocking Queue - traceContextQueue context = traceContextQueue.poll(5, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { } if (context != null) { contexts.add(context); } else { break; } } if (contexts.size() > 0) { AsyncAppenderRequest request = new AsyncAppenderRequest(contexts); traceExecutor.submit(request); } else if (AsyncTraceDispatcher.this.stopped) { // 同步 AsyncTraceDispatcher 的停止状态 this.stopped = true; } } } } } \",\"而真正的发送逻辑则在 AsyncAppenderRequest#run() 中执行的 sendTraceData 方法中执行\",\"/** * 一次发送一批消息轨迹数据 * * @param contextList 消息轨迹数据列表，本次要发送的数据 */ public void sendTraceData(List<TraceContext> contextList) { // 按 Topic 区分的消息轨迹数据表 Map<String, List<TraceTransferBean>> transBeanMap = new HashMap<String, List<TraceTransferBean>>(); for (TraceContext context : contextList) { if (context.getTraceBeans().isEmpty()) { continue; } // Topic value corresponding to original message entity content String topic = context.getTraceBeans().get(0).getTopic(); String regionId = context.getRegionId(); // 用原 Topic 和 regionId 组成 key // Use original message entity's topic as key String key = topic; if (!StringUtils.isBlank(regionId)) { key = key + TraceConstants.CONTENT_SPLITOR + regionId; } // 根据 Key 将消息轨迹数据分类，存入 map List<TraceTransferBean> transBeanList = transBeanMap.get(key); if (transBeanList == null) { transBeanList = new ArrayList<TraceTransferBean>(); transBeanMap.put(key, transBeanList); } // 按消息轨迹存储协议进行编码，当前为字符串拼接模式 TraceTransferBean traceData = TraceDataEncoder.encoderFromContextBean(context); transBeanList.add(traceData); } // 按 Topic 分批将消息发送到 Broker 中 for (Map.Entry<String, List<TraceTransferBean>> entry : transBeanMap.entrySet()) { String[] key = entry.getKey().split(String.valueOf(TraceConstants.CONTENT_SPLITOR)); String dataTopic = entry.getKey(); String regionId = null; if (key.length > 1) { dataTopic = key[0]; regionId = key[1]; } flushData(entry.getValue(), dataTopic, regionId); } } \"]},\"542\":{\"h\":\"参考资料\",\"t\":[\"消息轨迹——官方文档\",\"RocketMQ消息轨迹-设计篇\",\"源码分析RocketMQ消息轨迹\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"543\":{\"h\":\"RocketMQ 消息发送设计和原理详解 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220606-rocketmq-send-message.html\"]},\"544\":{\"h\":\"1. 背景\",\"t\":[\"发送消息是 MQ 最基础的操作之一。RocketMQ 官方提供了多语言客户端支持消息的发送和消费操作。 当然，消息发送并不仅仅牵扯到客户端操作。客户端做的是向 Broker 发送请求，请求中包含了消息的全部信息。而 Broker 需要处理客户端发送来的生产请求，将消息存储起来。 在这篇文章中我将解析消息发送流程中生产者和 Broker 的处理流程，揭秘 RocketMQ 消息发送高性能、高可靠的原理。\"]},\"545\":{\"h\":\"2. 概述\",\"t\":[\"RocketMQ 的 Java 客户端提供了丰富的消息发送 API，支持多种消息发送的方式和特殊消息的发送。 包括 3 种发送方式（同步、异步、单向）和多种特殊消息（顺序消息、延时消息、批量消息、过滤消息、事务消息）。 对于客户端消息发送 API 的具体使用方式，可以参考官方文档：https://github.com/apache/rocketmq/blob/develop/docs/cn/RocketMQ_Example.md。\"]},\"546\":{\"h\":\"2.1 消息发送方式和特殊消息\"},\"547\":{\"h\":\"2.1.1 三种消息发送方式\",\"t\":[\"RocketMQ 支持 3 种消息发送方式：同步、异步和单向。\",\"同步（Sync） \",\"发送消息时，同步等待，直到 Broker 返回发送结果。\",\"这种方式最为可靠，但是发送性能最差。\",\"在一些可靠性要求非常高的场景下，推荐使用同步方式。比如：重要的消息通知，短信通知。\",\"异步（Async） \",\"发送消息时，无需等待 Broker 返回发送结果，发送线程不阻塞。执行发送 API 时指定消息发送成功后的回调函数。\",\"这种方式相比于同步发送，性能可以提升多个数量级，但可靠性不如同步发送。\",\"在对响应时间敏感、流量较大的场景下，推荐使用异步方式。异步发送是使用最广泛的发送方式。\",\"单向（One-way） \",\"发送消息时，直接返回，不等待 Broker 返回发送结果，也不注册回调函数。\",\"这种发送方式性能最高，可靠性最差。它不关心发送结果，不在乎消息是否成功存储在 Broker 中。\",\"适用于消息丢失也没有太大影响的场景，例如发送日志。\",\"这三种发送方式中，异步发送是最为广泛使用的发送方式。配合一些重试和补偿机制，可以达成较高的可靠性和很高的性能。\"]},\"548\":{\"h\":\"2.1.2 特殊消息类型\",\"t\":[\"下面简单介绍一下几种特殊消息类型。\",\"普通消息：发送效率最高、使用场景最广泛的消息类型。普通消息可以由客户端并发发送。不保证普通消息消费的顺序。单 Broker 性能可以达到十万级别。（视 Broker 配置而变）\",\"队列级别顺序消息：RocketMQ 将一个 Topic 分为多个队列，以提高消费速度。每隔分区内的消息遵循先生产先消费的顺序。\",\"Topic 级别顺序消息：如果把一个 Topic 的队列数量设为 1，那么该 Topic 中的消息也遵循先生产先消费。\",\"延迟消息：消息发送后，消费者并不马上收到消息，而是等待一段指定的时间之后才能消费到该消息。\",\"事务消息：提供分布式事务功能，可以保证发送消息和另外的操作同时成功或者同时失败。\",\"批量消息：将多个消息包装成一个批量消息，一起发送。降低网络传输次数，提升传输效率。\"]},\"549\":{\"h\":\"2.2 路由机制\",\"t\":[\"RocketMQ 的 Topic 可以分为多个队列，每个队列可能分布在不同 Broker 上。\",\"消息的路由指的是发送消息时需要先获取 Topic 的路由信息（其中包含每个 Topic 的队列和它们所在的 Broker 地址），然后选择一个队列进行发送。\",\"具体选择队列的方式是轮询，但是如果上一次发送失败，下一次选择队列时会避开发送失败队列所在的 Broker。此外有一个故障延迟机制，它默认关闭，如果开启则会在一段时间内都规避发送失败的 Broker。\",\"消息发送的 API 提供了参数，可以传入要发送的队列信息，或者传入队列选择方法，以供用户选择发往某个 Broker 的具体队列。\"]},\"550\":{\"h\":\"2.3 消息发送流程\",\"t\":[\"消息发送的流程涉及到 RocketMQ 的三个组件：生产者、Broker、NameServer。 其中生产者负责发送消息，Broker 负责处理消息发送请求，NameServer 负责更新和提供路由信息。\",\"如图所示\",\"生产者每 30 秒向 NameServer 拉取路由信息，Broker 每 30 秒向 NameServer 发送路由信息。\",\"生产者发送消息时，会先在本地查询 Topic 路由信息。\",\"如果查询不到，会请求 NameServer 查询。\",\"随后将消息发送给 Broker。\",\"Broker 也会在本地查询 Topic 路由信息来检查消息的 Topic 是否存在。\",\"随后保存消息，如果是异步发送则直接返回，如果同步发送则等待消息保存成功后返回。\"]},\"551\":{\"h\":\"2.4 高可用设计\"},\"552\":{\"h\":\"2.4.1 生产者高可用\",\"t\":[\"消息发送重试机制：生产者在消息发送时如果出现失败，默认会重试 2 次。\",\"故障规避机制：如果重试的消息仍发往同一个 Broker，发送大概率还是会失败，所以在重试时会尽量避开刚刚发送失败的 Broker。 \",\"可以通过配置故障延迟机制来指定是在本次消息发送时暂时避开发送失败的 Broker，还是在之后一段时间都避开该 Broker\"]},\"553\":{\"h\":\"2.4.2 Broker 端高可用\",\"t\":[\"Broker 端的高可用是用数据同步的方式，将消息同步到备 Broker 上，当主 Broker 发生故障时，可以从备 Broker 上恢复数据。\"]},\"554\":{\"h\":\"3. 详细设计\"},\"555\":{\"h\":\"3.1 消息\",\"t\":[\"RocketMQ 中的消息类主要有 3 个\",\"Message 为客户端需要使用的消息类。\",\"MessageExt 为消息扩展属性类，它扩展了 Message，在 Broker 上产生此对象。\",\"MessageExtBrokerInner 是存储内部使用的 Message 对象，在 rocketmq-store 模块使用。\",\"在发送消息时，用到的是 Message，可以指定消息的属性、消息体和 flag。\"]},\"556\":{\"h\":\"3.2 生产者类图\",\"t\":[\"DefaultMQProducer 是 RocketMQ 中默认的生产者实现，它实现了 MQAdmin 接口。\",\"DefaultMQProducer 内部包装了一个 DefaultMQProducerImpl 字段，它是生产者的具体实现类，DefaultMQProducer 调用它内部的 DefaultMQProducerImpl 来发送命令。\",\"DefaultMQProducerImpl 内部注册了一个 MQClientInstance 字段。MQClientInstance 是与 NameServer 和 Broker 通信的中介。 MQClientInstance 与 ClientId 一一对应，ClientId 由 clientIp、instanceName、unitName 组成。如果不手动修改，一般来说一个启动的客户端进程只有一个 MQClientInstance 实例，这样可以节省客户端资源。\",\"MQClientInstnace 内部的 producerTable 注册了 ClientId 和 DefaultMQProducerImpl 的对应关系\",\"MQClientAPIImpl 提供了发送消息的 API，它调用 RemotingClient 执行发送。\"]},\"557\":{\"h\":\"3.3 生产者启动\",\"t\":[\"构造 DefaultMQProducer 实例，start() 启动\",\"初始化 DefaultMQProducerImpl，设置状态为 CREATE_JUST\",\"启动 DefaultMQProducerImpl\",\"检查配置\",\"根据 ClientId 获取或创建 MQClientInstance\",\"将 DefaultMQProducerImpl 注册到 MQClientInstance\",\"启动 MQClientInstance，MQClientInstance 启动定时任务，包括从 NameServer 拉取 Topic 路由信息、向 Broker 发送心跳\",\"MQClientInstance 启动 PullMessageService 和 RebalanceService\",\"设置服务状态为 RUNNING\"]},\"558\":{\"h\":\"3.4 消息发送\",\"t\":[\"RocketMQ 的消息发送流程图如下图所示：\",\"其中 MQProducerImpl 负责执行核心的消息发送方法 sendDefaultImpl\",\"这个方法中包含了消息发送的核心逻辑\",\"查找 Topic 路由信息\",\"选择消息队列\",\"发送消息\"]},\"559\":{\"h\":\"3.4.1 查找 Topic 路由信息\",\"t\":[\"指定 Topic 发送消息后，生产者需要知道消息要发往哪个 Broker 地址。于是需要获取 Topic 路由信息，查询 Topic 所在的 Broker，随后选择一个 Broker 进行发送。该逻辑在 DefaultMQProducerImpl#tryToFindTopicPublishInfo() 中执行。\",\"在第一次发送消息时，本地没有缓存 Topic 路由信息，所以需要主动从 NameServer 拉取，然后更新到本地路由表缓存。随后生产者会启动定时任务，每隔 30s 重新从 NameServer 拉取路由信息。\",\"注意，第一次查询 NameServer 时，如果没有拉取到 Topic 路由信息，则会使用默认 Topic（AUTO_CREATE_TOPIC_KEY_TOPIC）再次查询。\",\"默认 Topic 在 Broker 启动时创建，是为自动创建主题运用的。 它的目的是在主题没有被创建时，让生产者发送消息时也能够查询到 Broker 地址。 然后等消息真正发送到 Broker 时，会根据消息的 Topic 创建主题。\",\"如果最终都没有拉取到 Topic 路由信息，则会抛出异常。\"]},\"560\":{\"h\":\"3.4.2 重试机制\",\"t\":[\"同步发送和异步发送的重试次数分别由 retryTimesWhenSendFailed 和 retryTimesWhenSendAsyncFailed 指定，默认都为 2 次（发送 1 次，重试 1 次）。\",\"同步发送的重试逻辑即在 sendDefaultImpl() 方法中循环发送执行发送逻辑。\",\"异步发送的重试逻辑在 MQClientAPIIpml() 的sendMessageAsync() 构造的回调方法中指定。它调用 onExceptionImpl() 方法，如果当前发送次数小于异步发送重试次数，则再次执行 sendMessageAsync() 重试发送。\"]},\"561\":{\"h\":\"3.4.3 选择消息队列：故障延迟机制\",\"t\":[\"获取到 Topic 路由信息后，需要从中选择一个队列进行发送。选择队列的逻辑由 MQFaultStrategy#selectOneMessageQueue()处理，在正常情况下，会轮询所有队列进行发送；上一次发送异常的情况下它将执行 Broker 规避和故障延迟机制。\",\"默认机制\",\"默认机制下，按照轮询的方式选择队列。如果上一次发送成功，选择下一个队列。如果上一次发送失败，会规避上一次发送的 MessageQueue 所在的 Broker。\",\"故障延迟机制\",\"故障延迟机制是为了能够在消息发送的时候尽量避开上次发送失败的 Broker，它由 sendLatencyFaultEnable 参数来设置开启，默认为关闭状态。\",\"关闭：发送一次消息失败后，会在本次消息发送过程中避开该 Broker，但下次发送消息时还会继续尝试。\",\"开启：发送一次消息失败后，会悲观地认为 Broker 不可用，在接下来一段时间内都不再向其发送消息。随着发送失败次数的增多，规避时间将越来越长。\"]},\"562\":{\"h\":\"3.4.4 发送消息\",\"t\":[\"消息发送逻辑由 DefaultMQProducerImpl#sendKernelImpl() 处理。\",\"先根据上一步选择的队列，查询 MQClientInstance 获取对应的 Broker 地址（先查本地缓存，如果没有则从 NameServer 拉取）。\",\"设置消息的全局唯一 ID，然后对于超过 4KB （默认）的消息执行 zip 压缩。\",\"执行发送之前的钩子函数 executeSendMessageHookBefore()，如消息轨迹的处理逻辑就在这里进行处理。\",\"构建消息请求（头）\",\"根据消息发送方式调用 MQClientAPIImpl 进行网络传输\",\"执行消息发送后的钩子函数\",\"MQClientAPIImpl 负责调用 NettyRemotingClient 将生产消息的请求发往 Broker。\"]},\"563\":{\"h\":\"3.5 Broker 处理发送请求\",\"t\":[\"Broker 通过 SendMessageProcessor 处理生产者发来的消息生产请求。当前使用 asyncSendMessage() 异步处理生产者发送过来的请求。\",\"RocketMQ 的 Netty 请求处理机制会按照业务逻辑进行处理器的拆分。具体地说，RocketMQ 为不同的请求类型（请求码）注册不同的业务处理器和线程池去处理。比如消息生产的请求由 sendMessageExecutor 线程池处理，消费请求由 pullMessageExecutor 处理……\",\"Broker 处理消息生产请求逻辑如下：\",\"检查消息合理性\",\"如果消息重试次数超过允许的最大重试次数，将进入死信队列。\",\"调用存储模块将消息存储\"]},\"564\":{\"h\":\"3.6 Batch 消息（批量消息）\",\"t\":[\"为了减少网络请求次数，RocketMQ 支持将统一主题的一批消息打包发送。对于每条消息较小且消息较多的场景，使用批量发送可以提升发送效率。\",\"批量消息 MessageBatch 类继承普通消息类 Message，内部仅仅多了消息列表 List<Message> messages。这样就可以像发送普通消息一样发送批量消息。发送前需要做的就是将多条普通消息体编码，放到 MessageBatch 的消息体中。\",\"服务端接收到后，按照相同规则对批量消息进行解码，即可解码出多条消息。\"]},\"565\":{\"h\":\"4. 源码解析\"},\"566\":{\"h\":\"4.1 生产者启动\"},\"567\":{\"h\":\"4.1.1 DefaultMQProducerImpl#start\",\"t\":[\"// DefaultMQProducerImpl.java public void start(final boolean startFactory) throws MQClientException { switch (this.serviceState) { // 如果状态为 CREATE_JUST，执行启动逻辑。该对象创建时默认状态为 CREATE_JUST case CREATE_JUST: this.serviceState = ServiceState.START_FAILED; // 检查 producerGroup 是否合法 this.checkConfig(); // 改变生产者的 instanceName 为进程 ID，避免同一个服务器上的多个生产者实例名相同 if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) { this.defaultMQProducer.changeInstanceNameToPID(); } // 创建 MQClientInstance 实例 this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook); // 向 MQClientInstance 注册服务，将当前生产者加入 MQClientInstance 管理（加入 MQClientInstance.producerTable） // 方便后续调用网络请求、进行心跳检测等 boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this); if (!registerOK) { this.serviceState = ServiceState.CREATE_JUST; throw new MQClientException(\\\"The producer group[\\\" + this.defaultMQProducer.getProducerGroup() + \\\"] has been created before, specify another name please.\\\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL), null); } this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo()); // 启动 MQClientInstance，如果已经启动，则不会执行 if (startFactory) { mQClientFactory.start(); } log.info(\\\"the producer [{}] start OK. sendMessageWithVIPChannel={}\\\", this.defaultMQProducer.getProducerGroup(), this.defaultMQProducer.isSendMessageWithVIPChannel()); // 设置服务状态为 RUNNING this.serviceState = ServiceState.RUNNING; break; case RUNNING: case START_FAILED: case SHUTDOWN_ALREADY: throw new MQClientException(\\\"The producer service state not OK, maybe started once, \\\" + this.serviceState + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK), null); default: break; } // 启动后马上向 NameServer 发送心跳 this.mQClientFactory.sendHeartbeatToAllBrokerWithLock(); RequestFutureHolder.getInstance().startScheduledTask(this); } \"]},\"568\":{\"h\":\"4.1.2 MQClientException\",\"t\":[\"/** * 启动客户端代理 * * @throws MQClientException */ public void start() throws MQClientException { synchronized (this) { switch (this.serviceState) { case CREATE_JUST: this.serviceState = ServiceState.START_FAILED; // If not specified,looking address from name server if (null == this.clientConfig.getNamesrvAddr()) { this.mQClientAPIImpl.fetchNameServerAddr(); } // Start request-response channel this.mQClientAPIImpl.start(); // Start various schedule tasks this.startScheduledTask(); // Start pull service this.pullMessageService.start(); // Start rebalance service this.rebalanceService.start(); // Start push service // 当消费失败的时候，需要把消息发回去 this.defaultMQProducer.getDefaultMQProducerImpl().start(false); log.info(\\\"the client factory [{}] start OK\\\", this.clientId); this.serviceState = ServiceState.RUNNING; break; case START_FAILED: throw new MQClientException(\\\"The Factory object[\\\" + this.getClientId() + \\\"] has been created before, and failed.\\\", null); default: break; } } } /** * 启动定时任务 */ private void startScheduledTask() { if (null == this.clientConfig.getNamesrvAddr()) { this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.mQClientAPIImpl.fetchNameServerAddr(); } catch (Exception e) { log.error(\\\"ScheduledTask fetchNameServerAddr exception\\\", e); } } }, 1000 * 10, 1000 * 60 * 2, TimeUnit.MILLISECONDS); } /** * 默认每30s从nameserver获取Topic路由信息 * 包括 生产者和消费者 */ this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.updateTopicRouteInfoFromNameServer(); } catch (Exception e) { log.error(\\\"ScheduledTask updateTopicRouteInfoFromNameServer exception\\\", e); } } }, 10, this.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS); /** * 每30s向Broker端发送心跳 * 1. 清除离线的Broker * 2. 汇报心跳给broker */ this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.cleanOfflineBroker(); MQClientInstance.this.sendHeartbeatToAllBrokerWithLock(); } catch (Exception e) { log.error(\\\"ScheduledTask sendHeartbeatToAllBroker exception\\\", e); } } }, 1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS); /** * 每5s把消费者的offset持久化 */ this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.persistAllConsumerOffset(); } catch (Exception e) { log.error(\\\"ScheduledTask persistAllConsumerOffset exception\\\", e); } } }, 1000 * 10, this.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS); /** * 每60s调整线程池 */ this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.adjustThreadPool(); } catch (Exception e) { log.error(\\\"ScheduledTask adjustThreadPool exception\\\", e); } } }, 1, 1, TimeUnit.MINUTES); } \"]},\"569\":{\"h\":\"4.2 消息发送\"},\"570\":{\"h\":\"4.2.1 消息发送实现\",\"t\":[\"// DefaultMQProducerImpl.java /** * 发送消息实现 * - 验证合法性 checkMessage * - 查找主题路由信息 tryToFindTopicPublishInfo * - 选择消息队列 selectOneMessageQueue * - 发送消息 sendKernelImpl * * @param msg * @param communicationMode * @param sendCallback * @param timeout * @return * @throws MQClientException * @throws RemotingException * @throws MQBrokerException * @throws InterruptedException */ private SendResult sendDefaultImpl( Message msg, final CommunicationMode communicationMode, final SendCallback sendCallback, final long timeout ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 检查生产者处于运行状态 this.makeSureStateOK(); // 验证消息是否符合规范 Validators.checkMessage(msg, this.defaultMQProducer); final long invokeID = random.nextLong(); long beginTimestampFirst = System.currentTimeMillis(); long beginTimestampPrev = beginTimestampFirst; long endTimestamp = beginTimestampFirst; // 获取主题的路由信息 TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); if (topicPublishInfo != null && topicPublishInfo.ok()) { boolean callTimeout = false; MessageQueue mq = null; Exception exception = null; SendResult sendResult = null; int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; int times = 0; String[] brokersSent = new String[timesTotal]; // 循环执行发送，处理同步发送重试。同步发送共重试timesTotal次，默认为2次，异步发送只执行一次 for (; times < timesTotal; times++) { String lastBrokerName = null == mq ? null : mq.getBrokerName(); // 选择消息队列 MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); if (mqSelected != null) { mq = mqSelected; brokersSent[times] = mq.getBrokerName(); try { beginTimestampPrev = System.currentTimeMillis(); if (times > 0) { //Reset topic with namespace during resend. msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic())); } long costTime = beginTimestampPrev - beginTimestampFirst; if (timeout < costTime) { callTimeout = true; break; } // 发送消息 sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime); endTimestamp = System.currentTimeMillis(); // 处理发送异常，更新失败条目 this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false); switch (communicationMode) { case ASYNC: return null; case ONEWAY: return null; case SYNC: if (sendResult.getSendStatus() != SendStatus.SEND_OK) { if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) { continue; } } return sendResult; default: break; } } // catch ... } else { break; } } // 发送成功，返回发送结果 if (sendResult != null) { return sendResult; } // 发送失败，抛出异常 // ... // mqClientException.setResponseCode(...) throw mqClientException; } validateNameServerSetting(); throw new MQClientException(\\\"No route info of this topic: \\\" + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO), null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION); } \"]},\"571\":{\"h\":\"4.2.2 查找路由信息\",\"t\":[\"// DefaultMQProducerImpl.java private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) { // 尝试获取缓存的路由信息 TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic); // 如果路由信息没有找到，则从NameServer上获取 if (null == topicPublishInfo || !topicPublishInfo.ok()) { this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo()); this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic); topicPublishInfo = this.topicPublishInfoTable.get(topic); } if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) { return topicPublishInfo; } else { // 如果第一次没有查询到，第二次使用默认主题查询 this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer); topicPublishInfo = this.topicPublishInfoTable.get(topic); return topicPublishInfo; } } \"]},\"572\":{\"h\":\"4.2.3 选择消息队列\",\"t\":[\"默认机制，故障延迟机制关闭\",\"// TopicPublishInfo.java /** * 选择队列 * 上一次发送成功则选择下一个队列，上一次发送失败会规避上次发送的 MessageQueue 所在的 Broker * * @param lastBrokerName 上次发送的 Broker 名称，如果为空表示上次发送成功 * @return */ public MessageQueue selectOneMessageQueue(final String lastBrokerName) { if (lastBrokerName == null) { // 轮询队列，选择下一个队列 return selectOneMessageQueue(); } else { // 上次发送失败，规避上次发送的 MessageQueue 所在的 Broker for (int i = 0; i < this.messageQueueList.size(); i++) { int index = this.sendWhichQueue.incrementAndGet(); int pos = Math.abs(index) % this.messageQueueList.size(); if (pos < 0) pos = 0; MessageQueue mq = this.messageQueueList.get(pos); if (!mq.getBrokerName().equals(lastBrokerName)) { return mq; } } return selectOneMessageQueue(); } } \",\"故障延迟机制\",\"// MQFaultStrategy.java /** * 选择发送的队列，根据是否启用 Broker 故障延迟机制走不同逻辑 * * sendLatencyFaultEnable=false，默认不启用 Broker 故障延迟机制 * sendLatencyFaultEnable=true，启用 Broker 故障延迟机制 * * @param tpInfo * @param lastBrokerName * @return */ public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) { // 启用 Broker 故障延迟机制 if (this.sendLatencyFaultEnable) { try { // 轮询获取一个消息队列 int index = tpInfo.getSendWhichQueue().incrementAndGet(); for (int i = 0; i < tpInfo.getMessageQueueList().size(); i++) { int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size(); if (pos < 0) pos = 0; MessageQueue mq = tpInfo.getMessageQueueList().get(pos); // 验证该消息队列是否可用，规避注册过不可用的 Broker。 if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) return mq; } // 如果没有可用的 Broker，尝试从规避的 Broker 中选择一个可用的 Broker，如果没有找到，返回 null final String notBestBroker = latencyFaultTolerance.pickOneAtLeast(); int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker); if (writeQueueNums > 0) { final MessageQueue mq = tpInfo.selectOneMessageQueue(); if (notBestBroker != null) { mq.setBrokerName(notBestBroker); mq.setQueueId(tpInfo.getSendWhichQueue().incrementAndGet() % writeQueueNums); } return mq; } else { latencyFaultTolerance.remove(notBestBroker); } } catch (Exception e) { log.error(\\\"Error occurred when selecting message queue\\\", e); } return tpInfo.selectOneMessageQueue(); } // 不启用 Broker 故障延迟机制 return tpInfo.selectOneMessageQueue(lastBrokerName); } \"]},\"573\":{\"h\":\"4.2.4 发送消息 API 核心入口\",\"t\":[\"// DefaultMQProducerImpl.java /** * 消息发送 API 核心入口 * 1. 根据 MessageQueue 获取 Broker 地址 * 2. 为消息分配全局唯一 ID，执行消息压缩和事务 * 3. 如果注册了发送钩子函数，则执行发送之前的钩子函数 * 4. 构建消息发送请求包 * 5. 根据消息发送方式（同步、异步、单项）进行网络传输 * 6. 如果注册了发送钩子函数，执行发送之后的钩子函数 * * @param msg 待发送消息 * @param mq 发送的消息队列 * @param communicationMode 消息发送模式：SYNC、ASYNC、ONEWAY * @param sendCallback 异步发送回调函数 * @param topicPublishInfo 主题路由信息 * @param timeout 消息发送超时时间 * @return 消息发送结果 */ private SendResult sendKernelImpl(final Message msg, final MessageQueue mq, final CommunicationMode communicationMode, final SendCallback sendCallback, final TopicPublishInfo topicPublishInfo, final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { long beginStartTime = System.currentTimeMillis(); // 根据 MessageQueue 获取 Broker 的网络地址 String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName()); if (null == brokerAddr) { // 如果 MQClientInstance 的 brokerAddrTable 未缓存该 Broker 信息，则从 NameServer 主动拉取 topic 路由信息 tryToFindTopicPublishInfo(mq.getTopic()); brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName()); } SendMessageContext context = null; // 找到 topic 的路由信息 if (brokerAddr != null) { brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr); byte[] prevBody = msg.getBody(); try { // 设置消息的全局唯一 ID（UNIQUE_ID），对于批量消息，在生成过程中已经设置了 ID //for MessageBatch,ID has been set in the generating process if (!(msg instanceof MessageBatch)) { MessageClientIDSetter.setUniqID(msg); } // 处理命名空间逻辑 boolean topicWithNamespace = false; if (null != this.mQClientFactory.getClientConfig().getNamespace()) { msg.setInstanceId(this.mQClientFactory.getClientConfig().getNamespace()); topicWithNamespace = true; } // 处理压缩，默认消息体超过 4KB 的消息进行 zip 压缩，并设置压缩标识 int sysFlag = 0; boolean msgBodyCompressed = false; if (this.tryToCompressMessage(msg)) { sysFlag |= MessageSysFlag.COMPRESSED_FLAG; msgBodyCompressed = true; } // 处理事务 Prepared 消息，并设置事务标识 final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED); if (Boolean.parseBoolean(tranMsg)) { sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE; } // CheckForbiddenHook ... // 执行消息发送前的钩子函数 if (this.hasSendMessageHook()) { context = new SendMessageContext(); context.setProducer(this); context.setProducerGroup(this.defaultMQProducer.getProducerGroup()); context.setCommunicationMode(communicationMode); context.setBornHost(this.defaultMQProducer.getClientIP()); context.setBrokerAddr(brokerAddr); context.setMessage(msg); context.setMq(mq); context.setNamespace(this.defaultMQProducer.getNamespace()); String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED); if (isTrans != null && isTrans.equals(\\\"true\\\")) { context.setMsgType(MessageType.Trans_Msg_Half); } if (msg.getProperty(\\\"__STARTDELIVERTIME\\\") != null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != null) { context.setMsgType(MessageType.Delay_Msg); } // 执行所有 before 钩子函数 this.executeSendMessageHookBefore(context); } // 构建消息发送请求 SendMessageRequestHeader requestHeader = new SendMessageRequestHeader(); requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup()); requestHeader.setTopic(msg.getTopic()); requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey()); requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums()); requestHeader.setQueueId(mq.getQueueId()); requestHeader.setSysFlag(sysFlag); requestHeader.setBornTimestamp(System.currentTimeMillis()); requestHeader.setFlag(msg.getFlag()); requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties())); requestHeader.setReconsumeTimes(0); requestHeader.setUnitMode(this.isUnitMode()); requestHeader.setBatch(msg instanceof MessageBatch); if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { String reconsumeTimes = MessageAccessor.getReconsumeTime(msg); if (reconsumeTimes != null) { requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes)); MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME); } String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg); if (maxReconsumeTimes != null) { requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes)); MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES); } } // 根据消息发送方式进行网络传输 SendResult sendResult = null; switch (communicationMode) { case ASYNC: Message tmpMessage = msg; boolean messageCloned = false; if (msgBodyCompressed) { //If msg body was compressed, msgbody should be reset using prevBody. //Clone new message using commpressed message body and recover origin massage. //Fix bug:https://github.com/apache/rocketmq-externals/issues/66 tmpMessage = MessageAccessor.cloneMessage(msg); messageCloned = true; msg.setBody(prevBody); } if (topicWithNamespace) { if (!messageCloned) { tmpMessage = MessageAccessor.cloneMessage(msg); messageCloned = true; } msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace())); } long costTimeAsync = System.currentTimeMillis() - beginStartTime; if (timeout < costTimeAsync) { throw new RemotingTooMuchRequestException(\\\"sendKernelImpl call timeout\\\"); } sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage( brokerAddr, mq.getBrokerName(), tmpMessage, requestHeader, timeout - costTimeAsync, communicationMode, sendCallback, topicPublishInfo, this.mQClientFactory, this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), context, this); break; case ONEWAY: case SYNC: long costTimeSync = System.currentTimeMillis() - beginStartTime; if (timeout < costTimeSync) { throw new RemotingTooMuchRequestException(\\\"sendKernelImpl call timeout\\\"); } // 执行客户端同步发送方法 sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage( brokerAddr, mq.getBrokerName(), msg, requestHeader, timeout - costTimeSync, communicationMode, context, this); break; default: assert false; break; } if (this.hasSendMessageHook()) { context.setSendResult(sendResult); this.executeSendMessageHookAfter(context); } return sendResult; } // catch ... } finally { msg.setBody(prevBody); msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace())); } } // 主动更新后还是找不到路由信息，则抛出异常 throw new MQClientException(\\\"The broker[\\\" + mq.getBrokerName() + \\\"] not exist\\\", null); } \"]},\"574\":{\"h\":\"4.3 Broker 处理发送请求\"},\"575\":{\"h\":\"4.3.1 Broker 注册发送消息处理器\",\"t\":[\"/** * 创建和注册Broker请求处理类 * RocketMQ按照业务逻辑区分请求处理器，每个类型的请求码对应一个业务处理器（NettyRequestProcessor） * 这样就实现了为不同请求码设置对应线程池，实现不同请求线程池的隔离 */ public void registerProcessor() { /** * SendMessageProcessor */ SendMessageProcessor sendProcessor = new SendMessageProcessor(this); sendProcessor.registerSendMessageHook(sendMessageHookList); sendProcessor.registerConsumeMessageHook(consumeMessageHookList); this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, this.sendMessageExecutor); this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, this.sendMessageExecutor); this.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, this.sendMessageExecutor); this.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, this.sendMessageExecutor); // ... } \",\"其中 sendMessageExecutor 是发送消息处理线程池，默认有 4 个线程。每个线程执行 SendMessageProcessor#processRequest() 方法\"]},\"576\":{\"h\":\"4.3.2 发送消息处理器处理\",\"t\":[\"SendMessageProcessor#processRequest() 最终调用 asyncSendMessage() 方法处理发送请求\",\"// SendMessageProcessor.java /** * 处理客户端的发送消息请求 * 1. 检查消息合法性检查 * 2. 如果消息重试次数超过最大重试次数，消息将进入 DLQ 死信队列。 * 3. 将消息保存到存储 * * @param ctx * @param request * @param mqtraceContext * @param requestHeader * @return */ private CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request, SendMessageContext mqtraceContext, SendMessageRequestHeader requestHeader) { // 构造Response，包含消息合法性检查 final RemotingCommand response = preSend(ctx, request, requestHeader); final SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader(); if (response.getCode() != -1) { return CompletableFuture.completedFuture(response); } final byte[] body = request.getBody(); int queueIdInt = requestHeader.getQueueId(); TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic()); if (queueIdInt < 0) { queueIdInt = randomQueueId(topicConfig.getWriteQueueNums()); } // 构造存储用的Message对象 MessageExtBrokerInner msgInner = new MessageExtBrokerInner(); msgInner.setTopic(requestHeader.getTopic()); msgInner.setQueueId(queueIdInt); // 判断发过来的消息是否已经到达重新消费的重试最大次数，进入死信队列 if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) { return CompletableFuture.completedFuture(response); } msgInner.setBody(body); msgInner.setFlag(requestHeader.getFlag()); Map<String, String> origProps = MessageDecoder.string2messageProperties(requestHeader.getProperties()); MessageAccessor.setProperties(msgInner, origProps); msgInner.setBornTimestamp(requestHeader.getBornTimestamp()); msgInner.setBornHost(ctx.channel().remoteAddress()); msgInner.setStoreHost(this.getStoreHost()); msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes()); String clusterName = this.brokerController.getBrokerConfig().getBrokerClusterName(); MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName); if (origProps.containsKey(MessageConst.PROPERTY_WAIT_STORE_MSG_OK)) { // There is no need to store \\\"WAIT=true\\\", remove it from propertiesString to save 9 bytes for each message. // It works for most case. In some cases msgInner.setPropertiesString invoked later and replace it. String waitStoreMsgOKValue = origProps.remove(MessageConst.PROPERTY_WAIT_STORE_MSG_OK); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); // Reput to properties, since msgInner.isWaitStoreMsgOK() will be invoked later origProps.put(MessageConst.PROPERTY_WAIT_STORE_MSG_OK, waitStoreMsgOKValue); } else { msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); } // 保存到消息存储 CompletableFuture<PutMessageResult> putMessageResult = null; String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED); if (transFlag != null && Boolean.parseBoolean(transFlag)) { if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark( \\\"the broker[\\\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \\\"] sending transaction message is forbidden\\\"); return CompletableFuture.completedFuture(response); } putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner); } else { putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner); } return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt); } \"]},\"577\":{\"h\":\"参考资料\",\"t\":[\"生产消息样例——官方文档\",\"RocketMQ 消息发送流程\",\"《RocketMQ 技术内幕 第二版》\",\"《RocketMQ 分布式消息中间件 核心原理与最佳实践》\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"578\":{\"h\":\"RocketMQ Memory Store\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220618-rocketmq-memory-store.html\"]},\"579\":{\"h\":\"背景\"},\"580\":{\"h\":\"概要设计\"},\"581\":{\"h\":\"整体流程\",\"t\":[\"首先需要在 Broker 中创建 Topic，并指定为内存存储的 Topic。\",\"生产者发送生产请求\",\"SendMessageProcessor 处理生产请求 \",\"根据请求的 Topic 获取 TopicConfig\",\"判断该 Topic 是否是内存 Topic\",\"如果不是，走原有 DefaultMessageStore 存储\",\"如果是，走 MemoryMessageStore 存储\",\"消费者发送拉取消息请求\",\"PullMessageProcessor 处理拉取消息请求 \",\"根据请求的 Topic 获取 TopicConfig\",\"判断该 Topic 是否是内存 Topic\",\"如果不是，走原有 DefaultMessageStore 取消息\",\"如果是，走 MemoryMessageStore 取消息\"]},\"582\":{\"h\":\"详细设计\"},\"583\":{\"h\":\"整体流程顺序图\"},\"584\":{\"h\":\"类设计\"},\"585\":{\"h\":\"MemoryMessageStore\",\"t\":[\"为 MemoryMessageStore 设置一个存储阈值，为内存中存储的消息总大小，默认为可用内存的 75%\",\"messageQueueMap：一个 HashMap，Key 是 Topic 名称，Value 是 Disruptor 存储的 MessageExtBrokerInner 消息队列\",\"messageTotalSize：记录保存的消息总大小\",\"putMessage：将消息根据 Topic 放入指定队列，如果超过消息总大小阈值，则从该 Topic 中删除一条消息。如果该 Topic 为空，则删除一条保存最久的消息\"]},\"586\":{\"h\":\"TopicConfig\",\"t\":[\"boolean memory：是否是内存 Topic\"]},\"587\":{\"h\":\"BrokerController\",\"t\":[\"memoryTopicEnable：是否启动内存 Topic 功能，默认 false\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"588\":{\"h\":\"使用 Docker 和 docker-compose 快速部署 RocketMQ 集群 双主 / DLedger\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220724-rocketmq-docker-compose.html\"]},\"589\":{\"h\":\"背景\",\"t\":[\"RocketMQ 的部署和配置较为复杂，有众多配置项和部署方式可以选择。用户往往难以快速部署 RocketMQ，进行开发和验证。\",\"rocketmq-docker 这个项目提供了 RocketMQ 的 docker 镜像打包实现，并且提供了常用的 docker-compose 模板，可以很快地用 Docker 启动 RocketMQ，并支持多种部署模式。\"]},\"590\":{\"h\":\"环境准备\",\"t\":[\"需要安装完成 Docker，并且可以连接 Docker Hub。然后用 git 拉取 rocketmq-docker 仓库，并进入该仓库。\",\"git clone https://github.com/apache/rocketmq-docker.git cd rocketmq-docker \"]},\"591\":{\"h\":\"镜像准备\",\"t\":[\"可以预先准备好 RocketMQ 的镜像。本地构建或者从 Docker Hub 拉取官方打包的镜像都可以\"]},\"592\":{\"h\":\"本地构建 RocketMQ docker 镜像\",\"t\":[\"这一步不是必须要的，也可以从 Docker Hub 中拉取官方镜像。\",\"本地构建的最大意义在于，如果自己修改了 RocketMQ 的源码，则可以用这种方式构建自己的镜像。\",\"cd image-build sh build-image.sh RMQ-VERSION BASE-IMAGE \",\"运行脚本之后，会拉取相应版本的 RocketMQ 安装包到本地，然后构建镜像包。\",\"其中 RMQ-VERSION 是需要构建的 RocketMQ 版本，在 这个地方 查看可选版本列表。\",\"BASE-IMAGE 可以在 centos 和 alpine 中选择。比如当前最新版本为 4.9.4，那么可以用如下命令打镜像\",\"sh build-image.sh 4.9.4 alpine \",\"打包完成后可以用如下命令查看\",\"$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE apacherocketmq/rocketmq 4.9.4-alpine 58e1e7a5e556 16 hours ago 188MB \"]},\"593\":{\"h\":\"拉取远程\",\"t\":[\"$ docker search rocketmq NAME DESCRIPTION STARS OFFICIAL AUTOMATED foxiswho/rocketmq rocketmq 77 rocketmqinc/rocketmq Image repository for Apache RocketMQ 54 styletang/rocketmq-console-ng rocketmq-console-ng 38 apache/rocketmq 25 apacherocketmq/rocketmq Docker Image for Apache RocketMQ 22 \",\"我们选择 apache/rocketmq，其他的版本已经跟不上时代了，年久失修。\",\"看一下它支持的版本号列表：\",\"选择最新的 4.9.4 版本拉取\",\"$ docker pull apache/rocketmq:4.9.4 \"]},\"594\":{\"h\":\"Docker 启动 RocketMQ\",\"t\":[\"首先需要用版本号来创建一个 stage 文件夹，运行如下命令\",\"$ sh stage.sh 4.9.4 \",\"会在根目录下创建一个 stage 文件夹，进入到 stage/4.9.4/templates 目录下（有的 Linux 系统生成的路径是 stage/4.9.4/）\",\"$ cd stages/4.9.4/templates/ $ ls -l drwxrwxr-x 6 ubuntu ubuntu 4096 Jul 24 15:25 ./ drwxrwxr-x 3 ubuntu ubuntu 4096 Jul 24 15:23 ../ drwxrwxr-x 6 ubuntu ubuntu 4096 Jul 24 15:23 data/ drwxrwxr-x 4 ubuntu ubuntu 4096 Jul 24 15:26 docker-compose/ drwxrwxr-x 2 ubuntu ubuntu 4096 Jul 24 15:23 kubernetes/ -rwxrwxr-x 1 ubuntu ubuntu 902 Jul 24 15:23 play-consumer.sh* -rwxrwxr-x 1 ubuntu ubuntu 1497 Jul 24 15:23 play-docker-compose.sh* -rwxrwxr-x 1 ubuntu ubuntu 3201 Jul 24 15:23 play-docker-dledger.sh* -rwxrwxr-x 1 ubuntu ubuntu 2354 Jul 24 15:23 play-docker.sh* -rwxrwxr-x 1 ubuntu ubuntu 2271 Jul 24 15:23 play-docker-tls.sh* -rwxrwxr-x 1 ubuntu ubuntu 947 Jul 24 15:23 play-kubernetes.sh* -rwxrwxr-x 1 ubuntu ubuntu 901 Jul 24 15:23 play-producer.sh* drwxrwxr-x 2 ubuntu ubuntu 4096 Jul 24 15:23 ssl/ \",\"具体的原理是用原来 templates 下的模板，替换内容中的版本号，生成 4.9.4 版本的启动脚本。\",\"其中的多个 .sh 文件是用来以不同部署方式启动 RocketMQ\"]},\"595\":{\"h\":\"用 docker-compose 以集群模式启动 RocketMQ\",\"t\":[\"如果是采用远程拉取的镜像，首选需要修改一下 docker-compose.yml 文件保证使用的镜像名称正确。\",\"最新的 rocketmq-docker 项目已经将 docker-compose.yml 中的镜像地址改为了官方镜像地址 apache/rocketmq，如果你拉取的版本没有改，需要进行修改。\",\"此外，RocketMQ 有 brokerIP 配置，该配置默认会自动获取主机 IP，但是在容器中获取的是容器的 IP，客户端去连接会发现连不上。所以需要提前手动修改 Broker 配置的 IP。\",\"$ pwd /home/ubuntu/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates $ vim docker-compose/data/broker/conf/broker.conf $ vim docker-compose/data1/broker/conf/broker.conf # broker.conf brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH # 改为宿主机的 IP brokerIP1={宿主机IP} \",\"改成宿主机 IP 之后，发现如果是用 2 个主节点，他们的监听 IP 都将会是 {宿主机IP}:10911，需要将 broker-b 映射的监听 port 修改一下。 修改 docker-compose.yml\",\" #Service for another broker -- broker1 broker1: image: apache/rocketmq:4.9.4 container_name: rmqbroker-b links: - namesrv ports: # 修改映射到宿主机的 port #- 10929:10909 #- 10931:10911 #- 10932:10912 - 10929:10929 - 10931:10931 - 10932:10932 environment: - NAMESRV_ADDR=namesrv:9876 volumes: - ./data1/broker/logs:/home/rocketmq/logs - ./data1/broker/store:/home/rocketmq/store - ./data1/broker/conf/broker.conf:/opt/rocketmq-4.9.4/conf/broker.conf command: sh mqbroker -c /opt/rocketmq-4.9.4/conf/broker.conf \",\"docker-compose.yml 文件映射端口改了之外，还要修改 Broker2 的监听端口\",\"$ pwd /home/ubuntu/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates $ vim docker-compose/data1/broker/conf/broker.conf # broker.conf brokerClusterName = DefaultCluster brokerName = broker-b brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH # 改为宿主机的 IP brokerIP1={宿主机IP} # 修改监听端口 listenPort=10931 fastListenPort=10929 haListenPort=10932 \",\"然后可以启动 RocketMQ 容器\",\"$ pwd /home/ubuntu/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates $ vim docker-compose/docker-compose.yml # （如果拉取远程镜像）把其中默认的 image 从 apacherocketmq/rocketmq:4.9.4 改成最新的官方镜像地址 apache/rocketmq:4.9.4 $ ./play-docker-compose.sh [+] Running 4/4 ⠿ Network docker-compose_default Created ⠿ Container rmqnamesrv Started ⠿ Container rmqbroker-b Started ⠿ Container rmqbroker Started \",\"运行之后会启动两个 broker 和一个 nameserver\",\"$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 722c5c14d3d0 apache/rocketmq:4.9.4 \\\"sh mqbroker -c /opt…\\\" About a minute ago Up About a minute 0.0.0.0:10909->10909/tcp, :::10909->10909/tcp, 9876/tcp, 0.0.0.0:10911-10912->10911-10912/tcp, :::10911-10912->10911-10912/tcp rmqbroker a7d0e64c5335 apache/rocketmq:4.9.4 \\\"sh mqbroker -c /opt…\\\" About a minute ago Up About a minute 9876/tcp, 0.0.0.0:10929->10909/tcp, :::10929->10909/tcp, 0.0.0.0:10931->10911/tcp, :::10931->10911/tcp, 0.0.0.0:10932->10912/tcp, :::10932->10912/tcp rmqbroker-b a210d64eddb5 apache/rocketmq:4.9.4 \\\"sh mqnamesrv\\\" About a minute ago Up About a minute 10909/tcp, 0.0.0.0:9876->9876/tcp, :::9876->9876/tcp, 10911-10912/tcp rmqnamesrv \"]},\"596\":{\"h\":\"使用 docker 启动 RocketMQ-dashboard\",\"t\":[\"RocketMQ-dashboard 项目是 rocketmq 的控制台，可以可视化的查看 rocketmq 集群状态。也可以用 docker 启动。直接使用官方打包好的镜像，不本地构建了。\"]},\"597\":{\"h\":\"用 docker 单独启动 rocketmq-dashboard\",\"t\":[\"需要先修改 start-dashboard.sh 文件\",\"$ pwd /home/ubuntu/workspace/rocketmq/rocketmq-docker $ vim product/start-dashboard.sh \",\"将镜像名称改成 apacherocketmq/rocketmq-dashboard\",\"# 修改后 ROCKETMQ_DASHBOARD_VERSION=$1 docker run -d -it --name rocketmq-dashboard -p 6765:8080 apacherocketmq/rocketmq-dashboard:${ROCKETMQ_DASHBOARD_VERSION} \",\"然后运行\",\"$ sh start-dashboard.sh 1.0.0 \",\"会启动 rocketmq-dashboard 的 container\",\"$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 433021cbeb23 apacherocketmq/rocketmq-dashboard:1.0.0 \\\"sh -c 'java $JAVA_O…\\\" 45 minutes ago Up 45 minutes 0.0.0.0:6765->8080/tcp, :::6765->8080/tcp rocketmq-dashboard \",\"这样启动之后，登录访问 host:6765 地址，设置集群的 nameserver 地址，但是与集群的网络不通。\"]},\"598\":{\"h\":\"与集群一起用 docker-compose 启动 docker-dashboard\",\"t\":[\"还是要修改 docker-compose.yml 文件\",\"$ cd stages/4.9.4/templates $ vim docker-compose/docker-compose.yml \",\"在文件尾部添加如下配置，启动一个 rocketmq-dashboard 服务，并置于和集群同一个网络下\",\" # Service for dashboard dashboard: image: apacherocketmq/rocketmq-dashboard:1.0.0 container_name: rmq-dashboard ports: - 48080:8080 environment: - NAMESRV_ADDR=namesrv:9876 depends_on: - namesrv links: - namesrv \",\"然后访问 host:48080 地址，可以通过 dashboard 查看集群状态\"]},\"599\":{\"h\":\"Docker 启动 DLedger 模式的 RocketMQ\",\"t\":[\"用 DLedger 模式前保证有足够的可用内存（8G 以上）\",\"也是有两种方法，用本地构建的镜像和 Docker Hub 中官方上传的镜像。如果用本地打包的镜像，直接运行如下命令\",\"$ cd stages/4.9.4/templates $ ./play-docker-dledger.sh \",\"如果要用 Docker Hub 中的镜像，则需要修改 play-docker-dledger.sh 中的镜像地址\",\"$ vim play-docker-dledger.sh :%s/apacherocketmq/apache/g $ ./play-docker-dledger.sh \",\"但是我运行时三个 Broker 都未启动成功，查看 Broker 日志，发现 broker.conf 文件未找到\",\"ubuntu@VM-4-14-ubuntu:~/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1ae8a853012b apache/rocketmq:4.9.4 \\\"sh mqbroker -c ../c…\\\" 2 seconds ago Up 1 second 9876/tcp, 10909/tcp, 0.0.0.0:30929->30929/tcp, :::30929->30929/tcp, 10911-10912/tcp, 0.0.0.0:30931->30931/tcp, :::30931->30931/tcp rmqbroker2 71da5cd67513 apache/rocketmq:4.9.4 \\\"sh mqnamesrv\\\" 4 seconds ago Up 3 seconds 10909/tcp, 0.0.0.0:9876->9876/tcp, :::9876->9876/tcp, 10911-10912/tcp rmqnamesrv 0e80d1d53112 redis:6.2 \\\"docker-entrypoint.s…\\\" 3 months ago Up 3 months 0.0.0.0:46379->6379/tcp, :::46379->6379/tcp redis-redis-1 ubuntu@VM-4-14-ubuntu:~/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1ae8a853012b apache/rocketmq:4.9.4 \\\"sh mqbroker -c ../c…\\\" 8 seconds ago Exited (255) 6 seconds ago rmqbroker2 b959cf8b6542 apache/rocketmq:4.9.4 \\\"sh mqbroker -c ../c…\\\" 9 seconds ago Exited (255) 6 seconds ago rmqbroker1 919ce578e6db apache/rocketmq:4.9.4 \\\"sh mqbroker -c ../c…\\\" 10 seconds ago Exited (255) 7 seconds ago rmqbroker 71da5cd67513 apache/rocketmq:4.9.4 \\\"sh mqnamesrv\\\" 10 seconds ago Up 9 seconds 10909/tcp, 0.0.0.0:9876->9876/tcp, :::9876->9876/tcp, 10911-10912/tcp rmqnamesrv ubuntu@VM-4-14-ubuntu:~/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates$ docker logs -t rmqbroker --tail=100 2022-07-27T15:58:11.218761998Z java.io.FileNotFoundException: ../conf/dledger/broker.conf (No such file or directory) 2022-07-27T15:58:11.218878131Z at java.io.FileInputStream.open0(Native Method) 2022-07-27T15:58:11.218887204Z at java.io.FileInputStream.open(FileInputStream.java:195) 2022-07-27T15:58:11.218891884Z at java.io.FileInputStream.<init>(FileInputStream.java:138) 2022-07-27T15:58:11.218953791Z at java.io.FileInputStream.<init>(FileInputStream.java:93) 2022-07-27T15:58:11.218960481Z at org.apache.rocketmq.broker.BrokerStartup.createBrokerController(BrokerStartup.java:119) 2022-07-27T15:58:11.218965349Z at org.apache.rocketmq.broker.BrokerStartup.main(BrokerStartup.java:57) \",\"于是想办法修改 play-docker-dledger.sh 中的 Broker 配置文件路径，改成 /opt/rocketmq-4.9.4/conf/dledger/broker.conf，然后启动成功\"]},\"600\":{\"h\":\"修改内存配置\",\"t\":[\"DLedger 模式默认配置下，每个节点会占用 2G 内存。如果是内存较小的机器则可以通过定义环境变量修改内存占用。\",\"RocketMQ 使用 runbroker.sh 启动，其中启动参数设置脚本如下：\",\"# runbroker.sh JAVA_OPT=\\\"${JAVA_OPT} -server -Xms8g -Xmx8g\\\" choose_gc_options JAVA_OPT=\\\"${JAVA_OPT} -XX:-OmitStackTraceInFastThrow\\\" JAVA_OPT=\\\"${JAVA_OPT} -XX:+AlwaysPreTouch\\\" JAVA_OPT=\\\"${JAVA_OPT} -XX:MaxDirectMemorySize=15g\\\" JAVA_OPT=\\\"${JAVA_OPT} -XX:-UseLargePages -XX:-UseBiasedLocking\\\" #JAVA_OPT=\\\"${JAVA_OPT} -Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n\\\" JAVA_OPT=\\\"${JAVA_OPT} ${JAVA_OPT_EXT}\\\" JAVA_OPT=\\\"${JAVA_OPT} -cp ${CLASSPATH}\\\" \",\"这个脚本预留了定义额外的 Java 启动参数的环境变量，即 JAVA_OPT_EXT，于是将 play-docker-dledger.sh 文件做如下修改，添加 -e \\\"JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m\\\"（注意，这么小的内存无法生产消费消息，仅仅为了启动 Broker。需要同时改动 broker 配置中的 commitlog、consumequeue、indexfile 大小）\",\"docker run --net dledger-br --ip 172.18.0.12 -d -p 30911:30911 -p 30909:30909 -v `pwd`/data/broker0/logs:/home/rocketmq/logs -v `pwd`/data/broker0/store:/home/rocketmq/store -v `pwd`/data/broker0/conf/dledger:/opt/rocketmq-4.9.4/conf/dledger --name rmqbroker --link rmqnamesrv:namesrv -e \\\"NAMESRV_ADDR=namesrv:9876\\\" -e \\\"JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m\\\" apache/rocketmq:4.9.4 sh mqbroker -c /opt/rocketmq-4.9.4/conf/dledger/broker.conf docker run --net dledger-br --ip 172.18.0.13 -d -p 30921:30921 -p 30919:30919 -v `pwd`/data/broker1/logs:/home/rocketmq/logs -v `pwd`/data/broker1/store:/home/rocketmq/store -v `pwd`/data/broker1/conf/dledger:/opt/rocketmq-4.9.4/conf/dledger --name rmqbroker1 --link rmqnamesrv:namesrv -e \\\"NAMESRV_ADDR=namesrv:9876\\\" -e \\\"JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m\\\" apache/rocketmq:4.9.4 sh mqbroker -c /opt/rocketmq-4.9.4/conf/dledger/broker.conf docker run --net dledger-br --ip 172.18.0.14 -d -p 30931:30931 -p 30929:30929 -v `pwd`/data/broker2/logs:/home/rocketmq/logs -v `pwd`/data/broker2/store:/home/rocketmq/store -v `pwd`/data/broker2/conf/dledger:/opt/rocketmq-4.9.4/conf/dledger --name rmqbroker2 --link rmqnamesrv:namesrv -e \\\"NAMESRV_ADDR=namesrv:9876\\\" -e \\\"JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m\\\" apache/rocketmq:4.9.4 sh mqbroker -c /opt/rocketmq-4.9.4/conf/dledger/broker.conf \"]},\"601\":{\"h\":\"DLedger 与 Dashboard 同时启动\",\"t\":[\"需要修改 play-docker-dleger.sh，在 broker 运行的脚本下面添加 dashboard 的 docker 运行脚本，并与 broker、nameserver 用同一个网络\",\"# Start brokers # ... # Start dashboard docker run --net dledger-br -d -p 48080:8080 --link rmqnamesrv:namesrv -e \\\"NAMESRV_ADDR=namesrv:9876\\\" --name rmq-dledger-dashboard apacherocketmq/rocketmq-dashboard:1.0.0 \",\"然后运行 ./play-docker-dledger.sh，可以访问 48080 端口进入 Dashboard\"]},\"602\":{\"h\":\"以其他部署形式启动 RocketMQ\"},\"603\":{\"h\":\"Docker 启动单节点 RocketMQ\",\"t\":[\"$ cd stages/4.9.4/templates $ sh play-docker.sh alpine \"]},\"604\":{\"h\":\"Docker 启动带 TLS 的 RocketMQ\",\"t\":[\"$ cd stages/4.9.4/templates $ sh play-docker-tls.sh \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"605\":{\"h\":\"RocketMQ 消费者（1）概念和消费流程\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220820-rocketmq-consumer-1-summary.html\"]},\"606\":{\"h\":\"1. 背景\",\"t\":[\"RocketMQ 的消费可以算是 RocketMQ 的业务逻辑中最复杂的一块。这里面涉及到许多消费模式和特性。本想一篇文章写完，写到后面发现消费涉及到的内容太多，于是决定分多篇来写。本文作为消费系列的第一篇，主要讲述 RocketMQ 消费涉及到的模式和特性，也会概括性地讲一下消费流程。\",\"我将 RocketMQ 的消费流程大致分成 4 个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"每个步骤都会用一篇文章来讲解。\",\"先了解一下 RocketMQ 消费涉及到地概念\"]},\"607\":{\"h\":\"2. 概念简述\"},\"608\":{\"h\":\"2.1 消费组概念与消费模式\",\"t\":[\"和大多数消息队列一样，RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。在了解它们之前，需要先引入消费组的概念。\"]},\"609\":{\"h\":\"2.1.1 消费组\",\"t\":[\"一个消费者实例即是一个消费者进程，负责消费消息。单个消费者速度有限，在实际使用中通常会采用多个消费者共同消费同样的 Topic 以加快消费速度。这多个消费同样 Topic 的消费者组成了消费者组。\",\"消费组是一个逻辑概念，它包含了多个同一类的消费者实例，通常这些消费者都消费同一类消息（都消费相同的 Topic）且消费逻辑一致。\",\"消费组的引入是用来在消费消息时更好地进行负载均衡和容错。\"]},\"610\":{\"h\":\"2.1.2 广播消费模式（BROADCASTING）\",\"t\":[\"广播消费模式即全部的消息会广播分发到所有的消费者实例，每个消费者实例会收到全量的消息（即便消费组中有多个消费者都订阅同一 Topic）。\",\"如下图所示，生产者发送了 5 条消息，每个消费组中的消费者都收到全部的 5 条消息。\",\"广播模式使用较少，适合各个消费者都需要通知的场景，如刷新应用中的缓存。\",\"广播消费模式\",\"注意事项：\",\"广播消费模式下不支持 顺序消息。\",\"广播消费模式下不支持 重置消费位点。\",\"每条消息都需要被相同订阅逻辑的多台机器处理。\",\"消费进度在客户端维护，出现重复消费的概率稍大于集群模式。如果消费进度文件丢失，存在消息丢失的可能。\",\"广播模式下，消息队列 RocketMQ 版保证每条消息至少被每台客户端消费一次，但是并不会重投消费失败的消息，因此业务方需要关注消费失败的情况。\",\"广播模式下，客户端每一次重启都会从最新消息消费。客户端在被停止期间发送至服务端的消息将会被自动跳过，请谨慎选择。\",\"广播模式下，每条消息都会被大量的客户端重复处理，因此推荐尽可能使用集群模式。\",\"广播模式下服务端不维护消费进度，所以消息队列 RocketMQ 版控制台不支持消息堆积查询、消息堆积报警和订阅关系查询功能。\"]},\"611\":{\"h\":\"2.1.3 集群消费模式（CLUSTERING）\",\"t\":[\"集群消费模式下，同一 Topic 下的一条消息只会被同一消费组中的一个消费者消费。也就是说，消息被负载均衡到了同一个消费组的多个消费者实例上。\",\"更具体一点，在同一消费组中的不同消费者会根据负载机制来平均地订阅 Topic 中的每个 Queue。（默认 AVG 负载方式）\",\"广播消费模式\",\"RocketMQ 默认使用集群消费模式，这也是大部分场景下会使用到的消费模式。\"]},\"612\":{\"h\":\"2.2 消费者拉取消息模式\"},\"613\":{\"h\":\"2.2.1 Pull\",\"t\":[\"指消费者主动拉取消息进行消费，主动从 Broker 拉取消息，主动权由消费者应用控制。\"]},\"614\":{\"h\":\"2.2.2 Push\",\"t\":[\"指 Broker 主动将消息 Push 给消费者，Broker 收到消息就会主动推送到消费者端。该模式的消费实时性较高，也是主流场景中普遍采用的消费形式。\",\"消费者组中的消费者实例会根据预设的负载均衡算法对 Topic 中的 Queue 进行均匀的订阅，每个 Queue 最多只能被一个消费者订阅。\",\"在 RocketMQ 中，Push 消费其实也是由 Pull 消费（拉取）实现。Push 消费只是通过客户端 API 层面的封装让用户感觉像是 Broker 在推送消息给消费者。\"]},\"615\":{\"h\":\"2.2.3 POP\",\"t\":[\"RocketMQ 5.0 引入的新消费形式，是 Pull 拉取的另一种实现。也可以在 Push 模式下使用 POP 拉取消息，甚至可以和 Push 模式共同使用（分别消费重试 Topic 和普通 Topic）。\",\"POP 与 Pull 可以通过一个开关实时进行切换。POP 模式下，Broker 来控制每个消费者消费的队列和拉取的消息，把重平衡逻辑从客户端移到了服务端。\",\"主要解决了原来 Push 模式消费的以下痛点：\",\"富客户端：客户端逻辑比较重，多语言支持不友好\",\"队列独占：Topic 中的一个 Queue 最多只能被 1 个 Push 消费者消费，消费者数量无法无限扩展。且消费者 hang 住时该队列的消息会堆积。\",\"消费后更新 offset：本地消费成功才会提交 offset\",\"RocketMQ 5.0 的轻量化 gRPC 客户端就是基于 POP 消费模式开发\"]},\"616\":{\"h\":\"2.3 队列负载机制与重平衡\",\"t\":[\"在集群消费模式下，消费组中的消费者共同消费订阅的 Topic 中的所有消息，这里就存在 Topic 中的队列如何分配给消费者的问题。\"]},\"617\":{\"h\":\"2.3.1 队列负载机制\",\"t\":[\"RocketMQ Broker 中的队列负载机制将一个 Topic 的不同队列按照算法尽可能平均地分配给消费者组中的所有消费者。RocketMQ 预设了多种负载算法供不同场景下的消费。\",\"AVG：将队列按数量平均分配给多个消费者，按 Broker 顺序先分配第一个 Broker 的所有队列给第一个消费者，然后给第二个。\",\"AVG_BY_CIRCLE：将 Broker 上的队列轮流分给不同消费者，更适用于 Topic 在不同 Broker 之间分布不均匀的情况。\",\"默认采用 AVG 负载方式。\"]},\"618\":{\"h\":\"2.3.2 重平衡（Rebalance）\",\"t\":[\"为消费者分配队列消费的这一个负载过程并不是一劳永逸的，比如当消费者数量变化、Broker 掉线等情况发生后，原先的负载就变得不再均衡，此时就需要重新进行负载均衡，这一过程被称为重平衡机制。\",\"每隔 20s，RocketMQ 会进行一次检查，检查队列数量、消费者数量是否发生变化，如果变化则触发消费队列重平衡，重新执行上述负载算法。\"]},\"619\":{\"h\":\"2.4 消费端高可靠\"},\"620\":{\"h\":\"2.4.1 重试-死信机制\",\"t\":[\"在实际使用中，消息的消费可能出现失败。RocketMQ 拥有重试机制和死信机制来保证消息消费的可靠性。\",\"正常消费：消费成功则提交消费位点\",\"重试机制：如果正常消费失败，消息会被消费者发回 Broker，放入重试 Topic： %RETRY%消费者组。最多重试消费 16 次，重试的时间间隔逐渐变长。（消费者组会自动订阅重试 Topic）。\",\"这里地延迟重试采用了 RocketMQ 的延迟消息，重试的 16 次时间间隔为延迟消息配置的每个延迟等级的时间（从第三个等级开始）。如果修改延迟等级时间的配置，重试的时间间隔也会相应发生变化。但即便延迟等级时间间隔配置不足 16 个，仍会重试 16 次，后面按照最大的时间间隔来重试。\",\"死信机制：如果正常消费和重试 16 次均失败，消息会保存到死信 Topic %DLQ%消费者组 中，此时需人工介入处理\"]},\"621\":{\"h\":\"2.4.2 队列负载机制与重平衡\",\"t\":[\"当发生 Broker 挂掉或者消费者挂掉时，会引发重平衡，可以自动感知有组件挂掉的情况并重新调整消费者的订阅关系。\"]},\"622\":{\"h\":\"2.5 并发消费与顺序消费\",\"t\":[\"在消费者客户端消费时，有两种订阅消息的方式，分别是并发消费和顺序消费。广播模式不支持顺序消费，仅有集群模式能使用顺序消费。\",\"需要注意的是，这里所说的顺序消费指的是队列维度的顺序，即在消费一个队列时，消费消息的顺序和消息发送的顺序一致。如果一个 Topic 有多个队列， 是不可能达成 Topic 级别的顺序消费的，因为无法控制哪个队列的消息被先消费。Topic 只有一个队列的情况下能够实现 Topic 级别的顺序消费。\",\"具体顺序生产和消费代码见 官方文档。\",\"顺序生产的方式为串行生产，并在生产时指定队列。\",\"并发消费的方式是调用消费者的指定 MessageListenerConcurrently 作为消费的回调类，顺序消费则使用 MessageListenerOrderly 类进行回调。处理这两种消费方式的消费服务也不同，分别是 ConsumeMessageConcurrentlyService 和 ConsumeMessageOrderlyService。\",\"顺序消费的大致原理是依靠两组锁，一组在 Broker 端（Broker 锁），锁定队列和消费者的关系，保证同一时间只有一个消费者在消费；在消费者端也有一组锁（消费队列锁）以保证消费的顺序性。\"]},\"623\":{\"h\":\"2.6 消费进度保存和提交\",\"t\":[\"消费者消费一批消息完成之后，需要保存消费进度。如果是集群消费模式，还需要将消费进度让其他消费者知道，所以需要提交消费进度。这样在消费者重启或队列重平衡时可以根据消费进度继续消费。\",\"不同模式下消费进度保存方式的不同：\",\"广播模式：保存在消费者本地。因为每个消费者都需要消费全量消息消息。在 LocalfileOffsetStore 当中。\",\"集群模式：保存在 Broker，同时消费者端缓存。因为一个 Topic 的消息只要被消费者组中的一个消费者消费即可，所以消息的消费进度需要统一保存。通过 RemoteBrokerOffsetStore 存储。\",\"集群模式下，消费者端有定时任务，定时将内存中的消费进度提交到 Broker，Broker 也有定时任务将内存中的消费偏移量持久化到磁盘。此外，消费者向 Broker 拉取消息时也会提交消费偏移量。注意，消费者线程池提交的偏移量是线程池消费的这一批消息中偏移量最小的消息的偏移量。\",\"消费完一批消息后将消息消费进度存在本地内存\",\"消费者中有一个定时线程，每 5s 将内存中所有队列的消费偏移量提交到 Broker\",\"Broker 收到消费进度先缓存到内存，有一个定时任务每隔 5s 将消息偏移量持久化到磁盘\",\"消费者向 Broker 拉取消息时也会将队列的消息偏移量提交到 Broker\"]},\"624\":{\"h\":\"3. 消费流程\",\"t\":[\"这张图是阿里云的文章讲解消费时用到的，能够清晰地表示客户端 Push 模式并发消费流程。\",\"从左上角第一个方框开始看\",\"消费者启动时唤醒重平衡服务 RebalanceService，重平衡服务是客户端开始消费的起点。\",\"重平衡服务会周期性（每 20s）执行重平衡方法 doRebalance)，查询所有注册的 Broker，根据注册的 Broker 数量为自身分配负载的队列 rebalanceByTopic()\",\"分配完队列后，会为每个分配到的新队列创建一个消息拉取请求 pullRequest，这个拉取请求中保存一个处理队列 processQueue，即图中的红黑树（TreeMap），用来保存拉取到的消息。红黑树保存消息的顺序。\",\"消息拉取线程应用生产-消费模式，用一个线程从拉取请求队列 pullRequestQueue 中弹出拉取请求，执行拉取任务，将拉取到的消息放入处理队列。\",\"拉取请求在一次拉取消息完成之后会复用，重新被放入拉取请求队列 pullRequestQueue 中\",\"拉取完成后，在 NettyClientPublicExecutorThreadPool 线程池异步处理结果，将拉取到的消息放入处理队列，然后调用 consumeMessageService.submitConsumeRequest，将处理队列和 多个消费任务提交到消费线程池。每个消费任务消费 1 批消息（1 批默认为 1 条）\",\"每个消费者都有一个消费线程池 consumeMessageThreadPool ，默认有 20 个消费线程。\",\"消费线程池的每个消费线程会尝试从消费任务队列中获取消费请求，执行消费业务逻辑 listener.consumeMessage。\",\"消费完成后，如果消费成功，则更新偏移量 updateOffset（先更新到内存 offsetTable，定时上报到 Broker。Broker 端也先放到内存，定时刷盘）。\"]},\"625\":{\"h\":\"参考资料\",\"t\":[\"官方文档——设计\",\"RocketMQ 实战与进阶——丁威\",\"RocketMQ消费消息——白云鹏\",\"消息中间件—RocketMQ消息消费（一）——癫狂侠\",\"RocketMQ 消息接受流程——赵坤\",\"RocketMQ 消息消费——贝贝猫\",\"RocketMQ 5.0 POP 消费模式探秘\",\"RocketMQ消息消费源码分析\",\"Rocketmq消费消息原理——服务端技术栈\",\"RocketMQ——4. Consumer 消费消息——Kong\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"626\":{\"h\":\"RocketMQ 消费者（2）客户端设计和启动流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220827-rocketmq-consumer-2-struct-and-init.html\"]},\"627\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第二篇，介绍消费者相关类与调用关系，同时包含消费者启动流程。 看完本文能够对消息消费涉及到的相关类和消费流程有大体的了解。\"]},\"628\":{\"h\":\"2. 概要设计\"},\"629\":{\"h\":\"2.1 消费者客户端设计\",\"t\":[\"先看一下 RocketMQ 客户端代码中消费者相关的类图。\",\"其中 DefaultMQPullConsumer 和 DefaultMQPushConsumer 就是我们实际消费中需要新建的消费者对象。它们分别实现了消费者接口，扩展了客户端配置类。\",\"新建 DefaultXXXXConsumer 对象时会在内部一个创建 DefaultMQXXXXConsumerImpl 对象。这里使用了代理模式，DefaultXXXXConsumer 对象只是一个壳，内部的大部分方法都通过调用代理 DefaultMQXXXXConsumerImpl 来执行。\",\"DefaultMQXXXXConsumerImpl 实现类中包含了客户端实例 MQClientInstnace ，每个客户端进程一般只有一个这玩意。它的用处很多，比如保存路由和客户端信息，向 Broker 发送请求等。\"]},\"630\":{\"h\":\"2.2 消费者客户端启动\",\"t\":[\"消费者的启动主要涉及上面讲到的 DefaultMQXXXXConsumer、DefaultMQXXXXConsumerImpl 和 MQClientInstnace 这三个类。\"]},\"631\":{\"h\":\"2.2.1 新建消费者\",\"t\":[\"新建消费者时构造 DefaultMQXXXXConsumer 对象，指定队列负载算法，内部构造一个 DefaultMQXXXXConsumerImpl 对象。\",\"DefaultMQXXXXConsumerImpl 设为刚创建状态，并新建重平衡服务 RebalanceService\",\"在首次启动前，DefaultMQXXXXConsumerImpl 对象中的 MQClientInstance 对象还没有被创建出来。\"]},\"632\":{\"h\":\"2.2.2 消费者启动\",\"t\":[\"启动命令也是在 DefaultMQXXXXConsumer 调用并代理到 DefaultMQXXXXConsumerImpl。\",\"此时 DefaultMQXXXXConsumerImpl 会初始化一些服务和参数，然后创建一个 MQClientInstance 对象。\",\"MQClientInstance 对象启动客户端的各种服务（Broker 通信、定时任务、消息拉取、重平衡……）\"]},\"633\":{\"h\":\"3. 详细设计\"},\"634\":{\"h\":\"3.1 消费者客户端类设计\"},\"635\":{\"h\":\"3.1.1 整体类图\"},\"636\":{\"h\":\"3.1.2 消费者接口\",\"t\":[\"由于需要支持拉和推两种消费模式，所以按通常的想法，消费者类的设计中将会有一个消费者接口，然后推消费者和拉消费者接口分别扩展消费者接口。消费者接口提供一些共用方法，拉和推消费者实现拉消费和推消费方法。RocketMQ 就是这样做的。其中 MQConsumer 即消费者接口，扩展 MQAdmin 在这显得有些多余。\",\"MQAdmin 接口提供了客户端的一些基本的管理接口，生产者、消费者和命令工具都扩展了它。\",\"MQConsumer 接口很简单，主要提供了通过 Topic 获取读队列的方法 Set<MessageQueue> fetchSubscribeMessageQueues(final String topic)。\"]},\"637\":{\"h\":\"3.1.3 拉 & 推模式消费者接口\",\"t\":[\"接下来是拉消费者和推消费者接口。\",\"如果我们自己来设计拉 & 推模式消费者接口，需要定义哪些方法？可以想象一下消费时要做的操作，就可以定义出相应的方法。\",\"拉模式消费者的消费步骤为：拉取消息，执行消费逻辑，上报消费进度，如果有需要的话对于消费失败的消息还需要发回 Broker 重新消费。\",\"推模式消费者消费步骤更简单，只需要订阅一个 Topic，然后指定消费回调函数，即可在收到消息时自动消费。\",\"RocketMQ 的拉 & 推模式消费者接口就定义了这些方法，先来看一下类图：\",\"MQPullConsumer\",\"void registerMessageQueueListener(final String topic, final MessageQueueListener listener) 方法注册消息队列变更时的回调方法。\",\"PullResult pull 从 RocketMQ 服务器拉取一批消息。 \",\"MessageQueue：拉取的队列\",\"MessageSelector：消息过滤器\",\"offset：拉取的消息在消费队列中的偏移量\",\"maxNums：最大拉取消息条数\",\"timeout：拉取超时时间\",\"void pull 为异步拉取方法，拉取成功后调用 PullCallback\",\"updateConsumeOffset 更新消息消费偏移量\",\"fetchConsumeOffset 获取消息消费偏移量\",\"sendMessageBack 对于消费失败的消息，发回 Broker 重新消费\",\"MQPushConsumer\",\"subscribe：订阅主题，订阅之后可以收到来自该主题的消息。 \",\"topic：订阅的主题，可以多次调用该方法来订阅多个主题\",\"subExpression：消息过滤表达式\",\"messageSelector：消息选择器，提供了 SQL92 和 Tag 模式的过滤选择功能\",\"unsubscribe：取消订阅\",\"registerMessageListener：用来注册消费监听器，包含两种消费模式：并发消费和顺序消费\"]},\"638\":{\"h\":\"3.1.4 消费者实现\",\"t\":[\"DefaultMQXXXXConsumer 是拉消费者接口 MQXXXXConsumer 的默认实现。这里用到了代理模式，将具体的方法实现都实现在 DefaultMQXXXXConsumerImpl 中，DefaultMQXXXXConsumer 保存了一个 DefaultMQXXXXConsumerImpl 的代理。\",\"DefaultMQXXXXConsumerImpl 实现了 MQConsumerInner 接口，提供了消费者实现的一些公用方法。\",\"DefaultMQXXXXConsumerImpl 中有一个客户端实例的引用 MQClientInstance mqClientFactory，用来与 Broker 通信、保存元数据。\",\"MQClientInstnace：客户端实例，每个客户端进程一般只有一个这玩意。它的用处很多，很多操作最终都是调用它来做的。\",\"保存路由信息\",\"保存生产者消费者组信息\",\"向 Broker 发送请求\",\"启动重平衡\"]},\"639\":{\"h\":\"3.1.5 推模式消费者实现\",\"t\":[\"拉模式消费者需要手动拉取消息进行消费，平平无奇。推模式消费者自动监听推送过来的消息并进行消费，着重讲解。\",\"推模式消费者实际内部也是通过拉取消息的方式进行消息拉取，只不过封装了订阅和监听器这样的对外接口，让用户在使用时感觉像 Broker 主动推送消息到消费者。\",\"在拉消费者背后，有一个线程默默主动拉取消息，才能将拉转换为推，它就是 PullMessageService。此外，推消费者还支持并发消费和顺序消费，RocketMQ 定义了 ConsumeMessageService 接口来执行消息消费，ConsumeMessageConcurrentlyService 和 ConsumeMessageOrderlyService 分别是并发消费和顺序消费的实现。它们内部都定义了一个消费线程池 consumeExecutor 来执行最终的消息消费逻辑。而用户真正编写的只有最终的消费逻辑，即实现 MessageListener 接口的 consumeMessage 方法。\",\"推模式消费者实现相关的类图如下所示：\",\"在图中，展示了消息消费整个流程的调用关系。在系列后面的文章中会详细讲解。\",\"客户端实例中的重平衡服务进行重平衡，生成一个 PullRequest 并调用拉消费者实现类的 executePullRequestImmediately 方法\",\"DefaultMQPushConsumerImpl 调用 PullMessageService 线程的 executePullRequestImmediately 方法，\",\"该方法将 PullRequest 放入待执行的拉取请求队列\",\"PullMessageService 线程阻塞等待请求队列中的拉取请求\",\"收到拉去请求 PullRequest 后就执行拉取消息拉取方法 pullMessage 从 Broker 拉取消息，拉取后执行消费消息逻辑\",\"消费消息逻辑会调用 ConsumeMessageService 的 submitConsumeRequest 方法\",\"该方法将消费消息的请求提交到消费线程池 consumeExecutor\",\"消费线程池执行真正的消息消费逻辑，调用 MessageListener 接口的 consumeMessage 方法\",\"拉取一批消息成功后，将拉取请求 PullRequest 的拉取偏移量更新后再次调用 executePullRequestImmediately 方法，放入拉取队列，重新拉取\"]},\"640\":{\"h\":\"3.2 消费者启动\",\"t\":[\"由于拉模式和推模式消费者的启动流程大致相同，所以只介绍推模式消费者的启动流程。\",\"DefaultMQPushConsumer 的启动方法内部实际是调用其代理类 DefaultMQPushConsumerImpl 的启动方法，他本身的启动方法并没有什么逻辑。\",\"DefaultMQPushConsumerImpl 的启动方法执行的动作如下：\",\"检查是否是刚创建状态，如果是才继续走启动流程\",\"检查消费者配置信息是否合法\",\"将用户的 Topic 订阅信息和重试 Topic 的订阅信息添加到 rebalanceImpl 中的 Map 中\",\"创建和初始化一些对象 \",\"创建或获取已经创建的客户端实例 MQClientInstance\",\"初始化消费者的重平衡实现 RebalanceImpl\",\"创建拉取消息接口调用包装类 PullApiWrapper\",\"注册消息过滤钩子函数列表（如果有的话）\",\"初始化消费进度 \",\"广播模式，消费进度保存在消费者本地 LocalFileOffsetStore\",\"集群模式，消费进度保存在 Broker RemoteBrokerOffsetStore\",\"初始化消息消费服务，消费服务内部维护一个线程池，负责消息消费\",\"将消费者注册到客户端实例对象\",\"启动客户端实例对象\",\"从 Name server 更新 Topic 路由信息（如果路由信息有变化）\",\"将客户端的信息（ID、生产者、消费者信息）上报给 Broker\",\"唤醒重平衡线程 RebalanceService 立即执行重平衡\",\"重平衡后调用拉取消息方法，生成拉取请求 PullRequest 并放入 PullMessageService，开始消费流程\",\"客户端实例 MQClientInstance 的启动流程如下：\",\"更新 Namesrv 地址\",\"启动通信模块 MQClientAPIImpl\",\"启动定时任务（从 Namesrv 拉取路由、向 Broker 发送心跳等）\",\"启动拉取消息服务 PullMessageService\",\"启动重平衡线程 RebalanceService\",\"启动默认生产者（用于将消费失败的消息重新生产到 Broker）\"]},\"641\":{\"h\":\"4. 源码解析\"},\"642\":{\"h\":\"4.1 DefaultMQProducerImpl 启动\",\"t\":[\"// DefaultMQProducerImpl /** * Push 消费者启动 * * @throws MQClientException */ public synchronized void start() throws MQClientException { switch (this.serviceState) { // 检查消费者状态。只有第一次启动才执行，如果二次调用 start 方法会报错 case CREATE_JUST: log.info(\\\"the consumer [{}] start beginning. messageModel={}, isUnitMode={}\\\", this.defaultMQPushConsumer.getConsumerGroup(), this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode()); this.serviceState = ServiceState.START_FAILED; // 检查消费者配置是否合法 this.checkConfig(); // 将用户的 Topic 订阅信息和重试 Topic 的订阅信息添加到 RebalanceImpl 的容器中 this.copySubscription(); if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) { this.defaultMQPushConsumer.changeInstanceNameToPID(); } // 创建客户端实例 this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook); // 初始化 RebalanceImpl this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup()); this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel()); this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()); this.rebalanceImpl.setmQClientFactory(this.mQClientFactory); // 创建拉取消息接口调用包装类 this.pullAPIWrapper = new PullAPIWrapper( mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode()); // 注册消息过滤钩子函数列表 this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList); // 初始化消费进度 if (this.defaultMQPushConsumer.getOffsetStore() != null) { this.offsetStore = this.defaultMQPushConsumer.getOffsetStore(); } else { switch (this.defaultMQPushConsumer.getMessageModel()) { case BROADCASTING: // 广播模式，消费进度保存在消费者本地 this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup()); break; case CLUSTERING: // 集群模式，消费进度保存在 Broker this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup()); break; default: break; } this.defaultMQPushConsumer.setOffsetStore(this.offsetStore); } this.offsetStore.load(); // 初始化消息消费服务 if (this.getMessageListenerInner() instanceof MessageListenerOrderly) { this.consumeOrderly = true; this.consumeMessageService = new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner()); } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) { this.consumeOrderly = false; this.consumeMessageService = new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner()); } this.consumeMessageService.start(); // 注册消费者到客户端实例 boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this); if (!registerOK) { this.serviceState = ServiceState.CREATE_JUST; this.consumeMessageService.shutdown(defaultMQPushConsumer.getAwaitTerminationMillisWhenShutdown()); throw new MQClientException(\\\"The consumer group[\\\" + this.defaultMQPushConsumer.getConsumerGroup() + \\\"] has been created before, specify another name please.\\\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL), null); } // 启动客户端实例 mQClientFactory.start(); log.info(\\\"the consumer [{}] start OK.\\\", this.defaultMQPushConsumer.getConsumerGroup()); this.serviceState = ServiceState.RUNNING; break; case RUNNING: case START_FAILED: case SHUTDOWN_ALREADY: throw new MQClientException(\\\"The PushConsumer service state not OK, maybe started once, \\\" + this.serviceState + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK), null); default: break; } // 从 Namesrv 更新路由信息 this.updateTopicSubscribeInfoWhenSubscriptionChanged(); this.mQClientFactory.checkClientInBroker(); // 将客户端信息上报给 Broker this.mQClientFactory.sendHeartbeatToAllBrokerWithLock(); // 唤醒重平衡线程，立即执行重平衡 this.mQClientFactory.rebalanceImmediately(); } \"]},\"643\":{\"h\":\"4.2 MQClientInstance 启动\",\"t\":[\"// MQClientInstance.java /** * 启动客户端代理 * * @throws MQClientException */ public void start() throws MQClientException { synchronized (this) { switch (this.serviceState) { case CREATE_JUST: this.serviceState = ServiceState.START_FAILED; // If not specified,looking address from name server if (null == this.clientConfig.getNamesrvAddr()) { this.mQClientAPIImpl.fetchNameServerAddr(); } // 启动通信模块 this.mQClientAPIImpl.start(); // 启动定时任务（从 Namesrv 拉取路由、向 Broker 发送心跳等） this.startScheduledTask(); // 启动拉取消息服务 this.pullMessageService.start(); // 启动重平衡线程 this.rebalanceService.start(); // 启动默认生产者（用于将消费失败的消息重新生产到 Broker） this.defaultMQProducer.getDefaultMQProducerImpl().start(false); log.info(\\\"the client factory [{}] start OK\\\", this.clientId); this.serviceState = ServiceState.RUNNING; break; case START_FAILED: throw new MQClientException(\\\"The Factory object[\\\" + this.getClientId() + \\\"] has been created before, and failed.\\\", null); default: break; } } } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"644\":{\"h\":\"RocketMQ 消费者（3）重平衡 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220830-rocketmq-consumer-3-rebalance.html\"]},\"645\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第三篇，介绍消费者重平衡。\",\"我把 RocketMQ 消费分成如下几个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"其中重平衡是消费者开始消费的起点。\"]},\"646\":{\"h\":\"1.1 重平衡的含义\",\"t\":[\"RocketMQ 的 Topic 设计成有多个 Queue，被多个消费者同时消费来加快消费速率。\",\"在多个消费者同时消费一个 Topic 时，其中的每个 Queue 只能同时被一个消费者消费。在消费者数量变化时，将 Queue 分配给消费者进行消费的动作即重平衡。\"]},\"647\":{\"h\":\"2. 概要设计\",\"t\":[\"RocketMQ 的重平衡大致实现方式为：在消费者端用一个固定的分配策略将所有的消费队列分配给所有的消费者。通过将每个消费者的分配策略设置成一致，并且将消费者和消费队列排序的方法，保证每个消费者的分配的结果幂等。\"]},\"648\":{\"h\":\"2.1 重平衡的触发\",\"t\":[\"RocketMQ 的重平衡在消费端完成。唯一的触发点是一个重平衡线程，触发方式分主动触发和定时触发。\",\"主动触发：消费者数量发生变化\",\"推模式消费者启动或恢复时，唤醒本地的重平衡线程，立即重平衡。在这之前还上报心跳让 Broker 感知到新消费者启动，发送请求让所有消费者重平衡。\",\"消费者关机时，向 Broker 发请求解除注册。Broker 收到请求后发送请求让其他消费者重平衡。\",\"主动触发模式可以通过以下配置来关闭，当消费者数量很多，或者频繁上下线时，为了防止频繁进行重平衡，建议关闭主动触发。 \",\"Broker 级别配置：notifyConsumerIdsChangedEnable（broker.conf）\",\"消费组级别配置：notifyConsumerIdsChangedEnable（通过 updateSubGroup 命令设置）\",\"只要有一个为 false，就不会进行对应消费组的重平衡主动触发。\",\"定时触发：重平衡线程每 20s 触发一次重平衡。\"]},\"649\":{\"h\":\"2.2 重平衡类设计\",\"t\":[\"重平衡主要涉及两个类：重平衡实现 RebalanceImpl 和重平衡线程 RebalanceService\",\"重平衡线程：客户端实例持有，每个客户端进程一般只有一个，负责定时或者立即触发重平衡。但它只负责触发，重平衡的实际逻辑在实现类中。\",\"重平衡实现： \",\"RebalanceImpl 中保存了消费者负载的消息队列、重分配策略，并实现了重分配的方法（调用重平衡策略）。\",\"每个消费者持有一个重平衡实现，根据推和拉模式的不同，分别在 RebalanceImpl 的基础上新实现了推模式和拉模式的重平衡实现。\"]},\"650\":{\"h\":\"2.3 重平衡流程\",\"t\":[\"消费者按 Topic 维度进行重平衡。\",\"从本地缓存中获取 Topic 的所有 Queue\",\"向 Broker 获取所有消费者\",\"按预设的策略将队列分配给消费者\",\"判断自己分配到的队列是否变化 \",\"如果变化则丢弃老队列，开始拉取新队列，并将订阅关系上报到 Broker\",\"RocketMQ 的重平衡流程在消费者端完成，但是由 Broker 端发送信号给所有消费者触发。\"]},\"651\":{\"h\":\"3. 详细设计\",\"t\":[\"RocketMQ 的重平衡在客户端（即消费者端）完成。\",\"RocketMQ 5.0 中的 POP 消费者特性 支持将重平衡流程在服务端实现，解决了消费端异常 Hang 住时其负载的队列可能会堆积的问题。\"]},\"652\":{\"h\":\"3.1 重平衡实现类 RebalanceImpl\",\"t\":[\"RebalanceImpl 类中实现了整个重平衡流程。\"]},\"653\":{\"h\":\"3.1.1 域\",\"t\":[\"RabalanceImpl 类保存一些重平衡需要的基本信息。\",\"subscriptionInner：消费者订阅的所有 Topic。重平衡时遍历这些 Topic 进行重平衡。\",\"topicSubscribeInfoTable：Topic 下的所有队列。重平衡时对这些队列应用重分配策略进行分配。\",\"processQueueTable：该消费者负载的所有消息队列。重平衡完成后，对比之前的负载来判断是否要改变队列进行消息拉取。\",\"此外还有一个重要的域即重分配策略类 allocateMessageQueueStrategy，同一消费组中的每个消费者应保持一致，以保证重分配的结果一致。\"]},\"654\":{\"h\":\"3.1.2 方法\",\"t\":[\"重平衡实现类中包含重平衡的一系列逻辑，由抽象类直接实现。\",\"重平衡方法 doRebalance\",\"重平衡方法会可以细分为对每个 Topic 进行重平衡的方法 rebalanceByTopic\",\"对 Topic 进行重平衡后需要判断并更新消费者的负载，方法为 updateProcessQueueTableInRebalance\",\"此外还包含了一些抽象方法，根据消费者类型不同有着不同的实现。\",\"messageQueueChange：负载的消息队列发生变化时调用\",\"dispatchPullRequest：分发拉取请求到消息拉取服务，开始拉取消息\",\"removeUnnecessaryMessageQueue：将重平衡后丢弃的消费队列移除\"]},\"655\":{\"h\":\"3.2 重平衡流程\"},\"656\":{\"h\":\"3.2.1 重平衡触发\",\"t\":[\"我把重平衡的触发分为主动触发和被动触发，主动触发是由消费者的启动和停止触发的；而被动触发一般是其他消费者每 20s 进行检查或者是收到 Broker 发送的重平衡请求时触发。\",\"上图中标识了 4 个触发点。黄色为主动触发，蓝色为被动触发。\",\"消费者启动时（ start() ）先向 Broker 发送心跳（触发点 4），然后调用 rebalanceImmediately() 方法，立即唤醒重平衡线程执行本地重平衡。\",\"消费者停止时（shutdown()） \",\"Broker 发送请求解除注册\",\"Broker 处理之后再向每个消费者发送消费者数量变化消息\",\"所有消费者收到后唤醒重平衡线程进行重平衡\",\"被动触发，重平衡线程 RebalanceService 每等待 20s 进行一次重平衡\",\"其他消费者收到消费者数量变化请求时进行重平衡。与触发点 2 类似，都是消费者收到 Broker 请求后触发。\",\"RocketMQ 中主要有 3 种消费者实现，它们的重平衡触发也不太相同。上面主要讲的是推模式消费者 DefaultMQPushConsumer 的重平衡触发流程。此外还有两个拉模式消费者。\",\"DefaultMQPullConsumer：封装很原始的消费者，已经被标记为 @Deprecated。只有指定队列进行拉取的接口。\",\"它没有订阅 Topic 的方法，在启动和停止时也不会向 Broker 发送心跳标识消费者的数量变化。\",\"在每次拉取消息时（pull()）会更新订阅的 Topic，也会启动重平衡线程每 20s 进行重平衡。也就是说在第一次拉取消息之后的 20s 内可能会进行重平衡。\",\"一般不会用到该消费者的重平衡机制。\",\"DefaultLitePullConsumer：仿照 kafka 消费者的 API 实现的新消费者，后台有线程拉取消息进行缓存，可以做到比推模式消费者更高的拉取效率。\",\"在订阅 Topic 时（subscribe()）会向 Broker 发送心跳请求，此时就开始重平衡。\",\"在停止时（shutdown()）向 Broker 发送注销请求，此时也会触发重平衡。\",\"重平衡线程每 20s 进行重平衡的检查。\",\"可以看出该拉模式消费者与推模式消费者的重平衡机制比较类似，可以进行重平衡。\"]},\"657\":{\"h\":\"3.2.2 重平衡流程\",\"t\":[\"重平衡线程调用客户端实例的重平衡方法 doRebalance 进行重平衡，客户端实例的该方法没有具体逻辑，仅仅是遍历客户端上注册的所有消费者，获取它们的重平衡实现并且调用 RebalanceImpl#doRebalance 方法。\",\"该方法逻辑如下：\",\"rebalanceByTopic：从本地缓存中获取该消费者订阅的所有 Topic，对每个 Topic 进行重平衡 \",\"从本地缓存中获取该 Topic 的所有消息队列\",\"发送请求到 Broker，获取该消费组下所有的消费者（ID）\",\"将消息队列和消费者 ID 排序（用来保证每个消费者执行同样的重平衡流程得到的结果一致，刚好能完全分配队列给所有消费者）\",\"执行分配策略的重分配方法，获取自己分配到的消息队列\",\"updateProcessQueueTableInRebalance：更新自己需要拉取的处理队列 \",\"遍历本地缓存的消费者分到的消息队列，判断要丢弃的队列并丢弃\",\"computePullFromWhereWithException：计算并从偏移量存储中读取下次拉取的偏移量\",\"遍历新分配的消息队列，对于新分配的，添加处理队列并创建 PullRequest 启动拉取\",\"dispatchPullRequest：将新建的 PullRequest 加入消息拉取线程 PullMessageService，开始拉取\",\"messageQueueChanged：将新的队列订阅关系通过发送心跳请求上报给 Broker \",\"更新订阅数据版本号\",\"设置 Topic 维度拉取流控\",\"发送心跳给 Broker 更新队列订阅关系\",\"重新分配之后，移除不再属于当前实例的消息队列和处理队列\",\"这里的处理队列指 ProcessQueue，用来临时存放拉取到待消费的消息，与消息队列一一对应。\",\"拉取请求 PullRequest，每个队列只会新建一个，重复使用。每次拉取完一次后将拉取请求重新放入拉取服务的等待队列 pullRequestQueue，进行下一次拉取。初始化 PullRequest 的地方只有一个，就是重平衡实现 RebalanceImpl，也就是说重平衡是消息拉取唯一的起点。\"]},\"658\":{\"h\":\"3.3 重平衡队列分配策略\",\"t\":[\"RocketMQ 提供了 6 中重平衡策略（队列分配策略）\",\"AllocateMessageQueueAveragely：（默认）平均分配，推荐使用。\",\"AllocateMessageQueueAveragelyByCircle：环形寻论平均分配，推荐使用。\",\"AllocateMessageQueueConsistentHash：一致性哈希。\",\"AllocateMessageQueueByConfig：根据配置，为每个消费者配置固定的消息队列。\",\"AllocateMessageQueueByMachineRoom：根据 Broker 配置的机房名，对每隔消费者负载不同 Broker 上的队列。\"]},\"659\":{\"h\":\"4. 源码解析\"},\"660\":{\"h\":\"4.1 RebalanceService 重平衡线程\",\"t\":[\"public class RebalanceService extends ServiceThread { // ... @Override public void run() { log.info(this.getServiceName() + \\\" service started\\\"); while (!this.isStopped()) { // 等待 20s，调用 ServiceThread#wakeup() 方法可以直接跳过等待 this.waitForRunning(waitInterval); // 每隔 20s 对所有消费者执行一次重平衡检查 this.mqClientFactory.doRebalance(); } log.info(this.getServiceName() + \\\" service end\\\"); } } \"]},\"661\":{\"h\":\"4.2 RebalanceImpl 重平衡实现\"},\"662\":{\"h\":\"4.2.1 doRebalance 重平衡入口\",\"t\":[\"/** * 消费者重平衡 * 获取全部的订阅信息，从订阅信息中找到所有的 Topic，每一个 Topic 的队列进行重平衡 */ public void doRebalance(final boolean isOrder) { Map<String, SubscriptionData> subTable = this.getSubscriptionInner(); if (subTable != null) { // 遍历每个 Topic 的订阅信息 for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) { final String topic = entry.getKey(); try { // 对每个主题的队列进行重平衡 this.rebalanceByTopic(topic, isOrder); } catch (Throwable e) { if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"rebalanceByTopic Exception\\\", e); } } } } // 重新分配之后，移除不再属于当前实例的MessageQueue和ProcessQueue this.truncateMessageQueueNotMyTopic(); } \"]},\"663\":{\"h\":\"4.2.2 rebalanceByTopic 对 Topic 进行重平衡\",\"t\":[\"/** * 根据 Topic 重新进行 MessageQueue 负载（重平衡） * * @param topic */ private void rebalanceByTopic(final String topic, final boolean isOrder) { switch (messageModel) { case BROADCASTING: { Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic); if (mqSet != null) { boolean changed = this.updateProcessQueueTableInRebalance(topic, mqSet, isOrder); if (changed) { this.messageQueueChanged(topic, mqSet, mqSet); log.info(\\\"messageQueueChanged {} {} {} {}\\\", consumerGroup, topic, mqSet, mqSet); } } else { log.warn(\\\"doRebalance, {}, but the topic[{}] not exist.\\\", consumerGroup, topic); } break; } case CLUSTERING: { // 从客户端缓存表中获取 Topic 对应的队列信息 Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic); // 从 Broker 获取当前消费组内所有消费者的客户端 ID List<String> cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup); if (null == mqSet) { if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"doRebalance, {}, but the topic[{}] not exist.\\\", consumerGroup, topic); } } if (null == cidAll) { log.warn(\\\"doRebalance, {} {}, get consumer id list failed\\\", consumerGroup, topic); } if (mqSet != null && cidAll != null) { // Topic 下的所有队列 List<MessageQueue> mqAll = new ArrayList<MessageQueue>(); mqAll.addAll(mqSet); // 对该 Topic 下的所有队列和消费者列表进行排序，保证所有消费者分配的结果一致 Collections.sort(mqAll); Collections.sort(cidAll); // 分配策略 AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy; // 按策略分配，得到分配给当前消费者实例的队列列表 List<MessageQueue> allocateResult = null; try { allocateResult = strategy.allocate(// this.consumerGroup, // 消费组 this.mQClientFactory.getClientId(), // 当前消费者ID mqAll,// Topic下所有的MessageQueue cidAll); //当前Topic下，当前消费组中所有的消费者ID } catch (Throwable e) { log.error(\\\"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName={}\\\", strategy.getName(), e); return; } // 得到重平衡后的该消费者分到的消息队列 Set Set<MessageQueue> allocateResultSet = new HashSet<MessageQueue>(); if (allocateResult != null) { allocateResultSet.addAll(allocateResult); } // 对比分配给自己的消息队列是否发生变化 boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder); if (changed) { log.info( \\\"rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}\\\", strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(), allocateResultSet.size(), allocateResultSet); // 回调 MessageQueue 变化事件， this.messageQueueChanged(topic, mqSet, allocateResultSet); } } break; } default: break; } } \"]},\"664\":{\"h\":\"4.2.3 updateProcessQueueTableInRebalance 重平衡后更新订阅的队列和处理队列表\",\"t\":[\"/** * 重平衡后更新 ProcessQueue 表 * 丢弃不再消费的队列，为新增的队列新建 ProcessQueue 和 PullRequest * * @param topic 主题 * @param mqSet 重平衡后该消费者新分配到的的消息队列 * @param isOrder * @return */ private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet, final boolean isOrder) { boolean changed = false; // 遍历本地缓存的消费者分到的消息队列，判断要丢弃的队列并丢弃 Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator(); while (it.hasNext()) { Entry<MessageQueue, ProcessQueue> next = it.next(); MessageQueue mq = next.getKey(); ProcessQueue pq = next.getValue(); if (mq.getTopic().equals(topic)) { // 如果新分配到的消息队列集合中不含有老的消息队列，丢弃老的处理队列 if (!mqSet.contains(mq)) { // 该 ProcessQueue 中不会有消息被消费 pq.setDropped(true); // 移除消费队列，移除前持久化 if (this.removeUnnecessaryMessageQueue(mq, pq)) { it.remove(); changed = true; log.info(\\\"doRebalance, {}, remove unnecessary mq, {}\\\", consumerGroup, mq); } } else if (pq.isPullExpired()) { /** * 如果Reblance之后的mq集合包含该MessageQueue,但是ProcessQueue已经太久没有拉取数据（上次拉取消息的时间距离现在超过设置时间） */ switch (this.consumeType()) { case CONSUME_ACTIVELY: break; case CONSUME_PASSIVELY: /** * PushConsumer为被动消费 * 如果是PUSH，则丢弃ProcessQueue * 同时删除MessageQueue */ pq.setDropped(true); if (this.removeUnnecessaryMessageQueue(mq, pq)) { it.remove(); changed = true; log.error(\\\"[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it\\\", consumerGroup, mq); } break; default: break; } } } } // 遍历新分配的 MessageQueue，对于新分配的，创建 PullRequest 启动拉取 List<PullRequest> pullRequestList = new ArrayList<PullRequest>(); // 为每个 MessageQueue 新建一个 PullRequest for (MessageQueue mq : mqSet) { if (!this.processQueueTable.containsKey(mq)) { // 本地缓存的 ProcessQueue 中不包含，表示新增队列 if (isOrder && !this.lock(mq)) { log.warn(\\\"doRebalance, {}, add a new mq failed, {}, because lock failed\\\", consumerGroup, mq); continue; } // 从内存中移除该 MessageQueue 的消费进度（老的进度不需要） this.removeDirtyOffset(mq); ProcessQueue pq = new ProcessQueue(); // 计算当前 MessageQueue 应该从哪里开始拉取消息 long nextOffset = -1L; try { // 计算并从偏移量存储中读取下次拉取的偏移量 nextOffset = this.computePullFromWhereWithException(mq); } catch (Exception e) { log.info(\\\"doRebalance, {}, compute offset failed, {}\\\", consumerGroup, mq); continue; } if (nextOffset >= 0) { // 添加 MessageQueue 和 ProcessQueue 的映射关系 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq); if (pre != null) { log.info(\\\"doRebalance, {}, mq already exists, {}\\\", consumerGroup, mq); } else { // 添加成功，创建新的 PullRequest // 唯一的创建 PullRequest 的地方 log.info(\\\"doRebalance, {}, add a new mq, {}\\\", consumerGroup, mq); PullRequest pullRequest = new PullRequest(); pullRequest.setConsumerGroup(consumerGroup); pullRequest.setNextOffset(nextOffset); pullRequest.setMessageQueue(mq); pullRequest.setProcessQueue(pq); pullRequestList.add(pullRequest); changed = true; } } else { log.warn(\\\"doRebalance, {}, add new mq failed, {}\\\", consumerGroup, mq); } } } // 将新建的 PullRequest 加入消息拉取线程 PullMessageService，开始拉取 this.dispatchPullRequest(pullRequestList); return changed; } \"]},\"665\":{\"h\":\"4.2.4 MessageQueueChanged\",\"t\":[\"// RebalancePushImpl.java /** * 如果消费的 MessageQueue 变化，上报 Broker，将订阅关系发送给 Broker * @param topic * @param mqAll * @param mqDivided */ @Override public void messageQueueChanged(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided) { /** * When rebalance result changed, should update subscription's version to notify broker. * Fix: inconsistency subscription may lead to consumer miss messages. */ SubscriptionData subscriptionData = this.subscriptionInner.get(topic); long newVersion = System.currentTimeMillis(); log.info(\\\"{} Rebalance changed, also update version: {}, {}\\\", topic, subscriptionData.getSubVersion(), newVersion); subscriptionData.setSubVersion(newVersion); int currentQueueCount = this.processQueueTable.size(); if (currentQueueCount != 0) { // Topic 维度流控，默认为 -1，即不流控 int pullThresholdForTopic = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdForTopic(); if (pullThresholdForTopic != -1) { int newVal = Math.max(1, pullThresholdForTopic / currentQueueCount); log.info(\\\"The pullThresholdForQueue is changed from {} to {}\\\", this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdForQueue(), newVal); // 设置每个队列的拉取流控 this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().setPullThresholdForQueue(newVal); } // Topic 维度拉取大小流控 int pullThresholdSizeForTopic = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdSizeForTopic(); if (pullThresholdSizeForTopic != -1) { int newVal = Math.max(1, pullThresholdSizeForTopic / currentQueueCount); log.info(\\\"The pullThresholdSizeForQueue is changed from {} to {}\\\", this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdSizeForQueue(), newVal); this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().setPullThresholdSizeForQueue(newVal); } } // notify broker this.getmQClientFactory().sendHeartbeatToAllBrokerWithLock(); } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"666\":{\"h\":\"RocketMQ 消费者（4）消息拉取 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220904-rocketmq-consumer-4-pull-message.html\"]},\"667\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第四篇，介绍消息拉取的流程。\",\"RocketMQ 的消费主要分推和拉两个模式，拉模式主动拉取消息，整个逻辑比较简单。本文着重介绍推模式下，消费者客户端如何实现通过拉取来模拟推的效果，让消息看似主动从 Broker 推送到客户端。\",\"我把 RocketMQ 消费分成如下几个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"本文会涉及 2 和 3 这两个步骤。\"]},\"668\":{\"h\":\"2. 概要设计\"},\"669\":{\"h\":\"2.1 交互流程\",\"t\":[\"异步拉取消息的流程主要分为 3 步\",\"消费者组装拉取请求（包含队列信息、要拉取的逻辑偏移量、最大拉取的消息数量），发送给 Broker 端\",\"Broker 处理拉取请求，从存储中查询要被拉取的消息返回相应给消费者\",\"消费者的处理线程池处理拉取完成的回调，将消息从拉取到的响应中解码出来，放入消费队列，让消费服务消费。\"]},\"670\":{\"h\":\"2.2 客户端拉取流程设计\"},\"671\":{\"h\":\"2.2.1 拉模式消费者拉取\",\"t\":[\"拉模式消费者由于需要主动进行拉取，所以拉取流程并不复杂。\",\"拉取模式消费者提供了同步和异步的拉取方法，用户主动发起拉取，并对拉取到的消息进行消费处理。\"]},\"672\":{\"h\":\"2.2.2 推模式消费者拉取\",\"t\":[\"推模式消费也是通过拉取消息请求来拉取消息，通过客户端的封装让用户使用时感觉像是 Broker 主动将消息推给消费者。\",\"客户端实例包含一个消息拉取线程，客户端实例中的所有推模式消费者共用这个拉取线程。\",\"消息拉取线程用了生产-消费模式，内部有一个阻塞队列，存放消费者的拉取请求；运行的时候不断尝试从队列中取出拉取请求执行消息拉取动作。\",\"拉取请求从哪放入阻塞队列？上一篇重平衡篇有提到，重平衡将为消费者负载的队列创建拉取请求并放入队列，后续不会新建而是重复使用这个拉取请求，取出执行一次，拉取完成之后更新拉取偏移量，再将它重新放入队列。\",\"拉取到的消息存放在哪？每个消息队列会对应创建一个处理队列，拉取成功后将拉取到的消息存入处理队列，然后提交给消息消费服务处理。\"]},\"673\":{\"h\":\"2.3 Broker 端拉取流程设计\",\"t\":[\"Broker 端收到拉取请求后要做的就是将消息从磁盘中查询出来，封装后返回给客户端。\",\"根据队列找到对应的消费队列，读取消费队列判断是否有消息可以消费，如果有则根据消费队列中的索引项，用物理偏移量从消息存储中查找消息。\"]},\"674\":{\"h\":\"3. 详细设计\"},\"675\":{\"h\":\"3.1 相关类设计\",\"t\":[\"以下为推模式下消息消费者端拉取相关类设计，拉模式不涉及自动拉取消息。\",\"在消费者端需要处理拉取请求的发送和 Broker 端拉取结果的响应。\",\"RocketMQ 用单独的一个拉取消息线程 PullMessageService 来处理消息拉取，这个线程仅仅是异步发送自动拉取请求，并不负责请求处理，所以整个客户端实例只需要一个共用线程就足够了。拉取消息服务最终会调用 DefaultMQPushConsumerImpl 中的拉取方法实现 pullMessage 来真正发送拉取请求。\",\"消费者收到 Broker 端响应后会调用 PullCallback 接口，该逻辑由 NettyRemotingClient 的 publicExecutor 线程池执行，默认有 4 个线程。\",\"为了能够先后分别处理多个队列的拉取，拉取线程中应用了生产-消费模式，用阻塞队列 pullRequestQueue 存放其他地方（重平衡、上次拉取完成）用 executePullRequestImmediately() 提交的拉取请求 PullRequest。内部不断尝试从阻塞队列中获取拉去请求进行拉取操作。\",\"由于每个队列每次拉取所需要的元信息几乎没什么变化，只需要改变下次拉取的偏移量即可，所以并没有选择每次都创建新的 PullRequest ，而是不断重用在重平衡中创建的同一个 PullRequest 进行拉取。\",\"拉取到的消息会暂存在处理队列 ProcessQueue 中，其内用 TreeMap 保存这些消息，key 是消息在队列中的逻辑偏移量，value 是拉取到的消息。这样可以保证消息的顺序。\",\"消息消费服务从处理队列中获取消息并消费。\"]},\"676\":{\"h\":\"3.2 整体流程\",\"t\":[\"下图表示推模式消费者的消息拉取流程。整个流程分 3 个步骤\",\"左边 Client 部分为客户端发送拉取请求\",\"右边 Broker 部分为 Broker 端处理拉取请求从存储中查询消息返回\",\"橙色 PullCallback 部分为 客户端处理返回的消息\"]},\"677\":{\"h\":\"3.2.1 消费者拉取消息\"},\"678\":{\"h\":\"3.2.1.1 PullMessageService\",\"t\":[\"消费者使用消息拉取线程 PullMessageService 拉取消息，该线程中用生产-消费模式，run 方法不断从阻塞队列中读取拉取请求来执行拉取。每个拉取请求对应拉取一个消息队列的消息。\",\"拉取请求放入阻塞队列的时机主要有三个\",\"重平衡会创建拉取请求\",\"消息拉取逻辑处理完成会更新拉取请求下次拉取的偏移量，然后重新放入队列\",\"消费速度太慢，消息拉取被流控，会等待一段时间后将拉取请求放入队列\"]},\"679\":{\"h\":\"3.2.1.2 DefaultMQPushConsumerImpl\",\"t\":[\"从阻塞队列中获取拉取请求之后，会调用 DefaultMQPushConsumerImpl#pullMessage() 方法\",\"从拉取请求中获取处理队列 ProcessQueue，检查队列是否被丢弃和消费者是否挂起\",\"消息拉取流控检查，检查处理队列中还未被消费的消息，从待消费消息数量、大小和待消费消息偏移量差来判断。如果需要流控则延迟 50ms 后将拉取请求重新放入队列\",\"获取队列的订阅信息，准备构造拉取请求\",\"创建拉取消息成功的回调\",\"判断是否需要提交偏移量，查询偏移量\",\"构造消息拉取系统标记\",\"调用 PullAPIWrapper#pullKernelImpl 与服务端交互拉取消息\"]},\"680\":{\"h\":\"3.2.1.3 PullApiWrapper\",\"t\":[\"根据消息队列从本地缓存查询对应的 Broker 地址，如果查不到则请求 Name server 查询\",\"构造查询请求\",\"调用客户端 API 实现发送请求\"]},\"681\":{\"h\":\"3.2.1.4 MQClientAPIImpl\",\"t\":[\"根据请求发送的交互模式（单向/同步/异步）发送请求。\",\"推模式消费者的拉取为异步调用\"]},\"682\":{\"h\":\"3.2.2 Broker 端处理拉取请求\"},\"683\":{\"h\":\"3.2.2.1 PullMessageProcessor\",\"t\":[\"processRequest 方法处理客户端的消息拉取请求\",\"前置检查\",\"消息过滤相关逻辑\",\"从消息存储查询消息\",\"计算下次拉取建议的 Broker 地址，设置到返回体\",\"根据从存储查询消息的结果 \",\"如果找到消息，将消息放入返回体\",\"如果没有找到，执行长轮询逻辑，长轮询相关介绍见本文\",\"如果没有这个队列，发送异常消息\",\"执行消息轨迹的消费钩子\",\"存储消费者消费进度：如果 CommitLog 可用且当前节点为主节点，则更新消费进度\"]},\"684\":{\"h\":\"3.2.2.2 DefaultMessageStore\",\"t\":[\"从消息存储中查询需要拉取的一批消息\",\"找到对应的消费队列索引\",\"获取消费队列最大和最小的逻辑偏移量\",\"将要拉取的偏移量与上述偏移量比较，判断拉取结果。只有拉取偏移量大于等于最小偏移量、小于最大偏移量时才能正常拉取，否则返回错误\",\"遍历消费队列索引，最多遍历 maxNum 个（消息拉取最大数量）\",\"根据消费队列索引从 CommitLog 中查询消息\",\"返回查询结果\"]},\"685\":{\"h\":\"3.2.3 消费者拉取成功结果处理\",\"t\":[\"在 NettyRemotingClient 的处理线程池中处理异步请求完成的回调，默认有 4 个线程。\",\"将拉取到的消息解码，过滤\",\"根据拉取的状态进行判断，如果拉取成功才执行下述操作\",\"为拉取请求设置下次拉取的偏移量\",\"更新统计数据\",\"将拉取到的消息放入处理队列\",\"将处理队列让消息消费服务处理\",\"将拉取请求放入拉取线程继续下次拉取\"]},\"686\":{\"h\":\"4. 源码解析\"},\"687\":{\"h\":\"4.1 消费者拉取消息\"},\"688\":{\"h\":\"4.1.1 PullMessageService 消息拉取线程\",\"t\":[\"RocketMQ 封装的服务线程，不断执行 run() 方法\",\"// 拉取请求队列，阻塞队列 private final LinkedBlockingQueue<PullRequest> pullRequestQueue = new LinkedBlockingQueue<PullRequest>(); /** * 立即执行拉取消息请求（立即将拉取请求放入队列） * 每个 MessageQueue 复用一个拉取请求 PullRequest * 在如下位置被调用 * - 重平衡完 * - 一次拉取任务执行完 * * @param pullRequest */ public void executePullRequestImmediately(final PullRequest pullRequest) { try { this.pullRequestQueue.put(pullRequest); } catch (InterruptedException e) { log.error(\\\"executePullRequestImmediately pullRequestQueue.put\\\", e); } } public void run() { log.info(this.getServiceName() + \\\" service started\\\"); // 如果是启动状态，无限循环。stopped 是 volatile 的变量 while (!this.isStopped()) { try { // 从拉取请求队列中获取一个拉取请求 PullRequest pullRequest = this.pullRequestQueue.take(); // 执行拉取消息请求，拉取消息 this.pullMessage(pullRequest); } catch (InterruptedException ignored) { } catch (Exception e) { log.error(\\\"Pull Message Service Run Method exception\\\", e); } } log.info(this.getServiceName() + \\\" service end\\\"); } \"]},\"689\":{\"h\":\"4.1.2 PullRequest 消息拉取请求\",\"t\":[\"消息拉取请求主要包含拉取消息所需要的元数据\",\"/** * 拉取请求，为推模式消费者服务，在 {@link PullMessageService} 中保存和指定 */ public class PullRequest { // 消费者组 private String consumerGroup; // 待拉取的消费队列 private MessageQueue messageQueue; // 消息处理队列，从 Broker 中拉取到的消息会先存入 ProcessQueue，再提交到消费者消费线程池进行消费 private ProcessQueue processQueue; // 待拉取的 MessageQueue 偏移量 private long nextOffset; // ... } \"]},\"690\":{\"h\":\"4.1.3 DefaultMQPushConsumerImpl\",\"t\":[\"推消费者实现\",\"/** * 拉取消息入口 * * @param pullRequest 拉取请求，包含需要拉取的消费队列信息 */ public void pullMessage(final PullRequest pullRequest) { // 获取待拉取的消费队列 final ProcessQueue processQueue = pullRequest.getProcessQueue(); // 如果该队列被丢弃，返回 if (processQueue.isDropped()) { log.info(\\\"the pull request[{}] is dropped.\\\", pullRequest.toString()); return; } // 设置该队列的最新拉取时间为当前时间 pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis()); try { this.makeSureStateOK(); } catch (MQClientException e) { log.warn(\\\"pullMessage exception, consumer state not ok\\\", e); this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); return; } // 如果当前消费者被挂起，延迟1s后再拉取 if (this.isPause()) { log.warn(\\\"consumer was paused, execute pull request later. instanceName={}, group={}\\\", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup()); this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND); return; } // ====== 流控 begin ====== long cachedMessageCount = processQueue.getMsgCount().get(); long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024); // 消息消费数量流控，当前处理消息数量大于1000，触发流控 if (cachedMessageCount > this.defaultMQPushConsumer.getPullThresholdForQueue()) { // 放弃本次拉取，延迟50ms之后重新拉取 this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); if ((queueFlowControlTimes++ % 1000) == 0) { log.warn( \\\"the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}\\\", this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes); } return; } // 消息消费大小流控，当前消费消息超过100MB，触发流控 if (cachedMessageSizeInMiB > this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) { // 放弃本次拉取，延迟50ms之后重新拉取 this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); if ((queueFlowControlTimes++ % 1000) == 0) { log.warn( \\\"the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}\\\", this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes); } return; } if (!this.consumeOrderly) { // 消息消费偏移量间隔流控，大于2000，触发流控 if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) { this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) { log.warn( \\\"the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}\\\", processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(), pullRequest, queueMaxSpanFlowControlTimes); } return; } } else { // 处理顺序消费 if (processQueue.isLocked()) { if (!pullRequest.isPreviouslyLocked()) { long offset = -1L; try { offset = this.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue()); } catch (Exception e) { this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.error(\\\"Failed to compute pull offset, pullResult: {}\\\", pullRequest, e); return; } boolean brokerBusy = offset < pullRequest.getNextOffset(); log.info(\\\"the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}\\\", pullRequest, offset, brokerBusy); if (brokerBusy) { log.info(\\\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}\\\", pullRequest, offset); } pullRequest.setPreviouslyLocked(true); pullRequest.setNextOffset(offset); } } else { this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.info(\\\"pull message later because not locked in broker, {}\\\", pullRequest); return; } } // ====== 流控 end ====== // 拉取该主题订阅信息 final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic()); // 如果为空，延迟3s后拉取 // 由于并发关系，即使找不到订阅关系，也要重试下，防止丢失PullRequest if (null == subscriptionData) { this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.warn(\\\"find the consumer's subscription failed, {}\\\", pullRequest); return; } final long beginTimestamp = System.currentTimeMillis(); // 从Broker拉取完成的回调函数 PullCallback pullCallback = new PullCallback() { // ... }; // 偏移量提交计算 boolean commitOffsetEnable = false; long commitOffsetValue = 0L; if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) { commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY); if (commitOffsetValue > 0) { commitOffsetEnable = true; } } // ====== 消息过滤相关 ====== String subExpression = null; boolean classFilter = false; // 获取订阅数据，包含过滤信息 SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic()); if (sd != null) { // 如果不是类过滤模式，设置过滤表达式 if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() && !sd.isClassFilterMode()) { subExpression = sd.getSubString(); } classFilter = sd.isClassFilterMode(); } // 根据过滤类型构建拉取时的系统标记 int sysFlag = PullSysFlag.buildSysFlag( commitOffsetEnable, // commitOffset true, // suspend subExpression != null, // subscription classFilter // class filter ); // 从服务端拉取 try { this.pullAPIWrapper.pullKernelImpl( pullRequest.getMessageQueue(), // 从那个消费队列拉取消息 subExpression, // 消息过滤表达式 subscriptionData.getExpressionType(), // 消息表达式类型：TAG/SQL92 subscriptionData.getSubVersion(), // pullRequest.getNextOffset(), // 消息拉取偏移量 this.defaultMQPushConsumer.getPullBatchSize(), // 消息拉取最大条数，32 sysFlag, // 拉取系统标记 commitOffsetValue, // 内存中当前消费队列的消费进度 BROKER_SUSPEND_MAX_TIME_MILLIS, // 15000 CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, // 30000 CommunicationMode.ASYNC, // 消息拉取模式，异步 pullCallback // 拉取消息成功后的回调方法 ); } catch (Exception e) { log.error(\\\"pullKernelImpl exception\\\", e); this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); } } \"]},\"691\":{\"h\":\"4.1.4 PullAPIWrapper\",\"t\":[\"/** * 向 Broker 发送请求，拉取消息 * * @param mq 消息队列 * @param subExpression 过滤表达式 * @param expressionType 过滤类型 * @param subVersion 订阅关系版本号 * @param offset 拉取偏移量 * @param maxNums 拉取最大数量 * @param sysFlag 标志位 * @param commitOffset 提交偏移量 * @param brokerSuspendMaxTimeMillis Broker 挂起最大时间 * @param timeoutMillis 客户端拉取超时 * @param communicationMode 交互模式：单向/异步/同步 * @param pullCallback 拉取成功回调函数 * @return 拉取结果 * @throws MQClientException * @throws RemotingException * @throws MQBrokerException * @throws InterruptedException */ public PullResult pullKernelImpl( final MessageQueue mq, final String subExpression, final String expressionType, final long subVersion, final long offset, final int maxNums, final int sysFlag, final long commitOffset, final long brokerSuspendMaxTimeMillis, final long timeoutMillis, final CommunicationMode communicationMode, final PullCallback pullCallback ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 根据brokerName、brokerId从MQClientInstance中获取Broker地址。先从内存查找，找不到则从 NameServer 更新。 FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), this.recalculatePullFromWhichNode(mq), false); if (null == findBrokerResult) { this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic()); findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), this.recalculatePullFromWhichNode(mq), false); } if (findBrokerResult != null) { { // check version if (!ExpressionType.isTagType(expressionType) && findBrokerResult.getBrokerVersion() < MQVersion.Version.V4_1_0_SNAPSHOT.ordinal()) { throw new MQClientException(\\\"The broker[\\\" + mq.getBrokerName() + \\\", \\\" + findBrokerResult.getBrokerVersion() + \\\"] does not upgrade to support for filter message by \\\" + expressionType, null); } } int sysFlagInner = sysFlag; // 如果是子节点，把CommitOffset位去掉 // 因为子节点不保存消费者的Offset值，只有主节点才保存，所以如果是从子节点拉消息，就不能把这个位设为有效 if (findBrokerResult.isSlave()) { sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner); } PullMessageRequestHeader requestHeader = new PullMessageRequestHeader(); requestHeader.setConsumerGroup(this.consumerGroup); requestHeader.setTopic(mq.getTopic()); requestHeader.setQueueId(mq.getQueueId()); requestHeader.setQueueOffset(offset); requestHeader.setMaxMsgNums(maxNums); requestHeader.setSysFlag(sysFlagInner); // 消费的当前队列的已经消费的最大的Offset值 requestHeader.setCommitOffset(commitOffset); requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis); requestHeader.setSubscription(subExpression); requestHeader.setSubVersion(subVersion); requestHeader.setExpressionType(expressionType); String brokerAddr = findBrokerResult.getBrokerAddr(); // 如果过滤模式为类过滤，根据主题名称、Broker地址找到注册在Broker上的FilterServer地址，从FilterServer上拉取消息 if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) { brokerAddr = computePullFromWhichFilterServer(mq.getTopic(), brokerAddr); } // 从Broker拉取消息 PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage( brokerAddr, requestHeader, timeoutMillis, communicationMode, pullCallback); return pullResult; } throw new MQClientException(\\\"The broker[\\\" + mq.getBrokerName() + \\\"] not exist\\\", null); } \"]},\"692\":{\"h\":\"4.1.5 MQClientInstance\",\"t\":[\"public PullResult pullMessage( final String addr, final PullMessageRequestHeader requestHeader, final long timeoutMillis, final CommunicationMode communicationMode, final PullCallback pullCallback ) throws RemotingException, MQBrokerException, InterruptedException { RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader); switch (communicationMode) { case ONEWAY: assert false; return null; case ASYNC: this.pullMessageAsync(addr, request, timeoutMillis, pullCallback); return null; case SYNC: return this.pullMessageSync(addr, request, timeoutMillis); default: assert false; break; } return null; } \"]},\"693\":{\"h\":\"4.1.6 PullMessageProcessor\",\"t\":[\"/** * 处理客户端拉取请求入口 * * @param channel 网络通道，通过该通道向消息拉取客户端发送响应结果 * @param request 消息拉取请求 * @param brokerAllowSuspend Broker端是否允许挂起，默认true。true：如果未找到消息则挂起。false：未找到消息直接返回消息未找到 * @return 响应 * @throws RemotingCommandException 当解析请求发生异常时 */ private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend) throws RemotingCommandException { final long beginTimeMills = this.brokerController.getMessageStore().now(); RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class); final PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader(); final PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class); // 设置ID，用于响应和请求的匹配 response.setOpaque(request.getOpaque()); log.debug(\\\"receive PullMessage request command, {}\\\", request); // 判断Broker权限，broker是否可读 if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(String.format(\\\"the broker[%s] pulling message is forbidden\\\", this.brokerController.getBrokerConfig().getBrokerIP1())); return response; } // 校验ConsumerGroup配置是否存在 SubscriptionGroupConfig subscriptionGroupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup()); if (null == subscriptionGroupConfig) { response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST); response.setRemark(String.format(\\\"subscription group [%s] does not exist, %s\\\", requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST))); return response; } // 校验ConsumerGroup配置是否可消费 if (!subscriptionGroupConfig.isConsumeEnable()) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(\\\"subscription group no permission, \\\" + requestHeader.getConsumerGroup()); return response; } // 是否挂起 final boolean hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag()); // 客户端是否提交了消费进度 final boolean hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag()); final boolean hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag()); // 计算挂起时间 final long suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : 0; // 查找Topic配置信息 TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic()); if (null == topicConfig) { log.error(\\\"the topic {} not exist, consumer: {}\\\", requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel)); response.setCode(ResponseCode.TOPIC_NOT_EXIST); response.setRemark(String.format(\\\"topic[%s] not exist, apply first please! %s\\\", requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL))); return response; } // 判断Topic是否可读 if (!PermName.isReadable(topicConfig.getPerm())) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(\\\"the topic[\\\" + requestHeader.getTopic() + \\\"] pulling message is forbidden\\\"); return response; } // 请求的队列ID是否合法 // >= 0 && < 已知的最大队列数量 if (requestHeader.getQueueId() < 0 || requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) { String errorInfo = String.format(\\\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]\\\", requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress()); log.warn(errorInfo); response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(errorInfo); return response; } // ====== 消息过滤 ====== // 判断客户端是否传过来了SubscriptionData，即过滤数据 SubscriptionData subscriptionData = null; ConsumerFilterData consumerFilterData = null; if (hasSubscriptionFlag) { try { // true，则根据客户端传过来的数据构造subscriptionData subscriptionData = FilterAPI.build( requestHeader.getTopic(), requestHeader.getSubscription(), requestHeader.getExpressionType() ); if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) { // 如果不是 TAG 类型的过滤，则是 SQL92 过滤，构建过滤数据 ConsumerFilterData consumerFilterData = ConsumerFilterManager.build( requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getSubscription(), requestHeader.getExpressionType(), requestHeader.getSubVersion() ); assert consumerFilterData != null; } } catch (Exception e) { log.warn(\\\"Parse the consumer's subscription[{}] failed, group: {}\\\", requestHeader.getSubscription(), requestHeader.getConsumerGroup()); response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED); response.setRemark(\\\"parse the consumer's subscription failed\\\"); return response; } } else { // false，则通过服务端数据构造subscriptionData ConsumerGroupInfo consumerGroupInfo = this.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup()); if (null == consumerGroupInfo) { log.warn(\\\"the consumer's group info not exist, group: {}\\\", requestHeader.getConsumerGroup()); response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST); response.setRemark(\\\"the consumer's group info not exist\\\" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC)); return response; } if (!subscriptionGroupConfig.isConsumeBroadcastEnable() && consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(\\\"the consumer group[\\\" + requestHeader.getConsumerGroup() + \\\"] can not consume by broadcast way\\\"); return response; } subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic()); if (null == subscriptionData) { log.warn(\\\"the consumer's subscription not exist, group: {}, topic:{}\\\", requestHeader.getConsumerGroup(), requestHeader.getTopic()); response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST); response.setRemark(\\\"the consumer's subscription not exist\\\" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC)); return response; } // 判断Broker的订阅关系版本是否最新 if (subscriptionData.getSubVersion() < requestHeader.getSubVersion()) { log.warn(\\\"The broker's subscription is not latest, group: {} {}\\\", requestHeader.getConsumerGroup(), subscriptionData.getSubString()); response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST); response.setRemark(\\\"the consumer's subscription not latest\\\"); return response; } if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) { consumerFilterData = this.brokerController.getConsumerFilterManager().get(requestHeader.getTopic(), requestHeader.getConsumerGroup()); if (consumerFilterData == null) { response.setCode(ResponseCode.FILTER_DATA_NOT_EXIST); response.setRemark(\\\"The broker's consumer filter data is not exist!Your expression may be wrong!\\\"); return response; } if (consumerFilterData.getClientVersion() < requestHeader.getSubVersion()) { log.warn(\\\"The broker's consumer filter data is not latest, group: {}, topic: {}, serverV: {}, clientV: {}\\\", requestHeader.getConsumerGroup(), requestHeader.getTopic(), consumerFilterData.getClientVersion(), requestHeader.getSubVersion()); response.setCode(ResponseCode.FILTER_DATA_NOT_LATEST); response.setRemark(\\\"the consumer's consumer filter data not latest\\\"); return response; } } } if (!ExpressionType.isTagType(subscriptionData.getExpressionType()) && !this.brokerController.getBrokerConfig().isEnablePropertyFilter()) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"The broker does not support consumer to filter message by \\\" + subscriptionData.getExpressionType()); return response; } // 构建消息过滤器 MessageFilter messageFilter; if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) { // 支持对重试主题的属性进行过滤 messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData, this.brokerController.getConsumerFilterManager()); } else { // 不支持对重试主题的属性进行过滤 messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData, this.brokerController.getConsumerFilterManager()); } // 根据消费组、Topic、QueueID、队列Offset、拉取消息数量、订阅信息查找消息 final GetMessageResult getMessageResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter); if (getMessageResult != null) { // 填充responseHeader response.setRemark(getMessageResult.getStatus().name()); responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset()); responseHeader.setMinOffset(getMessageResult.getMinOffset()); responseHeader.setMaxOffset(getMessageResult.getMaxOffset()); // 如果允许从SLAVE拉数据，根据主从同步延迟计算下一次从主或从节点拉取 if (getMessageResult.isSuggestPullingFromSlave()) { // 消费较慢，重定向到另外一台机器 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly()); } else { // 消费正常，按照订阅组配置重定向 responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID); } switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) { case ASYNC_MASTER: case SYNC_MASTER: break; case SLAVE: if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) { response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY); responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID); } break; } if (this.brokerController.getBrokerConfig().isSlaveReadEnable()) { // consume too slow ,redirect to another machine if (getMessageResult.isSuggestPullingFromSlave()) { responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly()); } // consume ok else { responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId()); } } else { responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID); } // 根据GetMessageResult状态码推算Response状态码 switch (getMessageResult.getStatus()) { case FOUND: response.setCode(ResponseCode.SUCCESS); break; case MESSAGE_WAS_REMOVING: response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY); break; // 这两个返回值都表示服务器暂时没有这个队列，应该立刻将客户端Offset重置为0 case NO_MATCHED_LOGIC_QUEUE: case NO_MESSAGE_IN_QUEUE: if (0 != requestHeader.getQueueOffset()) { response.setCode(ResponseCode.PULL_OFFSET_MOVED); // XXX: warn and notify me log.info(\\\"the broker store no queue data, fix the request offset {} to {}, Topic: {} QueueId: {} Consumer Group: {}\\\", requestHeader.getQueueOffset(), getMessageResult.getNextBeginOffset(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getConsumerGroup() ); } else { response.setCode(ResponseCode.PULL_NOT_FOUND); } break; case NO_MATCHED_MESSAGE: response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY); break; case OFFSET_FOUND_NULL: response.setCode(ResponseCode.PULL_NOT_FOUND); break; case OFFSET_OVERFLOW_BADLY: response.setCode(ResponseCode.PULL_OFFSET_MOVED); // XXX: warn and notify me log.info(\\\"the request offset: {} over flow badly, broker max offset: {}, consumer: {}\\\", requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress()); break; case OFFSET_OVERFLOW_ONE: response.setCode(ResponseCode.PULL_NOT_FOUND); break; case OFFSET_TOO_SMALL: response.setCode(ResponseCode.PULL_OFFSET_MOVED); log.info(\\\"the request offset too small. group={}, topic={}, requestOffset={}, brokerMinOffset={}, clientIp={}\\\", requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(), getMessageResult.getMinOffset(), channel.remoteAddress()); break; default: assert false; break; } // 消息轨迹：记录客户端拉取的消息记录（不表示消费成功） if (this.hasConsumeMessageHook()) { // 执行hook ConsumeMessageContext context = new ConsumeMessageContext(); context.setConsumerGroup(requestHeader.getConsumerGroup()); context.setTopic(requestHeader.getTopic()); context.setQueueId(requestHeader.getQueueId()); String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER); switch (response.getCode()) { case ResponseCode.SUCCESS: int commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount(); int incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount; context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS); context.setCommercialRcvTimes(incValue); context.setCommercialRcvSize(getMessageResult.getBufferTotalSize()); context.setCommercialOwner(owner); break; case ResponseCode.PULL_NOT_FOUND: if (!brokerAllowSuspend) { context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS); context.setCommercialRcvTimes(1); context.setCommercialOwner(owner); } break; case ResponseCode.PULL_RETRY_IMMEDIATELY: case ResponseCode.PULL_OFFSET_MOVED: context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS); context.setCommercialRcvTimes(1); context.setCommercialOwner(owner); break; default: assert false; break; } this.executeConsumeMessageHookBefore(context); } switch (response.getCode()) { case ResponseCode.SUCCESS: // 统计 this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(), getMessageResult.getMessageCount()); this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(), getMessageResult.getBufferTotalSize()); this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount()); if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) { final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId()); this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), (int) (this.brokerController.getMessageStore().now() - beginTimeMills)); response.setBody(r); } else { try { FileRegion fileRegion = new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult); channel.writeAndFlush(fileRegion).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { getMessageResult.release(); if (!future.isSuccess()) { log.error(\\\"transfer many message by pagecache failed, {}\\\", channel.remoteAddress(), future.cause()); } } }); } catch (Throwable e) { log.error(\\\"transfer many message by pagecache exception\\\", e); getMessageResult.release(); } response = null; } break; case ResponseCode.PULL_NOT_FOUND: // 长轮询 // 如果当前没有消息，并且本次拉取是由客户端触发，而非挂起请求触发的话，那么挂起当前拉取请求 if (brokerAllowSuspend && hasSuspendFlag) { // 最大挂起时间，push模式固定15s，pull模式固定20s long pollingTimeMills = suspendTimeoutMillisLong; if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) { // 如果不启用长轮询，则使用短轮询，1s检查一次是否有新消息。默认启用长轮询 pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills(); } // 构造一个PullRequest并交给PullRequestHoldService线程 String topic = requestHeader.getTopic(); long offset = requestHeader.getQueueOffset(); int queueId = requestHeader.getQueueId(); PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills, this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter); this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest); response = null; // 将相应置为空，意味着暂时不返回给客户端 break; } // 向Consumer返回应答 case ResponseCode.PULL_RETRY_IMMEDIATELY: break; case ResponseCode.PULL_OFFSET_MOVED: if (this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE || this.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) { MessageQueue mq = new MessageQueue(); mq.setTopic(requestHeader.getTopic()); mq.setQueueId(requestHeader.getQueueId()); mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName()); OffsetMovedEvent event = new OffsetMovedEvent(); event.setConsumerGroup(requestHeader.getConsumerGroup()); event.setMessageQueue(mq); event.setOffsetRequest(requestHeader.getQueueOffset()); event.setOffsetNew(getMessageResult.getNextBeginOffset()); this.generateOffsetMovedEvent(event); log.warn( \\\"PULL_OFFSET_MOVED:correction offset. topic={}, groupId={}, requestOffset={}, newOffset={}, suggestBrokerId={}\\\", requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(), responseHeader.getSuggestWhichBrokerId()); } else { responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId()); response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY); log.warn(\\\"PULL_OFFSET_MOVED:none correction. topic={}, groupId={}, requestOffset={}, suggestBrokerId={}\\\", requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(), responseHeader.getSuggestWhichBrokerId()); } break; default: assert false; } } else { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"store getMessage return null\\\"); } // 存储Consumer消费进度：如果CommitLog可用且当前节点为主节点，则更新消费进度 boolean storeOffsetEnable = brokerAllowSuspend; // 说明是首次调用，相对于长轮询通知 storeOffsetEnable = storeOffsetEnable && hasCommitOffsetFlag; // 说明Consumer设置了标志位 storeOffsetEnable = storeOffsetEnable // 只有Master支持存储offset && this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE; if (storeOffsetEnable) { this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel), requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset()); } return response; } \"]},\"694\":{\"h\":\"4.1.7 DefaultMessageStore\",\"t\":[\"/** * 获取消息 * * @param group Consumer group that launches this query. 消费者组 * @param topic Topic to query. 主题 * @param queueId Queue ID to query. 队列ID * @param offset Logical offset to start from. 消息在队列中的逻辑偏移量 * @param maxMsgNums Maximum count of messages to query. 查询的最大消息数量 * @param messageFilter Message filter used to screen desired messages. 消息过滤器 * @return 查询消息结果 */ public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset, final int maxMsgNums, final MessageFilter messageFilter) { if (this.shutdown) { log.warn(\\\"message store has shutdown, so getMessage is forbidden\\\"); return null; } if (!this.runningFlags.isReadable()) { log.warn(\\\"message store is not readable, so getMessage is forbidden \\\" + this.runningFlags.getFlagBits()); return null; } if (MixAll.isLmq(topic) && this.isLmqConsumeQueueNumExceeded()) { log.warn(\\\"message store is not available, broker config enableLmq and enableMultiDispatch, lmq consumeQueue num exceed maxLmqConsumeQueueNum config num\\\"); return null; } long beginTime = this.getSystemClock().now(); GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE; long nextBeginOffset = offset; long minOffset = 0; long maxOffset = 0; // lazy init when find msg. GetMessageResult getResult = null; final long maxOffsetPy = this.commitLog.getMaxOffset(); ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId); if (consumeQueue != null) { minOffset = consumeQueue.getMinOffsetInQueue(); maxOffset = consumeQueue.getMaxOffsetInQueue(); if (maxOffset == 0) { status = GetMessageStatus.NO_MESSAGE_IN_QUEUE; nextBeginOffset = nextOffsetCorrection(offset, 0); } else if (offset < minOffset) { status = GetMessageStatus.OFFSET_TOO_SMALL; nextBeginOffset = nextOffsetCorrection(offset, minOffset); } else if (offset == maxOffset) { status = GetMessageStatus.OFFSET_OVERFLOW_ONE; nextBeginOffset = nextOffsetCorrection(offset, offset); } else if (offset > maxOffset) { status = GetMessageStatus.OFFSET_OVERFLOW_BADLY; if (0 == minOffset) { nextBeginOffset = nextOffsetCorrection(offset, minOffset); } else { nextBeginOffset = nextOffsetCorrection(offset, maxOffset); } } else { // 根据逻辑偏移量从 ConsumeQueue 中查出索引项 SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset); if (bufferConsumeQueue != null) { try { status = GetMessageStatus.NO_MATCHED_MESSAGE; long nextPhyFileStartOffset = Long.MIN_VALUE; long maxPhyOffsetPulling = 0; int i = 0; final int maxFilterMessageCount = Math.max(16000, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE); final boolean diskFallRecorded = this.messageStoreConfig.isDiskFallRecorded(); getResult = new GetMessageResult(maxMsgNums); ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit(); // 从消费队列中读取消息，直到读完或者读到查询消息数的最大值 for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { long offsetPy = bufferConsumeQueue.getByteBuffer().getLong(); int sizePy = bufferConsumeQueue.getByteBuffer().getInt(); long tagsCode = bufferConsumeQueue.getByteBuffer().getLong(); maxPhyOffsetPulling = offsetPy; // 物理文件正在被删除 if (nextPhyFileStartOffset != Long.MIN_VALUE) { if (offsetPy < nextPhyFileStartOffset) continue; } // 判断是否拉磁盘数据 boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy); // 此批消息到达上限 if (this.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(), isInDisk)) { break; } boolean extRet = false, isTagsCodeLegal = true; if (consumeQueue.isExtAddr(tagsCode)) { extRet = consumeQueue.getExt(tagsCode, cqExtUnit); if (extRet) { tagsCode = cqExtUnit.getTagsCode(); } else { // can't find ext content.Client will filter messages by tag also. log.error(\\\"[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}\\\", tagsCode, offsetPy, sizePy, topic, group); isTagsCodeLegal = false; } } // 消息过滤，先根据 ConsumeQueue 条目中的哈希码进行过滤，不匹配则直接跳过该条消息 if (messageFilter != null && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.NO_MATCHED_MESSAGE; } continue; } // 根据消息的偏移量和消息的大小从 CommitLog 文件中取出一条消息 SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy); if (null == selectResult) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.MESSAGE_WAS_REMOVING; } nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy); continue; } // 如果消息通过了 ConsumeQueue 的哈希码过滤，要从 CommitLog 中加载整个消息体，根据属性进行过滤 if (messageFilter != null && !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), null)) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.NO_MATCHED_MESSAGE; } // release... selectResult.release(); continue; } this.storeStatsService.getGetMessageTransferedMsgCount().add(1); getResult.addMessage(selectResult); status = GetMessageStatus.FOUND; nextPhyFileStartOffset = Long.MIN_VALUE; } if (diskFallRecorded) { long fallBehind = maxOffsetPy - maxPhyOffsetPulling; brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind); } nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); long diff = maxOffsetPy - maxPhyOffsetPulling; long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0)); getResult.setSuggestPullingFromSlave(diff > memory); } finally { bufferConsumeQueue.release(); } } else { status = GetMessageStatus.OFFSET_FOUND_NULL; nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset)); log.warn(\\\"consumer request topic: \\\" + topic + \\\"offset: \\\" + offset + \\\" minOffset: \\\" + minOffset + \\\" maxOffset: \\\" + maxOffset + \\\", but access logic queue failed.\\\"); } } } else { status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE; nextBeginOffset = nextOffsetCorrection(offset, 0); } if (GetMessageStatus.FOUND == status) { this.storeStatsService.getGetMessageTimesTotalFound().add(1); } else { this.storeStatsService.getGetMessageTimesTotalMiss().add(1); } long elapsedTime = this.getSystemClock().now() - beginTime; this.storeStatsService.setGetMessageEntireTimeMax(elapsedTime); // lazy init no data found. if (getResult == null) { getResult = new GetMessageResult(0); } getResult.setStatus(status); getResult.setNextBeginOffset(nextBeginOffset); getResult.setMaxOffset(maxOffset); getResult.setMinOffset(minOffset); return getResult; } public long getMaxOffsetInQueue(String topic, int queueId) { ConsumeQueue logic = this.findConsumeQueue(topic, queueId); if (logic != null) { long offset = logic.getMaxOffsetInQueue(); return offset; } return 0; } \"]},\"695\":{\"h\":\"4.1.8 PullCallback\",\"t\":[\"// DefaultMQPushConsumerImpl.java @Override public void onSuccess(PullResult pullResult) { if (pullResult != null) { // 将消息字节数组解码成消息列表并填充msgFoundList；对消息进行TAG模式过滤 pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult, subscriptionData); switch (pullResult.getPullStatus()) { // 找到对应消息 case FOUND: // 上次请求偏移量 long prevRequestOffset = pullRequest.getNextOffset(); // 更新下一次拉取的偏移量 pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 计算和记录拉取用时 long pullRT = System.currentTimeMillis() - beginTimestamp; DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullRT); // 如果msgFoundList为空，马上进行下次拉取 // msgFoundList为空的情况：因为根据TAG过滤时在服务端只验证了TAG的哈希码，客户端要再次对消息进行了过滤（见上），可能会出现为空的情况 long firstMsgOffset = Long.MAX_VALUE; if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } else { // 获取返回结果中第一条消息的消费队列offset firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset(); DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size()); // 将拉取到的消息存入ProcessQueue boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList()); // 将拉取到的消息提交到ConsumeMessageService中供消费者消费（异步） DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest( pullResult.getMsgFoundList(), processQueue, pullRequest.getMessageQueue(), dispatchToConsume); // 等待pullInterval毫秒后重新拉取，或立即重新拉取 if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) { DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval()); } else { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } } if (pullResult.getNextBeginOffset() < prevRequestOffset || firstMsgOffset < prevRequestOffset) { log.warn( \\\"[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}\\\", pullResult.getNextBeginOffset(), firstMsgOffset, prevRequestOffset); } break; // 没有新消息，对应服务端结果：OFFSET_FOUND_NULL/OFFSET_OVERFLOW_ONE case NO_NEW_MSG: // 没有匹配的消息 case NO_MATCHED_MSG: pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 使用服务器端校正的偏移量进行下一次消息的拉取 DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest); DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); break; // 偏移量非法，对应服务端结果：NO_MATCHED_LOGIC_QUEUE/NO_MESSAGE_IN_QUEUE/OFFSET_OVERFLOW_BADLY/OFFSET_TOO_SMALL case OFFSET_ILLEGAL: log.warn(\\\"the pull request offset illegal, {} {}\\\", pullRequest.toString(), pullResult.toString()); pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 丢弃该消费队列，意味着ProcessQueue中拉取的消息将停止消费 pullRequest.getProcessQueue().setDropped(true); DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() { @Override public void run() { try { // 根据服务端下一次校对的偏移量尝试更新消息消费进度（内存中） DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), false); // 尝试持久化消息消费进度 DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue()); // 将该消息队列从RebalanceImpl的处理队列中移除，意味着暂停该消息队列的消息拉取，等待下一次消息队列重新负载 DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue()); log.warn(\\\"fix the pull request offset, {}\\\", pullRequest); } catch (Throwable e) { log.error(\\\"executeTaskLater Exception\\\", e); } } }, 10000); break; default: break; } } } @Override public void onException(Throwable e) { if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"execute the pull request exception\\\", e); } DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"696\":{\"h\":\"RocketMQ 消费者（5）消息消费、消费进度上报 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220912-rocketmq-consumer-5-message-consume.html\"]},\"697\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第五篇，主要介绍并发消费者的消费和消费进度上报的流程。\",\"我把 RocketMQ 消费分成如下几个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"本文介绍的是步骤 4。RocketMQ 的消费还分并发消费和顺序消费，顺序消费将会在下一篇进行讲解。\"]},\"698\":{\"h\":\"2. 概要设计\"},\"699\":{\"h\":\"2.1 推模式并发消费交互流程\",\"t\":[\"RocketMQ 推模式下有并发消费和顺序消费两种消费模式。并发消费，顾名思义，将由一个消费线程池并行处理消费逻辑，消费速度较快。\",\"默认为消费线程池设置 20 个线程。从上一步拉取消息到消费者后，将拉取到的一批消息提交给并发消费服务，并发消费服务将消息封装成一个个消费请求（每个消费请求将消费一批消息，默认一批只包含一条消息）提交给消费线程池进行消费。\",\"消费时将会调用订阅时注册的消费监听器中的业务方法，执行真正的业务逻辑，然后处理消费结果。\",\"如果消费成功，则更新消费进度。如果消费失败，则需要将失败的消息发回 Broker，一段时间后进行重新消费。\",\"总结一下，推模式并发消费主要的步骤为：\",\"从拉取到的消息保存的处理队列获取消息，封装成消费请求，提交到消费线程池进行并发消费\",\"调用注册的监听器执行消费逻辑\",\"消费结果处理 \",\"消费成功则将这批消息从处理队列中移除，并更新消费进度\",\"消费失败则将失败的消息发回 Broker，利用延迟消息特性，过一段时间将会再次收到这些消息进行消费\"]},\"700\":{\"h\":\"2.2 重试消费设计\",\"t\":[\"为了保证消息消费的高可靠性，RocketMQ 默认提供了重试消费和死信队列功能。消费失败的消息将会过一段时间后重新消费，每次重新消费的时间间隔将会逐渐增加。当重新消费次数超过最大阈值时，消息将会被放入死信队列，为用户提供了主动处理这些消费多次失败的消息的可能。\",\"重试消费需要在消费结果处理的步骤中进行判断，如果消息消费失败，则将消息发回给 Broker。\",\"Broker 收到请求后用延迟消息机制，用该消息重新消费的次数计算延迟等级，生成一个新消息，将重新消费次数 + 1，作为延迟消息放入消息存储。\",\"延迟到期后该消息将被重新投递到消费者。\",\"初始的延迟为 30s，每次重试消费失败后延迟等级会增加，最后一次延迟 2 小时。如果仍然消费失败，则会被放入死信 Topic。\"]},\"701\":{\"h\":\"2.3 消费进度管理设计\",\"t\":[\"广播模式下，每个消费者都要消费全量消息，消费者之间不需要共享消费进度，所以消费进度可以存在本地。\",\"集群模式下，多个消费者共同消费一个 Topic，还存在重平衡的可能性，所以需要共享消费进度，这样的话消费进度存在 Broker 端比较好。\",\"RocketMQ 为广播模式和集群模式分别创建了消费进度存储类。\"]},\"702\":{\"h\":\"2.3.1 广播模式消费进度管理\",\"t\":[\"广播模式的消费者本地存储进度比较简单，它包含一个内存中的消费进度缓存表，用来实时更新。客户端实例启动时会启动定时任务，每 5s 将内存中的消费进度持久化到磁盘。\"]},\"703\":{\"h\":\"2.3.2 集群模式消费进度管理\",\"t\":[\"集群模式的消费进度管理涉及到消费者端和 Broker 端，每端都有一个消费进度管理器。消费者端仅保存一个消费进度内存缓存表，用来让消费者实时上报消费进度。客户端实例启动时的定时任务每 5s 会让消费者端的管理器向 Broker 端发送持久化请求。\",\"Broker 端也包含一个消费进度内存缓存表，每 5s 会收到消费者端的请求，更新内存缓存表。Broker 启动时也会启动定时任务，每 10s 将消费进度管理器的内存缓存持久化到磁盘。\"]},\"704\":{\"h\":\"2.3.3 消费者更新消费进度\",\"t\":[\"推模式消费者在处理消费结果的逻辑中，如果消费成功则会更新消费进度。\",\"拉模式消费者则需要用户自行调用消费者的方法触发消费进度更新。\"]},\"705\":{\"h\":\"3. 详细设计\"},\"706\":{\"h\":\"3.1 推模式并发消费\"},\"707\":{\"h\":\"3.1.1 消息消费类设计\",\"t\":[\"由于 RocketMQ 有两种消费方式：并发消费和顺序消费，这两种消费方式的流程又比较类似——都是构建消费请求，提交到消费线程池进行处理。\",\"所以定义了一个消费消息服务接口 ConsumeMessageService，然后并发消费和顺序消费分别实现该接口。\",\"消费消息服务接口定义了\",\"consumeMessageDirectly：直接消费消息的方法，主要用于管理命令触发的消息消费。\",\"submitConsumeRequest：提交消费请求到消费线程池，这个方法用于推模式的消费。\",\"两个消费服务实现中都包含了\",\"consumeRequestQueue：消费请求队列，生产-消费模式用的阻塞队列。\",\"consumeExecutor：消费线程池，默认 20 个线程。并发模式下，表示最多同时消费 20 批消息；顺序模式下，可以同时处理 20 个队列。\",\"messageListener：消息消费监听器，用于注册和执行消息消费的真正逻辑。\",\"顺序消费服务中还包含了消费队列锁。\",\"两个消费服务都实现了\",\"processConsumeResult：消费结果处理方法，处理消费结果。消费成功则更新消费进度；消费失败则将消息发回 Broker 重试消费。\",\"sendMessageBack：将消息发回给 Broker 的方法。\"]},\"708\":{\"h\":\"3.1.2 推模式并发消费流程\",\"t\":[\"推模式消费逻辑从消息拉取开始\",\"消息拉取到后存入处理队列，然后调用并发消费服务 ConsumeMessageConcurrentlyService 的 submitConsumeRequest 方法将拉取到消息的处理队列提交消费服务处理。\",\"将消息分批打包成消费请求 ConsumeRequest，默认每批 1 条消息\",\"将消费请求提交给消费线程池\",\"消费线程池从阻塞队列 consumeRequestQueue 中不断获取消费请求，执行消费请求的 run 方法执行消费逻辑\",\"先检查处理队列是否被丢弃，被丢弃则放弃消费\",\"检查消息是否含有重试 Topic 属性，如果有则将真正 Topic 从属性中获取，然后复原\",\"执行消费前钩子函数\",\"调用 messageListener 执行真正消费业务逻辑\",\"根据消费状态判定返回结果\",\"执行消费后钩子函数\",\"最后判断一次队列是否被丢弃，如果没有则进行结果处理\",\"执行结果处理函数 processConsumeResult\",\"检查消费成功与否\",\"处理消费失败的消息，如果是广播模式，只打印日志。如果是集群模式，5s 后将消费失败的消息发回 Broker。\",\"更新统计数据\",\"从处理队列中移除这批已经处理过的消息，返回移除这批消息的最小的偏移量\",\"用该偏移量更新消费进度（后面讲解）\",\"如果消费成功，则消费逻辑已经结束。如果消费失败，还需要重试消费，重试消费需要消费者将消费失败的消息发回给 Broker，调用 sendMessageBack 方法\",\"调用消费者 DefaultMQPushConsumerImpl 的 sendMessageBack 方法，先找到 Broker 地址，然后调用 API 发送请求给 Broker。\",\"Broker 由 SendMessageprossor 的 aynscConsumerSendMsgBack 处理重试消息请求\",\"执行消息消费后钩子函数\",\"获取订阅关系\",\"获取或创建重试 Topic，重试 Topic 名称为 %RETRY%{消费组名称}\",\"根据消息发回请求中带的物理偏移量，从消息存储 CommitLog 中查询出发回的消息。可以看出消费者发回消息并没有将整个消息都发回去，也没有这个必要，因为 Broker 端存储着所有的消息。只需要发回偏移量，Broker 就可以通过偏移量查询到这条消息的完整信息。\",\"如果是重试消息且第一次重试，将真正的 Topic 存入属性。因为延迟重试消息依赖延迟消息能力，该消息之后会发送到延迟消息的 Topic 中，所以需要一个地方保存真正的 Topic 信息。\",\"处理消息重新消费次数，\",\"如果大于重新消费次数阈值，则放进死信队列（先获取或创建死信队列）。死信队列名称为 %DLQ%{消费组名称}。\",\"如果在重新消费次数阈值之内，则为其设置延迟等级，延迟指定时间后投递。\",\"创建一个新的消息对象，有新的消息 ID，将它作为重新消费的消息存入消息存储 CommitLog。\",\"为什么已经保存过的消息还要重新建一个并且保存，这样不是很占用存储吗？\",\"由于 RocketMQ 同步消息的基准是 CommitLog，所以即便是已经保存在 CommitLog 的消息，如果要再次消费，也依然需要创建一个新的消息保存到 CommitLog 中。这样 CommitLog 会被同步到从 Broker 节点，从 Broker 节点也会收到该重试消息。\",\"新创建的重试消息是定时消息，它的 Topic 是定时消息 Topic，定时消息的机制会不停扫描定时消息 Topic 中的队列，看该消息是否到期，如果到期则投递。定时消息更详细的原理可以看这篇文章。该消息投递之后消费者会收到并重试消费\"]},\"709\":{\"h\":\"3.2 消费进度管理\"},\"710\":{\"h\":\"3.2.1 消费进度管理类设计\",\"t\":[\"消费者端，实现了 OffsetStore 接口，定义了更新、查询和持久化消费进度的方法。\",\"有两个实现类，这里都使用了内存缓存，定时持久化的设计方法。保存一个缓存表 offsetTable，用来快速更新和查询。\",\"LocalFileOffsetStore ：消费者本地进度存储，持久化时保存到消费者本地\",\"RemoteBrokerOffset：Broker 端存储，持久化时先保存到本地缓存，然后发送请求给 Broker，保存到 Broker 缓存。Broker 再定时持久化\",\"Broker 端也有一个对应的消费进度管理器 ConsumerOffsetManager，同样也是缓存 + 定时持久化的设计。\",\"它扩展了 ConfigManager，ConfigManager 是用来管理配置的，它定义了持久化和加载的接口。\",\"ConsumerOffsetManager 负责接收消费者的消费进度更新请求，然后定时持久化到磁盘。\"]},\"711\":{\"h\":\"3.2.2 消费进度更新流程\",\"t\":[\"这里讲解集群模式下消费进度的更新流程\",\"每个消费者都会有一个消费进度管理器 RemoteBrokerOffsetStore，在消费者启动时创建。\",\"Broker 端也有一个消费进度管理器 ConsumerOffsetManager，在 Broker 启动时创建。\",\"这两个消费进度管理器都保存一个消费进度缓存表 offsetStore 在内存中，用于快速更新和查询。Broker 端消费进度管理器会定时将消费进度表持久化到磁盘。\",\"客户端实例 MQClientInstance 启动时，创建定时任务，每 5s 触发消费进度管理器的持久化方法。\",\"消费流程最后，如果消费请求被消费成功，将会调用 RemoteBrokerOffsetStore 的 updateOffset 方法，更新消费进度缓存\",\"persistAll() 方法会遍历消费进度缓存表 offsetStore，为每个消息队列都向 Broker 发送消费进度更新和持久化的请求。\",\"updateConsumeOffsetToBroker 构造一个消息队列的消费进度更新请求，发送给 Broker\",\"Broker 的 ConsumerManagerProcess 处理请求，调用 updateConsumerOffset 方法，让消费进度管理器更新消费进度\",\"消费进度管理器的 commitOffset 方法将消费进度更新到其内存缓存表 offsetStore\",\"BrokerController 启动时启动定时任务，每 10s 调用 ConsumerOffsetManager 的 persist() 方法，持久化消费进度\"]},\"712\":{\"h\":\"4. 源码解析\"},\"713\":{\"h\":\"4.1 推模式并发消费\"},\"714\":{\"h\":\"4.1.1 并发消费服务提交消费请求\",\"t\":[\"// ConsumeMessageConcurrentlyService.java /** * 构造消费请求（多批）并提交，拉取到消息之后调用 * * @param msgs 每次拉取到的消息 * @param processQueue 消息处理队列 * @param messageQueue 消息队列 * @param dispatchToConsume */ @Override public void submitConsumeRequest( final List<MessageExt> msgs, final ProcessQueue processQueue, final MessageQueue messageQueue, final boolean dispatchToConsume) { // 每批次消费消息数量，默认为 1 final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize(); if (msgs.size() <= consumeBatchSize) { // 拉取的一批消息总数小于每批次可以消费的消息数，直接将所有拉取的消息构造成一个消费请求并提交 ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue); try { this.consumeExecutor.submit(consumeRequest); } catch (RejectedExecutionException e) { // 拒绝提交，延迟 5s 再提交 this.submitConsumeRequestLater(consumeRequest); } } else { // 如果这批消息数量大于每批次可以消费的消息，那么进行分页。每页包装可消费消息数量（1条）消息，构造多个消费请求提交消费 for (int total = 0; total < msgs.size(); ) { List<MessageExt> msgThis = new ArrayList<MessageExt>(consumeBatchSize); for (int i = 0; i < consumeBatchSize; i++, total++) { if (total < msgs.size()) { msgThis.add(msgs.get(total)); } else { break; } } ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue); try { // 提交给消费线程池消费 this.consumeExecutor.submit(consumeRequest); } catch (RejectedExecutionException e) { // 拒绝提交，延迟 5s 后再提交 for (; total < msgs.size(); total++) { msgThis.add(msgs.get(total)); } this.submitConsumeRequestLater(consumeRequest); } } } } \"]},\"715\":{\"h\":\"4.1.2 消费请求运行、处理结果\",\"t\":[\"// ConsumeMessageConcurrentlyService.java /** * 消费请求运行，执行消费逻辑 */ @Override public void run() { // 检查 processQueue 是否丢弃，重平衡时可能将队列分配给组内其他消费者会设置。如果丢弃，停止消费 if (this.processQueue.isDropped()) { log.info(\\\"the message queue not be able to consume, because it's dropped. group={} {}\\\", ConsumeMessageConcurrentlyService.this.consumerGroup, this.messageQueue); return; } MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.this.messageListener; ConsumeConcurrentlyContext context = new ConsumeConcurrentlyContext(messageQueue); ConsumeConcurrentlyStatus status = null; // 恢复重试消息的主题名 defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup()); // 执行消费前钩子函数 ConsumeMessageContext consumeMessageContext = null; if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext = new ConsumeMessageContext(); consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace()); consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup()); consumeMessageContext.setProps(new HashMap<String, String>()); consumeMessageContext.setMq(messageQueue); consumeMessageContext.setMsgList(msgs); consumeMessageContext.setSuccess(false); ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext); } // 执行具体消费逻辑 long beginTimestamp = System.currentTimeMillis(); boolean hasException = false; ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; try { // 设置消费开始时间戳 if (msgs != null && !msgs.isEmpty()) { for (MessageExt msg : msgs) { MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis())); } } // 消费逻辑，消息调用监听器的方法进行消费 status = listener.consumeMessage(Collections.unmodifiableList(msgs), context); } catch (Throwable e) { log.warn(String.format(\\\"consumeMessage exception: %s Group: %s Msgs: %s MQ: %s\\\", RemotingHelper.exceptionSimpleDesc(e), ConsumeMessageConcurrentlyService.this.consumerGroup, msgs, messageQueue), e); hasException = true; } long consumeRT = System.currentTimeMillis() - beginTimestamp; // 判断消费结果 if (null == status) { if (hasException) { returnType = ConsumeReturnType.EXCEPTION; } else { returnType = ConsumeReturnType.RETURNNULL; } } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) { returnType = ConsumeReturnType.TIME_OUT; } else if (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) { // 消费失败，需要重试 returnType = ConsumeReturnType.FAILED; } else if (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) { // 消费成功 returnType = ConsumeReturnType.SUCCESS; } if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name()); } if (null == status) { log.warn(\\\"consumeMessage return null, Group: {} Msgs: {} MQ: {}\\\", ConsumeMessageConcurrentlyService.this.consumerGroup, msgs, messageQueue); status = ConsumeConcurrentlyStatus.RECONSUME_LATER; } // 执行消费后钩子函数 if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext.setStatus(status.toString()); consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status); ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext); } ConsumeMessageConcurrentlyService.this.getConsumerStatsManager() .incConsumeRT(ConsumeMessageConcurrentlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT); // 消费后，验证队列是否丢弃，如果丢弃则不处理结果，此时其他消费者会重新消费该消息 if (!processQueue.isDropped()) { // 处理消费结果，成功则更新统计数据；失败则重试，将消息发回 Broker，延迟一段时间后再次进行消费 ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this); } else { log.warn(\\\"processQueue is dropped without process consume result. messageQueue={}, msgs={}\\\", messageQueue, msgs); } } \",\"// ConsumeMessageConcurrentlyService.java /** * 处理消费结果 * * @param status 消费状态，成功或失败 * @param context 消费上下文信息 * @param consumeRequest 消费请求 */ public void processConsumeResult( final ConsumeConcurrentlyStatus status, final ConsumeConcurrentlyContext context, final ConsumeRequest consumeRequest ) { // 用来标记消费成功失败的位置，默认为 Integer.MAX_VALUE，表示拉取的一批消息都消费成功 // 消费时可以通过设置 context 的 ackIndex 来标记哪些消息成功了，哪些失败了 // ackIndex 位置之前的消息都是消费成功的，index 大于 ackIndex 的后面的数据都是处理失败的 int ackIndex = context.getAckIndex(); // 如果没有消息则不处理 if (consumeRequest.getMsgs().isEmpty()) return; // 消费状态判断和处理 switch (status) { case CONSUME_SUCCESS: // 消费成功，设置 ackIndex 为 size - 1（消费成功的消息数量的 index，为下面失败处理逻辑使用） if (ackIndex >= consumeRequest.getMsgs().size()) { ackIndex = consumeRequest.getMsgs().size() - 1; } // 成功数量 int ok = ackIndex + 1; // 失败数量 int failed = consumeRequest.getMsgs().size() - ok; // 更新统计数据 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok); this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed); break; case RECONSUME_LATER: // 消费失败，ackIndex 设为 -1，为下面的失败处理逻辑使用 ackIndex = -1; // 消费失败统计数据更新 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), consumeRequest.getMsgs().size()); break; default: break; } // 处理消费失败的消息 switch (this.defaultMQPushConsumer.getMessageModel()) { case BROADCASTING: // 广播模式，对消费失败的消息不会重复消费，只会打印警告日志，输出消息内容 // ackIndex 后面的 index 都是消费失败的 for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) { MessageExt msg = consumeRequest.getMsgs().get(i); log.warn(\\\"BROADCASTING, the message consume failed, drop it, {}\\\", msg.toString()); } break; case CLUSTERING: List<MessageExt> msgBackFailed = new ArrayList<MessageExt>(consumeRequest.getMsgs().size()); // 集群模式，处理消费失败的消息。将消费失败的消息发回 Broker // ackIndex 后面的消息（index 大于 ackIndex）都是消费失败的 for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) { MessageExt msg = consumeRequest.getMsgs().get(i); // 将消息发回 Broker boolean result = this.sendMessageBack(msg, context); if (!result) { // 如果发回失败，加入失败列表 msg.setReconsumeTimes(msg.getReconsumeTimes() + 1); msgBackFailed.add(msg); } } // 5 秒后重新消费发回失败的消息 if (!msgBackFailed.isEmpty()) { consumeRequest.getMsgs().removeAll(msgBackFailed); this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue()); } break; default: break; } // 从 ProcessQueue 中移除这批已经处理过的消息 long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs()); if (offset >= 0 && !consumeRequest.getProcessQueue().isDropped()) { // 更新消费进度 this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true); } } \"]},\"716\":{\"h\":\"4.2 重试消费\"},\"717\":{\"h\":\"4.2.1 消费者消费失败，将消息发回 Broker\",\"t\":[\"// ConsumeMessageConcurrentlyService.java /** * 把消费失败的消息发回 Broker * * @param msg * @param context * @return */ public boolean sendMessageBack(final MessageExt msg, final ConsumeConcurrentlyContext context) { // 获取延迟等级，默认为 0，表示由 Broker 端控制延迟等级 // Broker 端将延迟等级设置为重试消费次数 + 3 int delayLevel = context.getDelayLevelWhenNextConsume(); // Wrap topic with namespace before sending back message. msg.setTopic(this.defaultMQPushConsumer.withNamespace(msg.getTopic())); try { this.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName()); return true; } catch (Exception e) { log.error(\\\"sendMessageBack exception, group: \\\" + this.consumerGroup + \\\" msg: \\\" + msg.toString(), e); } return false; } \",\"// DefaultMQPushConsumerImpl.java /** * 把消费失败的消息发回 Broker * * @param msg * @param delayLevel * @param brokerName * @throws RemotingException * @throws MQBrokerException * @throws InterruptedException * @throws MQClientException */ public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName) throws RemotingException, MQBrokerException, InterruptedException, MQClientException { try { // 查找 Broker 地址，如果知道 Broker 名称，根据名称查询主节点地址；否则使用消息存储的地 host 为 Broker 地址 String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName) : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost()); this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg, this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes()); } catch (Exception e) { // 发回 Broker 失败，将消息发送回重试 Topic 中，设置延迟等级，等待重新消费 log.error(\\\"sendMessageBack Exception, \\\" + this.defaultMQPushConsumer.getConsumerGroup(), e); Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody()); String originMsgId = MessageAccessor.getOriginMessageId(msg); MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId); newMsg.setFlag(msg.getFlag()); MessageAccessor.setProperties(newMsg, msg.getProperties()); MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic()); // 重新消费次数 +1 MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1)); MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes())); MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED); newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes()); this.mQClientFactory.getDefaultMQProducer().send(newMsg); } finally { msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace())); } } \"]},\"718\":{\"h\":\"4.2.2 Broker 端处理客户端发回的消息\",\"t\":[\"// SendMessageProcessor.java /** * Broker 处理消费者消费失败发回的消息 * * @param ctx * @param request * @return * @throws RemotingCommandException */ private CompletableFuture<RemotingCommand> asyncConsumerSendMsgBack(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { final RemotingCommand response = RemotingCommand.createResponseCommand(null); final ConsumerSendMsgBackRequestHeader requestHeader = (ConsumerSendMsgBackRequestHeader)request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class); String namespace = NamespaceUtil.getNamespaceFromResource(requestHeader.getGroup()); // 消息轨迹：记录消费失败的消息 if (this.hasConsumeMessageHook() && !UtilAll.isBlank(requestHeader.getOriginMsgId())) { ConsumeMessageContext context = buildConsumeMessageContext(namespace, requestHeader, request); this.executeConsumeMessageHookAfter(context); } // 获取消费组的订阅配置 SubscriptionGroupConfig subscriptionGroupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup()); if (null == subscriptionGroupConfig) { // 订阅配置不存在，返回错误 response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST); response.setRemark(\\\"subscription group not exist, \\\" + requestHeader.getGroup() + \\\" \\\" + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)); return CompletableFuture.completedFuture(response); } if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())) { // Broker 不可写 response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(\\\"the broker[\\\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \\\"] sending message is forbidden\\\"); return CompletableFuture.completedFuture(response); } // 如果重试队列数量为 0，说明该消费组不支持重试，返回成功并丢弃消息 if (subscriptionGroupConfig.getRetryQueueNums() <= 0) { response.setCode(ResponseCode.SUCCESS); response.setRemark(null); return CompletableFuture.completedFuture(response); } String newTopic = MixAll.getRetryTopic(requestHeader.getGroup()); int queueIdInt = ThreadLocalRandom.current().nextInt(99999999) % subscriptionGroupConfig.getRetryQueueNums(); // 如果是单元化模式，对 Topic 进行设置 int topicSysFlag = 0; if (requestHeader.isUnitMode()) { topicSysFlag = TopicSysFlag.buildSysFlag(false, true); } // 创建重试主题 %RETRY%{消费组名称}，构建主题配置 TopicConfig topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod( newTopic, subscriptionGroupConfig.getRetryQueueNums(), PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag); // 检查 Topic 是否存在 if (null == topicConfig) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"topic[\\\" + newTopic + \\\"] not exist\\\"); return CompletableFuture.completedFuture(response); } // 检查 Topic 权限 if (!PermName.isWriteable(topicConfig.getPerm())) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(String.format(\\\"the topic[%s] sending message is forbidden\\\", newTopic)); return CompletableFuture.completedFuture(response); } // 根据偏移量从 CommitLog 查询发回的消息 MessageExt msgExt = this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset()); if (null == msgExt) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"look message by offset failed, \\\" + requestHeader.getOffset()); return CompletableFuture.completedFuture(response); } // 如果消息之前没有重新消费过，将消息的真正 Topic 存入属性，因为 Topic 之后会被重试 Topic 覆盖 final String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC); if (null == retryTopic) { MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic()); } msgExt.setWaitStoreMsgOK(false); // 客户端自动决定延迟等级 int delayLevel = requestHeader.getDelayLevel(); int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes(); if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) { Integer times = requestHeader.getMaxReconsumeTimes(); if (times != null) { maxReconsumeTimes = times; } } // 死信消息处理，如果 > 0，表示由客户端控制重试次数 // 如果重试次数超过 maxReconsumeTimes，或者小于 0，会放入死信队列。改变 Topic 为 %DLQ%{消费者组} if (msgExt.getReconsumeTimes() >= maxReconsumeTimes || delayLevel < 0) { newTopic = MixAll.getDLQTopic(requestHeader.getGroup()); queueIdInt = ThreadLocalRandom.current().nextInt(99999999) % DLQ_NUMS_PER_GROUP; topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, DLQ_NUMS_PER_GROUP, PermName.PERM_WRITE | PermName.PERM_READ, 0); if (null == topicConfig) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"topic[\\\" + newTopic + \\\"] not exist\\\"); return CompletableFuture.completedFuture(response); } msgExt.setDelayTimeLevel(0); } else { // 如果是 0，表示由 Broker 端控制延迟时间，将延迟等级设置为：重新消费次数 + 3 if (0 == delayLevel) { delayLevel = 3 + msgExt.getReconsumeTimes(); } msgExt.setDelayTimeLevel(delayLevel); } // 创建一个新的消息对象，作为重试消息，它有新的消息 ID MessageExtBrokerInner msgInner = new MessageExtBrokerInner(); msgInner.setTopic(newTopic); msgInner.setBody(msgExt.getBody()); msgInner.setFlag(msgExt.getFlag()); MessageAccessor.setProperties(msgInner, msgExt.getProperties()); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties())); msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(null, msgExt.getTags())); msgInner.setQueueId(queueIdInt); msgInner.setSysFlag(msgExt.getSysFlag()); msgInner.setBornTimestamp(msgExt.getBornTimestamp()); msgInner.setBornHost(msgExt.getBornHost()); msgInner.setStoreHost(msgExt.getStoreHost()); // 重新消费次数 +1，下次重新消费的延迟等级根据该值来确定 msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + 1); // 保存源消息的 ID String originMsgId = MessageAccessor.getOriginMessageId(msgExt); MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties())); // 存入 CommitLog CompletableFuture<PutMessageResult> putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner); // 存入之后统计数据并返回结果 return putMessageResult.thenApply((r) -> { if (r != null) { switch (r.getPutMessageStatus()) { case PUT_OK: String backTopic = msgExt.getTopic(); String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC); if (correctTopic != null) { backTopic = correctTopic; } if (TopicValidator.RMQ_SYS_SCHEDULE_TOPIC.equals(msgInner.getTopic())) { this.brokerController.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic()); this.brokerController.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(), r.getAppendMessageResult().getWroteBytes()); this.brokerController.getBrokerStatsManager().incQueuePutNums(msgInner.getTopic(), msgInner.getQueueId()); this.brokerController.getBrokerStatsManager().incQueuePutSize(msgInner.getTopic(), msgInner.getQueueId(), r.getAppendMessageResult().getWroteBytes()); } this.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic); response.setCode(ResponseCode.SUCCESS); response.setRemark(null); return response; default: break; } response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(r.getPutMessageStatus().name()); return response; } response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"putMessageResult is null\\\"); return response; }); } \"]},\"719\":{\"h\":\"4.3 消费进度管理\"},\"720\":{\"h\":\"4.3.1 客户端消费进度管理器持久化消费进度\",\"t\":[\"// RemoteBrokerOffsetStore.java /** * 持久化消费进度 * 发送请求给 Broker，让 Broker 持久化消费进度到磁盘 * * @param mqs */ @Override public void persistAll(Set<MessageQueue> mqs) { if (null == mqs || mqs.isEmpty()) return; final HashSet<MessageQueue> unusedMQ = new HashSet<MessageQueue>(); // 遍历所有缓存的消息队列，为每隔队列发送持久化消费进度请求给 Broker for (Map.Entry<MessageQueue, AtomicLong> entry : this.offsetTable.entrySet()) { MessageQueue mq = entry.getKey(); AtomicLong offset = entry.getValue(); if (offset != null) { if (mqs.contains(mq)) { try { this.updateConsumeOffsetToBroker(mq, offset.get()); log.info(\\\"[persistAll] Group: {} ClientId: {} updateConsumeOffsetToBroker {} {}\\\", this.groupName, this.mQClientFactory.getClientId(), mq, offset.get()); } catch (Exception e) { log.error(\\\"updateConsumeOffsetToBroker exception, \\\" + mq.toString(), e); } } else { unusedMQ.add(mq); } } } if (!unusedMQ.isEmpty()) { for (MessageQueue mq : unusedMQ) { this.offsetTable.remove(mq); log.info(\\\"remove unused mq, {}, {}\\\", mq, this.groupName); } } } \",\"// RemoteBrokerOffsetStore.java /** * Update the Consumer Offset synchronously, once the Master is off, updated to Slave, here need to be optimized. * 发送 UPDATE_CONSUMER_OFFSET 请求到 Broker，让 Broker 持久化消费进度 */ @Override public void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException, MQBrokerException, InterruptedException, MQClientException { // 获取 Broker 地址 FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true); if (null == findBrokerResult) { this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic()); findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, false); } if (findBrokerResult != null) { UpdateConsumerOffsetRequestHeader requestHeader = new UpdateConsumerOffsetRequestHeader(); requestHeader.setTopic(mq.getTopic()); requestHeader.setConsumerGroup(this.groupName); requestHeader.setQueueId(mq.getQueueId()); requestHeader.setCommitOffset(offset); // 向 Broker 发送请求，持久化消费进度 if (isOneway) { this.mQClientFactory.getMQClientAPIImpl().updateConsumerOffsetOneway( findBrokerResult.getBrokerAddr(), requestHeader, 1000 * 5); } else { this.mQClientFactory.getMQClientAPIImpl().updateConsumerOffset( findBrokerResult.getBrokerAddr(), requestHeader, 1000 * 5); } } else { throw new MQClientException(\\\"The broker[\\\" + mq.getBrokerName() + \\\"] not exist\\\", null); } } \"]},\"721\":{\"h\":\"4.3.2 Broker 端消费进度管理器\",\"t\":[\"收到客户端发来的持久化消费进度请求，将消费进度缓存\",\"/** * 持久化消费进度 * * @param clientHost * @param group * @param topic * @param queueId * @param offset */ public void commitOffset(final String clientHost, final String group, final String topic, final int queueId, final long offset) { // topic@group String key = topic + TOPIC_GROUP_SEPARATOR + group; this.commitOffset(clientHost, key, queueId, offset); } /** * 持久化消费进度，将消费进度保存到缓存表 * * @param clientHost * @param key * @param queueId * @param offset */ private void commitOffset(final String clientHost, final String key, final int queueId, final long offset) { ConcurrentMap<Integer, Long> map = this.offsetTable.get(key); if (null == map) { map = new ConcurrentHashMap<Integer, Long>(32); map.put(queueId, offset); this.offsetTable.put(key, map); } else { Long storeOffset = map.put(queueId, offset); if (storeOffset != null && offset < storeOffset) { log.warn(\\\"[NOTIFYME]update consumer offset less than store. clientHost={}, key={}, queueId={}, requestOffset={}, storeOffset={}\\\", clientHost, key, queueId, offset, storeOffset); } } } \",\"定时持久化消费进度\",\"// BrokerController#initialize() // 每 10s 持久化消费进度到磁盘 this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { BrokerController.this.consumerOffsetManager.persist(); } catch (Throwable e) { log.error(\\\"schedule persist consumerOffset error.\\\", e); } } }, 1000 * 10, this.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS); \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"722\":{\"h\":\"RocketMQ 消费者（6）顺序消费 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220929-rocketmq-consumer-6-consume-orderly.html\"]},\"723\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第六篇，上一篇主要介绍并发消费，而本片主要介绍 RocketMQ 顺序消费的设计和流程。\",\"我把 RocketMQ 消费分成如下几个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"顺序消息逻辑主要在步骤 4 当中承载，然而为了能够实现顺序的消费，在步骤 1 和 2 中就需要有相应的操作以锁定消费队列，确保顺序消费。\",\"RocketMQ 支持 2 种消费方式，即并发消费和顺序消费。\",\"并发消费是比较常用的一种消费方式。并发有两层含义：\",\"队列间并发消费：一个 Topic 可以有 N 个队列，每个队列都可以被一个消费者消费，最多可以有 N 个消费者同时进行消费\",\"队列中的多个消息并发消费：消费者执行消费逻辑时，使用一个消费线程池进行消费，该线程池默认有 20 个线程同时进行消费，所以也有可能并发消费一个队列中的多个消息\",\"由于 RocketMQ 的 Topic 和队列的设计，让同一 Topic 下的并发消费无法避免，因为只要有多个队列让多个消费者同时消费，就必定存在并发消费。所以 RocketMQ 仅支持单个队列中的消息的顺序消费。\",\"如果要做到 Topic 维度严格的顺序，那么需要将 Topic 的队列数设为 1。\"]},\"724\":{\"h\":\"2. 概要设计\",\"t\":[\"顺序消费的设计的要点主要有两个：\",\"保证消费速度，即消费线程池同时消费多个队列的消息。\",\"保证顺序性，即一个队列同一时间只能被一个消费者的一个线程消费。\",\"第一点可以在并发消费的基础上修改消费线程池的逻辑，第二点需要用到多个锁来保证。\"]},\"725\":{\"h\":\"2.1 消费线程池逻辑\"},\"726\":{\"h\":\"2.1.1 消费线程池顺序消费\",\"t\":[\"并发消费的消费线程池，每个线程的消费任务是：消费一批（默认一条）消息。消费任务由拉取任务提交，存在同时运行的多个任务都是消费同一个队列的可能。\",\"顺序消费的消费任务也由拉取任务提交，逻辑改成了：持续消费一个队列的消息，直到该队列的消息消费完或者超过最大消费时间（1分钟）。这样可以保证每个队列最多被一个消费线程处理，每个消费线程也最大程度上被使用。1 分钟的超时时间是为了防止某个队列消息过多或消费过慢，让其他队列也有被消费到的机会。\"]},\"727\":{\"h\":\"2.1.2 保证一个队列同时仅被一个消费线程消费\",\"t\":[\"在上述逻辑的基础上，可能存在同时有多个同一队列的消费任务被提交到消费线程池的情况，需要保证一个队列最多仅被一个线程消费。\",\"RocketMQ 为每个消息队列都初始化一把锁（消息队列锁），消费任务开始时获取锁，消费任务结束时释放锁，保证就算有多个线程同时消费一个队列，但同时最多只有一个线程真正在执行消费（其他线程都在等待锁释放）。\",\"这个实现可能导致消费线程池中多个线程同时等待一把锁，似乎是一个可以优化的点。比如通过修改消息拉取线程， 保证该队列消费完之前不拉取新的消息（拉取消息前判断该队列的消息是否被消费完，如果未被消费完则跳过拉取操作，将该拉取请求放入拉取队列末尾）\"]},\"728\":{\"h\":\"2.2 重平衡时顺序消费\",\"t\":[\"消费任务中添加的消息队列锁保证了同一消费者中的顺序消费，但保证消费线程池顺序消费就可以实现顺序消费了吗？NO。顺序消费还有一个敌人——重平衡。\",\"重平衡可能会将一个队列的消费负载从一个消费者切换到另一个消费者。老消费者的消费任务可能还没有结束，新消费者开始消费，这样也存在两个消费者同时消费一个队列的情况。\"]},\"729\":{\"h\":\"2.2.1 Broker 管理的分布式锁\",\"t\":[\"为了跨消费者进行消费队列负载的协调，引入分布式锁是最好的选择，RocketMQ 让 Broker 来管理和保存该锁，我们姑且把这个锁叫做 Broker锁。\",\"消费者在重平衡后，对于新分配到的队列，会尝试向 Broker 请求 Broker锁 ；丢弃的队列则向 Broker 释放锁。如果请求到锁才开始拉取，请求不到则等到下次重平衡再次请求。\",\"Broker锁 在 Broker 端被设了过期时间，1 分钟不更新则过期。顺序消费服务的定时任务会每 20s 向 Broker 发送请求，请求和更新自己负载的消费队列的 Broker锁。\",\"在消息拉取和顺序消费服务每消费一批消息前，都会判断是否持有 Broker锁，来保证没有多个消费者在重平衡后同时消费一个队列。\",\"还有一个消费锁，用来保证在有消息正在被顺序消费时，不能释放 Broker锁。\"]},\"730\":{\"h\":\"3. 详细设计\"},\"731\":{\"h\":\"3.1 Broker锁\"},\"732\":{\"h\":\"3.1.1 设计\",\"t\":[\"Broker锁 是在 Broker 上保存和管理的分布式锁，它的存在是为了解决重平衡后可能的不同消费者并行消费问题。由 Broker 端的 RebalanceLockManager 管理。\",\"每个消息队列都可能会有一个锁，每个消费组的消费应该隔离，所以每个消费组都有一组锁。锁的容器是两层 Map：\",\"ConcurrentMap<String/* group */, ConcurrentHashMap<MessageQueue, LockEntry/* client ID & update timestamp */>> mqLockTable \",\"为了避免一些异常情况，如消费者异常退出，没有主动解锁，导致队列一直上锁，这里为 Broker锁 设置了超时时间（默认 1 分钟）。\",\"由消费者向 Broker 发请求进行加解锁、查询是否加锁等操作。\"]},\"733\":{\"h\":\"3.1.2 加解锁时机\",\"t\":[\"消费者重平衡后，调用 updateProcessQueueTableInRebalance，如上图粉色部分所示。\",\"对于要丢弃的队列，尝试释放 Broker锁；对于对分配到的队列尝试请求 Broker锁。\"]},\"734\":{\"h\":\"3.1.3 加解锁流程\",\"t\":[\"加锁的过程是向 Broker 发请求，锁管理器将锁创建后放入锁容器 mqLockTable 并更新加锁时间；解锁则是将 LockEntry 从锁容器中移除。\",\"上图展示了加锁流程：\",\"重平衡后更新处理队列，尝试加锁（或者更新现有锁），向 Broker 发请求\",\"MQClientAPIImpl 中准备锁定请求，调用 NettyRemotingClient 向 Broker 发送请求\",\"Broker 端 AdminBrokerProcessor 处理加锁请求\",\"RebalanceLockManager 最终处理加锁逻辑，先获取锁容器的改动锁。然后为没有加锁的队列新建 LockEntry，为已有的 LockEntry 更新加锁时间和客户端 ID。最后释放锁容器的锁。\"]},\"735\":{\"h\":\"3.1.4 边界条件：消费消息时重平衡\",\"t\":[\"存在一种边界条件，消费消息耗时较长的情况下，可能存在重平衡后要释放某个队列的 Broker锁，但是这个队列仍有消息正在被消费。\",\"这种情况下不能贸然释放 Broker锁，因为如果释放，其他消费者会获取 Broker锁并开始消费，可能会重复且并发地消费那批没有消费完的消息，这里就存在并发问题。\",\"RocketMQ 的做法是如果队列有消息正被消费，则不会释放它的 Broker锁，等到下一次重平衡（默认 20s 周期）再判断是否可以释放。\",\"具体的做法是引入一个新的锁 消费锁，一批消息消费时加锁，消费完后解锁。\",\"重平衡后尝试释放 Broker锁 前，先试着获取 消费锁，如果 1s 内获取不到，则跳过。\"]},\"736\":{\"h\":\"3.2 消费线程池顺序消费逻辑\"},\"737\":{\"h\":\"3.2.1 消费线程池顺序消费设计\",\"t\":[\"每个消费者都有一个消费线程池（默认 20 个线程）来处理消息拉取任务拉取成功后提交的消费任务。\",\"消息拉取任务将拉取到的消息都放到消息队列对应的处理队列中，然后将处理队列整个放入消费任务，提交给消费线程池。\",\"每个消费任务都持续消费一个队列，直到消费时间到期（1 分钟）或者处理队列中消息消费完。\",\"为了保证消费线程池中没有多个线程消费同一个队列，为每个消费队列初始化消费队列锁（MQ Lock），并在消费任务执行时加锁\"]},\"738\":{\"h\":\"3.2.2 消费线程池顺序消费任务流程\",\"t\":[\"检查处理队列是否丢弃（是否仍由该消费者负载该队列）\",\"获取消费队列锁（保证消费线程池中消费这个队列的最多只有一个线程）\",\"保证处理队列的 Broker锁 已经获取且未过期\",\"从处理队列中取一批消息（默认 1 条）\",\"对于重试消息，从消息属性中获取它真正的 Topic 并恢复\",\"执行消费前钩子函数\",\"加 消费锁，执行消费逻辑，释放 消费锁\",\"根据消费结果设置返回状态\",\"执行消费后钩子函数\",\"处理这批消息的消费结果 \",\"检查消费结果\",\"如果消费失败，广播模式：打印错误日志；集群模式：将消息发回 Broker，等待重新消费\",\"将消息从处理队列移除\",\"提交消费进度\"]},\"739\":{\"h\":\"3.3 顺序消费流程\",\"t\":[\"消费流程以重平衡为起点。重平衡后向 Broker 发送请求，释放和申请 Broker锁\",\"为该消费者负载的队列新建消息拉取请求，进行消息拉取\",\"pullMessage：拉取前再次判断队列 Broker锁 的状态。消息拉取线程从拉取任务队列中获取任务并执行拉取\",\"拉取成功后的 PullCallback 将拉取到的消息放入处理队列，然后给顺序消费服务提交顺序消费任务\",\"顺序消费服务的消费线程池执行消费任务，执行逻辑上面讲过\"]},\"740\":{\"h\":\"4. 源码解析\"},\"741\":{\"h\":\"4.1 Broker锁\"},\"742\":{\"h\":\"4.1.1 Broker锁 管理器\",\"t\":[\"public class RebalanceLockManager { // 锁容器读写锁 private final Lock lock = new ReentrantLock(); // 消息队列锁定状态表 private final ConcurrentMap<String/* group */, ConcurrentHashMap<MessageQueue, LockEntry>> mqLockTable = new ConcurrentHashMap<String, ConcurrentHashMap<MessageQueue, LockEntry>>(1024); /** * 批量锁定消息队列 * * @param group 消费组 * @param mqs 要锁定的消息队列 * @param clientId 客户端 ID * @return 锁定成功的消息队列 */ public Set<MessageQueue> tryLockBatch(final String group, final Set<MessageQueue> mqs, final String clientId) { // 要锁定的队列中已经锁定的队列 Set<MessageQueue> lockedMqs = new HashSet<MessageQueue>(mqs.size()); // 之前没有锁定，需要锁定的队列 Set<MessageQueue> notLockedMqs = new HashSet<MessageQueue>(mqs.size()); for (MessageQueue mq : mqs) { if (this.isLocked(group, mq, clientId)) { lockedMqs.add(mq); } else { notLockedMqs.add(mq); } } // 锁定需要锁定的队列 if (!notLockedMqs.isEmpty()) { try { this.lock.lockInterruptibly(); try { ConcurrentHashMap<MessageQueue, LockEntry> groupValue = this.mqLockTable.get(group); if (null == groupValue) { groupValue = new ConcurrentHashMap<>(32); this.mqLockTable.put(group, groupValue); } for (MessageQueue mq : notLockedMqs) { // 为队列新建锁定标识，加入锁定状态表 LockEntry lockEntry = groupValue.get(mq); if (null == lockEntry) { lockEntry = new LockEntry(); lockEntry.setClientId(clientId); groupValue.put(mq, lockEntry); } if (lockEntry.isLocked(clientId)) { lockEntry.setLastUpdateTimestamp(System.currentTimeMillis()); lockedMqs.add(mq); continue; } String oldClientId = lockEntry.getClientId(); if (lockEntry.isExpired()) { lockEntry.setClientId(clientId); lockEntry.setLastUpdateTimestamp(System.currentTimeMillis()); lockedMqs.add(mq); continue; } } } finally { this.lock.unlock(); } } catch (InterruptedException e) { log.error(\\\"putMessage exception\\\", e); } } return lockedMqs; } } \"]},\"743\":{\"h\":\"4.1.2 消费者解锁/加锁\"},\"744\":{\"h\":\"4.1.2.1 重平衡后更新处理队列\",\"t\":[\"重平衡时，队列分配完成后对队列进行解锁和加锁\",\"// RebalanceImpl.java /** * 重平衡后更新 ProcessQueue 表 * 丢弃不再消费的队列，为新增的队列新建 ProcessQueue 和 PullRequest * * @param topic 主题 * @param mqSet 重平衡后该消费者新分配到的的消息队列 * @param isOrder 是否顺序消费 * @return */ private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet, final boolean isOrder) { boolean changed = false; // 遍历本地缓存的消费者分到的消息队列，判断要丢弃的队列并丢弃 Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator(); while (it.hasNext()) { Entry<MessageQueue, ProcessQueue> next = it.next(); MessageQueue mq = next.getKey(); ProcessQueue pq = next.getValue(); if (mq.getTopic().equals(topic)) { // 如果新分配到的消息队列集合中不含有老的消息队列，丢弃老的处理队列 if (!mqSet.contains(mq)) { // 该 ProcessQueue 中不会有消息被消费 pq.setDropped(true); // 移除消费队列，并释放 Broker锁，移除前持久化。 if (this.removeUnnecessaryMessageQueue(mq, pq)) { it.remove(); changed = true; } } else if (pq.isPullExpired()) { /** * 如果Reblance之后的mq集合包含该MessageQueue,但是ProcessQueue已经太久没有拉取数据（上次拉取消息的时间距离现在超过设置时间） */ switch (this.consumeType()) { case CONSUME_ACTIVELY: break; case CONSUME_PASSIVELY: /** * PushConsumer为被动消费 * 如果是PUSH，则丢弃ProcessQueue * 同时删除MessageQueue */ pq.setDropped(true); if (this.removeUnnecessaryMessageQueue(mq, pq)) { it.remove(); changed = true; } break; default: break; } } } } // 遍历新分配的 MessageQueue，对于新分配的，创建 PullRequest 启动拉取 List<PullRequest> pullRequestList = new ArrayList<PullRequest>(); // 为每个 MessageQueue 新建一个 PullRequest for (MessageQueue mq : mqSet) { // 本地缓存的 ProcessQueue 中不包含，表示新增队列 if (!this.processQueueTable.containsKey(mq)) { // 如果是顺序消费，尝试给处理队列加锁：尝试向 Broker 发送锁定队列请求。如果加锁失败则跳过，在下一次重平衡时尝试加锁 if (isOrder && !this.lock(mq)) { log.warn(\\\"doRebalance, {}, add a new mq failed, {}, because lock failed\\\", consumerGroup, mq); // 顺序消费，锁定处理队列失败，跳过拉取 continue; } // 从内存中移除该 MessageQueue 的消费进度（老的进度不需要） this.removeDirtyOffset(mq); ProcessQueue pq = new ProcessQueue(); // 计算当前 MessageQueue 应该从哪里开始拉取消息 long nextOffset = -1L; try { // 计算并从偏移量存储中读取下次拉取的偏移量 nextOffset = this.computePullFromWhereWithException(mq); } catch (Exception e) { log.info(\\\"doRebalance, {}, compute offset failed, {}\\\", consumerGroup, mq); continue; } if (nextOffset >= 0) { // 添加 MessageQueue 和 ProcessQueue 的映射关系 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq); if (pre != null) { log.info(\\\"doRebalance, {}, mq already exists, {}\\\", consumerGroup, mq); } else { // 添加成功，创建新的 PullRequest // 唯一的创建 PullRequest 的地方 log.info(\\\"doRebalance, {}, add a new mq, {}\\\", consumerGroup, mq); PullRequest pullRequest = new PullRequest(); pullRequest.setConsumerGroup(consumerGroup); pullRequest.setNextOffset(nextOffset); pullRequest.setMessageQueue(mq); pullRequest.setProcessQueue(pq); pullRequestList.add(pullRequest); changed = true; } } else { log.warn(\\\"doRebalance, {}, add new mq failed, {}\\\", consumerGroup, mq); } } } // 将新建的 PullRequest 加入消息拉取线程 PullMessageService，开始拉取 this.dispatchPullRequest(pullRequestList); return changed; } \"]},\"745\":{\"h\":\"4.1.2.2 消息队列解锁\",\"t\":[\"// RebalancePushImpl.java /** * 将重平衡后丢弃的消费队列移除 * 移除前持久化消费的消费进度 * * @param mq 消息队列 * @param pq 处理队列 * @return */ @Override public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) { // 持久化消费进度，然后移除 this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq); this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq); if (this.defaultMQPushConsumerImpl.isConsumeOrderly() && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) { try { // 如果是顺序消费，尝试获取队列的消费锁，最多等待 1s if (pq.getConsumeLock().tryLock(1000, TimeUnit.MILLISECONDS)) { // 获取成功，表示该队列没有消息正被消费，可以向 Broker 发请求解锁该队列 try { return this.unlockDelay(mq, pq); } finally { pq.getConsumeLock().unlock(); } } else { // 获取消费锁失败，表示该队列有消息正被消费，且消费时长大于 1s，那么本次无法将该队列解锁 // 该队列新分配到负载的 Broker 由于拿不到该队列的锁，也无法开始消费，需要等待下一次重平衡时再尝试解锁 log.warn(\\\"[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}\\\", mq, pq.getTryUnlockTimes()); // 增加解锁尝试次数 pq.incTryUnlockTimes(); } } catch (Exception e) { log.error(\\\"removeUnnecessaryMessageQueue Exception\\\", e); } return false; } return true; } \"]},\"746\":{\"h\":\"4.1.2.3 消息队列加锁\",\"t\":[\"// RebalanceImpl.java /** * 锁定消息队列，向 Broker 发请求 * 顺序消费时使用 * * @param mq 要锁定的消息队列 * @return 是否锁定成功 */ public boolean lock(final MessageQueue mq) { // 查询 Broker 地址 FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true); if (findBrokerResult != null) { // 构造锁定消息队列请求 LockBatchRequestBody requestBody = new LockBatchRequestBody(); requestBody.setConsumerGroup(this.consumerGroup); requestBody.setClientId(this.mQClientFactory.getClientId()); requestBody.getMqSet().add(mq); try { // 调用 API 向 Broker 发送锁定队列请求，返回锁定成功的队列集合 Set<MessageQueue> lockedMq = this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000); for (MessageQueue mmqq : lockedMq) { // 将锁定成功队列的处理队列加锁 ProcessQueue processQueue = this.processQueueTable.get(mmqq); if (processQueue != null) { processQueue.setLocked(true); processQueue.setLastLockTimestamp(System.currentTimeMillis()); } } boolean lockOK = lockedMq.contains(mq); log.info(\\\"the message queue lock {}, {} {}\\\", lockOK ? \\\"OK\\\" : \\\"Failed\\\", this.consumerGroup, mq); return lockOK; } catch (Exception e) { log.error(\\\"lockBatchMQ exception, \\\" + mq, e); } } return false; } \"]},\"747\":{\"h\":\"4.2 消息拉取\"},\"748\":{\"h\":\"4.2.1 消息拉取\",\"t\":[\"消息拉取操作，对于顺序消费情况，提交拉取请求前会先判断处理队列的锁定状态。\",\"锁定：如果是第一次锁定（第一次拉取），计算并设置本次拉取任务消息队列的拉取偏移量\",\"未锁定：等待 3s 后再次执行拉取请求\",\"/** * 拉取消息入口 * * @param pullRequest 拉取请求，包含需要拉取的消费队列信息 */ public void pullMessage(final PullRequest pullRequest) { // 获取待拉取的消费队列 final ProcessQueue processQueue = pullRequest.getProcessQueue(); // ... if (!this.consumeOrderly) { // ... } else { // 处理顺序消费，如果处理队列已经被锁定 if (processQueue.isLocked()) { // 如果之前没有被锁定过（是第一次拉取） if (!pullRequest.isPreviouslyLocked()) { long offset = -1L; try { // 计算拉取偏移量 offset = this.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue()); } catch (Exception e) { // 计算异常，等待 3s 后再次判断 this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.error(\\\"Failed to compute pull offset, pullResult: {}\\\", pullRequest, e); return; } boolean brokerBusy = offset < pullRequest.getNextOffset(); log.info(\\\"the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}\\\", pullRequest, offset, brokerBusy); if (brokerBusy) { log.info(\\\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}\\\", pullRequest, offset); } // 设置之前已经锁定过 pullRequest.setPreviouslyLocked(true); // 设置要拉取的偏移量，在方法后面的逻辑中立即执行拉取 pullRequest.setNextOffset(offset); } } else { // 如果处理队列没有被锁定，等待 3s 后将 PullRequest 放入拉取请求队列，再次判断锁定情况尝试拉取 this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.info(\\\"pull message later because not locked in broker, {}\\\", pullRequest); return; } } // ... } \"]},\"749\":{\"h\":\"4.2.2 消息拉取成功\",\"t\":[\"public void onSuccess(PullResult pullResult) { if (pullResult != null) { // 将消息字节数组解码成消息列表并填充msgFoundList；对消息进行TAG模式过滤 pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult, subscriptionData); switch (pullResult.getPullStatus()) { // 找到对应消息 case FOUND: // 上次请求偏移量 long prevRequestOffset = pullRequest.getNextOffset(); // 更新下一次拉取的偏移量 pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 计算和记录拉取用时 long pullRT = System.currentTimeMillis() - beginTimestamp; DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullRT); // 如果msgFoundList为空，马上进行下次拉取 // msgFoundList为空的情况：因为根据TAG过滤时在服务端只验证了TAG的哈希码，客户端要再次对消息进行了过滤（见上），可能会出现为空的情况 long firstMsgOffset = Long.MAX_VALUE; if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } else { // 获取返回结果中第一条消息的消费队列offset firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset(); DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size()); // 将拉取到的消息存入ProcessQueue boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList()); // 将拉取到的消息提交到ConsumeMessageService中供消费者消费（异步） DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest( pullResult.getMsgFoundList(), processQueue, pullRequest.getMessageQueue(), dispatchToConsume); // 等待pullInterval毫秒后重新拉取，或立即重新拉取 if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) { DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval()); } else { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } } // ... } // ... } } \"]},\"750\":{\"h\":\"4.3 顺序消费任务\",\"t\":[\"// ConsumeMessageOrderlyService.java // class ConsumeRequest public void run() { if (this.processQueue.isDropped()) { log.warn(\\\"run, the message queue not be able to consume, because it's dropped. {}\\\", this.messageQueue); return; } // 从锁容器中获取消息队列消费锁 final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue); // 消费时申请独占消息队列消费锁对象 synchronized (objLock) { // 如果是广播模式；或者集群模式下处理队列被锁定且锁未超时，直接消费 if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) { final long beginTime = System.currentTimeMillis(); // 是否继续本次消费请求的消费任务 for (boolean continueConsume = true; continueConsume; ) { if (this.processQueue.isDropped()) { log.warn(\\\"the message queue not be able to consume, because it's dropped. {}\\\", this.messageQueue); break; } if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) { log.warn(\\\"the message queue not locked, so consume later, {}\\\", this.messageQueue); ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); break; } if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) { log.warn(\\\"the message queue lock expired, so consume later, {}\\\", this.messageQueue); ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); break; } // 计算本次消费请求任务执行时长，如果超过 60s，结束本次消费任务，（顺序消费任务以时长计算） long interval = System.currentTimeMillis() - beginTime; if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) { // 如果本次消费任务执行时长超过 60s，等到 10ms 后继续执行，以便让其他队列有机会消费 ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10); break; } // 每次从处理队列获取的一批消息数量，默认为 1 final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize(); // 从处理队列中取一批（默认 1 条）消息 List<MessageExt> msgs = this.processQueue.takeMessages(consumeBatchSize); // 为重试消息恢复真正的 Topic defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup()); if (!msgs.isEmpty()) { // 如果获取的这批消息不为空 final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue); ConsumeOrderlyStatus status = null; // 消费前钩子函数 ConsumeMessageContext consumeMessageContext = null; if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext = new ConsumeMessageContext(); consumeMessageContext .setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup()); consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace()); consumeMessageContext.setMq(messageQueue); consumeMessageContext.setMsgList(msgs); consumeMessageContext.setSuccess(false); // init the consume context type consumeMessageContext.setProps(new HashMap<String, String>()); ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext); } long beginTimestamp = System.currentTimeMillis(); ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; boolean hasException = false; try { // 消费消息锁 this.processQueue.getConsumeLock().lock(); if (this.processQueue.isDropped()) { log.warn(\\\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\\\", this.messageQueue); break; } // 消息消费监听器执行真正的消费业务逻辑 status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context); } catch (Throwable e) { log.warn(String.format(\\\"consumeMessage exception: %s Group: %s Msgs: %s MQ: %s\\\", RemotingHelper.exceptionSimpleDesc(e), ConsumeMessageOrderlyService.this.consumerGroup, msgs, messageQueue), e); hasException = true; } finally { // 消费消息锁解锁 this.processQueue.getConsumeLock().unlock(); } if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) { log.warn(\\\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\\\", ConsumeMessageOrderlyService.this.consumerGroup, msgs, messageQueue); } // 判断消费状态 long consumeRT = System.currentTimeMillis() - beginTimestamp; if (null == status) { if (hasException) { returnType = ConsumeReturnType.EXCEPTION; } else { returnType = ConsumeReturnType.RETURNNULL; } } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) { returnType = ConsumeReturnType.TIME_OUT; } else if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) { returnType = ConsumeReturnType.FAILED; } else if (ConsumeOrderlyStatus.SUCCESS == status) { returnType = ConsumeReturnType.SUCCESS; } if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name()); } if (null == status) { status = ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; } // 消息消费后钩子函数 if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext.setStatus(status.toString()); consumeMessageContext .setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status); ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext); } // 更新统计数据（消息消费时间） ConsumeMessageOrderlyService.this.getConsumerStatsManager() .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT); // 消费结果处理 continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this); } else { // 获取的这批消息为空，说明处理队列为空，结束本次消费请求的消费 continueConsume = false; } } } else { if (this.processQueue.isDropped()) { log.warn(\\\"the message queue not be able to consume, because it's dropped. {}\\\", this.messageQueue); return; } ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100); } } } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"751\":{\"h\":\"RocketMQ 最佳实践\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20221104-rocketmq-best-practice.html\"]},\"752\":{\"h\":\"生产者\"},\"753\":{\"h\":\"发送重试\",\"t\":[\"默认的消息发送超时时间为 3s，重试次数为 2 次。\",\"在生产环境中建议将超时时间合重试次数设大一点，以便有足够的重试次数来应对发送失败的场景。\",\"配置建议：\",\"使用异步发送可以避免上游调用超时，可以将超时时间设为 10s，重试次数设为 16次。\",\" producer.setSendMsgTimeout(10000); producer.setRetryTimesWhenSendFailed(16); producer.setRetryTimesWhenSendAsyncFailed(16); \"]},\"754\":{\"h\":\"延迟故障规避\",\"t\":[\"RocketMQ 引入了延迟故障规避机制，当消息发送失败后，不再会发送到失败的 Broker，而是换一个 Broker 发送。该机制默认不开启。\",\"该配置项为 sendLatencyFaultEnable\",\"false：默认值，规避策略只在当前消息发送失败重试时失效。\",\"true：一旦消息发送失败，在接下来的一段时间内所有的客户端都不会向对应的 Broker 发送消息。\",\"配置建议：\",\"根据集群的负载来选择，一般无需开启。\",\"如果集群负载较高，不建议开启。因为某个 Broker 发送失败后的 5 分钟不会接收消息，会造成其他 Broker 负载过高。\"]},\"755\":{\"h\":\"同一进程中多个生产者发送消息到多个集群\",\"t\":[\"RocketMQ 客户端 SDK 中的 MQClientInstance 表示对应到一个 RocketMQ 集群的客户端，在一个进程中可以有多个。 在 MQClientInstance 中可以注册多个生产者和消费者，这些生产者和消费者的元数据配置是相同的。\",\"为了实现多个生产者分别发送消息到多个集群，需要将生产者分别注册到多个 MQClientInstance 下，具体的方法为：为生产者设置不同的 ClientId。\",\"配置建议：\",\"将生产者的 UnitName 设置成集群名称，ClientId 生成时会拼接 UnitName，进而产生不同的 ClientId。\",\"DefaultMQProducer producer1 = new DefaultMQProducer(\\\"producer_group1\\\"); producer.setUnitName(\\\"Cluster1\\\") producer.setNamesrvAddr(\\\"1.1.1.1:9876\\\"); producer.start(); DefaultMQProducer producer2 = new DefaultMQProducer(\\\"producer_group2\\\"); producer.setUnitName(\\\"Cluster2\\\") producer.setNamesrvAddr(\\\"2.2.2.2:9876\\\"); producer.start(); \",\"附：生成 ClientId 的源码，\",\"public String buildMQClientId() { StringBuilder sb = new StringBuilder(); sb.append(this.getClientIP()); sb.append(\\\"@\\\"); sb.append(this.getInstanceName()); if (!UtilAll.isBlank(this.unitName)) { sb.append(\\\"@\\\"); sb.append(this.unitName); } return sb.toString(); } \"]},\"756\":{\"h\":\"消费者\"},\"757\":{\"h\":\"消费幂等\",\"t\":[\"RocketMQ无法避免消息重复（Exactly-Once），所以如果业务对消费重复非常敏感，有必要根据业务上的唯一Key对消息做幂等处理。 因为不同的Message ID对应的消息内容可能相同，有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息Key设置。\"]},\"758\":{\"h\":\"消费组线程数\",\"t\":[\"RocketMQ 消费者提供 consumeThreadMin、consumeThreadMax 两个参数来设置线程池中的线程个数，但是由于线程池内部为无界队列，所以 consumeThreadMax 参数无效。 在实践中这两个值往往会设置成相同的。\"]},\"759\":{\"h\":\"避免订阅关系不一致导致消息丢失\",\"t\":[\"RocketMQ 的一个消费组可以订阅多个 Topic，订阅多个 Tag。到那时同一个消费组中的订阅关系必须一致。 如果订阅关系不一致会造成消息丢失（部分消息未被消费）。\"]},\"760\":{\"h\":\"避免 ClientId 相同\",\"t\":[\"消费者的 ClientId 生成规则与生产者一样。如果一个消费组内两个消费者的 ClientId 相同，会出现有的队列重复消费、有的队列无法消费的情况。\",\"配置建议：\",\"由于 ClientId 生成时会拼接消费者的 clientIP 属性，同一 IP 下不同消费者的 clientIP 相同会导致 ClientId 相同，所以建议手动设置 clientIP。\",\"consumer.setClientIP('192.168.3.10' + System.currentTimeMillis()); \"]},\"761\":{\"h\":\"消费重试次数\",\"t\":[\"普通消息默认重试 16 次，重试实践按照延迟等级每次重试会递增，到达 16 次后，之后每次重试按照最大延迟等级对应的时间间隔。\",\" // 重试的时间从 10s 开始 private String messageDelayLevel = \\\"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\\\"; \",\"顺序消费模式下重试次数配置无效，如果一条消息消费不成功会一直重试，重试次数为 Integer.MAX_VALUE。重试时间间隔可以用 suspendCurrentQueueTimeMillis 设置，默认为 1s。\"]},\"762\":{\"h\":\"Broker\",\"t\":[\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"763\":{\"h\":\"RocketMQ 5.0：POP 消费模式 原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20221212-rocketmq-consumer-7-pop-consume.html\"]},\"764\":{\"h\":\"1. 背景\"},\"765\":{\"h\":\"1.1 什么是 Pop 消费\",\"t\":[\"RocketMQ 5.0 中引入了一种新的消费模式：Pop 消费模式。\",\"我们知道 RocketMQ 原来有两种消费模式：Pull 模式消费和 Push 模式消费，其中 Push 模式指的是 Broker 将消息主动“推送”给消费者，它的背后其实是消费者在不断地 Pull 消息来实现类似于 Broker “推”消息给消费者的效果。\",\"新引入的 Pop 消费模式主要是用于 Push 消费时将拉消息的动作替换成 Pop 。Pop 消费的行为和 Pull 消费很像，区别在于 Pop 消费的重平衡是在 Broker 端做的，而之前的 Pull 和 Push 消费都是由客户端完成重平衡。\"]},\"766\":{\"h\":\"1.2 如何使用 Pop 消费\",\"t\":[\"RocketMQ 提供了 2 种方式，能够让 Push 消费切换为使用 Pop 模式拉取消息（Pull 消费暂不支持切换 Pop 模式），分别为命令行方式切换和客户端代码方式切换。\"]},\"767\":{\"h\":\"1.2.1 使用命令行方式切换\",\"t\":[\"利用命令行，用如下命令，指定集群和需要切换的消费组，可以将一个消费组切换成 Pop 消费模式消费某个 Topic\",\"mqadmin setConsumeMode -c cluster -t topic -g group -m POP -q 8 \",\"以下为参数含义，其中 popShareQueueNum 表示 1 个队列最多可以被 N 个消费者同时消费。\",\"opt = new Option(\\\"c\\\", \\\"clusterName\\\", true, \\\"create subscription group to which cluster\\\"); opt = new Option(\\\"t\\\", \\\"topicName\\\", true, \\\"topic name\\\"); opt = new Option(\\\"g\\\", \\\"groupName\\\", true, \\\"consumer group name\\\"); opt = new Option(\\\"m\\\", \\\"mode\\\", true, \\\"consume mode. PULL/POP\\\"); opt = new Option(\\\"q\\\", \\\"popShareQueueNum\\\", true, \\\"num of queue which share in pop mode\\\"); \"]},\"768\":{\"h\":\"1.2.2 代码切换\",\"t\":[\"在创建 Consumer 之前，先运行 switchPop() 方法，它其实与上面命令行的逻辑一样，也是发送请求给集群中的所有 Broker 节点，让它们切换对应消费者组和 Topic 的消费者的消费模式为 Pop 模式。\",\"// PopPushConsumer.java public class PopPushConsumer { public static final String CONSUMER_GROUP = \\\"CID_JODIE_1\\\"; public static final String TOPIC = \\\"TopicTest\\\"; // Or use AdminTools directly: mqadmin setConsumeMode -c cluster -t topic -g group -m POP -n 8 private static void switchPop() throws Exception { DefaultMQAdminExt mqAdminExt = new DefaultMQAdminExt(); mqAdminExt.start(); ClusterInfo clusterInfo = mqAdminExt.examineBrokerClusterInfo(); Set<String> brokerAddrs = clusterInfo.getBrokerAddrTable().values().stream().map(BrokerData::selectBrokerAddr).collect(Collectors.toSet()); for (String brokerAddr : brokerAddrs) { mqAdminExt.setMessageRequestMode(brokerAddr, TOPIC, CONSUMER_GROUP, MessageRequestMode.POP, 8, 3_000); } } public static void main(String[] args) throws Exception { switchPop(); DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP); consumer.subscribe(TOPIC, \\\"*\\\"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> { System.out.printf(\\\"%s Receive New Messages: %s %n\\\", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; }); consumer.setClientRebalance(false); consumer.start(); System.out.printf(\\\"Consumer Started.%n\\\"); } } \"]},\"769\":{\"h\":\"1.3 引入 Pop 消费模式的原因\",\"t\":[\"引入 Pop 消费主要的原因是由于 Push 消费的机制导致它存在一些痛点。RocketMQ 5.0 云原生化的要求催生着一种能够解决这些痛点的新消费模式诞生。\",\"Push 消费模式的重平衡逻辑是在客户端完成的，这就导致了几个问题：\",\"客户端代码逻辑较重，要支持一种新语言的客户端就必须实现完整的重平衡逻辑，此外还需要实现拉消息、位点管理、消费失败后将消息发回 Broker 重试等逻辑。这给多语言客户端的支持造成很大的阻碍。\",\"当客户端升级或者下线时，都要进行重平衡操作，可能造成消息堆积。\",\"此外，Push 消费的特性是重平衡后每个消费者都分配到消费一定数量的队列，而每个队列最多只能被一个消费者消费。这就决定了消费者的横向扩展能力受到 Topic 中队列数量的限制。这里有引入了如下痛点\",\"消费者无法无限扩展，当消费者数量扩大到大于队列数量时，有的消费者将无法分配到队列。\",\"当某些消费者僵死（hang 住）时（与 Broker 的心跳未断，但是无法消费消息），会造成其消费的队列的消息堆积，迟迟无法被消费，也不会主动重平衡来解决这个问题。\",\"引入 Pop 消费模式之后，可以解决 Push 消费导致的可能的消息堆积问题和横向扩展能力问题。此外，RocketMQ 5.0 中引入了的轻量化客户端就用到了 Pop 消费能力，将 Pop 消费接口用 gRPC 封装，实现了多语言轻量化客户端，而不必在客户端实现重平衡逻辑。详见该项目 rocketmq-clients。\"]},\"770\":{\"h\":\"2. 概要设计\",\"t\":[\"Pop 消费主要的设计思想是将繁重的客户端逻辑如重平衡、消费进度提交、消费失败后发到 Broker 重试等逻辑放到 Broker 端。\",\"客户端只需要不断发送 Pop 请求，由 Broker 端来分配每次拉取请求要拉取的队列并返回消息。这样就可以实现多个客户端同时拉取一个队列的效果，不会存在一个客户端 hang 住导致队列消息堆积，也不会存在频繁的重平衡导致消息积压。\"]},\"771\":{\"h\":\"2.1 Pop 消费流程\",\"t\":[\"为了保证消费速度，Pop 消费一次请求可以拉取一批消息，拉取到的消息系统属性中有一个比较重要的属性叫做 POP_CK，它是该消息的句柄，ACK 时要通过句柄来定位到它。在 Broker 端会为这批消息保存一个 CheckPoint，它里面包含一批消息的句柄信息。\",\"对于长时间没有 ACK 的消息，Broker 端并非毫无办法。Pop 消费引入了消息不可见时间（invisibleTime）的机制。当 Pop 出一条消息后，这条消息对所有消费者不可见，即进入不可见时间，当它超过该时刻还没有被 ACK，Broker 将会把它放入 Pop 专门的重试 Topic（这个过程称为 Revive），这条消息重新可以被消费。\",\"Push 消费的重试间隔时间会随着重试次数而增加，Pop 消费也沿用了这个设计。此外，Pop 消费提供了一个接口 changeInvisibleTime() 来修改单条消息的不可见时间。\",\"从图上可以看见，本来消息会在中间这个时间点再一次的可见的，但是我们在可见之前提前使用 changeInvisibleTime 延长了不可见时间，让这条消息的可见时间推迟了。\",\"当消费失败（用户业务代码返回 reconsumeLater 或者抛异常）的时候，消费者就通过 changeInvisibleTime 按照重试次数来修改下一次的可见时间。另外如果消费消息用时超过了 30 秒（默认值，可以修改），则 Broker 也会把消息放到重试队列。\"]},\"772\":{\"h\":\"2.2 客户端-服务端交互\",\"t\":[\"Pop 消费的流程与 Push 消费较为相似，这里我分为 5 个步骤。\",\"向 Broker 端发送请求，切换消息拉取模式为 Pop 模式\",\"重平衡服务执行重平衡，此时已经切换为 Pop 模式，所以是向 Broker 端发起请求，请求中带有重平衡策略，Broker 会返回重平衡的结果。\",\"重平衡完毕之后开始拉取消息，拉取消息服务发送 POP_MESSAGE 请求给 Broker，获取一批消息\",\"消费这批消息\",\"对成功消费的消息，发送 ACK 请求给 Broker\"]},\"773\":{\"h\":\"2.3 服务端实现\",\"t\":[\"服务端收到 Pop 请求后，会先在 Queue 维度上加锁，保证同一时间只有一个消费者可以拉取该队列的消息。\",\"随后服务端会在存储中查询一批消息，将这批消息的构建的 CheckPoint 保存在 Broker 中，以便与 ACK 的消息匹配。\",\"CheckPoint 的存在目的是与 ACK 的消息匹配，并将没有匹配的消息重试。CheckPoint 的 ReviveTime 就是它这批消息需要被尝试重试（唤醒）的时间。\",\"CheckPoint会先被保存在内存中，一般来说消息消费很快，所以在内存中就能够与 ACK 消息匹配成功后删除。如果在一段时间（默认 3s）内没有匹配成功，它将会从内存中被删除，转入磁盘等待匹配。\",\"对于 ACK 消息也一样，它先被放入内存中匹配，如果在内存中找不到对应的 CheckPoint，也会放入磁盘。\",\"RocketMQ 的磁盘存储实际上就是 Topic 和队列。为了避免频繁检查匹配状态，我们只在 CheckPoint 需要被唤醒时做检查，这里就可以用到定时消息，将 CheckPoint 和 ACK 消息定时到 ReviveTime 投递。这里 RocketMQ 将 CheckPoint 的投递时间提前 1s，以便能先消费到，与 ACK 消息匹配。\",\"当定时到期，它们会被投递到 REVIVE_TOPIC。有个后台线程消费这个 Topic，把 CheckPoint 放到一个 map 中，对于 ACK 消息则从 map 中查找 CheckPoint 来尝试匹配，如果匹配成功则更新 REVIVE_TOPIC 的消费位点。对于超过 ReviveTime 还没有被匹配的 CheckPoint，查出这批消息中要重试消息对应的真实消息，并放到 Pop 消费重试 Topic 中。\",\"Broker 端的 Pop 消费逻辑会概率性消费到重试 Topic 中的消息。\"]},\"774\":{\"h\":\"3. 详细设计\"},\"775\":{\"h\":\"3.1 Broker 端重平衡\",\"t\":[\"Pop 消费的重平衡在 Broker 端完成，客户端的重平衡服务重平衡时会向 Broker 端发送查询请求，查询自己的分配结果。\",\"重平衡的主要逻辑其实与在客户端重平衡类似，只不过变成了 Broker 接收客户端的参数之后根据这些参数进行重平衡，然后把重平衡结果返回给客户端。\",\"Broker 端重平衡入口为 QueryAssignmentProcessor#doLoadBalance()。\",\"对于广播模式，直接返回 Topic 下所有的队列。\",\"对于集群模式，Pop 模式的重平衡与 Push 模式不同，它允许一个队列被多个消费者 Pop 消费。在切换 Pop 模式时引入了 popShareQueueNum 参数，表示允许消费者进行额外的负载获取队列的次数（可以被共享的队列数），0 表示可以消费所有队列。\",\"所以重平衡时对每个消费者执行 popShareQueueNum 次重平衡策略，将多次重平衡分配到的队列都分给这个消费者消费。这样，每个队列就会被多个消费者消费。\",\"下图为 popShareQueueNum = 1 时的重平衡情况，每个消费者被负载了 2 次，每个队列被 2 个消费者共享（1 + popShareQueueNum）。\"]},\"776\":{\"h\":\"3.2 Broker 端 Pop 消息\"},\"777\":{\"h\":\"3.2.1 请求处理入口\",\"t\":[\"Pop 消息的 Broker 端处理是由 PopMessageProcessor#processRequest() 完成。\",\"该方法逻辑为\",\"完成请求体解析和一些参数和权限的校验\",\"生成一个 0 到 99 的随机整数，如果能被 5 整除，则先拉取重试 Topic。\",\"从重试 Topic 的每个 Queue 中 Pop 消息\",\"根据请求的队列 Pop 对应的队列的消息。如果 Pop 请求指定了队列，只会消费一个队列的消息；如果没有指定队列，则 Pop 所有队列的消息\",\"如果 Pop 的消息没有满（达到请求的最大消息数量），且之前没有拉取过重试消息，则 Pop 重试 Topic 所有队列的消息（期望填充满 Pop 请求要求的数量）\",\"判断是否 Pop 到消息，如果有则传输回客户端，如果没有则挂起轮询，直到超过请求的 timeout 参数指定的时间\"]},\"778\":{\"h\":\"3.2.2 Pop 消息方法\",\"t\":[\"上面的 3、4、5 都涉及到从存储中 Pop 消息，它们都调用同一个方法：popMsgFromQueue，它是真正查询消息的方法，下面看一下它的逻辑\",\"将需要 Pop 的队列上锁（用 AtomicBoolean 实现）\",\"计算 Pop 消息的起始偏移量，会返回内存中 CheckPoint 与 ACK 消息匹配后的最新位点\",\"从磁盘中根据起始偏移量查询一批消息\",\"计算队列剩余的消息数量（用作返回值）\",\"拉取的这批消息将生成一个 CheckPoint，存入内存和磁盘\",\"解锁队列\",\"返回 Pop 到的消息\",\"上面方法第 5 步会将生成的 CheckPoint 放入内存和磁盘，注意这个 CheckPoint 会保存一批获取到的消息的起始偏移量和相对偏移量（相对于起始偏移量），所以一个 CheckPoint 在保存和匹配时都对应一批消息。\"]},\"779\":{\"h\":\"3.2.3 保存 CheckPoint 用于匹配\",\"t\":[\"构造 CheckPoint，添加起始偏移量和所有 Pop 出的消息的相对偏移量\",\"尝试将 CheckPoint 添加到内存 Buffer，如果成功则直接返回。但是在内存中匹配 CheckPoint 和 AckMsg 的开关默认是关闭的，所以这里不会加入到内存，会继续后面的逻辑放入磁盘\",\"将 CheckPoint 构造成一个消息，数据都放到消息体中，然后这个消息定时到 ReviveTime（唤醒重试的时间）- 1s（为了留时间与 AckMsg 匹配）发送。会发送到 ReviveTopic 的一个队列。\"]},\"780\":{\"h\":\"3.3 Broker 端 ACK 消息\",\"t\":[\"Ack 消息接口每次只允许 Ack 一条消息，入口是 AckMessageProcessor#processRequest()\",\"从请求头解析和构造 Ack 消息，并作一些校验\",\"顺序消息 Ack 和普通消息 Ack 分别处理，这里针对普通消息\",\"先尝试将 Ack 消息放入内存 Buffer，如果成功则直接返回。失败则有可能是内存匹配未开启。\",\"如果放入内存失败，构造一个用于存到磁盘的消息，定时到唤醒重试时间投递（到 ReviveTopic）。\"]},\"781\":{\"h\":\"3.4 Broker 端 CheckPoint 与 AckMsg 匹配\",\"t\":[\"CheckPoint 和 AckMsg 都被设计成先尝试放入内存中匹配，然后再磁盘中匹配，因为通常情况下消息消费之后都能很快 ACK，内存匹配性能较高。如果 CheckPoint 在内存中停留太久没有被匹配，则会转移到磁盘中（ReviveTopic），有个线程消费这个 ReviveTopic 来匹配。到达唤醒重试时间（ReviveTime）还没有被匹配的 CheckPoint 里面的消息将会重试（发送到 Pop 消息重试 Topic，后面的 Pop 有概率消费到）。\"]},\"782\":{\"h\":\"3.4.1 内存匹配\",\"t\":[\"内存匹配逻辑由一个线程 PopBufferMergeService 完成，只有主节点运行该匹配线程。\",\"Pop 消息时会先添加 CheckPoint 到 buffer，Ack 消息时尝试从内存 buffer 中的 CheckPoint 匹配。同时，它每 5ms 执行一次扫描，将不符合内存中存活条件的 CheckPoint 移除，放入磁盘存储。\",\"addCk 方法将 CheckPoint 放入内存 Buffer。CheckPoint 中有一个码表 BitMap，用来表示它里面的每个条消息是否被 Ack 和被存到磁盘。用 BitMap 可以加速匹配。\",\"addAk 方法会尝试从 buffer 中找 CheckPoint 来匹配。如果找到对应的 CheckPoint，则修改它码表的对应位，表示这条消息被 ACK。\",\"scan 方法每 5ms 执行一次\",\"将已经匹配或存盘的 CheckPoint 移出 buffer\",\"把超时的 CheckPoint 存入磁盘\",\"对于匹配完成或者存盘的 CheckPoint，为他们提交消息偏移量\"]},\"783\":{\"h\":\"3.4.2 Store 匹配和消息重试\",\"t\":[\"从内存中移除保存到磁盘的 CheckPoint 和 AckMsg 都会封装成消息进行定时投递（定时到重试时间），最终投递到 ReviveTopic。存储中匹配也由一个线程 PopReviveService 完成，它消费 ReviveTopic 的消息进行匹配和重试。\",\"Pop 消费由于要根据 Topic 来 Pop 消息，重试 Topic 需要针对每个 [消费组-Topic] 隔离，所以它不能用普通消息的消费组维度的重试 Topic，而是用专门的 Pop 重试 Topic %RETRY%{消费组}_{TOPIC}。\",\"PopReviveService#run 方法是该处理线程的入口，它每秒都会调用 consumeReviveMessage 消费和匹配 ReviveTopic 消息，然后调用 mergeAndRevive 方法检查匹配的情况并对达到唤醒时间还没有成功匹配的消息重试。\",\"这两个方法会先初始化一个 map，用于存放 CheckPoint，供 AckMsg 根据 map key 查找 CheckPoint。\",\"consumeReviveMessage 会消费 2s 内的一批 ReviveTopic 消息，CK 消息放入 map，Ack 消息则从 map 中查找 CK，在码表上标记对应的消息为 Acked。\",\"mergeAndRevive 方法如其名，遍历消费到的 CK 消息，对于已经到重试时间的，对没有 Ack 的消息进行重试。\",\"重试逻辑为先从 MessageStore 查询对应的真正消息，然后将该消息发送到 Pop 重试队列。\"]},\"784\":{\"h\":\"4. 源码解析\"},\"785\":{\"h\":\"4.1 Broker 端重平衡\"},\"786\":{\"h\":\"4.1.1 QueryAssignmentProcessor#doLoadBalance\",\"t\":[\"/** * Broker 端重平衡 * Returns empty set means the client should clear all load assigned to it before, null means invalid result and the * client should skip the update logic * * @param topic * @param consumerGroup * @param clientId * @param messageModel 消费模型（广播/集群） * @param strategyName 重平衡策略名 * @return the MessageQueues assigned to this client */ private Set<MessageQueue> doLoadBalance(final String topic, final String consumerGroup, final String clientId, final MessageModel messageModel, final String strategyName, SetMessageRequestModeRequestBody setMessageRequestModeRequestBody, final ChannelHandlerContext ctx) { Set<MessageQueue> assignedQueueSet = null; final TopicRouteInfoManager topicRouteInfoManager = this.brokerController.getTopicRouteInfoManager(); switch (messageModel) { case BROADCASTING: { // 广播模式，返回该 Topic 下所有队列 assignedQueueSet = topicRouteInfoManager.getTopicSubscribeInfo(topic); if (assignedQueueSet == null) { log.warn(\\\"QueryLoad: no assignment for group[{}], the topic[{}] does not exist.\\\", consumerGroup, topic); } break; } case CLUSTERING: { // 集群模式 // 获取 Topic 下所有队列 Set<MessageQueue> mqSet = topicRouteInfoManager.getTopicSubscribeInfo(topic); if (null == mqSet) { if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"QueryLoad: no assignment for group[{}], the topic[{}] does not exist.\\\", consumerGroup, topic); } return null; } if (!brokerController.getBrokerConfig().isServerLoadBalancerEnable()) { return mqSet; } List<String> cidAll = null; // 获取发起请求的消费组信息 ConsumerGroupInfo consumerGroupInfo = this.brokerController.getConsumerManager().getConsumerGroupInfo(consumerGroup); if (consumerGroupInfo != null) { cidAll = consumerGroupInfo.getAllClientId(); } if (null == cidAll) { log.warn(\\\"QueryLoad: no assignment for group[{}] topic[{}], get consumer id list failed\\\", consumerGroup, topic); return null; } List<MessageQueue> mqAll = new ArrayList<MessageQueue>(); mqAll.addAll(mqSet); // 将队列和消费者客户端ID 排序 Collections.sort(mqAll); Collections.sort(cidAll); List<MessageQueue> allocateResult = null; try { // 根据重平衡策略名称获取策略 AllocateMessageQueueStrategy allocateMessageQueueStrategy = name2LoadStrategy.get(strategyName); if (null == allocateMessageQueueStrategy) { log.warn(\\\"QueryLoad: unsupported strategy [{}], {}\\\", strategyName, RemotingHelper.parseChannelRemoteAddr(ctx.channel())); return null; } if (setMessageRequestModeRequestBody != null && setMessageRequestModeRequestBody.getMode() == MessageRequestMode.POP) { // POP 模式重平衡 allocateResult = allocate4Pop(allocateMessageQueueStrategy, consumerGroup, clientId, mqAll, cidAll, setMessageRequestModeRequestBody.getPopShareQueueNum()); } else { // 普通重平衡 allocateResult = allocateMessageQueueStrategy.allocate(consumerGroup, clientId, mqAll, cidAll); } } catch (Throwable e) { log.error(\\\"QueryLoad: no assignment for group[{}] topic[{}], allocate message queue exception. strategy name: {}, ex: {}\\\", consumerGroup, topic, strategyName, e); return null; } assignedQueueSet = new HashSet<MessageQueue>(); if (allocateResult != null) { assignedQueueSet.addAll(allocateResult); } break; } default: break; } return assignedQueueSet; } \"]},\"787\":{\"h\":\"4.1.2 QueryAssignmentProcessor#allocate4Pop\",\"t\":[\"/** * POP 模式重平衡 * * @param allocateMessageQueueStrategy 重平衡策略 * @param consumerGroup 消费组 * @param clientId 消费组客户端 ID * @param mqAll 全部消息队列 * @param cidAll 全部客户端ID * @param popShareQueueNum Pop 模式下可允许被共享的队列数，0 表示无限 * @return 该消费者负载的队列列表 */ public List<MessageQueue> allocate4Pop(AllocateMessageQueueStrategy allocateMessageQueueStrategy, final String consumerGroup, final String clientId, List<MessageQueue> mqAll, List<String> cidAll, int popShareQueueNum) { List<MessageQueue> allocateResult; if (popShareQueueNum <= 0 || popShareQueueNum >= cidAll.size() - 1) { // 每个消费者能消费所有队列，返回全部队列。队列 ID 为 -1 表示 Pop 消费时消费全部队列 //each client pop all messagequeue allocateResult = new ArrayList<>(mqAll.size()); for (MessageQueue mq : mqAll) { //must create new MessageQueue in case of change cache in AssignmentManager MessageQueue newMq = new MessageQueue(mq.getTopic(), mq.getBrokerName(), -1); allocateResult.add(newMq); } } else { if (cidAll.size() <= mqAll.size()) { // 消费者数量小于等于队列数量，每个消费者分配 N 个队列，每个队列也会被分配给多个消费者 //consumer working in pop mode could share the MessageQueues assigned to the N (N = popWorkGroupSize) consumer following it in the cid list allocateResult = allocateMessageQueueStrategy.allocate(consumerGroup, clientId, mqAll, cidAll); int index = cidAll.indexOf(clientId); if (index >= 0) { // 负载 popShareQueueNum 次，将每次负载的结果加入最终结果 for (int i = 1; i <= popShareQueueNum; i++) { index++; index = index % cidAll.size(); List<MessageQueue> tmp = allocateMessageQueueStrategy.allocate(consumerGroup, cidAll.get(index), mqAll, cidAll); allocateResult.addAll(tmp); } } } else { // 消费者数量大于队列数量，保证每个消费者都有队列消费 //make sure each cid is assigned allocateResult = allocate(consumerGroup, clientId, mqAll, cidAll); } } return allocateResult; } \"]},\"788\":{\"h\":\"4.2 Broker 端 Pop 消息\"},\"789\":{\"h\":\"4.2.1 PopMessageProcessor#processRequest\",\"t\":[\"/** * 处理 POP 消息请求 * * @param channel * @param request * @return * @throws RemotingCommandException */ private RemotingCommand processRequest(final Channel channel, RemotingCommand request) throws RemotingCommandException { // ... 解析请求体和一系列校验 // 生成随机数 int randomQ = random.nextInt(100); int reviveQid; if (requestHeader.isOrder()) { reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE; } else { // 轮询选一个 Revive 队列 reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum()); } int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg(); GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg); // 队列中剩余的消息数量 long restNum = 0; // 1/5 的概率拉取重试消息 boolean needRetry = randomQ % 5 == 0; long popTime = System.currentTimeMillis(); // 拉取重试消息 if (needRetry && !requestHeader.isOrder()) { TopicConfig retryTopicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup())); if (retryTopicConfig != null) { for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) { int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums(); restNum = popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, messageFilter, startOffsetInfo, msgOffsetInfo, orderCountInfo); } } } // 如果拉取请求没有指定队列（-1），则拉取所有队列 if (requestHeader.getQueueId() < 0) { // read all queue for (int i = 0; i < topicConfig.getReadQueueNums(); i++) { int queueId = (randomQ + i) % topicConfig.getReadQueueNums(); restNum = popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, messageFilter, startOffsetInfo, msgOffsetInfo, orderCountInfo); } } else { // 拉取请求指定了队列，拉取对应的队列 int queueId = requestHeader.getQueueId(); restNum = popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, messageFilter, startOffsetInfo, msgOffsetInfo, orderCountInfo); } // 如果前面拉取普通消息之后，没有满，则再拉取一次重试消息 // if not full , fetch retry again if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) { TopicConfig retryTopicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup())); if (retryTopicConfig != null) { for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) { int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums(); restNum = popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, messageFilter, startOffsetInfo, msgOffsetInfo, orderCountInfo); } } } // 拉取消息成功 if (!getMessageResult.getMessageBufferList().isEmpty()) { response.setCode(ResponseCode.SUCCESS); getMessageResult.setStatus(GetMessageStatus.FOUND); if (restNum > 0) { // all queue pop can not notify specified queue pop, and vice versa notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueId()); } } else { // 没有拉取到消息，长轮询 int pollingResult = polling(channel, request, requestHeader); if (POLLING_SUC == pollingResult) { return null; } else if (POLLING_FULL == pollingResult) { response.setCode(ResponseCode.POLLING_FULL); } else { response.setCode(ResponseCode.POLLING_TIMEOUT); } getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE); } responseHeader.setInvisibleTime(requestHeader.getInvisibleTime()); responseHeader.setPopTime(popTime); responseHeader.setReviveQid(reviveQid); responseHeader.setRestNum(restNum); responseHeader.setStartOffsetInfo(startOffsetInfo.toString()); responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString()); if (requestHeader.isOrder() && orderCountInfo != null) { responseHeader.setOrderCountInfo(orderCountInfo.toString()); } response.setRemark(getMessageResult.getStatus().name()); // 传输消息 return response; } \"]},\"790\":{\"h\":\"4.2.2 PopMessageProcessor#popMsgFromQueue\",\"t\":[\"/** * 从消息队列中 POP 消息 * * @param isRetry 是否是重试 Topic * @param getMessageResult * @param requestHeader * @param queueId 消息队列 ID * @param restNum 队列剩余消息数量 * @param reviveQid 唤醒队列 ID * @param channel Netty Channel，用于获取客户端 host，来提交消费进度 * @param popTime Pop 时间 * @param messageFilter * @param startOffsetInfo 获取 Pop 的起始偏移量 * @param msgOffsetInfo 获取所有 Pop 的消息的逻辑偏移量 * @param orderCountInfo * @return 队列剩余消息 */ private long popMsgFromQueue(boolean isRetry, GetMessageResult getMessageResult, PopMessageRequestHeader requestHeader, int queueId, long restNum, int reviveQid, Channel channel, long popTime, ExpressionMessageFilter messageFilter, StringBuilder startOffsetInfo, StringBuilder msgOffsetInfo, StringBuilder orderCountInfo) { String topic = isRetry ? KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()) : requestHeader.getTopic(); // {TOPIC}@{GROUP}@{QUEUE_ID} String lockKey = topic + PopAckConstants.SPLIT + requestHeader.getConsumerGroup() + PopAckConstants.SPLIT + queueId; boolean isOrder = requestHeader.isOrder(); long offset = getPopOffset(topic, requestHeader, queueId, false, lockKey); // Queue 上加锁，保证同一时刻只有一个消费者可以拉取同一个 Queue 的消息 if (!queueLockManager.tryLock(lockKey)) { // 返回该队列中待 Pop 的消息数量 restNum = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId) - offset + restNum; return restNum; } // 计算要 POP 的消息偏移量 offset = getPopOffset(topic, requestHeader, queueId, true, lockKey); GetMessageResult getMessageTmpResult = null; try { // 顺序消费，阻塞 if (isOrder && brokerController.getConsumerOrderInfoManager().checkBlock(topic, requestHeader.getConsumerGroup(), queueId, requestHeader.getInvisibleTime())) { return this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId) - offset + restNum; } // 已经拉取到足够的消息 if (getMessageResult.getMessageMapedList().size() >= requestHeader.getMaxMsgNums()) { restNum = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId) - offset + restNum; return restNum; } // 从磁盘消息存储中根据逻辑偏移量查询消息 getMessageTmpResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup() , topic, queueId, offset, requestHeader.getMaxMsgNums() - getMessageResult.getMessageMapedList().size(), messageFilter); if (getMessageTmpResult == null) { return this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId) - offset + restNum; } // maybe store offset is not correct. if (GetMessageStatus.OFFSET_TOO_SMALL.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.OFFSET_OVERFLOW_BADLY.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.OFFSET_FOUND_NULL.equals(getMessageTmpResult.getStatus())) { // commit offset, because the offset is not correct // If offset in store is greater than cq offset, it will cause duplicate messages, // because offset in PopBuffer is not committed. POP_LOGGER.warn(\\\"Pop initial offset, because store is no correct, {}, {}->{}\\\", lockKey, offset, getMessageTmpResult.getNextBeginOffset()); offset = getMessageTmpResult.getNextBeginOffset(); this.brokerController.getConsumerOffsetManager().commitOffset(channel.remoteAddress().toString(), requestHeader.getConsumerGroup(), topic, queueId, offset); getMessageTmpResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), topic, queueId, offset, requestHeader.getMaxMsgNums() - getMessageResult.getMessageMapedList().size(), messageFilter); } // 计算队列还剩下的消息数量 restNum = getMessageTmpResult.getMaxOffset() - getMessageTmpResult.getNextBeginOffset() + restNum; if (!getMessageTmpResult.getMessageMapedList().isEmpty()) { // 更新统计数据 this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageTmpResult.getMessageCount()); this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), topic, getMessageTmpResult.getMessageCount()); this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), topic, getMessageTmpResult.getBufferTotalSize()); if (isOrder) { // 顺序消费，更新偏移量 int count = brokerController.getConsumerOrderInfoManager().update(topic, requestHeader.getConsumerGroup(), queueId, getMessageTmpResult.getMessageQueueOffset()); this.brokerController.getConsumerOffsetManager().commitOffset(channel.remoteAddress().toString(), requestHeader.getConsumerGroup(), topic, queueId, offset); ExtraInfoUtil.buildOrderCountInfo(orderCountInfo, isRetry, queueId, count); } else { // 添加 CheckPoint 到内存，用于等待 ACK appendCheckPoint(requestHeader, topic, reviveQid, queueId, offset, getMessageTmpResult, popTime, this.brokerController.getBrokerConfig().getBrokerName()); } ExtraInfoUtil.buildStartOffsetInfo(startOffsetInfo, isRetry, queueId, offset); ExtraInfoUtil.buildMsgOffsetInfo(msgOffsetInfo, isRetry, queueId, getMessageTmpResult.getMessageQueueOffset()); } else if ((GetMessageStatus.NO_MATCHED_MESSAGE.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.OFFSET_FOUND_NULL.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.MESSAGE_WAS_REMOVING.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.NO_MATCHED_LOGIC_QUEUE.equals(getMessageTmpResult.getStatus())) && getMessageTmpResult.getNextBeginOffset() > -1) { // 没有拉取到消息，添加假的消息 CheckPoint 到队列 popBufferMergeService.addCkMock(requestHeader.getConsumerGroup(), topic, queueId, offset, requestHeader.getInvisibleTime(), popTime, reviveQid, getMessageTmpResult.getNextBeginOffset(), brokerController.getBrokerConfig().getBrokerName()); // this.brokerController.getConsumerOffsetManager().commitOffset(channel.remoteAddress().toString(), requestHeader.getConsumerGroup(), topic, // queueId, getMessageTmpResult.getNextBeginOffset()); } } catch (Exception e) { POP_LOGGER.error(\\\"Exception in popMsgFromQueue\\\", e); } finally { // Pop 完后解锁 queueLockManager.unLock(lockKey); } // 将拉取到的消息放入结果容器中 if (getMessageTmpResult != null) { for (SelectMappedBufferResult mapedBuffer : getMessageTmpResult.getMessageMapedList()) { getMessageResult.addMessage(mapedBuffer); } } return restNum; } \"]},\"791\":{\"h\":\"4.2.3 PopMessageProcessor#appendCheckPoint\",\"t\":[\"/** * 在 POP 拉取消息后调用，添加 CheckPoint，等待 ACK * * @param requestHeader * @param topic POP 的 Topic * @param reviveQid Revive 队列 ID * @param queueId POP 的队列 ID * @param offset POP 消息的起始偏移量 * @param getMessageTmpResult POP 一批消息的结果 * @param popTime POP 时间 * @param brokerName */ private void appendCheckPoint(final PopMessageRequestHeader requestHeader, final String topic, final int reviveQid, final int queueId, final long offset, final GetMessageResult getMessageTmpResult, final long popTime, final String brokerName) { // add check point msg to revive log final PopCheckPoint ck = new PopCheckPoint(); // ... 构造 PopCheckPoint，赋值过程省略 for (Long msgQueueOffset : getMessageTmpResult.getMessageQueueOffset()) { // 添加所有拉取的消息的偏移量与起始偏移量的差值 ck.addDiff((int) (msgQueueOffset - offset)); } // 将 Offset 放入内存 final boolean addBufferSuc = this.popBufferMergeService.addCk( ck, reviveQid, -1, getMessageTmpResult.getNextBeginOffset() ); if (addBufferSuc) { return; } // 放入内存匹配失败（内存匹配未开启），将 Offset 放入内存和磁盘 this.popBufferMergeService.addCkJustOffset( ck, reviveQid, -1, getMessageTmpResult.getNextBeginOffset() ); } \"]},\"792\":{\"h\":\"4.3 Broker 端 Ack 消息\"},\"793\":{\"h\":\"4.3.1 AckMessageProcessor#processRequest\",\"t\":[\"/** * 处理 Ack 消息请求，每次 Ack 一条消息 * * @param channel * @param request * @param brokerAllowSuspend * @return * @throws RemotingCommandException */ private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend) throws RemotingCommandException { // 解析请求头 final AckMessageRequestHeader requestHeader = (AckMessageRequestHeader) request.decodeCommandCustomHeader(AckMessageRequestHeader.class); MessageExtBrokerInner msgInner = new MessageExtBrokerInner(); AckMsg ackMsg = new AckMsg(); RemotingCommand response = RemotingCommand.createResponseCommand(ResponseCode.SUCCESS, null); response.setOpaque(request.getOpaque()); // ... 校验 // 拆分消息句柄字符串 String[] extraInfo = ExtraInfoUtil.split(requestHeader.getExtraInfo()); // 用请求头中的信息构造 AckMsg ackMsg.setAckOffset(requestHeader.getOffset()); ackMsg.setStartOffset(ExtraInfoUtil.getCkQueueOffset(extraInfo)); ackMsg.setConsumerGroup(requestHeader.getConsumerGroup()); ackMsg.setTopic(requestHeader.getTopic()); ackMsg.setQueueId(requestHeader.getQueueId()); ackMsg.setPopTime(ExtraInfoUtil.getPopTime(extraInfo)); ackMsg.setBrokerName(ExtraInfoUtil.getBrokerName(extraInfo)); int rqId = ExtraInfoUtil.getReviveQid(extraInfo); this.brokerController.getBrokerStatsManager().incBrokerAckNums(1); this.brokerController.getBrokerStatsManager().incGroupAckNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(), 1); if (rqId == KeyBuilder.POP_ORDER_REVIVE_QUEUE) { // ... 顺序消息 ACK } // 普通消息 ACK // 先尝试放入内存匹配，成功则直接返回。失败可能是内存匹配未开启 if (this.brokerController.getPopMessageProcessor().getPopBufferMergeService().addAk(rqId, ackMsg)) { return response; } // 构造 Ack 消息 msgInner.setTopic(reviveTopic); msgInner.setBody(JSON.toJSONString(ackMsg).getBytes(DataConverter.charset)); //msgInner.setQueueId(Integer.valueOf(extraInfo[3])); msgInner.setQueueId(rqId); msgInner.setTags(PopAckConstants.ACK_TAG); msgInner.setBornTimestamp(System.currentTimeMillis()); msgInner.setBornHost(this.brokerController.getStoreHost()); msgInner.setStoreHost(this.brokerController.getStoreHost()); // 定时消息，定时到唤醒重试时间投递 msgInner.setDeliverTimeMs(ExtraInfoUtil.getPopTime(extraInfo) + ExtraInfoUtil.getInvisibleTime(extraInfo)); msgInner.getProperties().put(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, PopMessageProcessor.genAckUniqueId(ackMsg)); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); // 保存 Ack 消息到磁盘 PutMessageResult putMessageResult = this.brokerController.getEscapeBridge().putMessageToSpecificQueue(msgInner); if (putMessageResult.getPutMessageStatus() != PutMessageStatus.PUT_OK && putMessageResult.getPutMessageStatus() != PutMessageStatus.FLUSH_DISK_TIMEOUT && putMessageResult.getPutMessageStatus() != PutMessageStatus.FLUSH_SLAVE_TIMEOUT && putMessageResult.getPutMessageStatus() != PutMessageStatus.SLAVE_NOT_AVAILABLE) { POP_LOGGER.error(\\\"put ack msg error:\\\" + putMessageResult); } return response; } \"]},\"794\":{\"h\":\"4.4 Broker 端 CheckPoint 与 AckMsg 匹配\"},\"795\":{\"h\":\"4.4.1 PopBufferMergeService#addCk\",\"t\":[\"/** * POP 消息后，新增 CheckPoint，放入内存 Buffer * * @param point * @param reviveQueueId * @param reviveQueueOffset * @param nextBeginOffset * @return 是否添加成功 */ public boolean addCk(PopCheckPoint point, int reviveQueueId, long reviveQueueOffset, long nextBeginOffset) { // key: point.getT() + point.getC() + point.getQ() + point.getSo() + point.getPt() if (!brokerController.getBrokerConfig().isEnablePopBufferMerge()) { return false; } // 内存匹配服务是否开启 if (!serving) { return false; } // 距离下次可重试 Pop 消费的时刻 < 4.5s long now = System.currentTimeMillis(); if (point.getReviveTime() - now < brokerController.getBrokerConfig().getPopCkStayBufferTimeOut() + 1500) { if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.warn(\\\"[PopBuffer]add ck, timeout, {}, {}\\\", point, now); } return false; } if (this.counter.get() > brokerController.getBrokerConfig().getPopCkMaxBufferSize()) { POP_LOGGER.warn(\\\"[PopBuffer]add ck, max size, {}, {}\\\", point, this.counter.get()); return false; } PopCheckPointWrapper pointWrapper = new PopCheckPointWrapper(reviveQueueId, reviveQueueOffset, point, nextBeginOffset); if (!checkQueueOk(pointWrapper)) { return false; } // 将 CheckPoint 放入 Offset 队列 putOffsetQueue(pointWrapper); // 将 CheckPoint 放入内存 Buffer this.buffer.put(pointWrapper.getMergeKey(), pointWrapper); this.counter.incrementAndGet(); if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"[PopBuffer]add ck, {}\\\", pointWrapper); } return true; } \"]},\"796\":{\"h\":\"4.4.2 PopBufferMergeService#addAk\",\"t\":[\"/** * 消息 ACK，与内存中的 CheckPoint 匹配 * * @param reviveQid * @param ackMsg * @return 是否匹配成功 */ public boolean addAk(int reviveQid, AckMsg ackMsg) { // 如果未开启内存匹配，直接返回 if (!brokerController.getBrokerConfig().isEnablePopBufferMerge()) { return false; } if (!serving) { return false; } try { // 根据 ACK 的消息找到内存 Buffer 中的 CheckPoint PopCheckPointWrapper pointWrapper = this.buffer.get(ackMsg.getTopic() + ackMsg.getConsumerGroup() + ackMsg.getQueueId() + ackMsg.getStartOffset() + ackMsg.getPopTime() + ackMsg.getBrokerName()); if (pointWrapper == null) { // 找不到 CheckPoint if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.warn(\\\"[PopBuffer]add ack fail, rqId={}, no ck, {}\\\", reviveQid, ackMsg); } return false; } // 内存中仅保存 Offset，实际已经保存到磁盘，内存中不处理 ACK 消息的匹配，直接返回 if (pointWrapper.isJustOffset()) { return false; } PopCheckPoint point = pointWrapper.getCk(); long now = System.currentTimeMillis(); if (point.getReviveTime() - now < brokerController.getBrokerConfig().getPopCkStayBufferTimeOut() + 1500) { if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.warn(\\\"[PopBuffer]add ack fail, rqId={}, almost timeout for revive, {}, {}, {}\\\", reviveQid, pointWrapper, ackMsg, now); } return false; } if (now - point.getPopTime() > brokerController.getBrokerConfig().getPopCkStayBufferTime() - 1500) { if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.warn(\\\"[PopBuffer]add ack fail, rqId={}, stay too long, {}, {}, {}\\\", reviveQid, pointWrapper, ackMsg, now); } return false; } // 标记该 CheckPoint 已经被 ACK int indexOfAck = point.indexOfAck(ackMsg.getAckOffset()); if (indexOfAck > -1) { // 设置 CheckPoint 中被 Ack 消息的 bit 码表为 1 markBitCAS(pointWrapper.getBits(), indexOfAck); } else { POP_LOGGER.error(\\\"[PopBuffer]Invalid index of ack, reviveQid={}, {}, {}\\\", reviveQid, ackMsg, point); return true; } return true; } catch (Throwable e) { POP_LOGGER.error(\\\"[PopBuffer]add ack error, rqId=\\\" + reviveQid + \\\", \\\" + ackMsg, e); } return false; } \"]},\"797\":{\"h\":\"4.4.3 PopBufferMergeService#scan\",\"t\":[\"/** * 扫描内存中的 CheckPoint * 把已经匹配或存盘的 CheckPoint 移出 buffer * 把已经全部 Ack 的 CheckPoint 存盘 */ private void scan() { long startTime = System.currentTimeMillis(); int count = 0, countCk = 0; Iterator<Map.Entry<String, PopCheckPointWrapper>> iterator = buffer.entrySet().iterator(); // 遍历所有内存中的 CheckPoint while (iterator.hasNext()) { Map.Entry<String, PopCheckPointWrapper> entry = iterator.next(); PopCheckPointWrapper pointWrapper = entry.getValue(); // 如果 CheckPoint 已经在磁盘中，或者全部消息都匹配成功，从内存中 buffer 中移除 // just process offset(already stored at pull thread), or buffer ck(not stored and ack finish) if (pointWrapper.isJustOffset() && pointWrapper.isCkStored() || isCkDone(pointWrapper) || isCkDoneForFinish(pointWrapper) && pointWrapper.isCkStored()) { iterator.remove(); counter.decrementAndGet(); continue; } PopCheckPoint point = pointWrapper.getCk(); long now = System.currentTimeMillis(); // 是否要从内存中移除 CheckPoint boolean removeCk = !this.serving; // 距离 ReviveTime 时间小于阈值（默认3s） // ck will be timeout if (point.getReviveTime() - now < brokerController.getBrokerConfig().getPopCkStayBufferTimeOut()) { removeCk = true; } // 在内存中时间大于阈值（默认10s） // the time stayed is too long if (now - point.getPopTime() > brokerController.getBrokerConfig().getPopCkStayBufferTime()) { removeCk = true; } if (now - point.getPopTime() > brokerController.getBrokerConfig().getPopCkStayBufferTime() * 2L) { POP_LOGGER.warn(\\\"[PopBuffer]ck finish fail, stay too long, {}\\\", pointWrapper); } // double check if (isCkDone(pointWrapper)) { continue; } else if (pointWrapper.isJustOffset()) { // just offset should be in store. if (pointWrapper.getReviveQueueOffset() < 0) { putCkToStore(pointWrapper, false); countCk++; } continue; } else if (removeCk) { // 将 CheckPoint 包装成消息放入磁盘，从内存中移除 // put buffer ak to store if (pointWrapper.getReviveQueueOffset() < 0) { putCkToStore(pointWrapper, false); countCk++; } if (!pointWrapper.isCkStored()) { continue; } // 在内存中移除 CheckPoint 前，把它当中已经 Ack 的消息也作为 Ack 消息存入磁盘 for (byte i = 0; i < point.getNum(); i++) { // 遍历 CheckPoint 中消息 bit 码表每一位，检查是否已经 Ack 并且没有存入磁盘 // reput buffer ak to store if (DataConverter.getBit(pointWrapper.getBits().get(), i) && !DataConverter.getBit(pointWrapper.getToStoreBits().get(), i)) { if (putAckToStore(pointWrapper, i)) { count++; markBitCAS(pointWrapper.getToStoreBits(), i); } } } if (isCkDoneForFinish(pointWrapper) && pointWrapper.isCkStored()) { if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"[PopBuffer]ck finish, {}\\\", pointWrapper); } iterator.remove(); counter.decrementAndGet(); continue; } } } // 扫描已经完成的 CheckPoint，为它们提交消息消费进度 int offsetBufferSize = scanCommitOffset(); scanTimes++; if (scanTimes >= countOfMinute1) { counter.set(this.buffer.size()); scanTimes = 0; } } \"]},\"798\":{\"h\":\"4.4.4 PopReviveService#consumeReviveMessage\",\"t\":[\"/** * 消费 Revive Topic 中的消息，匹配 ACK 消息和 CheckPoint * CK 消息放到 Map 中，ACK 消息根据 Map key 匹配 CK 消息，更新 CK 消息的码表以完成 ACK * 只对 CK 进行标记 * 消费时间差 2s 内的 CK、ACK 消息，或 4s 没有消费到新消息 * * @param consumeReviveObj CK 与 ACK 匹配对象，用于 Revive 需要重试 Pop 消费的消息 */ protected void consumeReviveMessage(ConsumeReviveObj consumeReviveObj) { // CheckPoint 匹配 map，key = point.getTopic() + point.getCId() + point.getQueueId() + point.getStartOffset() + point.getPopTime() HashMap<String, PopCheckPoint> map = consumeReviveObj.map; long startScanTime = System.currentTimeMillis(); long endTime = 0; // 查询 ReviveTopic queue 之前的消费进度 long oldOffset = this.brokerController.getConsumerOffsetManager().queryOffset(PopAckConstants.REVIVE_GROUP, reviveTopic, queueId); consumeReviveObj.oldOffset = oldOffset; POP_LOGGER.info(\\\"reviveQueueId={}, old offset is {} \\\", queueId, oldOffset); long offset = oldOffset + 1; // 没有查询到消息的次数 int noMsgCount = 0; long firstRt = 0; // offset self amend while (true) { if (!shouldRunPopRevive) { POP_LOGGER.info(\\\"slave skip scan , revive topic={}, reviveQueueId={}\\\", reviveTopic, queueId); break; } // 查询一批 Revive Topic 中的消息（32条） List<MessageExt> messageExts = getReviveMessage(offset, queueId); if (messageExts == null || messageExts.isEmpty()) { long old = endTime; long timerDelay = brokerController.getMessageStore().getTimerMessageStore().getReadBehind(); long commitLogDelay = brokerController.getMessageStore().getTimerMessageStore().getEnqueueBehind(); // move endTime if (endTime != 0 && System.currentTimeMillis() - endTime > 3 * PopAckConstants.SECOND && timerDelay <= 0 && commitLogDelay <= 0) { endTime = System.currentTimeMillis(); } POP_LOGGER.info(\\\"reviveQueueId={}, offset is {}, can not get new msg, old endTime {}, new endTime {}\\\", queueId, offset, old, endTime); // 最后一个 CK 的唤醒时间与第一个 CK 的唤醒时间差大于 2s，中断消费 if (endTime - firstRt > PopAckConstants.ackTimeInterval + PopAckConstants.SECOND) { break; } noMsgCount++; // Fixme: why sleep is useful here? try { Thread.sleep(100); } catch (Throwable ignore) { } // 连续 4s 没有消费到新的消息，中断消费 if (noMsgCount * 100L > 4 * PopAckConstants.SECOND) { break; } else { continue; } } else { noMsgCount = 0; } if (System.currentTimeMillis() - startScanTime > brokerController.getBrokerConfig().getReviveScanTime()) { POP_LOGGER.info(\\\"reviveQueueId={}, scan timeout \\\", queueId); break; } // 遍历查询到的消息 for (MessageExt messageExt : messageExts) { if (PopAckConstants.CK_TAG.equals(messageExt.getTags())) { // 如果是 CheckPoint String raw = new String(messageExt.getBody(), DataConverter.charset); if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"reviveQueueId={},find ck, offset:{}, raw : {}\\\", messageExt.getQueueId(), messageExt.getQueueOffset(), raw); } PopCheckPoint point = JSON.parseObject(raw, PopCheckPoint.class); if (point.getTopic() == null || point.getCId() == null) { continue; } // 放入 HashMap，等待 ACK 消息匹配 map.put(point.getTopic() + point.getCId() + point.getQueueId() + point.getStartOffset() + point.getPopTime(), point); // 设置 reviveOffset 为 revive 队列中消息的逻辑 offset point.setReviveOffset(messageExt.getQueueOffset()); if (firstRt == 0) { firstRt = point.getReviveTime(); } } else if (PopAckConstants.ACK_TAG.equals(messageExt.getTags())) { // 如果是 ACK 消息 String raw = new String(messageExt.getBody(), DataConverter.charset); if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"reviveQueueId={},find ack, offset:{}, raw : {}\\\", messageExt.getQueueId(), messageExt.getQueueOffset(), raw); } AckMsg ackMsg = JSON.parseObject(raw, AckMsg.class); PopCheckPoint point = map.get(ackMsg.getTopic() + ackMsg.getConsumerGroup() + ackMsg.getQueueId() + ackMsg.getStartOffset() + ackMsg.getPopTime()); if (point == null) { continue; } // 如果 HashMap 中有 CheckPoint，计算 ACK 的 bit 码表 int indexOfAck = point.indexOfAck(ackMsg.getAckOffset()); if (indexOfAck > -1) { // Ack 消息 bit 码表为 1 的位 Ack 成功 point.setBitMap(DataConverter.setBit(point.getBitMap(), indexOfAck, true)); } else { POP_LOGGER.error(\\\"invalid ack index, {}, {}\\\", ackMsg, point); } } long deliverTime = messageExt.getDeliverTimeMs(); if (deliverTime > endTime) { endTime = deliverTime; } } offset = offset + messageExts.size(); } consumeReviveObj.endTime = endTime; } \"]},\"799\":{\"h\":\"4.4.5 PopReviveService#mergeAndRevive\",\"t\":[\"/** * 匹配消费到的一批 CK 和 ACK 消息，对于没有成功 ACK 的消息，重发到重试 Topic */ protected void mergeAndRevive(ConsumeReviveObj consumeReviveObj) throws Throwable { // 获取排序后的 CheckPoint 列表 ArrayList<PopCheckPoint> sortList = consumeReviveObj.genSortList(); // ... long newOffset = consumeReviveObj.oldOffset; for (PopCheckPoint popCheckPoint : sortList) { // ... // 如果没有到 Revive 时间，跳过 if (consumeReviveObj.endTime - popCheckPoint.getReviveTime() <= (PopAckConstants.ackTimeInterval + PopAckConstants.SECOND)) { break; } // 从 CK 中解析原 Topic 并检查该 Topic 是否存在，如果不存在则跳过 // check normal topic, skip ck , if normal topic is not exist String normalTopic = KeyBuilder.parseNormalTopic(popCheckPoint.getTopic(), popCheckPoint.getCId()); if (brokerController.getTopicConfigManager().selectTopicConfig(normalTopic) == null) { POP_LOGGER.warn(\\\"reviveQueueId={},can not get normal topic {} , then continue \\\", queueId, popCheckPoint.getTopic()); newOffset = popCheckPoint.getReviveOffset(); continue; } if (null == brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(popCheckPoint.getCId())) { POP_LOGGER.warn(\\\"reviveQueueId={},can not get cid {} , then continue \\\", queueId, popCheckPoint.getCId()); newOffset = popCheckPoint.getReviveOffset(); continue; } // 重发 CK 中没有 Ack 的所有消息 reviveMsgFromCk(popCheckPoint); newOffset = popCheckPoint.getReviveOffset(); } // 匹配和重试完成后，更新 ReviveTopic 消费进度 if (newOffset > consumeReviveObj.oldOffset) { if (!shouldRunPopRevive) { POP_LOGGER.info(\\\"slave skip commit, revive topic={}, reviveQueueId={}\\\", reviveTopic, queueId); return; } this.brokerController.getConsumerOffsetManager().commitOffset(PopAckConstants.LOCAL_HOST, PopAckConstants.REVIVE_GROUP, reviveTopic, queueId, newOffset); } consumeReviveObj.newOffset = newOffset; } \"]},\"800\":{\"h\":\"4.4.6 PopReviveService : 重试消息\",\"t\":[\"/** * 重发 CK 中没有 Ack 的所有消息 */ private void reviveMsgFromCk(PopCheckPoint popCheckPoint) throws Throwable { // 遍历 CK 中的所有消息 for (int j = 0; j < popCheckPoint.getNum(); j++) { if (DataConverter.getBit(popCheckPoint.getBitMap(), j)) { continue; } // retry msg long msgOffset = popCheckPoint.ackOffsetByIndex((byte) j); // 查询 CK 消息对应的真正消息 MessageExt messageExt = getBizMessage(popCheckPoint.getTopic(), msgOffset, popCheckPoint.getQueueId(), popCheckPoint.getBrokerName()); if (messageExt == null) { POP_LOGGER.warn(\\\"reviveQueueId={},can not get biz msg topic is {}, offset is {} , then continue \\\", queueId, popCheckPoint.getTopic(), msgOffset); continue; } //skip ck from last epoch if (popCheckPoint.getPopTime() < messageExt.getStoreTimestamp()) { POP_LOGGER.warn(\\\"reviveQueueId={},skip ck from last epoch {}\\\", queueId, popCheckPoint); continue; } // 唤醒没有被 ACK 的消息，发到重试队列 reviveRetry(popCheckPoint, messageExt); } } /** * 根据 CheckPoint 唤醒没有被 ACK 的消息，发到重试队列 * * @param popCheckPoint CK * @param messageExt 要被重试的消息 * @throws Exception */ private void reviveRetry(PopCheckPoint popCheckPoint, MessageExt messageExt) throws Exception { if (!shouldRunPopRevive) { POP_LOGGER.info(\\\"slave skip retry , revive topic={}, reviveQueueId={}\\\", reviveTopic, queueId); return; } // 构造新的消息 MessageExtBrokerInner msgInner = new MessageExtBrokerInner(); // 唤醒的消息发到重试 Topic if (!popCheckPoint.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { msgInner.setTopic(KeyBuilder.buildPopRetryTopic(popCheckPoint.getTopic(), popCheckPoint.getCId())); } else { msgInner.setTopic(popCheckPoint.getTopic()); } msgInner.setBody(messageExt.getBody()); msgInner.setQueueId(0); if (messageExt.getTags() != null) { msgInner.setTags(messageExt.getTags()); } else { MessageAccessor.setProperties(msgInner, new HashMap<String, String>()); } msgInner.setBornTimestamp(messageExt.getBornTimestamp()); msgInner.setBornHost(brokerController.getStoreHost()); msgInner.setStoreHost(brokerController.getStoreHost()); // 重试次数 += 1 msgInner.setReconsumeTimes(messageExt.getReconsumeTimes() + 1); msgInner.getProperties().putAll(messageExt.getProperties()); if (messageExt.getReconsumeTimes() == 0 || msgInner.getProperties().get(MessageConst.PROPERTY_FIRST_POP_TIME) == null) { msgInner.getProperties().put(MessageConst.PROPERTY_FIRST_POP_TIME, String.valueOf(popCheckPoint.getPopTime())); } msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); // 添加 Pop 重试 Topic addRetryTopicIfNoExit(msgInner.getTopic(), popCheckPoint.getCId()); // 保存重试消息到存储 PutMessageResult putMessageResult = brokerController.getEscapeBridge().putMessageToSpecificQueue(msgInner); if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"reviveQueueId={},retry msg , ck={}, msg queueId {}, offset {}, reviveDelay={}, result is {} \\\", queueId, popCheckPoint, messageExt.getQueueId(), messageExt.getQueueOffset(), (System.currentTimeMillis() - popCheckPoint.getReviveTime()) / 1000, putMessageResult); } if (putMessageResult.getAppendMessageResult() == null || putMessageResult.getAppendMessageResult().getStatus() != AppendMessageStatus.PUT_OK) { throw new Exception(\\\"reviveQueueId=\\\" + queueId + \\\",revive error ,msg is :\\\" + msgInner); } // ... 更新统计数据 if (brokerController.getPopMessageProcessor() != null) { brokerController.getPopMessageProcessor().notifyMessageArriving( KeyBuilder.parseNormalTopic(popCheckPoint.getTopic(), popCheckPoint.getCId()), popCheckPoint.getCId(), -1 ); } } \"]},\"801\":{\"h\":\"参考资料\",\"t\":[\"[RIP 19] Server side rebalance, lightweight consumer client support\",\"RocketMQ 5.0 POP 消费模式探秘\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"802\":{\"h\":\"RocketMQ 轻量级队列 Light Message Queue（RIP-28）原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20230304-rocketmq-light-message-queue.html\"]},\"803\":{\"h\":\"1. 背景\"},\"804\":{\"h\":\"1.1 引入原因\",\"t\":[\"在 RocketMQ 4.9.3 版本中，引入了轻量级队列（以下简称 LMQ）特性。\",\"合入PR：https://github.com/apache/rocketmq/pull/3694\",\"这个特性主要是为了支持在一些消息场景下可能存在的大量队列场景。比如 MQTT 的多级主题和 AMQP 的队列，这些队列的数量可能非常多。而 RocketMQ 的 Topic 资源密集，很难支持百万级别甚至更多数量。Light Message Queue 特性就是为了解决 IOT 设备和 AMQP 协议可能需要的海量队列的场景。\",\"rocketmq-mqtt 项目就应用了 LMQ，实现了 RocketMQ 对 MQTT 协议的兼容。\"]},\"805\":{\"h\":\"1.2 使用方法\"},\"806\":{\"h\":\"1.2.1 Broker 启动配置\",\"t\":[\"broker.conf 文件需要增加以下的配置项，开启 LMQ 开关和多队列转发开关，这样才能识别 LMQ 相关消息属性，分发消息到 LMQ。\",\"enableLmq = true enableMultiDispatch = true \"]},\"807\":{\"h\":\"1.2.2 生产消息\",\"t\":[\"发送消息的时候通过设置 INNER_MULTI_DISPATCH 属性，分发消息到多个 LMQ，多个 LMQ 之间使用逗号分割，名称前缀必须是 %LMQ%，这样 broker 就可以识别 LMQ。\",\"DefaultMQProducer producer = new DefaultMQProducer(\\\"please_rename_unique_group_name\\\"); producer.setNamesrvAddr(\\\"name-server1-ip:9876;name-server2-ip:9876\\\"); producer.start(); /* * Create a message instance, specifying topic, tag and message body. */ Message msg = new Message(\\\"TopicTest\\\" /* Topic */, \\\"TagA\\\" /* Tag */, (\\\"Hello RocketMQ \\\" + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */ ); /* * INNER_MULTI_DISPATCH property and PREFIX must start as \\\"%LMQ%\\\", * If it is multiple LMQ, need to use “,” split */ message.putUserProperty(\\\"INNER_MULTI_DISPATCH\\\", \\\"%LMQ%123,%LMQ%456\\\"); /* * Call send message to deliver message to one of brokers. */ SendResult sendResult = producer.send(msg); \"]},\"808\":{\"h\":\"1.2.3 消费消息\",\"t\":[\"LMQ 在每个 broker 上只有一个 queue，queueId 为 0， 指明要消费的 LMQ 名称，就可以拉取消息进行消费。\",\"DefaultMQPullConsumer defaultMQPullConsumer = new DefaultMQPullConsumer(); defaultMQPullConsumer.setNamesrvAddr(\\\"name-server1-ip:9876;name-server2-ip:9876\\\"); defaultMQPullConsumer.setVipChannelEnabled(false); defaultMQPullConsumer.setConsumerGroup(\\\"CID_RMQ_SYS_LMQ_TEST\\\"); defaultMQPullConsumer.setInstanceName(\\\"CID_RMQ_SYS_LMQ_TEST\\\"); defaultMQPullConsumer.setRegisterTopics(new HashSet<>(Arrays.asList(\\\"TopicTest\\\"))); defaultMQPullConsumer.setBrokerSuspendMaxTimeMillis(2000); defaultMQPullConsumer.setConsumerTimeoutMillisWhenSuspend(3000); defaultMQPullConsumer.start(); String brokerName = \\\"set broker Name\\\"; MessageQueue mq = new MessageQueue(\\\"%LMQ%123\\\", brokerName, 0); defaultMQPullConsumer.getDefaultMQPullConsumerImpl().getRebalanceImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(\\\"TopicTest\\\"); Thread.sleep(30000); Long offset = defaultMQPullConsumer.maxOffset(mq); defaultMQPullConsumer.pullBlockIfNotFound( mq, \\\"*\\\", offset, 32, new PullCallback() { @Override public void onSuccess(PullResult pullResult) { List<MessageExt> list = pullResult.getMsgFoundList(); if (list == null || list.isEmpty()) { return; } for (MessageExt messageExt : list) { System.out.println(messageExt); } } @Override public void onException(Throwable e) { } }); \"]},\"809\":{\"h\":\"2. 概要设计\"},\"810\":{\"h\":\"2.1 当前痛点\",\"t\":[\"在 AMQP 协议中，消息发送到 Exchange，由 Exchange 将消息分发到一个或多个 Queue 中。在 RocketMQ 实现 AMQP 协议时，如果将 Topic 与 Queue 对应，就意味着同一条消息会保存到多个 Topic，在磁盘上存储多份。\",\"MQTT 协议的 Topic 则可以看作类似文件路径的字符串，可以有多个层级，如 home/kitchen/coffeemaker。订阅 Topic 时可以进行通配，以订阅一组路径的 Topic。在 IOT 场景下，Topic 数量可能会非常多。\",\"RocketMQ 原本的 Topic 是资源密集型的，并不适合海量 Topic 的场景。这体现在消息数据的存储和 Topic 元数据上。\",\"Topic 中的每个消息数据都会在磁盘上存储。\",\"所有 Topic 的元数据会上报到 NameServer，存储在内存中。\",\"当存在大量 Topic 时就会有严重的数据放大，占用大量磁盘存储空间和内存。\"]},\"811\":{\"h\":\"2.1 实现思想\",\"t\":[\"对于上面两个痛点，LMQ 的实现思想是减少数据的重复存储，也减少元数据的内存占用。\",\"对于队列数据重复保存的问题，可以想到消费者消费时实际是读取消费队列 ConsumeQueue 进行消费，ConsumeQueue 将消费者和消息存储的 CommitLog 分开。那么可以用消费队列来表示一个 Topic，不同的消费队列可以复用 CommitLog 中存储的数据，但是对消费者来说看到的是多个消费队列。\",\"此外，用消费队列表示的好处还在于，它不会作为元数据上报到 NameServer。不过消费者需要在消费时指定拉取这个消费队列才可以消费。\",\"那么轻量级队列的实现也就呼之欲出：用消费队列来表示轻量级队列，消息存到 CommitLog 后分发构建索引时，构建轻量级队列。这样，一个 Topic 构建的队列除了它本身的读写队列以外，还可以包含大量轻量级队列。这样的队列模型也有助于实现 MQTT 与 AMQP 协议的兼容。\"]},\"812\":{\"h\":\"3. 详细设计\"},\"813\":{\"h\":\"3.1 消息生产和消费\",\"t\":[\"LMQ 依赖于一个父 Topic 存在，父 Topic 的消息分发构建消费索引时会构建 LMQ。LMQ 不需要提前创建，只需要在生产消息时带有需要分发的 LMQ 属性，就会在分发时构建。\",\"在消费时，LMQ 不在对应 Topic 上报的元数据中，订阅 Topic 也无法消费到其 LMQ。要消费 LMQ，需要显式指定拉取或订阅的队列信息才可以。因为 LMQ 仅仅是一个队列，所以它的队列 ID 为 0。\"]},\"814\":{\"h\":\"3.2 CommitLog 分发到 LMQ\",\"t\":[\"LMQ 实现的重点就是 CommitLog 在生成消费索引时一并生成 LMQ。生成 LMQ 消息的主要步骤有两步\",\"在消息存入 CommitLog 前，解析消息属性中是否有需要分发的 LMQ 属性，如果有则解析该属性，查询要分发的 LMQ 当前的逻辑偏移量。然后把这些属性封装放入消息属性中，以便构建 LMQ 时使用。\",\"消息存入 CommitLog 后，索引构建线程 ReputMessageService 为每个消息构建消费队列时，会检查消息属性，判断是否需要分发构建 LMQ。如果属性中有 LMQ 和其逻辑偏移量，则从该偏移量开始构建 LMQ。\",\"处理 LMQ 消息分发的逻辑主要在 MultiDispatch 类中（4.9.x 版本），最新的 5.x 版本引入了 ConsumeQueueInterface 将这部分代码重构，放到 ConsumeQueue 中。\",\"分发 LMQ 逻辑如下：\",\"消息存到 CommitLog 之前，先调用 MultiDispatch.wrapMultiDispatch() （5.x 中 ConsumeQueue#assignQueueOffset()）方法，获取消息属性中需要分发的 LMQ 信息，然后查询 LMQ 当前的偏移量，把 LMQ 消息需要分发的新偏移量也放入消息属性。\",\"消息分发，生成消费索引\",\"生成消息的消费索引之后，如果需要分发到 LMQ，则执行 ConsumeQueue.multiDispatchLmqQueue() 方法进行分发。\"]},\"815\":{\"h\":\"4. 源码解析\",\"t\":[\"（以 5.0.x 的源码为例）\"]},\"816\":{\"h\":\"4.1 查询 LMQ 偏移量\",\"t\":[\"// CommitLog.java public CompletableFuture<PutMessageResult> asyncPutMessages(final MessageExtBatch messageExtBatch) { // ... try { defaultMessageStore.assignOffset(messageExtBatch, (short) putMessageContext.getBatchSize()); // ... result = mappedFile.appendMessages(messageExtBatch, this.appendMessageCallback, putMessageContext); // ... } // ... } \",\"/** * 查询要分发的队列的逻辑偏移量，放入消息属性 * * @param queueOffsetAssigner the delegated queue offset assigner * @param msg message itself * @param messageNum message number */ @Override public void assignQueueOffset(QueueOffsetAssigner queueOffsetAssigner, MessageExtBrokerInner msg, short messageNum) { String topicQueueKey = getTopic() + \\\"-\\\" + getQueueId(); long queueOffset = queueOffsetAssigner.assignQueueOffset(topicQueueKey, messageNum); msg.setQueueOffset(queueOffset); // 轻量级队列分发准备，为消息添加多队列分发属性 // For LMQ if (!messageStore.getMessageStoreConfig().isEnableMultiDispatch()) { return; } String multiDispatchQueue = msg.getProperty(MessageConst.PROPERTY_INNER_MULTI_DISPATCH); if (StringUtils.isBlank(multiDispatchQueue)) { return; } // 从原始消息属性中获取分发的队列列表 String[] queues = multiDispatchQueue.split(MixAll.MULTI_DISPATCH_QUEUE_SPLITTER); // 从队列偏移量表中查询当前队列偏移量 Long[] queueOffsets = new Long[queues.length]; for (int i = 0; i < queues.length; i++) { String key = queueKey(queues[i], msg); if (messageStore.getMessageStoreConfig().isEnableLmq() && MixAll.isLmq(key)) { queueOffsets[i] = queueOffsetAssigner.assignLmqOffset(key, (short) 1); } } // 将队列偏移量作为属性存入消息 MessageAccessor.putProperty(msg, MessageConst.PROPERTY_INNER_MULTI_QUEUE_OFFSET, StringUtils.join(queueOffsets, MixAll.MULTI_DISPATCH_QUEUE_SPLITTER)); // 移除消息的 WAIT_STORE 属性，节省存储空间 removeWaitStorePropertyString(msg); } \"]},\"817\":{\"h\":\"4.2 分发 LMQ\",\"t\":[\"@Override public void putMessagePositionInfoWrapper(DispatchRequest request) { final int maxRetries = 30; boolean canWrite = this.messageStore.getRunningFlags().isCQWriteable(); // 写入ConsumeQueue，重试最多30次 for (int i = 0; i < maxRetries && canWrite; i++) { long tagsCode = request.getTagsCode(); if (isExtWriteEnable()) { ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit(); cqExtUnit.setFilterBitMap(request.getBitMap()); cqExtUnit.setMsgStoreTime(request.getStoreTimestamp()); cqExtUnit.setTagsCode(request.getTagsCode()); long extAddr = this.consumeQueueExt.put(cqExtUnit); if (isExtAddr(extAddr)) { tagsCode = extAddr; } else { log.warn(\\\"Save consume queue extend fail, So just save tagsCode! {}, topic:{}, queueId:{}, offset:{}\\\", cqExtUnit, topic, queueId, request.getCommitLogOffset()); } } // 写入ConsumeQueue，注意这里还未强制刷盘 boolean result = this.putMessagePositionInfo(request.getCommitLogOffset(), request.getMsgSize(), tagsCode, request.getConsumeQueueOffset()); if (result) { // 如果是SLAVE，在写入成功后更新CheckPoint中的最新写入时间。是为了修复在SLAVE中ConsumeQueue异常恢复慢的问题 // 因为在当前的设计中，没有更新SLAVE的消费队列时间戳到CheckPoint中的逻辑，所以在SLAVE中在doReput()逻辑中更新该时间戳 // https://github.com/apache/rocketmq/pull/1455 if (this.messageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE || this.messageStore.getMessageStoreConfig().isEnableDLegerCommitLog()) { this.messageStore.getStoreCheckpoint().setPhysicMsgTimestamp(request.getStoreTimestamp()); } this.messageStore.getStoreCheckpoint().setLogicsMsgTimestamp(request.getStoreTimestamp()); if (checkMultiDispatchQueue(request)) { multiDispatchLmqQueue(request, maxRetries); } return; } else { // 只有一种情况会失败，创建新的MapedFile时报错或者超时 // 写入失败，等待1s继续写入，直到30次都失败 // XXX: warn and notify me log.warn(\\\"[BUG]put commit log position info to \\\" + topic + \\\":\\\" + queueId + \\\" \\\" + request.getCommitLogOffset() + \\\" failed, retry \\\" + i + \\\" times\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { log.warn(\\\"\\\", e); } } } // XXX: warn and notify me log.error(\\\"[BUG]consume queue can not write, {} {}\\\", this.topic, this.queueId); this.messageStore.getRunningFlags().makeLogicsQueueError(); } /** * 判断消息是否需要执行多队列分发 * * @param dispatchRequest 投递请求 * @return 是否需要分发 */ private boolean checkMultiDispatchQueue(DispatchRequest dispatchRequest) { if (!this.messageStore.getMessageStoreConfig().isEnableMultiDispatch()) { return false; } Map<String, String> prop = dispatchRequest.getPropertiesMap(); if (prop == null || prop.isEmpty()) { return false; } String multiDispatchQueue = prop.get(MessageConst.PROPERTY_INNER_MULTI_DISPATCH); String multiQueueOffset = prop.get(MessageConst.PROPERTY_INNER_MULTI_QUEUE_OFFSET); if (StringUtils.isBlank(multiDispatchQueue) || StringUtils.isBlank(multiQueueOffset)) { return false; } return true; } /** * Light message queue 分发到多个队列 * * @param request 分发请求 * @param maxRetries 最大重试次数，默认 30 */ private void multiDispatchLmqQueue(DispatchRequest request, int maxRetries) { Map<String, String> prop = request.getPropertiesMap(); String multiDispatchQueue = prop.get(MessageConst.PROPERTY_INNER_MULTI_DISPATCH); String multiQueueOffset = prop.get(MessageConst.PROPERTY_INNER_MULTI_QUEUE_OFFSET); String[] queues = multiDispatchQueue.split(MixAll.MULTI_DISPATCH_QUEUE_SPLITTER); String[] queueOffsets = multiQueueOffset.split(MixAll.MULTI_DISPATCH_QUEUE_SPLITTER); if (queues.length != queueOffsets.length) { log.error(\\\"[bug] queues.length!=queueOffsets.length \\\", request.getTopic()); return; } for (int i = 0; i < queues.length; i++) { String queueName = queues[i]; long queueOffset = Long.parseLong(queueOffsets[i]); int queueId = request.getQueueId(); // Light message queue 在每个 broker 上只有一个 queue，queueId 为 0 if (this.messageStore.getMessageStoreConfig().isEnableLmq() && MixAll.isLmq(queueName)) { queueId = 0; } doDispatchLmqQueue(request, maxRetries, queueName, queueOffset, queueId); } return; } /** * 分发消息到消费索引 * * @param request * @param maxRetries * @param queueName * @param queueOffset * @param queueId */ private void doDispatchLmqQueue(DispatchRequest request, int maxRetries, String queueName, long queueOffset, int queueId) { // 查找 ConsumeQueue ConsumeQueueInterface cq = this.messageStore.findConsumeQueue(queueName, queueId); boolean canWrite = this.messageStore.getRunningFlags().isCQWriteable(); for (int i = 0; i < maxRetries && canWrite; i++) { // 向 ConsumeQueue 写入索引项 boolean result = ((ConsumeQueue) cq).putMessagePositionInfo(request.getCommitLogOffset(), request.getMsgSize(), request.getTagsCode(), queueOffset); if (result) { break; } else { log.warn(\\\"[BUG]put commit log position info to \\\" + queueName + \\\":\\\" + queueId + \\\" \\\" + request.getCommitLogOffset() + \\\" failed, retry \\\" + i + \\\" times\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { log.warn(\\\"\\\", e); } } } } \"]},\"818\":{\"h\":\"参考资料\",\"t\":[\"RIP28-Llight message queue (LMQ)\",\"RocketMQ LMQ 官方文档\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"819\":{\"h\":\"RocketMQ Netty 写缓冲区水位配置 NettyServerConfig#writeBufferHighWaterMark\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20230324-rocketmq-netty-write-buffer-watermark.html\",\"RocketMQ 4.9.3 版本中，Issue#3651 新增了 Netty 缓冲区高低水位的配置。\",\"该改动在服务端NettyServerConfig和客户端配置NettyClientConfig中新增了如下配置项：\",\"// NettySystemConfig.java public static int writeBufferHighWaterMark = Integer.parseInt(System.getProperty(COM_ROCKETMQ_REMOTING_WRITE_BUFFER_HIGH_WATER_MARK_VALUE, \\\"4194304\\\"));//4M public static int writeBufferLowWaterMark = Integer.parseInt(System.getProperty(COM_ROCKETMQ_REMOTING_WRITE_BUFFER_LOW_WATER_MARK, \\\"1048576\\\")); //1MB \",\"一开始的默认低水位为 1M，高水位为 4M，Issue#3825 将默认值改为 0。支持在配置文件中进行修改。\",\"这两个配置是 netty channel 的配置，原来的默认值分别为 32K 和 64K\",\"// WriteBufferWaterMark.java private static final int DEFAULT_LOW_WATER_MARK = 32 * 1024; private static final int DEFAULT_HIGH_WATER_MARK = 64 * 1024; public static final WriteBufferWaterMark DEFAULT = new WriteBufferWaterMark(DEFAULT_LOW_WATER_MARK, DEFAULT_HIGH_WATER_MARK, false); \",\"根据 Netty 的文档，这两个参数含义如下\",\"WriteBufferWaterMark 用于设置写缓冲区的低水位线和高水位线。\",\"如果在写缓冲区中排队的字节数超过了高水位线，Channel.isWritable() 将开始返回 false。\",\"如果在写缓冲区中排队的字节数先超过了高水位线，然后下降到低水位线以下，Channel.isWritable() 将再次开始返回 true。\",\"再看 Channel.isWritable() 的文档\",\"当且仅当I/O线程将立即执行所请求的写操作时返回 true。在此方法返回 false 时提交的写请求将被放入队列，直到I/O线程准备好处理队列中的写请求。\",\"https://www.liaoxuefeng.com/discuss/1279869501571105/1450880018677794\"]},\"820\":{\"h\":\"WRITE_BUFFER_WATER_MARK\",\"t\":[\"控制 Netty 中 Write Buffer 的水位线\",\"要理解水位线 (wrter mark) 的概念，还要从 Netty 的 channel.write(...) 讲起。\",\"首先先来根据下面这张图来观察 write 的大致流程\",\"img\",\"首先，我们对一个 Channel 写入的时候，会先将需要 write 的对象封装为任务放入 Queue\",\"然后，同时 I/O 线程会定时将任务从 Queue 取出来，然后再经过 Pipeline 中各个处理器处理（图中未画出），再将处理结果写入到 Netty Buffer，然后到达操作系统的底层的 TCP 的发送缓冲区。\",\"最后，TCP 发送缓冲区中的数据会分包发送给对端，就是在这里的对面的 Client 的 TCP 接收缓冲区。\",\"需要注意的是，如果只是调用 channel.write(..) 方法是，该数据只会暂时存储到 Netty Buffer。在 channel.flush() 被调用后，则会发送信息 flush （即上图中标记为 \\\"F\\\" 的包），在 Netty Buffer 收到了 flush 控制包，才会将 Buffer 冲刷到 TCP Buffer。\",\"其中，TCP 连接的数据发送一方中的 TCP Buffer (发送缓冲区) 的大小由 SO_SNDBUF 控制，而 Netty Buffer 是\\\"无界\\\"的，且它的位置在堆外内存（Direct Buffer）。\",\"我们在一开始提到的水位线，则是标记当前 Netty Buffer 所使用的大小的一个值。当 Netty Buffer 的大小到达这个值后，调用 chanel.isWriteable 则会返回 false，且会通过调用业务 handler 的 writabilityChanged 方法来通知上层应用。\",\"同时水位线还分为高水位线和低水位线，到达高水位线后调用 chanel.isWriteable 则会返回 false ，直到下降到低水位线，调用时才会返回为 true 。\",\"不过，水位线只是一个警示，并不是实际上限，到达水位线后 Netty Buffer 仍然可以被写入，写入后会在由 Netty 维护的内部缓冲区进行排队。\",\"顺带一提，在之前的 netty 版本中，高水位线通过 WRITE_BUFFER_HIGH_WATER_MARK 设置，低水位线通过 WRITE_BUFFER_LOW_WATER_MARK，但现在已经被标记为 Deprecated，取而代之则是上文介绍的 WRITE_BUFFER_WATER_MARK，通过下列样式进行配置 .option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(10000, 20000))\",\"上面提到的 Netty Buffer 的在 Netty 中的类名为 ChannelOutboundBuffer；TCP Buffer 也叫 socket 发送缓冲区\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"821\":{\"h\":\"Rocketmq Filter 消息过滤（TAGS、SQL92）原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20230716-rocketmq-filter.html\"]},\"822\":{\"h\":\"1. 背景\"},\"823\":{\"h\":\"1.1 Rocketmq 支持的过滤方式\",\"t\":[\"Rocketmq 作为金融级的业务消息中间件，拥有强大的消息过滤能力。其支持多种消息过滤方式：\",\"表达式过滤：通过设置过滤表达式的方式进行过滤 \",\"TAG：根据消息的 tag 进行过滤。\",\"SQL92：可以用 SQL92 表达式来灵活地过滤消息的 tag 和属性。\",\"类过滤：可以新建一个过滤类，编写自定义的过滤规则。\"]},\"824\":{\"h\":\"1.2 使用方法\"},\"825\":{\"h\":\"1.2.1 TAG 过滤\",\"t\":[\"Tag 过滤是最简单的一种过滤方法，通常 Tag 可以用作消息的业务标识。可以设置 Tag 表达式，判断消息是否包含这个 Tag。\"]},\"826\":{\"h\":\"生产者\",\"t\":[\"String[] tags = new String[] {\\\"TagA\\\", \\\"TagB\\\", \\\"TagC\\\"}; for (int i = 0; i < 60; i++) { Message msg = new Message(\\\"TagFilterTest\\\", tags[i % tags.length], // 设置消息 Tag \\\"Hello world\\\".getBytes(RemotingHelper.DEFAULT_CHARSET)); msg.setTags(tags[i % tags.length]); // 也可以通过 setTags 方法设置 Tag SendResult sendResult = producer.send(msg); } \"]},\"827\":{\"h\":\"消费者\",\"t\":[\"在消费时，可以通过表达式过滤的方式设置需要过滤的 Tag，用 || 表达式表示或的意思，可以匹配多个 Tag。\",\"// 4.9.x consumer.subscribe(\\\"TagFilterTest\\\", \\\"TagA || TagC\\\"); \",\"在 Rocketmq 5.x 客户端之后，引入了新的订阅表达式写法：\",\"// 5.x // 只订阅消息标签为\\\"TagA\\\"、\\\"TagB\\\"或\\\"TagC\\\"的消息。 FilterExpression filterExpression = new FilterExpression(\\\"TagA||TagB||TagC\\\", FilterExpressionType.TAG); pushConsumer.subscribe(\\\"TagFilterTest\\\", filterExpression); \"]},\"828\":{\"h\":\"1.2.2 SQL92\",\"t\":[\"SQL92 过滤比 Tag 过滤更灵活，它可以使用SQL92语法作为过滤规则表达式，可以过滤消息的属性和 Tag（在SQL语法中，Tag的属性名称为TAGS）。\",\"如果要使用 SQL92 过滤，需要设置 Broker 的配置项 enablePropertyFilter=true，这个配置默认为 false。\",\"enablePropertyFilter=true \",\"如果要开启布隆过滤器进行双层过滤，需要设置如下配置。\",\"enableCalcFilterBitMap=true # 设置在构造消费队列时，用布隆过滤器计算匹配过滤条件的消费组，构造成二进制数组 enableConsumeQueueExt=true # 启用消费队列扩展存储，二进制数组会存到扩展存储中 \",\"SQL92 的过滤语法规则如下：\",\"语法\",\"说明\",\"示例\",\"IS NULL\",\"判断属性不存在。\",\"a IS NULL ：属性a不存在。\",\"IS NOT NULL\",\"判断属性存在。\",\"a IS NOT NULL：属性a存在。\",\"> >= < <=\",\"用于比较数字，不能用于比较字符串，否则消费者客户端启动时会报错。 说明 可转化为数字的字符串也被认为是数字。\",\"a IS NOT NULL AND a > 100：属性a存在且属性a的值大于100。a IS NOT NULL AND a > 'abc'：错误示例，abc为字符串，不能用于比较大小。\",\"BETWEEN xxx AND xxx\",\"用于比较数字，不能用于比较字符串，否则消费者客户端启动时会报错。等价于>= xxx AND <= xxx。表示属性值在两个数字之间。\",\"a IS NOT NULL AND (a BETWEEN 10 AND 100)：属性a存在且属性a的值大于等于10且小于等于100。\",\"NOT BETWEEN xxx AND xxx\",\"用于比较数字，不能用于比较字符串，否则消费者客户端启动会报错。等价于< xxx OR > xxx，表示属性值在两个值的区间之外。\",\"a IS NOT NULL AND (a NOT BETWEEN 10 AND 100)：属性a存在且属性a的值小于10或大于100。\",\"IN (xxx, xxx)\",\"表示属性的值在某个集合内。集合的元素只能是字符串。\",\"a IS NOT NULL AND (a IN ('abc', 'def'))：属性a存在且属性a的值为abc或def。\",\"= <>\",\"等于和不等于。可用于比较数字和字符串。\",\"a IS NOT NULL AND (a = 'abc' OR a<>'def')：属性a存在且属性a的值为abc或a的值不为def。\",\"AND OR\",\"逻辑与、逻辑或。可用于组合任意简单的逻辑判断，需要将每个逻辑判断内容放入括号内。\",\"a IS NOT NULL AND (a > 100) OR (b IS NULL)：属性a存在且属性a的值大于100或属性b不存在。\"]},\"829\":{\"h\":\"生产者\",\"t\":[\"String[] tags = new String[] {\\\"TagA\\\", \\\"TagB\\\", \\\"TagC\\\"}; for (int i = 0; i < 10; i++) { Message msg = new Message(\\\"SqlFilterTest\\\", tags[i % tags.length], (\\\"Hello RocketMQ \\\" + i).getBytes(RemotingHelper.DEFAULT_CHARSET) ); msg.putUserProperty(\\\"a\\\", String.valueOf(i)); // 设置消息属性 SendResult sendResult = producer.send(msg); System.out.printf(\\\"%s%n\\\", sendResult); } \"]},\"830\":{\"h\":\"消费者\",\"t\":[\"// 4.9.x consumer.subscribe(\\\"SqlFilterTest\\\", MessageSelector.bySql(\\\"(TAGS is not null and TAGS in ('TagA', 'TagB'))\\\" + \\\"and (a is not null and a between 0 and 3)\\\")); \",\"// 5.x FilterExpression filterExpression = new FilterExpression(\\\"TAGS is not null and TAGS in ('TagA', 'TagB')\\\", FilterExpressionType.SQL92); simpleConsumer.subscribe(\\\"SqlFilterTest\\\", filterExpression); \"]},\"831\":{\"h\":\"2. 概要设计\"},\"832\":{\"h\":\"2.1 过滤信息的注册\",\"t\":[\"消费者启动时（和每隔一段时间）会向 Broker 端发送心跳，心跳的信息就包含消费者的订阅信息（和过滤信息）。Broker 端有一个专门的消费者过滤信息管理器，更新和存储消费者的过滤信息。\"]},\"833\":{\"h\":\"2.2 表达式过滤\",\"t\":[\"表达式过滤的逻辑在 Broker 端处理消费者的拉取消息请求时执行。\",\"Rocketmq 的消息过滤接口MessageFilter 设计了两层过滤机制，它定义了两个方法，分别是根据消费队列过滤和根据消息详情过滤。这样设计的原因是：根据消息属性精确匹配的性能消耗比较大，所以先根据消费队列进行一次过滤，剩下的消息再根据消息详情过滤，可以减少比较次数，提升性能。\"]},\"834\":{\"h\":\"2.2.1 Tag 过滤\",\"t\":[\"对于 Tag 过滤，在构建消费队列时会保存根据消息 Tag 生成的 Hash 码（Long 类型，8 字节）。\",\"根据消费队列过滤时，先计算消息的 Hash 码，判断是否与消费队列中保存的 hash 码一致。如果一致，说明消息的 Tag 有可能是过滤匹配的 Tag，需要进一步匹配。这是由于不同的 Tag 字符串计算出的 Hash 码可能相同。\",\"在 Broker 端，Tag 过滤不会进行进一步的匹配，而是在消费者端处理消息拉取结果时进行判断，如果过滤规则 Tag 集合中包含消息的 Tag，则返回给消费者，否则不消费。\"]},\"835\":{\"h\":\"2.2.2 SQL92 过滤\",\"t\":[\"对于 SQL92 过滤，也有两层过滤机制。第一层根据消费队列过滤主要是用来在许多消费组之间筛选出有可能匹配的消费组，第二层过滤（消息详情过滤）则根据消费组设定的过滤表达式，根据消息的属性和 Tag 进行精确匹配过滤。\",\"具体的做法是，在消息生产时构造消费队列的过程当中，获取所有订阅该 Topic 的有过滤条件的消费组，预先根据这些消费组的过滤表达式进行一次精确匹配，计算出这条消息是否匹配。\",\"随后将这些匹配的消费组的名称通过布隆过滤器进行计算，得到一个二进制数组，将其放入消费队列的扩展存储中。\",\"布隆过滤器可以用来判断某个元素是否可能存在于集合中，在这里就用来判断这个消息是否可能匹配某个消费组的过滤规则。\",\"在第一层过滤（消费队列过滤）时，从消费队列扩展存储中取出这个消息的布隆过滤器产生的二进制数组，用它来判断这个消费者是否可能匹配过滤规则；然后在第二层过滤时将通过第一层过滤的消息信息进行 SQL92 表达式匹配。\",\"其中，在消息生产时用布隆过滤器计算二进制数组的操作和构造消费队列扩展存储的操作默认都是关闭的，也就是说默认只会进行 SQL92 表达式计算来精确匹配。如果要开启则需要设置一下配置项：\",\"enableCalcFilterBitMap=true # 设置在构造消费队列时，用布隆过滤器计算匹配过滤条件的消费组，构造成二进制数组 enableConsumeQueueExt=true # 启用消费队列扩展存储，二进制数组会存到扩展存储中 \",\"开启这两项相当于开启了第一层过滤（消费队列过滤），它其实是把精确过滤的逻辑提前到消息生产时来做。\"]},\"836\":{\"h\":\"3. 详细设计\"},\"837\":{\"h\":\"3.1 过滤信息注册\",\"t\":[\"Tag 过滤信息和 SQL92 过滤信息的保存位置不同。\",\"Tag 过滤信息由消费者发送心跳时有 Broker 端心跳处理方法调用 ConsumerManager#registerConsumer 进行更新，它存在 ConsumerManager 的 ConcurrentMap<String/* Group */, ConsumerGroupInfo> consumerTable 表中。其中的 SubscriptionData 就保存着 Tag 过滤表达式。\",\"SQL92 过滤信息的注册也是由消费这发送心跳触发，它的存储位置是 ConsumerFilterManager，最终的 ConsumerFilterData 中包含了编译好的过滤表达式。\"]},\"838\":{\"h\":\"3.2 过滤器接口\",\"t\":[\"image-20230702220114234\",\"Rocketmq 的消息过滤逻辑（表达式过滤、类过滤）都需要实现 MessageFilter 接口。它的两个方法先后在从 MessageStore 获取消息时调用。通过这两个过滤方法，可以实现二层过滤，先根据较少的信息（消费队列）进行一次粗粒度的过滤，再根据完整的消息信息做精确过滤，这样能够减少精确过滤的次数，提升性能。\",\"boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit)：根据消费队列判断消息是否匹配过滤规则 \",\"Long tagsCode：存在消费队列中消息的 Hash 码\",\"CqExtUnit cqExtUnit：消息消费队列扩展属性，为 SQL92 过滤专用，需要开启配置项才会存储扩展属性。\",\"boolean isMatchedByCommitLog(ByteBuffer msgBuffer, Map<String, String> properties)：根据完整消息来判断消息是否匹配过滤规则 \",\"ByteBuffer msgBuffer：完整消息内容\",\"Map<String, String> Properties：消息属性，主要用于 SQL92 过滤\",\"SQL92 和 Tag 过滤的逻辑都在 ExpressionMessageFilter 中，ExpressionForRetryMessageFilter 则为支持重试 Topic 的 Filter 实现。\",\"其中 Tag 过滤只用到 isMatchedByConsumeQueue，而 SQL92 过滤主要用到 isMatchedByCommitLog，如果开启了一些配置则也会用到 isMatchedByConsumeQueue。\",\"下面是 Tag 过滤的主方法 isMatchedByConsumeQUeue 和 isMatchedByCommitLog的调用层级（在 getMessage 中先后被调用）：\",\"PullMessageProcessor#processRequest： Broker 端消息拉取请求的入口。先尝试从消息拉取请求中获取过滤信息，如果没有则从服务端 ConsumerManager 中获取过滤信息，然后用订阅信息构造一个 ExpressionMessageFilter，将其传入 getMessage 。\",\"DefaultMessageStore#getMessage ：先根据 Topic 和队列 offset 获取消息的消费索引，然后根据消费索引从 CommitLog 查出完整消息。\",\"查出消费索引后，会先执行 isMatchedByConsumeQueue 的判断\",\"查出完整消息后，再执行 isMatchedByCommitLog 的判断\"]},\"839\":{\"h\":\"3.3 Tag 过滤\",\"t\":[\"Rocketmq 的消费队列中专门开辟了 8 个字节的存储位置用于存储消息的 Tag 字符串的 Hash 码，用来为 Tag 过滤进行初筛。之所以不直接存 Tag 字符串，是因为 ConsumeQueue 的存储项是定长结构，加快处理性能。而且 ConsumeQueue 是内存映射文件，每个文件也不宜太大。\",\"在消费者上报心跳，注册消费者时就会把过滤信息（Tag 的 Hash 码）生成，放入 ConsumerManager 中。\",\"拉取消息时会先根据拉取消息的消费者信息，构造 ExpressionMessageFilter。\",\"在 Broker 端，调用 ExpressionMessageFilter#isMatchedByConsumeQueue 方法判断该消息 Tag 的 Hash 码是否在过滤规则允许的 Tag Hash 码列表中，如果在则表示该消息可能符合过滤条件，返回给消费者。\",\"在消费者端处理拉取结果的方法 PullApiWrapper#processPullResult 中，再进行精确判断，如果过滤匹配的 Tag 字符串列表中包含消息的 Tag，则返回给消费者消费。\"]},\"840\":{\"h\":\"3.4 SQL92 过滤\"},\"841\":{\"h\":\"3.4.1 编译 SQL 语句\",\"t\":[\"Rocketmq 从 ActiveMQ 中拿到的 SelectorParser.jj 语法标准文件，在其之上做了一些修改。用它能够将消费者端指定的 SQL 语句解析为 Expression 表达式对象，方便后续消息的过滤匹配。\",\"JavaCC (Java Compiler Compiler) 是一个能生成语法和词法分析器的生成程序，它通过阅读一个自定义的语法标准文件 (通常以 jj 为后缀名) ，然后就能生成能够解析该语法的扫描器和解析器的代码。\",\"通过执行 javacc SelectorParser.jj 命令以后，其会生成如下七个 Java 文件，用以解析 SQL 语法：\",\"JavaCC 生成的文件\",\"其中 SelectorParser.java 是主要的解析器类，会将 SQL92 表达式解析成一个抽象语法树（由 Expression 对象组成）。\",\"SqlFilter#compile 作为表达式编译的入口，内部调用 SelectorParser#parse 方法，将 SQL92 语句编译成 Expression 表达式对象。\",\"Rocketmq 实现了一些基本的 Expression 用以执行基本的 SQL92 过滤逻辑：\",\"image-20230703004414898\",\"编译 SQL92 Expression 表达式的时机与 Tag 表达式类似。消费者上报心跳，注册消费者时会预先编译好，放在 ConsumerFilterManager 中。\",\"在 Broker 端处理拉取消息请求时，先判断拉取消息请求是否带有过滤信息，如果带有，则根据过滤信息编译；否则从 ConsumerFilterManager 中获取编译好的 Expression 树。\"]},\"842\":{\"h\":\"3.4.2 布隆过滤器 BloomFilter\",\"t\":[\"注意，仅 isEnableCalcFilterBitMap 配置为 true 时才使用布隆过滤器进行第一层过滤。否则仅进行第二层过滤。\",\"SQL92 的二层过滤中，第一层利用布隆过滤器判断这个消息是否大概率要被对应的消费者拉取，第二层则执行精确的过滤匹配。\",\"布隆过滤器的优点是它的空间占用率非常小，缺点则是只能判断出元素大概率存在集合中，但是无法确定。\",\"它主要提供了两个方法：put 用来将元素加入到集合中，contains 判断元素在集合中是否大概率存在，一般不能删除数据。\",\"存入的原理是：对要插入的元素进行 K 次 Hash 运算，将每次运算结果保存到一个二进制数组的一个下标中。\",\"img\",\"查询的原理是：对需要查询的数据进行 K 次同样的 Hash 运算，判断运算的结果是否都为 1。\"]},\"843\":{\"h\":\"3.4.3 生成布隆过滤器位数组\",\"t\":[\"Rocketmq 的布隆过滤器实现与 Guava 的不太一样，它没有把二进制位数组 BitsArray 存到布隆过滤器中，而是无状态的，每次运算都需要传入这个数组运算函数。\",\"它的方法：\",\"put 方法：\",\"// 将 filterData 存入 BitsArray void hashTo(BloomFilterData filterData, BitsArray bits) \",\"contains 方法：\",\"// 检查给定的 BloomFilterData 对应数据是否在 BitsArray 中 boolean isHit(BloomFilterData filterData, BitsArray bits) \",\"bits：存储所有消费者名称经过 K 次 Hash 结果的位数组\",\"在消息生产时在 reput 步骤由 CommitLogDispatcherCalcBitMap 中调用 hashTo 生成，存到 ConsumeQueueExt 中。\",\"遍历所有消费者（的过滤信息），将所有消费者名称经过 K 次 Hash，存入位数组。（相当于将所有需要过滤的消费者名称存入布隆过滤器）\",\"BloomFilterData：本次拉取消息的消费者的过滤信息\",\"在消费者注册时根据消费者名称和订阅的 Topic 生成。\",\"BloomFilterData bloomFilterData = bloomFilter.generate(consumerGroup + \\\"#\\\" + topic); \",\"其中包含有消费者名称经过 K 次 Hash 得到的位数组 int[] bitPos\",\"class BloomFilterData { private int[] bitPos; private int bitNum; } \"]},\"844\":{\"h\":\"3.4.4 消息过滤\",\"t\":[\"消息的两层过滤与 Tag 过滤一样，在拉消息方法中被调用。\",\"在拉取消息处理方法中，根据拉取消息的消费者信息，从 ConsumerFilterManager 中获取过滤数据，生成 ExpressionMessageFilter 对象。\",\"先调用 ExpressionMessageFilter#isMatchedByConsumeQueue，利用布隆过滤器进行初筛。判断拉消息的消费者是否可能需要消费到这条消息。\",\"然后调用 isMatchedByCommitLog 方法，用编译好的 Expression 进行过滤逻辑判断。\"]},\"845\":{\"h\":\"4. 源码解析\"},\"846\":{\"h\":\"4.1 Tag 过滤\"},\"847\":{\"h\":\"4.1.1 Broker 端过滤\",\"t\":[\"// ExpressMessageFilter.java /** * 根据 ConsumeQueue 中的属性哈希码进行过滤 * * @param tagsCode tagsCode * @param cqExtUnit extend unit of consume queue * @return */ @Override public boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit) { if (null == subscriptionData) { return true; } // 如果是类过滤模式，直接返回 true if (subscriptionData.isClassFilterMode()) { return true; } // Tag 过滤 // by tags code. if (ExpressionType.isTagType(subscriptionData.getExpressionType())) { // 消息发送时没有设置 Tag，返回 true if (tagsCode == null) { return true; } // 允许任意 Tag，返回 true if (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) { return true; } // 返回过滤数据的 Tag 哈希码表中是否包含发送消息的哈希码 return subscriptionData.getCodeSet().contains(tagsCode.intValue()); } else { // SQL92 表达式过滤 // ... } return true; } \"]},\"848\":{\"h\":\"4.1.2 客户端过滤\",\"t\":[\"// PullAPIWrapper.java /** * 拉取消息结果处理 * 消息过滤 & 将二进制消息解析成对象 * * @param mq * @param pullResult * @param subscriptionData * @return */ public PullResult processPullResult(final MessageQueue mq, final PullResult pullResult, final SubscriptionData subscriptionData) { PullResultExt pullResultExt = (PullResultExt) pullResult; // 根据拉取结果，更新下次从哪个节点拉取消息 this.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId()); // 拉取成功 if (PullStatus.FOUND == pullResult.getPullStatus()) { ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary()); List<MessageExt> msgList = MessageDecoder.decodes(byteBuffer); List<MessageExt> msgListFilterAgain = msgList; if (!subscriptionData.getTagsSet().isEmpty() && !subscriptionData.isClassFilterMode()) { // Tag 过滤模式 msgListFilterAgain = new ArrayList<MessageExt>(msgList.size()); for (MessageExt msg : msgList) { if (msg.getTags() != null) { // 如果过滤的 tag 集合中包含消息的 tag，则返回给消费者，否则不消费 if (subscriptionData.getTagsSet().contains(msg.getTags())) { msgListFilterAgain.add(msg); } } } } // ... } pullResultExt.setMessageBinary(null); return pullResult; } \"]},\"849\":{\"h\":\"4.2 SQL92 过滤\"},\"850\":{\"h\":\"4.2.1 注册过滤信息\",\"t\":[\"// DefaultConsumerIdsChangeListener.java /** * 消费者注册、注销，或连接断开时触发 */ @Override public void handle(ConsumerGroupEvent event, String group, Object... args) { if (event == null) { return; } switch (event) { case CHANGE: // 如果发生变化，向所有消费者发送重平衡请求 if (args == null || args.length < 1) { return; } // 获取消费组中所有消费者的 Channel List<Channel> channels = (List<Channel>) args[0]; if (channels != null && brokerController.getBrokerConfig().isNotifyConsumerIdsChangedEnable()) { for (Channel chl : channels) { // 发送重平衡请求 this.brokerController.getBroker2Client().notifyConsumerIdsChanged(chl, group); } } break; case UNREGISTER: this.brokerController.getConsumerFilterManager().unRegister(group); break; case REGISTER: if (args == null || args.length < 1) { return; } Collection<SubscriptionData> subscriptionDataList = (Collection<SubscriptionData>) args[0]; // 新消费者注册，更新过滤信息 this.brokerController.getConsumerFilterManager().register(group, subscriptionDataList); break; default: throw new RuntimeException(\\\"Unknown event \\\" + event); } } \",\"// ConsumerFilterManager.java /** * 注册 SQL92 的过滤信息，构造布隆过滤器 * * @param topic * @param consumerGroup * @param expression * @param type * @param clientVersion * @return */ public boolean register(final String topic, final String consumerGroup, final String expression, final String type, final long clientVersion) { if (ExpressionType.isTagType(type)) { return false; } if (expression == null || expression.length() == 0) { return false; } FilterDataMapByTopic filterDataMapByTopic = this.filterDataByTopic.get(topic); if (filterDataMapByTopic == null) { FilterDataMapByTopic temp = new FilterDataMapByTopic(topic); FilterDataMapByTopic prev = this.filterDataByTopic.putIfAbsent(topic, temp); filterDataMapByTopic = prev != null ? prev : temp; } // 生成布隆过滤器的位数据，保存到消费者过滤信息中。 BloomFilterData bloomFilterData = bloomFilter.generate(consumerGroup + \\\"#\\\" + topic); // 生成消费者过滤信息，保存到 Broker 的 ConsumerFilterManager 过滤信息管理器 return filterDataMapByTopic.register(consumerGroup, expression, type, bloomFilterData, clientVersion); } \"]},\"851\":{\"h\":\"4.2.2 消息生产时构建布隆过滤器数据\",\"t\":[\"// CommitLogDispatcherCalcBitMap.java @Override public void dispatch(DispatchRequest request) { // enableCalcFilterBitMap 配置开启时才创建位数组 if (!this.brokerConfig.isEnableCalcFilterBitMap()) { return; } try { Collection<ConsumerFilterData> filterDatas = consumerFilterManager.get(request.getTopic()); if (filterDatas == null || filterDatas.isEmpty()) { return; } Iterator<ConsumerFilterData> iterator = filterDatas.iterator(); BitsArray filterBitMap = BitsArray.create( this.consumerFilterManager.getBloomFilter().getM() ); long startTime = System.currentTimeMillis(); // 遍历所有注册的带有 SQL92 表达式的消费者，判断是否通过过滤，如果没有被过滤，则消费者名称的位映射，放入到 filterBitMap 中 while (iterator.hasNext()) { ConsumerFilterData filterData = iterator.next(); if (filterData.getCompiledExpression() == null) { log.error(\\\"[BUG] Consumer in filter manager has no compiled expression! {}\\\", filterData); continue; } if (filterData.getBloomFilterData() == null) { log.error(\\\"[BUG] Consumer in filter manager has no bloom data! {}\\\", filterData); continue; } Object ret = null; try { MessageEvaluationContext context = new MessageEvaluationContext(request.getPropertiesMap()); ret = filterData.getCompiledExpression().evaluate(context); } catch (Throwable e) { log.error(\\\"Calc filter bit map error!commitLogOffset={}, consumer={}, {}\\\", request.getCommitLogOffset(), filterData, e); } log.debug(\\\"Result of Calc bit map:ret={}, data={}, props={}, offset={}\\\", ret, filterData, request.getPropertiesMap(), request.getCommitLogOffset()); // eval true if (ret != null && ret instanceof Boolean && (Boolean) ret) { // 将消费组对应的位数据（由 \\\"消费组#Topic\\\" Hash 生成）保存到位数组中 consumerFilterManager.getBloomFilter().hashTo( filterData.getBloomFilterData(), filterBitMap ); } } // 将所有没有被过滤的消费者名称计算出的位映射，放入 DispatchRequest 中，尝试存入 ConsumeQueueExt 文件中（如果开关开启）。 request.setBitMap(filterBitMap.bytes()); long elapsedTime = UtilAll.computeElapsedTimeMilliseconds(startTime); // 1ms if (elapsedTime >= 1) { log.warn(\\\"Spend {} ms to calc bit map, consumerNum={}, topic={}\\\", elapsedTime, filterDatas.size(), request.getTopic()); } } catch (Throwable e) { log.error(\\\"Calc bit map error! topic={}, offset={}, queueId={}, {}\\\", request.getTopic(), request.getCommitLogOffset(), request.getQueueId(), e); } } \"]},\"852\":{\"h\":\"4.2.3 消息拉取时过滤\",\"t\":[\"一层过滤\",\"// ExpressionMessageFilter.java /** * 根据 ConsumeQueue 中的属性哈希码进行过滤 * * @param tagsCode tagsCode * @param cqExtUnit extend unit of consume queue * @return */ @Override public boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit) { if (null == subscriptionData) { return true; } // 如果是类过滤模式，直接返回 true if (subscriptionData.isClassFilterMode()) { return true; } // Tag 过滤 // by tags code. if (ExpressionType.isTagType(subscriptionData.getExpressionType())) { // ... } else { // SQL92 表达式过滤 // no expression or no bloom if (consumerFilterData == null || consumerFilterData.getExpression() == null || consumerFilterData.getCompiledExpression() == null || consumerFilterData.getBloomFilterData() == null) { return true; } // message is before consumer if (cqExtUnit == null || !consumerFilterData.isMsgInLive(cqExtUnit.getMsgStoreTime())) { log.debug(\\\"Pull matched because not in live: {}, {}\\\", consumerFilterData, cqExtUnit); return true; } // 从 ConsumeQueueExt 中取出消息 Reput 时计算的 BitMap，它表示通过过滤条件的所有 SQL92 消费者名称。 byte[] filterBitMap = cqExtUnit.getFilterBitMap(); BloomFilter bloomFilter = this.consumerFilterManager.getBloomFilter(); if (filterBitMap == null || !this.bloomDataValid || filterBitMap.length * Byte.SIZE != consumerFilterData.getBloomFilterData().getBitNum()) { return true; } BitsArray bitsArray = null; try { // 判断当前消费者是否需要消费该消息（是否通过过滤），如果返回 true，表示可能需要消费该消息，false 则一定不需要消费 bitsArray = BitsArray.create(filterBitMap); boolean ret = bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray); log.debug(\\\"Pull {} by bit map:{}, {}, {}\\\", ret, consumerFilterData, bitsArray, cqExtUnit); return ret; } catch (Throwable e) { log.error(\\\"bloom filter error, sub=\\\" + subscriptionData + \\\", filter=\\\" + consumerFilterData + \\\", bitMap=\\\" + bitsArray, e); } } return true; } \",\"二层过滤\",\" /** * 根据 CommitLog 中保存的消息内容进行过滤，主要为 SQL92 表达式模式过滤服务 * * @param msgBuffer message buffer in commit log, may be null if not invoked in store. * @param properties message properties, should decode from buffer if null by yourself. * @return */ @Override public boolean isMatchedByCommitLog(ByteBuffer msgBuffer, Map<String, String> properties) { if (subscriptionData == null) { return true; } // 类过滤模式 if (subscriptionData.isClassFilterMode()) { return true; } // TAG 模式 if (ExpressionType.isTagType(subscriptionData.getExpressionType())) { return true; } ConsumerFilterData realFilterData = this.consumerFilterData; Map<String, String> tempProperties = properties; // no expression if (realFilterData == null || realFilterData.getExpression() == null || realFilterData.getCompiledExpression() == null) { return true; } // 从消息 Buffer 中解码消息属性 if (tempProperties == null && msgBuffer != null) { tempProperties = MessageDecoder.decodeProperties(msgBuffer); } Object ret = null; try { MessageEvaluationContext context = new MessageEvaluationContext(tempProperties); // 用编译好的 SQL92 表达式去过滤消息属性 ret = realFilterData.getCompiledExpression().evaluate(context); } catch (Throwable e) { log.error(\\\"Message Filter error, \\\" + realFilterData + \\\", \\\" + tempProperties, e); } log.debug(\\\"Pull eval result: {}, {}, {}\\\", ret, realFilterData, tempProperties); if (ret == null || !(ret instanceof Boolean)) { return false; } return (Boolean) ret; } \"]},\"853\":{\"h\":\"参考资料\",\"t\":[\"官方文档——消息过滤\",\"RocketMQ 消息过滤流程——赵坤\",\"源码分析RocketMQ消息过滤机制下篇-FilterServer、ClassFilter模式详解——丁威\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"854\":{\"h\":\"Rocketmq 动态配置\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/99991231-rocketmq-dynamic-config.html\",\"# BrokerController#constructor // 初始化配置类，把 4 个配置项注册到配置类中，在配置类被更新时刷新配置项 this.configuration = new Configuration( log, BrokerPathConfigHelper.getBrokerConfigPath(), this.brokerConfig, this.nettyServerConfig, this.nettyClientConfig, this.messageStoreConfig ); \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"855\":{\"h\":\"RocketMQ 与 Kafka 对零拷贝的使用 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/99991231-rocketmq-kafka-zero-copy.html\"]},\"856\":{\"h\":\"背景\"},\"857\":{\"h\":\"用户态和内核态\"},\"858\":{\"h\":\"参考资料\",\"t\":[\"用户态和内核态：用户态线程和内核态线程有什么区别？\",\"磁盘I/O那些事 - 美团技术团队\",\"什么是零拷贝？ - 小林coding\",\"文件 I/O 简明概述 - Spongecaptain\",\"怎么理解内存中的Buffer和Cache？ - 倪朋飞\",\"linux中普通文件和块设备文件的区别 - CobbLiu\",\"Linux内核Page Cache和Buffer Cache关系及演化历史 - lday\",\"Kafka和RocketMQ底层存储之那些你不知道的事 - yes的练级攻略\",\"性能之道：RocketMQ与Kafka高性能设计对比 - 丁威\",\"Linux I/O 原理和 Zero-copy 技术全面揭秘\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"859\":{\"h\":\"RocketMQ 的底层存储实现：内存映射文件 MappedFile、MappedFileQueue 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/99991231-rocketmq-mappedfile.html\"]},\"860\":{\"h\":\"1. 背景\",\"t\":[\"RocketMQ 是一个低延迟、拥有金融级别稳定性的高性能消息队列。\"]},\"861\":{\"h\":\"2. 概述\"},\"862\":{\"h\":\"2.1 MappedFile 的创建\"},\"863\":{\"h\":\"2.2 MappedFile 的写入\"},\"864\":{\"h\":\"2.3 MappedFile 刷盘\"},\"865\":{\"h\":\"2.4\"},\"866\":{\"h\":\"3. 详解\"},\"867\":{\"h\":\"4. 代码\"},\"868\":{\"h\":\"5. 参考资料\",\"t\":[\"RocketMQ 官方文档\",\"Kafka 和 RocketMQ 底层存储之那些你不知道的事\",\"RocketMQ高性能之底层存储设计\",\"深入剖析 RocketMQ 源码 - 消息存储模块\",\"RocketMQ存储实现分析\",\"谈谈MQ | 与Page Cache的爱恨情仇\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"869\":{\"h\":\"Rocketmq 5.0 任意时间定时消息（RIP-43） 原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/99991231-rocketmq-timer.html\"]},\"870\":{\"h\":\"1. 背景\"},\"871\":{\"h\":\"1.1 概念和应用场景\",\"t\":[\"延迟消息（定时消息）即消息到达消息队列服务端后不会马上投递，而是到达某个时间才投递给消费者。它在在当前的互联网环境中有非常大的需求。\",\"例如电商/网约车等业务中都会出现的订单场景，客户下单后并不会马上付款，但是这个订单也不可能一直开着，因为订单会占用商品/网约车资源。这时候就需要一个机制，在比如 5 分钟后进行一次回调，回调关闭订单的方法。 这个回调的触发可以用分布式定时任务来处理，，但是更好的方法可以是使用消息队列发送一个延迟消息，因为一条消息会比一个分布式定时任务轻量得多。 开启一个消费者消费订单取消 Topic 的消息，收到消息后关闭订单，简单高效。\",\"当用户支付了订单，那么这个订单不再需要被取消，刚才发的延迟消息也不再需要被投递。当然，你可以在消费消息时判断一下订单的状态以确定是否需要关闭，但是这样做会有一次额外的数据库操作。如果可以取消定时消息，那么只要发送一条定时消息取消的命令就可以取消之前发送的定时消息投递。\",\"除此之外，定时消息还能用于更多其他场景，如定时任务触发、等待重试、事件预订等等。\"]},\"872\":{\"h\":\"1.2 延迟消息与定时消息\",\"t\":[\"首先需要明确延迟消息与定时消息虽然意思不同，但在体现的效果上确实相同的，都是在消息生产到 Broker 之一段时间之后才会被投递（消费者可以消费到）。只不过在使用的 API 上，延迟消息指定延迟的时间，而定时消息指定确切的投递时间。实际上它们可以实现相同的效果。\",\"在 Rocketmq 4.x 中只支持通过设定延迟等级来支持 18 个固定延迟时间。具体的原理可以看 RocketMQ 延迟消息（定时消息）源码解析。\",\"4.x 的延迟消息有很大的局限性，它无法支持任意时间的定时，而且最大的定时时间也只有 2 小时，它的性能也达不到普通消息（后来 4.x 的延迟消息性能被优化，详见 RocketMQ 延迟消息（定时消息）4.9.3 版本优化 异步投递支持。\",\"许多公司不满足于它的能力，自研了任意时间定时消息，扩展了最大定时时长。\",\"在 Rocketmq 5.x 中终于开源了支持任意时间的定时消息（以下简称定时消息）。它与 4.x 的延迟消息是两套实现机制，互相之间几乎不影响。\"]},\"873\":{\"h\":\"1.2 任意时间定时消息的使用\",\"t\":[\"在 Rocketmq 5.x 的客户端中，在构造消息时提供了 3 个 API 来指定延迟时间或定时时间。\",\"Message message = new Message(TOPIC, (\\\"Hello scheduled message \\\" + i).getBytes(StandardCharsets.UTF_8)); // 延迟 10s 后投递 message.setDelayTimeSec(10); // 延迟 10000ms 后投递 message.setDelayTimeMs(10_000L); // 定时投递，定时时间为当前时间 + 10000ms message.setDeliverTimeMs(System.currentTimeMillis() + 10_000L); // 发送消息 SendResult result = producer.send(message); \"]},\"874\":{\"h\":\"2. 概述\"},\"875\":{\"h\":\"2.1 任意时间定时消息的难点\",\"t\":[\"任意时间定时消息的实现存在一定的难点，所以 4.x 才会实现 18 个延迟等级的定时消息，作为一个折衷的方案。\",\"任意时间定时消息的主要难点有以下几个。\"]},\"876\":{\"h\":\"2.1.1 难点1：任意的定时时间\",\"t\":[\"Rocketmq 4.x 的延迟消息的原理简单来说是：将延迟消息先不存到真正的 Topic，先存到一个延迟 Topic，然后周期性扫描这个 Topic 还未投递的消息是否到期，到期则投递到真正的 Topic 中。\",\"这个方案的局限性在于扫描的每个队列的消息延迟时间必须是相同的。否则会出现先扫描的消息要后投递的情况，如下图所示：\",\"队列中的第一个消息延迟 100s，从队列头开始扫描，需要等待第一个消息先投递，从队列中弹出，后面的消息才能投递。所以第一条消息会阻塞后续消息的投递。\",\"所以 Rocketmq 4.x 的延迟 Topic 中包含 18 个队列，每个队列代表一个延迟等级，对应一个固定的延迟时长，用一个周期性任务去扫描。这样就避免了这个问题。\",\"但任意时间定时消息不可能无限制地增加延迟时长对应的队列数量，这是一个难点。\"]},\"877\":{\"h\":\"2.1.2 难点2：定时消息的存储和老化\",\"t\":[\"我们知道 Rocketmq 的消息是有老化时间的，默认时间为 3 天。这就意味着延迟时间超过 3 天的消息可能会被老化清除，永远无法投递。\",\"让定时消息不受老化时间的限制，这也是一个难点。\"]},\"878\":{\"h\":\"2.1.3 难点3：大量定时消息的极端情况\",\"t\":[\"在定时消息场景下有一种极端情况，就是在同一时刻定时了超大量的消息，需要在一瞬间投递（比如在 8 点定时了 1 亿条消息）。\",\"如果不进行流控直接写入，会把 Rocketmq 冲垮。\"]},\"879\":{\"h\":\"2.2 设计思路\"},\"880\":{\"h\":\"2.2.1 任意时间定时\",\"t\":[\"实现任意时间的定时的要点在于知道在某一时刻需要投递哪些消息，以及破除一个队列只能保存同一个延迟等级的消息的限制。\",\"联想 Rocketmq 的索引文件 IndexFile，可以通过索引文件来辅助定时消息的查询。需要建立这样的一个索引结构：Key 是时间戳，Value 表示这个时间要投递的所有定时消息。\",\"Map<Long /* 投递时间戳 */, List<Message /* 被定时的消息 */>> \",\"把这个索引结构以文件的形式实现，这个结构里的 Message 可以仅保存消息的存储位置，投递的时候再查出来。\"]},\"881\":{\"h\":\"2.2.2\"},\"882\":{\"h\":\"3.\"},\"883\":{\"h\":\"参考资料\",\"t\":[\"PR: [RIP-43] Support Timing Messages with Arbitrary Time Delay\",\"RIP-43 Support timing messages with arbitrary time delay\",\"社区在讨论什么？《Support Timing Messages with Arbitrary Time Delay》\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"884\":{\"h\":\"rocketmq\",\"t\":[\"RocketMQ 4.9.1 性能优化 源码剖析\",\"RocketMQ ConsumeQueue 消费队列文件\",\"RocketMQ IndexFile 索引文件\",\"RocketMQ 消息消费 轮询机制 PullRequestHoldService\",\"RocketMQ 延迟消息（定时消息）源码解析\",\"RocketMQ 延迟消息（定时消息）4.9.3 版本优化 异步投递支持\",\"RocketMQ 过期文件删除机制 源码剖析\",\"RocketMQ 如何实现高性能消息读写？\",\"RocketMQ 4.9.3 版本 性能优化 源码剖析\",\"RocketMQ 实现高性能定时消息\",\"RocketMQ NameServer 详解 源码剖析\",\"RocketMQ ACL 权限控制 详解 & 源码剖析\",\"RocketMQ 消息轨迹\",\"RocketMQ 消息发送设计和原理详解 源码剖析\",\"RocketMQ Memory Store\",\"使用 Docker 和 docker-compose 快速部署 RocketMQ 集群 双主 / DLedger\",\"RocketMQ 消费者（1）概念和消费流程\",\"RocketMQ 消费者（2）客户端设计和启动流程详解 & 源码解析\",\"RocketMQ 消费者（3）重平衡 流程详解 & 源码解析\",\"RocketMQ 消费者（4）消息拉取 流程详解 & 源码解析\",\"RocketMQ 消费者（5）消息消费、消费进度上报 流程详解 & 源码解析\",\"RocketMQ 消费者（6）顺序消费 流程详解 & 源码解析\",\"RocketMQ 最佳实践\",\"RocketMQ 5.0：POP 消费模式 原理详解 & 源码解析\",\"RocketMQ 轻量级队列 Light Message Queue（RIP-28）原理详解 & 源码解析\",\"RocketMQ Netty 写缓冲区水位配置 NettyServerConfig#writeBufferHighWaterMark\",\"Rocketmq Filter 消息过滤（TAGS、SQL92）原理详解 & 源码解析\"]}},\"dirtCount\":0,\"index\":[[\"联想\",{\"1\":{\"880\":1}}],[\"亿条消息\",{\"1\":{\"878\":1}}],[\"永远无法投递\",{\"1\":{\"877\":1}}],[\"难点3\",{\"0\":{\"878\":1}}],[\"难点2\",{\"0\":{\"877\":1}}],[\"难点1\",{\"0\":{\"876\":1}}],[\"难点和取舍\",{\"0\":{\"444\":1}}],[\"许多公司不满足于它的能力\",{\"1\":{\"872\":1}}],[\"许多模块需要共享通用的记录定义\",{\"1\":{\"61\":1}}],[\"谈谈mq\",{\"1\":{\"868\":1}}],[\"深入剖析\",{\"1\":{\"868\":1}}],[\"深入剖析rocketmq源码\",{\"1\":{\"494\":1}}],[\"技术全面揭秘\",{\"1\":{\"858\":1}}],[\"技术内幕\",{\"1\":{\"404\":1,\"494\":1,\"577\":1}}],[\"倪朋飞\",{\"1\":{\"858\":1}}],[\"简明概述\",{\"1\":{\"858\":1}}],[\"简单高效\",{\"1\":{\"441\":1,\"871\":1}}],[\"简单说\",{\"1\":{\"166\":1}}],[\"简单来说\",{\"1\":{\"152\":1,\"155\":1}}],[\"美团技术团队\",{\"1\":{\"858\":1}}],[\"动态配置\",{\"0\":{\"854\":1}}],[\"动态代码载入\",{\"0\":{\"57\":1}}],[\"哈希码表中是否包含发送消息的哈希码\",{\"1\":{\"847\":1}}],[\"允许任意\",{\"1\":{\"847\":1}}],[\"允许多个元素拥有相同的键\",{\"1\":{\"98\":1}}],[\"树\",{\"1\":{\"841\":1}}],[\"布隆过滤器的优点是它的空间占用率非常小\",{\"1\":{\"842\":1}}],[\"布隆过滤器\",{\"0\":{\"842\":1}}],[\"布隆过滤器可以用来判断某个元素是否可能存在于集合中\",{\"1\":{\"835\":1}}],[\"布尔表达式\",{\"0\":{\"56\":1}}],[\"布尔值\",{\"0\":{\"56\":1}}],[\"剩下的消息再根据消息详情过滤\",{\"1\":{\"833\":1}}],[\"剩下元素是列表尾\",{\"1\":{\"27\":1}}],[\"集合中包含消息的\",{\"1\":{\"834\":1,\"848\":1}}],[\"集合的元素只能是字符串\",{\"1\":{\"828\":1}}],[\"集群模式的消费进度管理涉及到消费者端和\",{\"1\":{\"703\":1}}],[\"集群模式消费进度管理\",{\"0\":{\"703\":1}}],[\"集群模式下\",{\"1\":{\"623\":1,\"701\":1}}],[\"集群模式\",{\"1\":{\"623\":1,\"640\":1,\"642\":1,\"715\":1,\"738\":1,\"786\":1}}],[\"集群消费模式下\",{\"1\":{\"611\":1}}],[\"集群消费模式\",{\"0\":{\"611\":1}}],[\"集群消费\",{\"1\":{\"608\":1}}],[\"集群状态\",{\"1\":{\"596\":1}}],[\"集群信息\",{\"1\":{\"469\":1}}],[\"集群名称\",{\"1\":{\"464\":1,\"472\":1}}],[\"集群的客户端\",{\"1\":{\"755\":1}}],[\"集群的每台机器都发送心跳包\",{\"1\":{\"465\":1}}],[\"集群的路由信息\",{\"1\":{\"461\":1}}],[\"集群的注册信息并且保存下来作为路由信息的基本数据\",{\"1\":{\"461\":1}}],[\"集群中队列副本的数量\",{\"1\":{\"190\":1}}],[\"集群创建\",{\"1\":{\"163\":1}}],[\"集群\",{\"0\":{\"588\":1},\"1\":{\"135\":1,\"181\":1,\"498\":1,\"786\":1,\"884\":1}}],[\"集群均可在故障期间自行转移主节点\",{\"1\":{\"134\":1}}],[\"集群无法自行恢复\",{\"1\":{\"134\":1}}],[\"集群在主节点与从节点网络断开\",{\"1\":{\"134\":1}}],[\"集群缺乏自动恢复能力\",{\"1\":{\"134\":1}}],[\"示例\",{\"1\":{\"828\":1}}],[\"语法标准文件\",{\"1\":{\"841\":1}}],[\"语法\",{\"1\":{\"828\":1,\"841\":1}}],[\"语句编译成\",{\"1\":{\"841\":1}}],[\"语句解析为\",{\"1\":{\"841\":1}}],[\"语句\",{\"0\":{\"841\":1}}],[\"语句来打印出感兴趣的变量值\",{\"1\":{\"108\":1}}],[\"语句里\",{\"1\":{\"45\":1}}],[\"低水位线通过\",{\"1\":{\"820\":1}}],[\"低于\",{\"1\":{\"442\":1}}],[\"水位线只是一个警示\",{\"1\":{\"820\":1}}],[\"水平扩容指部署\",{\"1\":{\"181\":1}}],[\"冲垮\",{\"1\":{\"878\":1}}],[\"冲刷到\",{\"1\":{\"820\":1}}],[\"冲突时变成链表结构\",{\"1\":{\"306\":1}}],[\"冲突的可能\",{\"1\":{\"306\":1}}],[\"讲起\",{\"1\":{\"820\":1}}],[\"缓冲区高低水位的配置\",{\"1\":{\"819\":1}}],[\"缓存其结果\",{\"1\":{\"416\":1,\"437\":1}}],[\"缓存\",{\"0\":{\"415\":1},\"1\":{\"177\":1,\"517\":1,\"710\":1}}],[\"父\",{\"1\":{\"813\":1}}],[\"占用大量磁盘存储空间和内存\",{\"1\":{\"810\":1}}],[\"占用较大快的\",{\"1\":{\"434\":1}}],[\"场景下\",{\"1\":{\"810\":1}}],[\"合入pr\",{\"1\":{\"804\":1}}],[\"合并了\",{\"1\":{\"251\":1}}],[\"合并机制\",{\"0\":{\"221\":1}}],[\"轻量级队列分发准备\",{\"1\":{\"816\":1}}],[\"轻量级队列\",{\"0\":{\"802\":1},\"1\":{\"884\":1}}],[\"连续\",{\"1\":{\"798\":1}}],[\"连接的数据发送一方中的\",{\"1\":{\"820\":1}}],[\"连接的状态保存在\",{\"1\":{\"417\":1}}],[\"连接\",{\"1\":{\"249\":1,\"416\":1}}],[\"距离\",{\"1\":{\"797\":1}}],[\"距离下次可重试\",{\"1\":{\"795\":1}}],[\"拆分消息句柄字符串\",{\"1\":{\"793\":1}}],[\"赋值过程省略\",{\"1\":{\"791\":1}}],[\"供\",{\"1\":{\"783\":1}}],[\"供广大学生选择与参与\",{\"1\":{\"136\":1}}],[\"隔离\",{\"1\":{\"783\":1}}],[\"隔离模式即单独选一个\",{\"1\":{\"532\":1}}],[\"隔离模式\",{\"1\":{\"524\":1,\"532\":1}}],[\"入口是\",{\"1\":{\"780\":1}}],[\"切换消息拉取模式为\",{\"1\":{\"772\":1}}],[\"切换至下一个文件\",{\"1\":{\"291\":1}}],[\"迟迟无法被消费\",{\"1\":{\"769\":1}}],[\"住导致队列消息堆积\",{\"1\":{\"770\":1}}],[\"住\",{\"1\":{\"769\":1}}],[\"住时其负载的队列可能会堆积的问题\",{\"1\":{\"651\":1}}],[\"住时该队列的消息会堆积\",{\"1\":{\"615\":1}}],[\"什么是零拷贝\",{\"1\":{\"858\":1}}],[\"什么是\",{\"0\":{\"765\":1}}],[\"附\",{\"1\":{\"755\":1}}],[\"结束本次消费请求的消费\",{\"1\":{\"750\":1}}],[\"结束本次消费任务\",{\"1\":{\"750\":1}}],[\"结果的位数组\",{\"1\":{\"843\":1}}],[\"结果\",{\"1\":{\"190\":1}}],[\"结果会输出到一个文件\",{\"1\":{\"105\":1}}],[\"结果会自动转换成浮点数\",{\"1\":{\"24\":1}}],[\"周期\",{\"1\":{\"735\":1}}],[\"周期性启动定时任务\",{\"0\":{\"452\":1}}],[\"边界条件\",{\"0\":{\"735\":1}}],[\"似乎是一个可以优化的点\",{\"1\":{\"727\":1}}],[\"持续消费一个队列的消息\",{\"1\":{\"726\":1}}],[\"持久化消费进度到磁盘\",{\"1\":{\"720\":1,\"721\":1}}],[\"持久化消费进度\",{\"1\":{\"711\":1,\"720\":3,\"721\":2,\"745\":1}}],[\"持久化消息存储\",{\"1\":{\"220\":1}}],[\"持久化时先保存到本地缓存\",{\"1\":{\"710\":1}}],[\"持久化时保存到消费者本地\",{\"1\":{\"710\":1}}],[\"持久化的机制来带的问题\",{\"1\":{\"462\":1}}],[\"持久化的过程是通过后台服务\",{\"1\":{\"288\":1}}],[\"持久化指的是数据保存在磁盘中\",{\"1\":{\"216\":1}}],[\"持久化\",{\"0\":{\"216\":1}}],[\"确保顺序消费\",{\"1\":{\"723\":1}}],[\"确保当其他关卡都失败时表达式的最后部分会被执行\",{\"1\":{\"38\":1}}],[\"然而为了能够实现顺序的消费\",{\"1\":{\"723\":1}}],[\"然后周期性扫描这个\",{\"1\":{\"876\":1}}],[\"然后周期性调用\",{\"1\":{\"332\":1}}],[\"然后就能生成能够解析该语法的扫描器和解析器的代码\",{\"1\":{\"841\":1}}],[\"然后在第二层过滤时将通过第一层过滤的消息信息进行\",{\"1\":{\"835\":1}}],[\"然后到达操作系统的底层的\",{\"1\":{\"820\":1}}],[\"然后下降到低水位线以下\",{\"1\":{\"819\":1}}],[\"然后查询\",{\"1\":{\"814\":1}}],[\"然后这个消息定时到\",{\"1\":{\"779\":1}}],[\"然后这条消息会延迟相应的时间发送\",{\"1\":{\"353\":1}}],[\"然后给顺序消费服务提交顺序消费任务\",{\"1\":{\"739\":1}}],[\"然后给第二个\",{\"1\":{\"617\":1}}],[\"然后定时持久化到磁盘\",{\"1\":{\"710\":1}}],[\"然后复原\",{\"1\":{\"708\":1}}],[\"然后复制到镜像\",{\"1\":{\"193\":1}}],[\"然后并发消费和顺序消费分别实现该接口\",{\"1\":{\"707\":1}}],[\"然后处理消费结果\",{\"1\":{\"699\":1}}],[\"然后重新放入队列\",{\"1\":{\"678\":1}}],[\"然后重新投递到\",{\"1\":{\"356\":1}}],[\"然后重新投递\",{\"1\":{\"354\":1}}],[\"然后提交给消息消费服务处理\",{\"1\":{\"672\":1}}],[\"然后提供心跳检测机制\",{\"1\":{\"461\":1}}],[\"然后指定消费回调函数\",{\"1\":{\"637\":1}}],[\"然后推消费者和拉消费者接口分别扩展消费者接口\",{\"1\":{\"636\":1}}],[\"然后创建一个\",{\"1\":{\"632\":1}}],[\"然后调用并发消费服务\",{\"1\":{\"708\":1}}],[\"然后调用\",{\"1\":{\"624\":1,\"656\":1,\"708\":1,\"783\":1,\"844\":1}}],[\"然后启动成功\",{\"1\":{\"599\":1}}],[\"然后访问\",{\"1\":{\"598\":1}}],[\"然后运行\",{\"1\":{\"597\":1,\"601\":1}}],[\"然后构建镜像包\",{\"1\":{\"592\":1}}],[\"然后等消息真正发送到\",{\"1\":{\"559\":1}}],[\"然后选择一个队列进行发送\",{\"1\":{\"549\":1}}],[\"然后发送\",{\"1\":{\"540\":1}}],[\"然后发送请求给\",{\"1\":{\"710\":1}}],[\"然后发送请求\",{\"1\":{\"509\":1}}],[\"然后遍历这些文件读取权限数据和全局白名单\",{\"1\":{\"518\":1}}],[\"然后遍历每个\",{\"1\":{\"391\":1}}],[\"然后进行签名\",{\"1\":{\"509\":1,\"515\":1}}],[\"然后注册到客户端中\",{\"1\":{\"504\":1}}],[\"然后依次写入\",{\"1\":{\"473\":1}}],[\"然后依靠\",{\"1\":{\"450\":1}}],[\"然后初始化\",{\"1\":{\"467\":2,\"480\":1,\"481\":1}}],[\"然后站在开源\",{\"1\":{\"456\":1}}],[\"然后保存到\",{\"1\":{\"450\":1}}],[\"然后通过位置信息从消息存储文件\",{\"1\":{\"447\":1}}],[\"然后通过异步的方式由\",{\"1\":{\"399\":1}}],[\"然后的实现十分简单粗暴\",{\"1\":{\"445\":1}}],[\"然后设置这条消息延迟\",{\"1\":{\"440\":1}}],[\"然后用订阅信息构造一个\",{\"1\":{\"838\":1}}],[\"然后用\",{\"1\":{\"590\":1}}],[\"然后用位图匹配的方式替换正则匹配\",{\"1\":{\"424\":1}}],[\"然后用偏移量从\",{\"1\":{\"302\":1}}],[\"然后可以启动\",{\"1\":{\"595\":1}}],[\"然后可以使用\",{\"1\":{\"420\":1}}],[\"然后可以将\",{\"1\":{\"246\":1}}],[\"然后优化该方法\",{\"1\":{\"417\":1}}],[\"然后观察其火焰图中方法的时间占用百分比\",{\"1\":{\"407\":1}}],[\"然后异步写入\",{\"1\":{\"403\":1}}],[\"然后应用程序再从\",{\"1\":{\"399\":1}}],[\"然后关闭\",{\"1\":{\"390\":1}}],[\"然后移除\",{\"1\":{\"378\":1,\"745\":1}}],[\"然后投递\",{\"1\":{\"377\":1}}],[\"然后更新到本地路由表缓存\",{\"1\":{\"559\":1}}],[\"然后更新\",{\"1\":{\"313\":1}}],[\"然后转发和构建\",{\"1\":{\"281\":1}}],[\"然后使用offset从consumequeue中获取相应位置的索引信息\",{\"1\":{\"277\":1}}],[\"然后根据消费索引从\",{\"1\":{\"838\":1}}],[\"然后根据\",{\"1\":{\"365\":1}}],[\"然后根据这条请求传入的offset消费队列偏移量\",{\"1\":{\"277\":1,\"286\":1}}],[\"然后根据位置获取\",{\"1\":{\"271\":1}}],[\"然后为没有加锁的队列新建\",{\"1\":{\"734\":1}}],[\"然后为生产消息和消费消息的协议单独实现解码方法\",{\"1\":{\"411\":1}}],[\"然后为\",{\"1\":{\"261\":1}}],[\"然后把这些属性封装放入消息属性中\",{\"1\":{\"814\":1}}],[\"然后把重平衡结果返回给客户端\",{\"1\":{\"775\":1}}],[\"然后把预编码的数据放到\",{\"1\":{\"257\":1}}],[\"然后把读到的\",{\"1\":{\"249\":1}}],[\"然后生产者可以重试之前阻塞的时候生产失败的消息\",{\"1\":{\"226\":1}}],[\"然后恢复上线之后\",{\"1\":{\"226\":1}}],[\"然后才处于上面的某种状态\",{\"1\":{\"223\":1}}],[\"然后消费者就有责任重新发行基本版\",{\"1\":{\"198\":1}}],[\"然后\",{\"1\":{\"198\":1,\"365\":1,\"461\":1,\"515\":1,\"820\":1}}],[\"然后将该消息发送到\",{\"1\":{\"783\":1}}],[\"然后将处理队列整个放入消费任务\",{\"1\":{\"737\":1}}],[\"然后将\",{\"1\":{\"491\":1}}],[\"然后将结果返回给消费者\",{\"1\":{\"345\":1}}],[\"然后将结果与左侧\",{\"1\":{\"23\":1}}],[\"然后将消息真正的\",{\"1\":{\"354\":1,\"359\":1,\"363\":1}}],[\"然后将消息投递到queue\",{\"1\":{\"201\":1}}],[\"然后将消息处理完后发给\",{\"1\":{\"154\":1}}],[\"然后分析基于信用证的流控机制\",{\"1\":{\"154\":1}}],[\"然后对于超过\",{\"1\":{\"562\":1}}],[\"然后对其进行压测\",{\"1\":{\"407\":1}}],[\"然后对这些请求调用\",{\"1\":{\"334\":1}}],[\"然后对错误进行处理\",{\"1\":{\"43\":1}}],[\"然后对它做一些操作\",{\"1\":{\"27\":1}}],[\"然后再经过\",{\"1\":{\"820\":1}}],[\"然后再磁盘中匹配\",{\"1\":{\"781\":1}}],[\"然后再重试查询\",{\"1\":{\"324\":1}}],[\"然后再从消息存储中查询具体的消息\",{\"1\":{\"220\":1}}],[\"然后再按照键的排序比较键和值\",{\"1\":{\"42\":1}}],[\"然后再执行测试\",{\"1\":{\"4\":1}}],[\"然后舍去余数\",{\"1\":{\"24\":1}}],[\"覆盖\",{\"1\":{\"718\":1}}],[\"覆盖高靠性\",{\"1\":{\"128\":1}}],[\"输出消息内容\",{\"1\":{\"715\":1}}],[\"输出集群的处理语义情况\",{\"1\":{\"133\":1}}],[\"失败可能是内存匹配未开启\",{\"1\":{\"793\":1}}],[\"失败则有可能是内存匹配未开启\",{\"1\":{\"780\":1}}],[\"失败则重试\",{\"1\":{\"715\":1}}],[\"失败\",{\"1\":{\"717\":1}}],[\"失败数量\",{\"1\":{\"715\":1}}],[\"失去多数节点时意味着队列不可用\",{\"0\":{\"236\":1}}],[\"成功\",{\"1\":{\"798\":1}}],[\"成功则直接返回\",{\"1\":{\"793\":1}}],[\"成功则更新统计数据\",{\"1\":{\"715\":1}}],[\"成功数量\",{\"1\":{\"715\":1}}],[\"成功或失败\",{\"1\":{\"715\":1}}],[\"成熟的specific度量指标\",{\"1\":{\"127\":1}}],[\"利用布隆过滤器进行初筛\",{\"1\":{\"844\":1}}],[\"利用命令行\",{\"1\":{\"767\":1}}],[\"利用延迟消息特性\",{\"1\":{\"699\":1}}],[\"利用了这个特性\",{\"1\":{\"396\":1}}],[\"顾名思义\",{\"1\":{\"699\":1}}],[\"见上\",{\"1\":{\"695\":1,\"749\":1}}],[\"见下面credit\",{\"1\":{\"157\":1}}],[\"准备构造拉取请求\",{\"1\":{\"679\":1}}],[\"准备工作\",{\"0\":{\"122\":1}}],[\"橙色\",{\"1\":{\"676\":1}}],[\"步骤由\",{\"1\":{\"843\":1}}],[\"步会将生成的\",{\"1\":{\"778\":1}}],[\"步\",{\"1\":{\"669\":1}}],[\"丢弃的队列则向\",{\"1\":{\"729\":1}}],[\"丢弃的消息个数\",{\"1\":{\"541\":1}}],[\"丢弃该消费队列\",{\"1\":{\"695\":1}}],[\"丢弃老的处理队列\",{\"1\":{\"664\":1,\"744\":1}}],[\"丢弃不再消费的队列\",{\"1\":{\"664\":1,\"744\":1}}],[\"环形寻论平均分配\",{\"1\":{\"658\":1}}],[\"环境准备\",{\"0\":{\"590\":1}}],[\"刚好能完全分配队列给所有消费者\",{\"1\":{\"657\":1}}],[\"刚才发的延迟消息也不再需要被投递\",{\"1\":{\"441\":1,\"871\":1}}],[\"仿照\",{\"1\":{\"656\":1}}],[\"封装\",{\"1\":{\"769\":1}}],[\"封装成消费请求\",{\"1\":{\"699\":1}}],[\"封装成一个\",{\"1\":{\"541\":1}}],[\"封装成一个发送任务提交给消息发送线程池处理\",{\"1\":{\"541\":1}}],[\"封装的服务线程\",{\"1\":{\"688\":1}}],[\"封装后返回给客户端\",{\"1\":{\"673\":1}}],[\"封装很原始的消费者\",{\"1\":{\"656\":1}}],[\"蓝色为被动触发\",{\"1\":{\"656\":1}}],[\"黄色为主动触发\",{\"1\":{\"656\":1}}],[\"域\",{\"0\":{\"653\":1}}],[\"感知到新消费者启动\",{\"1\":{\"648\":1}}],[\"着重讲解\",{\"1\":{\"639\":1}}],[\"着重体现了长轮询逻辑\",{\"1\":{\"332\":1}}],[\"平均分配\",{\"1\":{\"658\":1}}],[\"平平无奇\",{\"1\":{\"639\":1}}],[\"平时不会启动\",{\"1\":{\"384\":1}}],[\"拉模式不涉及自动拉取消息\",{\"1\":{\"675\":1}}],[\"拉模式主动拉取消息\",{\"1\":{\"667\":1}}],[\"拉模式消费者则需要用户自行调用消费者的方法触发消费进度更新\",{\"1\":{\"704\":1}}],[\"拉模式消费者由于需要主动进行拉取\",{\"1\":{\"671\":1}}],[\"拉模式消费者拉取\",{\"0\":{\"671\":1}}],[\"拉模式消费者需要手动拉取消息进行消费\",{\"1\":{\"639\":1}}],[\"拉模式消费者的消费步骤为\",{\"1\":{\"637\":1}}],[\"拉\",{\"0\":{\"637\":1}}],[\"拉和推消费者实现拉消费和推消费方法\",{\"1\":{\"636\":1}}],[\"拉取对应的队列\",{\"1\":{\"789\":1}}],[\"拉取重试消息\",{\"1\":{\"789\":1}}],[\"拉取前再次判断队列\",{\"1\":{\"739\":1}}],[\"拉取到消息之后调用\",{\"1\":{\"714\":1}}],[\"拉取到的消息系统属性中有一个比较重要的属性叫做\",{\"1\":{\"771\":1}}],[\"拉取到的消息会暂存在处理队列\",{\"1\":{\"675\":1}}],[\"拉取到的消息存放在哪\",{\"1\":{\"672\":1}}],[\"拉取结果\",{\"1\":{\"691\":1}}],[\"拉取成功\",{\"1\":{\"848\":1}}],[\"拉取成功回调函数\",{\"1\":{\"691\":1}}],[\"拉取成功后的\",{\"1\":{\"739\":1}}],[\"拉取成功后将拉取到的消息存入处理队列\",{\"1\":{\"672\":1}}],[\"拉取成功后调用\",{\"1\":{\"637\":1}}],[\"拉取最大数量\",{\"1\":{\"691\":1}}],[\"拉取偏移量\",{\"1\":{\"691\":1}}],[\"拉取系统标记\",{\"1\":{\"690\":1}}],[\"拉取线程中应用了生产\",{\"1\":{\"675\":1}}],[\"拉取完成之后更新拉取偏移量\",{\"1\":{\"672\":1}}],[\"拉取完成后\",{\"1\":{\"624\":1}}],[\"拉取模式消费者提供了同步和异步的拉取方法\",{\"1\":{\"671\":1}}],[\"拉取路由\",{\"1\":{\"640\":1,\"643\":1}}],[\"拉取路由信息\",{\"1\":{\"475\":1,\"550\":1,\"559\":1}}],[\"拉取一批消息成功后\",{\"1\":{\"639\":1}}],[\"拉取后执行消费消息逻辑\",{\"1\":{\"639\":1}}],[\"拉取超时时间\",{\"1\":{\"637\":1}}],[\"拉取的这批消息将生成一个\",{\"1\":{\"778\":1}}],[\"拉取的一批消息总数小于每批次可以消费的消息数\",{\"1\":{\"714\":1}}],[\"拉取的消息在消费队列中的偏移量\",{\"1\":{\"637\":1}}],[\"拉取的队列\",{\"1\":{\"637\":1}}],[\"拉取的另一种实现\",{\"1\":{\"615\":1}}],[\"拉取远程\",{\"0\":{\"593\":1}}],[\"拉取官方打包的镜像都可以\",{\"1\":{\"591\":1}}],[\"拉取\",{\"1\":{\"557\":1,\"559\":1,\"562\":1,\"590\":1,\"614\":1}}],[\"拉取该主题订阅信息\",{\"1\":{\"690\":1}}],[\"拉取该\",{\"1\":{\"465\":1}}],[\"拉取消息结果处理\",{\"1\":{\"848\":1}}],[\"拉取消息时会先根据拉取消息的消费者信息\",{\"1\":{\"839\":1}}],[\"拉取消息时也会将队列的消息偏移量提交到\",{\"1\":{\"623\":1}}],[\"拉取消息时也会提交消费偏移量\",{\"1\":{\"623\":1}}],[\"拉取消息后调用\",{\"1\":{\"791\":1}}],[\"拉取消息成功\",{\"1\":{\"789\":1}}],[\"拉取消息成功后的回调方法\",{\"1\":{\"690\":1}}],[\"拉取消息服务发送\",{\"1\":{\"772\":1}}],[\"拉取消息服务最终会调用\",{\"1\":{\"675\":1}}],[\"拉取消息前判断该队列的消息是否被消费完\",{\"1\":{\"727\":1}}],[\"拉取消息数量\",{\"1\":{\"693\":1}}],[\"拉取消息入口\",{\"1\":{\"690\":1,\"748\":1}}],[\"拉取消息\",{\"1\":{\"410\":1,\"613\":1,\"615\":1,\"637\":1,\"639\":1,\"678\":1,\"688\":1,\"691\":1}}],[\"拉取消息请求\",{\"1\":{\"342\":1}}],[\"拉取等等\",{\"1\":{\"410\":1}}],[\"拉取请求指定了队列\",{\"1\":{\"789\":1}}],[\"拉取请求队列\",{\"1\":{\"688\":1}}],[\"拉取请求放入阻塞队列的时机主要有三个\",{\"1\":{\"678\":1}}],[\"拉取请求从哪放入阻塞队列\",{\"1\":{\"672\":1}}],[\"拉取请求\",{\"1\":{\"657\":1,\"689\":1,\"690\":1,\"748\":1}}],[\"拉取请求在一次拉取消息完成之后会复用\",{\"1\":{\"624\":1}}],[\"拉取请求暂时挂起\",{\"1\":{\"335\":1}}],[\"拉取请求时调用\",{\"1\":{\"334\":1}}],[\"拉取请求的入口方法\",{\"1\":{\"334\":1}}],[\"拉取请求挂起时间超过阈值\",{\"1\":{\"345\":1}}],[\"拉取请求挂起时间\",{\"1\":{\"325\":1}}],[\"拉取清求的入口类\",{\"1\":{\"329\":1,\"334\":1}}],[\"贝贝猫\",{\"1\":{\"625\":1}}],[\"赵坤\",{\"1\":{\"625\":1,\"853\":1}}],[\"癫狂侠\",{\"1\":{\"625\":1}}],[\"丁威\",{\"1\":{\"625\":1,\"853\":1,\"858\":1}}],[\"批默认为\",{\"1\":{\"624\":1}}],[\"批消息\",{\"1\":{\"624\":1,\"707\":1}}],[\"批量锁定消息队列\",{\"1\":{\"742\":1}}],[\"批量消息\",{\"0\":{\"564\":1},\"1\":{\"545\":1,\"548\":1,\"564\":1}}],[\"批量从等待处理的消息轨迹队列中获取数据\",{\"1\":{\"541\":1}}],[\"批量从待处理消息轨迹队列中取数据\",{\"1\":{\"541\":1}}],[\"批量发送机制是为了提高效率\",{\"1\":{\"541\":1}}],[\"批量拉任务进行通知\",{\"1\":{\"436\":1}}],[\"批量进行处理\",{\"1\":{\"435\":1}}],[\"红黑树保存消息的顺序\",{\"1\":{\"624\":1}}],[\"级别配置\",{\"1\":{\"648\":1}}],[\"级别的顺序消费\",{\"1\":{\"622\":1}}],[\"级别的顺序消费的\",{\"1\":{\"622\":1}}],[\"级别顺序消息\",{\"1\":{\"548\":1}}],[\"挂掉或者消费者挂掉时\",{\"1\":{\"621\":1}}],[\"挂起最大时间\",{\"1\":{\"691\":1}}],[\"挂起\",{\"1\":{\"342\":1}}],[\"挂起的最长时间\",{\"1\":{\"332\":1}}],[\"挂起的拉取请求会在这里进行保存\",{\"1\":{\"330\":1}}],[\"死信消息处理\",{\"1\":{\"718\":1}}],[\"死信机制\",{\"0\":{\"620\":1},\"1\":{\"620\":1}}],[\"死信队列名称为\",{\"1\":{\"708\":1}}],[\"死信队列\",{\"1\":{\"576\":1}}],[\"掉线等情况发生后\",{\"1\":{\"618\":1}}],[\"富客户端\",{\"1\":{\"615\":1}}],[\"层面的封装让用户感觉像是\",{\"1\":{\"614\":1}}],[\"适合各个消费者都需要通知的场景\",{\"1\":{\"610\":1}}],[\"适用于消息丢失也没有太大影响的场景\",{\"1\":{\"547\":1}}],[\"适用于小规模的性能分析\",{\"1\":{\"105\":1}}],[\"登录访问\",{\"1\":{\"597\":1}}],[\"⠿\",{\"1\":{\"595\":4}}],[\"宿主机ip\",{\"1\":{\"595\":3}}],[\"仓库\",{\"1\":{\"590\":1}}],[\"双主\",{\"0\":{\"588\":1},\"1\":{\"884\":1}}],[\"放在\",{\"1\":{\"841\":1}}],[\"放弃本次拉取\",{\"1\":{\"690\":2}}],[\"放入到\",{\"1\":{\"851\":1}}],[\"放入消息属性\",{\"1\":{\"816\":1}}],[\"放入消费队列\",{\"1\":{\"669\":1}}],[\"放入\",{\"1\":{\"795\":1,\"798\":1,\"839\":1,\"851\":1}}],[\"放入内存匹配失败\",{\"1\":{\"791\":1}}],[\"放入内存\",{\"1\":{\"782\":1,\"791\":1,\"795\":2}}],[\"放入内存和磁盘\",{\"1\":{\"778\":1,\"791\":1}}],[\"放入磁盘存储\",{\"1\":{\"782\":1}}],[\"放入拉取请求队列\",{\"1\":{\"748\":1}}],[\"放入拉取队列\",{\"1\":{\"639\":1}}],[\"放入待执行的拉取请求队列\",{\"1\":{\"639\":1}}],[\"放入重试\",{\"1\":{\"620\":1}}],[\"放入指定队列\",{\"1\":{\"585\":1}}],[\"放到一个\",{\"1\":{\"773\":1}}],[\"放到\",{\"1\":{\"564\":1,\"814\":1}}],[\"放到消息属性中\",{\"1\":{\"363\":1}}],[\"放到消息的\",{\"1\":{\"354\":1}}],[\"放到锁外\",{\"1\":{\"256\":1}}],[\"放到了锁外\",{\"1\":{\"256\":1}}],[\"走\",{\"1\":{\"581\":2}}],[\"走原有\",{\"1\":{\"581\":2}}],[\"走到文件末尾\",{\"1\":{\"291\":1}}],[\"核心原理与最佳实践\",{\"1\":{\"577\":1}}],[\"核心入口\",{\"0\":{\"573\":1},\"1\":{\"573\":1}}],[\"待发送消息\",{\"1\":{\"573\":1}}],[\"待拉取的\",{\"1\":{\"689\":1}}],[\"待拉取的消费队列\",{\"1\":{\"689\":1}}],[\"待拉取偏移量等于队列最大偏移量\",{\"1\":{\"339\":1}}],[\"待拉取消息的偏移量是否小于消费队列最大偏移量\",{\"1\":{\"335\":1}}],[\"启用消费队列扩展存储\",{\"1\":{\"828\":1,\"835\":1}}],[\"启用\",{\"1\":{\"572\":2}}],[\"启动配置\",{\"0\":{\"806\":1}}],[\"启动拉取\",{\"1\":{\"657\":1,\"664\":1,\"744\":1}}],[\"启动拉取消息服务\",{\"1\":{\"640\":1,\"643\":1}}],[\"启动默认生产者\",{\"1\":{\"640\":1,\"643\":1}}],[\"启动通信模块\",{\"1\":{\"640\":1,\"643\":1}}],[\"启动客户端实例\",{\"1\":{\"642\":1}}],[\"启动客户端实例对象\",{\"1\":{\"640\":1}}],[\"启动客户端代理\",{\"1\":{\"568\":1,\"643\":1}}],[\"启动重平衡线程\",{\"1\":{\"640\":1,\"643\":1}}],[\"启动重平衡\",{\"1\":{\"638\":1}}],[\"启动命令也是在\",{\"1\":{\"632\":1}}],[\"启动带\",{\"0\":{\"604\":1}}],[\"启动单节点\",{\"0\":{\"603\":1}}],[\"启动参数的环境变量\",{\"1\":{\"600\":1}}],[\"启动后马上向\",{\"1\":{\"567\":1}}],[\"启动后浏览器打开\",{\"1\":{\"123\":1}}],[\"启动流程的示意图\",{\"1\":{\"467\":1}}],[\"启动了一个新的工作线程\",{\"1\":{\"435\":1}}],[\"启动定时任务\",{\"1\":{\"557\":1,\"568\":1,\"640\":1,\"643\":1}}],[\"启动定时任务执行的\",{\"1\":{\"372\":1}}],[\"启动定时清理过期文件线程\",{\"1\":{\"389\":1}}],[\"启动时启动定时任务\",{\"1\":{\"711\":1}}],[\"启动时也会启动定时任务\",{\"1\":{\"703\":1}}],[\"启动时创建\",{\"1\":{\"559\":1,\"711\":1}}],[\"启动时会由\",{\"1\":{\"510\":1,\"516\":1}}],[\"启动时会自动创建\",{\"1\":{\"356\":1}}],[\"启动时的一些默认\",{\"1\":{\"490\":1}}],[\"启动时调用\",{\"1\":{\"389\":1}}],[\"启动时运行\",{\"1\":{\"360\":1}}],[\"启动时\",{\"1\":{\"354\":1,\"711\":1}}],[\"启动一个\",{\"1\":{\"598\":1}}],[\"启动一个定时任务线程\",{\"1\":{\"465\":1}}],[\"启动一个新的定时任务\",{\"1\":{\"452\":1}}],[\"启动一个新的进程使用`spawn`函数\",{\"1\":{\"80\":1}}],[\"启动一个线程将前一个写满的文件异步刷盘\",{\"1\":{\"313\":1}}],[\"启动\",{\"0\":{\"467\":1,\"479\":1,\"481\":1,\"594\":1,\"596\":1,\"598\":1,\"599\":1,\"642\":1,\"643\":1},\"1\":{\"21\":1,\"102\":1,\"467\":1,\"480\":2,\"557\":4,\"567\":1,\"589\":1,\"596\":1,\"600\":1}}],[\"抛出异常\",{\"1\":{\"570\":1}}],[\"汇报心跳给broker\",{\"1\":{\"568\":1}}],[\"清除离线的broker\",{\"1\":{\"568\":1}}],[\"清理的策略一般是\",{\"1\":{\"399\":1}}],[\"清理的条件比较多\",{\"1\":{\"390\":1}}],[\"清理\",{\"1\":{\"389\":2,\"391\":1,\"392\":2}}],[\"头\",{\"1\":{\"562\":1}}],[\"压缩\",{\"1\":{\"562\":1,\"573\":1}}],[\"压力\",{\"1\":{\"255\":1}}],[\"规避策略只在当前消息发送失败重试时失效\",{\"1\":{\"754\":1}}],[\"规避注册过不可用的\",{\"1\":{\"572\":1}}],[\"规避上次发送的\",{\"1\":{\"572\":1}}],[\"规避时间将越来越长\",{\"1\":{\"561\":1}}],[\"规避和故障延迟机制\",{\"1\":{\"561\":1}}],[\"降低网络传输次数\",{\"1\":{\"548\":1}}],[\"视\",{\"1\":{\"548\":1}}],[\"配合一些重试和补偿机制\",{\"1\":{\"547\":1}}],[\"配置开启时才创建位数组\",{\"1\":{\"851\":1}}],[\"配置为\",{\"1\":{\"842\":1}}],[\"配置建议\",{\"1\":{\"753\":1,\"754\":1,\"755\":1,\"760\":1}}],[\"配置中的\",{\"1\":{\"600\":1}}],[\"配置而变\",{\"1\":{\"548\":1}}],[\"配置规则加载到内存\",{\"1\":{\"518\":1}}],[\"配置用户名和密码\",{\"1\":{\"504\":1,\"505\":1}}],[\"配置文件路径\",{\"1\":{\"599\":1}}],[\"配置文件版本号表\",{\"1\":{\"517\":1}}],[\"配置文件和全局白名单的映射关系\",{\"1\":{\"517\":1}}],[\"配置文件的数量发生变化\",{\"1\":{\"519\":1}}],[\"配置文件的全局白名单\",{\"1\":{\"517\":1}}],[\"配置文件的映射关系\",{\"1\":{\"517\":1}}],[\"配置文件\",{\"1\":{\"500\":1,\"517\":1,\"518\":3}}],[\"配置信息发生变化或第一次注册才会更新\",{\"1\":{\"491\":1}}],[\"配置的机房名\",{\"1\":{\"658\":1}}],[\"配置的\",{\"1\":{\"595\":1}}],[\"配置的版本号\",{\"1\":{\"472\":1}}],[\"配置的操作是修改\",{\"1\":{\"472\":1}}],[\"配置项\",{\"1\":{\"307\":2,\"309\":1}}],[\"配置参数\",{\"0\":{\"189\":1},\"1\":{\"480\":2}}],[\"配置完\",{\"1\":{\"188\":1}}],[\"配置方法\",{\"0\":{\"184\":1}}],[\"配置镜像队列规则后\",{\"1\":{\"182\":1}}],[\"配置\",{\"0\":{\"510\":1,\"516\":1},\"1\":{\"163\":1,\"171\":2,\"467\":2,\"472\":1,\"480\":1,\"481\":3,\"490\":1,\"506\":1,\"518\":1,\"595\":1}}],[\"流程详解\",{\"0\":{\"644\":1,\"666\":1,\"696\":1,\"722\":1},\"1\":{\"884\":4}}],[\"流量较大的场景下\",{\"1\":{\"547\":1}}],[\"流控和重试意味着任务暂时等待\",{\"1\":{\"451\":1}}],[\"流控\",{\"0\":{\"197\":1,\"453\":1},\"1\":{\"380\":2,\"690\":2}}],[\"流控详细流程\",{\"0\":{\"154\":1}}],[\"流控时发送消息被完全阻塞\",{\"1\":{\"146\":1}}],[\"流控主要是为了防止生产者生产消息速度过快\",{\"1\":{\"144\":1}}],[\"三种消息发送方式\",{\"0\":{\"547\":1}}],[\"揭秘\",{\"1\":{\"544\":1}}],[\"区别在于\",{\"1\":{\"765\":1}}],[\"区分的消息轨迹数据表\",{\"1\":{\"541\":1}}],[\"区块\",{\"1\":{\"44\":1}}],[\"收集将要消费消息的轨迹信息\",{\"1\":{\"540\":1}}],[\"收到了\",{\"1\":{\"820\":1}}],[\"收到客户端发来的持久化消费进度请求\",{\"1\":{\"721\":1}}],[\"收到客户端获取路由信息请求后\",{\"1\":{\"477\":1,\"493\":1}}],[\"收到请求后用延迟消息机制\",{\"1\":{\"700\":1}}],[\"收到请求后发送请求让其他消费者重平衡\",{\"1\":{\"648\":1}}],[\"收到请求后交给请求处理模块处理\",{\"1\":{\"326\":1}}],[\"收到拉去请求\",{\"1\":{\"639\":1}}],[\"收到消费进度先缓存到内存\",{\"1\":{\"623\":1}}],[\"收到消息就会主动推送到消费者端\",{\"1\":{\"614\":1}}],[\"收到消息后关闭订单\",{\"1\":{\"441\":1,\"871\":1}}],[\"收到消息后存储消息时调用\",{\"1\":{\"359\":1}}],[\"收到消息后\",{\"1\":{\"354\":1}}],[\"收到消息之后也要立即打印\",{\"1\":{\"108\":1}}],[\"收到消息进行处理之后立即再次调用\",{\"1\":{\"85\":1}}],[\"收到延迟消息后\",{\"1\":{\"445\":1}}],[\"收到\",{\"1\":{\"329\":1,\"334\":1}}],[\"收到的广播消息进行回调处理\",{\"1\":{\"205\":1}}],[\"收到的消息会被放入该进程的邮箱\",{\"1\":{\"79\":1}}],[\"钩子方法中采集消息轨迹数据\",{\"0\":{\"540\":1}}],[\"钩子函数的\",{\"1\":{\"501\":1}}],[\"钩子函数\",{\"1\":{\"480\":1,\"573\":1}}],[\"轨迹类型\",{\"1\":{\"537\":1}}],[\"轨迹数据发送\",{\"0\":{\"535\":1}}],[\"轨迹数据采集\",{\"0\":{\"534\":1}}],[\"势必使用异步发送\",{\"1\":{\"530\":1}}],[\"势必会对性能造成非常大的损耗\",{\"1\":{\"523\":1}}],[\"势必会用到类似定时任务地机制\",{\"1\":{\"444\":1}}],[\"采集消费完成的消息轨迹数据\",{\"1\":{\"540\":1}}],[\"采集消息轨迹数据的最佳方法就是在发送和消费时在钩子函数中进行\",{\"1\":{\"534\":1}}],[\"采集每条消息的轨迹数据\",{\"1\":{\"540\":1}}],[\"采集数据并将该上下文信息交给轨迹数据异步发送线程池\",{\"1\":{\"534\":1}}],[\"采集的轨迹数据要包含哪些数据\",{\"1\":{\"530\":1}}],[\"采用\",{\"1\":{\"201\":1}}],[\"采用回车符\",{\"1\":{\"138\":1}}],[\"采用回车+换行\",{\"1\":{\"138\":1}}],[\"采用换行符\",{\"1\":{\"138\":1}}],[\"便于对消息进行高性能查询\",{\"1\":{\"526\":1}}],[\"便于在发送命令的前后拦截\",{\"1\":{\"514\":1}}],[\"互相之间几乎不影响\",{\"1\":{\"872\":1}}],[\"互相解析的性能\",{\"0\":{\"261\":1}}],[\"互不影响\",{\"1\":{\"524\":1}}],[\"扯皮\",{\"1\":{\"523\":1}}],[\"官网文档\",{\"1\":{\"521\":1}}],[\"官方提供了多语言客户端支持消息的发送和消费操作\",{\"1\":{\"544\":1}}],[\"官方将消息轨迹存储的模式分为两种\",{\"1\":{\"532\":1}}],[\"官方文档\",{\"1\":{\"404\":1,\"494\":1,\"542\":1,\"577\":1,\"622\":1,\"625\":1,\"818\":1,\"853\":1,\"868\":1}}],[\"官方推荐的使用方法是使用\",{\"1\":{\"7\":1}}],[\"官方介绍如下\",{\"1\":{\"2\":1}}],[\"监听acl配置文件变化\",{\"1\":{\"519\":1}}],[\"监听配置文件变化\",{\"1\":{\"516\":1}}],[\"变化\",{\"1\":{\"665\":1}}],[\"变化事件\",{\"1\":{\"663\":1}}],[\"变化考虑两种情况\",{\"1\":{\"519\":1}}],[\"变量含义\",{\"1\":{\"289\":1}}],[\"变量保存着每个\",{\"1\":{\"285\":1}}],[\"变量的作用域是它定义时所处的语汇单元\",{\"1\":{\"23\":1}}],[\"变量\",{\"0\":{\"23\":1}}],[\"刷新全局配置\",{\"1\":{\"518\":1}}],[\"刷盘线程会将该文件刷盘\",{\"1\":{\"313\":1}}],[\"刷盘机制\",{\"0\":{\"303\":1}}],[\"刷盘\",{\"0\":{\"272\":1,\"278\":1,\"288\":1,\"316\":1,\"864\":1},\"1\":{\"309\":1}}],[\"远程\",{\"1\":{\"517\":1}}],[\"验证队列是否丢弃\",{\"1\":{\"715\":1}}],[\"验证该消息队列是否可用\",{\"1\":{\"572\":1}}],[\"验证消息是否符合规范\",{\"1\":{\"570\":1}}],[\"验证合法性\",{\"1\":{\"570\":1}}],[\"验证是否有某资源的访问权限\",{\"1\":{\"520\":1}}],[\"验证资源访问权限\",{\"1\":{\"511\":1,\"520\":1}}],[\"验证与客户端计算的签名是否一致\",{\"1\":{\"511\":1,\"520\":1}}],[\"及时将变更加载到内存\",{\"1\":{\"510\":1,\"516\":1}}],[\"及不可用的恢复时间\",{\"1\":{\"133\":1}}],[\"排序\",{\"1\":{\"509\":1,\"515\":1,\"657\":1,\"786\":1}}],[\"排它队列\",{\"1\":{\"231\":1}}],[\"白云鹏\",{\"1\":{\"625\":1}}],[\"白名单配置\",{\"1\":{\"518\":1}}],[\"白名单\",{\"1\":{\"498\":1,\"503\":1}}],[\"白白产生\",{\"1\":{\"261\":1}}],[\"白白空转\",{\"1\":{\"253\":1}}],[\"订阅\",{\"1\":{\"810\":1,\"813\":1}}],[\"订阅多个\",{\"1\":{\"759\":1}}],[\"订阅配置不存在\",{\"1\":{\"718\":1}}],[\"订阅信息查找消息\",{\"1\":{\"693\":1}}],[\"订阅信息和重试\",{\"1\":{\"640\":1,\"642\":1}}],[\"订阅关系版本号\",{\"1\":{\"691\":1}}],[\"订阅的主题\",{\"1\":{\"637\":1}}],[\"订阅之后可以收到来自该主题的消息\",{\"1\":{\"637\":1}}],[\"订阅主题\",{\"1\":{\"637\":1}}],[\"订阅权限\",{\"1\":{\"498\":1}}],[\"订阅模型会造成更严重的写入放大\",{\"1\":{\"234\":1}}],[\"订阅模型下\",{\"1\":{\"233\":1}}],[\"拒绝提交\",{\"1\":{\"714\":2}}],[\"拒绝\",{\"1\":{\"498\":1}}],[\"含义\",{\"1\":{\"498\":1,\"503\":1}}],[\"含服务网格\",{\"1\":{\"126\":1}}],[\"密码\",{\"1\":{\"498\":1}}],[\"访问控制列表\",{\"1\":{\"516\":1}}],[\"访问控制的基本要素\",{\"1\":{\"498\":1}}],[\"访问列表头是一种非常高效的操作\",{\"1\":{\"27\":1}}],[\"种方式\",{\"1\":{\"766\":1}}],[\"种消费方式\",{\"1\":{\"723\":1}}],[\"种消费者实现\",{\"1\":{\"656\":1}}],[\"种消息发送方式\",{\"1\":{\"547\":1}}],[\"种发送方式\",{\"1\":{\"545\":1}}],[\"种作用域\",{\"1\":{\"498\":1}}],[\"种\",{\"1\":{\"498\":1}}],[\"种概念\",{\"1\":{\"498\":1}}],[\"种类\",{\"0\":{\"165\":1}}],[\"段进行白名单控制\",{\"1\":{\"496\":1}}],[\"权限映射配置表\",{\"1\":{\"517\":1}}],[\"权限验证主要逻辑都在\",{\"1\":{\"520\":1}}],[\"权限验证的逻辑在\",{\"1\":{\"511\":1}}],[\"权限验证\",{\"0\":{\"511\":1,\"520\":1},\"1\":{\"506\":1}}],[\"权限\",{\"1\":{\"496\":1,\"498\":4,\"718\":1}}],[\"权限控制\",{\"0\":{\"495\":1},\"1\":{\"521\":2,\"884\":1}}],[\"角色\",{\"1\":{\"496\":1,\"498\":2}}],[\"软件\",{\"1\":{\"496\":1}}],[\"首选需要修改一下\",{\"1\":{\"595\":1}}],[\"首次注册\",{\"1\":{\"491\":1}}],[\"首先先来根据下面这张图来观察\",{\"1\":{\"820\":1}}],[\"首先是如何采集数据\",{\"1\":{\"530\":1}}],[\"首先\",{\"1\":{\"515\":1,\"820\":1}}],[\"首先操作起来太复杂\",{\"1\":{\"462\":1}}],[\"首先分析了任意时间定时消息实现的难点\",{\"1\":{\"456\":1}}],[\"首先想到的方法是将\",{\"1\":{\"435\":1}}],[\"首先这里面有使用\",{\"1\":{\"429\":1}}],[\"首先回顾一下同步投递的逻辑\",{\"1\":{\"375\":1}}],[\"首先需要明确延迟消息与定时消息虽然意思不同\",{\"1\":{\"872\":1}}],[\"首先需要用版本号来创建一个\",{\"1\":{\"594\":1}}],[\"首先需要在\",{\"1\":{\"503\":1,\"581\":1}}],[\"首先需要找到\",{\"1\":{\"407\":1}}],[\"首先需要补充一点消费相关的前置知识\",{\"1\":{\"320\":1}}],[\"首先需要安装\",{\"1\":{\"175\":1}}],[\"首先看一下\",{\"1\":{\"305\":1}}],[\"首先看生产者消费者直接与主节点连接的情况\",{\"1\":{\"201\":1}}],[\"首先查询出这些偏移量信息\",{\"1\":{\"302\":1}}],[\"首先保存到\",{\"1\":{\"275\":1}}],[\"首先执行\",{\"1\":{\"44\":1}}],[\"构造布隆过滤器\",{\"1\":{\"850\":1}}],[\"构造成二进制数组\",{\"1\":{\"828\":1,\"835\":1}}],[\"构造成一个消息\",{\"1\":{\"779\":1}}],[\"构造新的消息\",{\"1\":{\"800\":1}}],[\"构造锁定消息队列请求\",{\"1\":{\"746\":1}}],[\"构造多个消费请求提交消费\",{\"1\":{\"714\":1}}],[\"构造消费请求\",{\"1\":{\"714\":1}}],[\"构造消息拉取系统标记\",{\"1\":{\"679\":1}}],[\"构造一个用于存到磁盘的消息\",{\"1\":{\"780\":1}}],[\"构造一个消息队列的消费进度更新请求\",{\"1\":{\"711\":1}}],[\"构造一个pullrequest并交给pullrequestholdservice线程\",{\"1\":{\"693\":1}}],[\"构造查询请求\",{\"1\":{\"680\":1}}],[\"构造存储用的message对象\",{\"1\":{\"576\":1}}],[\"构造response\",{\"1\":{\"576\":1}}],[\"构造的回调方法中指定\",{\"1\":{\"560\":1}}],[\"构造\",{\"1\":{\"557\":1,\"779\":1,\"791\":1,\"793\":1,\"839\":1}}],[\"构造统一的请求体\",{\"1\":{\"490\":1}}],[\"构建的队列除了它本身的读写队列以外\",{\"1\":{\"811\":1}}],[\"构建的项目已经写好了\",{\"1\":{\"9\":1}}],[\"构建轻量级队列\",{\"1\":{\"811\":1}}],[\"构建主题配置\",{\"1\":{\"718\":1}}],[\"构建过滤数据\",{\"1\":{\"693\":1}}],[\"构建消息过滤器\",{\"1\":{\"693\":1}}],[\"构建消息发送请求\",{\"1\":{\"573\":1}}],[\"构建消息发送请求包\",{\"1\":{\"573\":1}}],[\"构建消息请求\",{\"1\":{\"562\":1}}],[\"构建消息的dispatchrequest\",{\"1\":{\"282\":1}}],[\"构建消费后的轨迹数据\",{\"1\":{\"540\":1}}],[\"构建消费者\",{\"1\":{\"527\":1}}],[\"构建生产者\",{\"1\":{\"526\":1}}],[\"构建定时消息底座\",{\"1\":{\"443\":1}}],[\"构建索引\",{\"1\":{\"314\":1}}],[\"构建而成\",{\"1\":{\"306\":1}}],[\"构建该消息的索引\",{\"1\":{\"270\":1,\"301\":1}}],[\"构建\",{\"0\":{\"270\":1,\"276\":1,\"281\":1}}],[\"构建项目\",{\"1\":{\"7\":2}}],[\"初次请求时为空\",{\"1\":{\"490\":1}}],[\"初始的延迟为\",{\"1\":{\"700\":1}}],[\"初始延迟\",{\"1\":{\"389\":1}}],[\"初始化配置类\",{\"1\":{\"854\":1}}],[\"初始化消息消费服务\",{\"1\":{\"640\":1,\"642\":1}}],[\"初始化消费进度\",{\"1\":{\"640\":1,\"642\":1}}],[\"初始化消费者的重平衡实现\",{\"1\":{\"640\":1}}],[\"初始化时会创建\",{\"1\":{\"510\":1,\"516\":1}}],[\"初始化时会创建一个\",{\"1\":{\"354\":1}}],[\"初始化前\",{\"1\":{\"500\":1}}],[\"初始化线程池\",{\"1\":{\"481\":1}}],[\"初始化通信层\",{\"1\":{\"481\":1}}],[\"初始化的时候就设定长度呢\",{\"1\":{\"426\":1}}],[\"初始化\",{\"0\":{\"500\":1,\"510\":1,\"516\":1},\"1\":{\"347\":1,\"467\":1,\"480\":7,\"500\":1,\"506\":1,\"510\":1,\"516\":2,\"557\":1,\"642\":1,\"657\":1}}],[\"初始化数据表\",{\"1\":{\"103\":1}}],[\"初始化方法\",{\"1\":{\"9\":1,\"481\":1}}],[\"心跳的信息就包含消费者的订阅信息\",{\"1\":{\"832\":1}}],[\"心跳信息\",{\"1\":{\"491\":1}}],[\"心跳包发送的响应列表\",{\"1\":{\"490\":1}}],[\"心跳包的请求头中包含\",{\"1\":{\"472\":1}}],[\"心跳上报\",{\"1\":{\"487\":1}}],[\"名加入集群信息表\",{\"1\":{\"491\":1}}],[\"名\",{\"1\":{\"484\":1}}],[\"名称前缀必须是\",{\"1\":{\"807\":1}}],[\"名称为\",{\"1\":{\"708\":1}}],[\"名称\",{\"1\":{\"472\":1,\"572\":1,\"585\":1,\"717\":1,\"808\":1}}],[\"名称列表\",{\"1\":{\"464\":1}}],[\"名称和读写队列数量\",{\"1\":{\"464\":1}}],[\"名称过长\",{\"1\":{\"426\":1}}],[\"名称的正则匹配检查\",{\"0\":{\"424\":1}}],[\"宕机\",{\"1\":{\"474\":1}}],[\"宕机了\",{\"1\":{\"461\":1}}],[\"均每\",{\"1\":{\"465\":1}}],[\"继承了\",{\"1\":{\"464\":1}}],[\"继续下一次扫描\",{\"1\":{\"381\":1}}],[\"继续下次扫描\",{\"1\":{\"361\":1}}],[\"继续创建一个定时任务\",{\"1\":{\"365\":2,\"380\":1}}],[\"继续提供服务\",{\"1\":{\"228\":1}}],[\"地址白名单\",{\"1\":{\"498\":1}}],[\"地址表\",{\"1\":{\"491\":1}}],[\"地址列表\",{\"1\":{\"473\":1,\"491\":1}}],[\"地址\",{\"1\":{\"464\":1,\"469\":1,\"472\":1,\"485\":1,\"490\":1,\"491\":1,\"517\":1,\"549\":1,\"559\":2,\"562\":1,\"573\":1,\"597\":2,\"598\":1,\"640\":1,\"680\":1,\"683\":1,\"708\":1,\"717\":2,\"720\":1,\"746\":1}}],[\"地址生产或消费消息\",{\"1\":{\"461\":1}}],[\"划分多个zookeeper集群来解决\",{\"1\":{\"462\":1}}],[\"期望填充满\",{\"1\":{\"777\":1}}],[\"期望写入的位置应该等于被写过的位置\",{\"1\":{\"285\":1}}],[\"期间整个集群都处于不可用的状态\",{\"1\":{\"462\":1}}],[\"维护的内部缓冲区进行排队\",{\"1\":{\"820\":1}}],[\"维护和定位问题较困难\",{\"1\":{\"462\":1}}],[\"维度上加锁\",{\"1\":{\"773\":1}}],[\"维度严格的顺序\",{\"1\":{\"723\":1}}],[\"维度拉取大小流控\",{\"1\":{\"665\":1}}],[\"维度拉取流控\",{\"1\":{\"657\":1}}],[\"维度流控\",{\"1\":{\"665\":1}}],[\"维度进行重平衡\",{\"1\":{\"650\":1}}],[\"维度来保存消息在\",{\"1\":{\"397\":1}}],[\"典型的双主双从部署方式如下图所示\",{\"1\":{\"461\":1}}],[\"路由机制\",{\"0\":{\"549\":1}}],[\"路由发现\",{\"0\":{\"475\":1,\"493\":1}}],[\"路由删除逻辑如下\",{\"1\":{\"474\":1,\"492\":1}}],[\"路由删除\",{\"0\":{\"474\":1,\"492\":1}}],[\"路由注册需要加写锁\",{\"1\":{\"491\":1}}],[\"路由注册包含两个方面\",{\"1\":{\"471\":1}}],[\"路由注册\",{\"0\":{\"471\":1,\"489\":1}}],[\"路由注册中心\",{\"1\":{\"461\":1}}],[\"路由信息后\",{\"1\":{\"561\":1}}],[\"路由信息来检查消息的\",{\"1\":{\"550\":1}}],[\"路由信息\",{\"0\":{\"468\":1,\"482\":1,\"483\":1,\"559\":1},\"1\":{\"465\":1,\"470\":2,\"476\":1,\"477\":1,\"493\":1,\"550\":1,\"557\":1,\"558\":1,\"559\":4,\"573\":1,\"640\":1}}],[\"路由信息管理\",{\"1\":{\"461\":1}}],[\"路由管理模块\",{\"1\":{\"464\":1}}],[\"延长了不可见时间\",{\"1\":{\"771\":1}}],[\"延时消息\",{\"1\":{\"545\":1}}],[\"延时消息常见实现方案\",{\"1\":{\"458\":1}}],[\"延迟故障规避\",{\"0\":{\"754\":1}}],[\"延迟一段时间后再次进行消费\",{\"1\":{\"715\":1}}],[\"延迟指定时间后投递\",{\"1\":{\"708\":1}}],[\"延迟到期后该消息将被重新投递到消费者\",{\"1\":{\"700\":1}}],[\"延迟到期执行\",{\"1\":{\"365\":1}}],[\"延迟3s后拉取\",{\"1\":{\"690\":1}}],[\"延迟50ms之后重新拉取\",{\"1\":{\"690\":2}}],[\"延迟1s后再拉取\",{\"1\":{\"690\":1}}],[\"延迟时间不限\",{\"1\":{\"448\":2}}],[\"延迟时间受限\",{\"1\":{\"448\":1}}],[\"延迟时间\",{\"1\":{\"442\":2,\"444\":1}}],[\"延迟变高的原因是\",{\"1\":{\"435\":1}}],[\"延迟等级处理线程周期性扫描对应的延迟等级\",{\"1\":{\"354\":1}}],[\"延迟等级个数\",{\"1\":{\"354\":1}}],[\"延迟消息指定延迟的时间\",{\"1\":{\"872\":1}}],[\"延迟消息与定时消息\",{\"0\":{\"872\":1}}],[\"延迟消息实现的基础上\",{\"1\":{\"456\":1}}],[\"延迟消息的流程图\",{\"1\":{\"445\":2}}],[\"延迟消息的投递逻辑全部在\",{\"1\":{\"376\":1}}],[\"延迟消息处理服务启动时会在\",{\"1\":{\"377\":1}}],[\"延迟消息投递服务中维护了一个\",{\"1\":{\"377\":1}}],[\"延迟消息到期投递到\",{\"1\":{\"370\":1}}],[\"延迟消息服务启动\",{\"1\":{\"364\":1}}],[\"延迟消息每个消息的投递时间不确定\",{\"1\":{\"356\":1}}],[\"延迟消息在\",{\"1\":{\"355\":1}}],[\"延迟消息保存后\",{\"1\":{\"354\":1}}],[\"延迟消息\",{\"0\":{\"350\":1,\"369\":1},\"1\":{\"370\":1,\"440\":1,\"548\":1,\"871\":1,\"872\":2,\"884\":2}}],[\"延迟\",{\"0\":{\"237\":1},\"1\":{\"714\":2,\"873\":2}}],[\"版控制台不支持消息堆积查询\",{\"1\":{\"610\":1}}],[\"版保证每条消息至少被每台客户端消费一次\",{\"1\":{\"610\":1}}],[\"版任意时间定时消息特性\",{\"1\":{\"457\":1}}],[\"版本拉取\",{\"1\":{\"593\":1}}],[\"版本正式引入了消息轨迹功能\",{\"1\":{\"523\":1}}],[\"版本引入了\",{\"1\":{\"496\":1,\"814\":1}}],[\"版本号\",{\"1\":{\"472\":1}}],[\"版本后被废弃\",{\"1\":{\"464\":1}}],[\"版本发布\",{\"1\":{\"409\":1,\"412\":1}}],[\"版本优化\",{\"0\":{\"369\":1},\"1\":{\"872\":1,\"884\":1}}],[\"版本中的性能优化\",{\"1\":{\"437\":1}}],[\"版本中的性能优化点\",{\"1\":{\"406\":1}}],[\"版本中被引进\",{\"1\":{\"422\":1}}],[\"版本中对延迟消息的优化已经在另一篇文章中详解\",{\"1\":{\"406\":1}}],[\"版本中\",{\"1\":{\"370\":1,\"804\":1,\"819\":1,\"820\":1}}],[\"版本中新的\",{\"0\":{\"293\":1}}],[\"版本中最重要的改动那非仲裁队列\",{\"1\":{\"225\":1}}],[\"版本这个锁是\",{\"1\":{\"253\":1}}],[\"版本针对\",{\"1\":{\"240\":1}}],[\"版本问世之前\",{\"1\":{\"225\":1}}],[\"版本的启动脚本\",{\"1\":{\"594\":1}}],[\"版本的优化后不仅支持高性能异步投递\",{\"1\":{\"452\":1}}],[\"版本的优化\",{\"1\":{\"445\":1}}],[\"版本的优化做了深入分析\",{\"1\":{\"406\":1}}],[\"版本的\",{\"1\":{\"178\":1}}],[\"版本的安装\",{\"1\":{\"174\":1}}],[\"版本依赖\",{\"1\":{\"175\":1}}],[\"版本\",{\"0\":{\"174\":1,\"405\":1},\"1\":{\"175\":1,\"177\":1,\"178\":1,\"238\":1,\"406\":2,\"409\":1,\"412\":1,\"433\":1,\"592\":1,\"814\":1,\"884\":1}}],[\"版本开始\",{\"1\":{\"147\":1,\"150\":1}}],[\"万物皆消息\",{\"1\":{\"455\":1}}],[\"取而代之则是上文介绍的\",{\"1\":{\"820\":1}}],[\"取出来\",{\"1\":{\"820\":1}}],[\"取出执行一次\",{\"1\":{\"672\":1}}],[\"取出挂起的拉起请求并执行\",{\"1\":{\"336\":1}}],[\"取自\",{\"1\":{\"537\":1}}],[\"取值\",{\"1\":{\"503\":1}}],[\"取每个\",{\"1\":{\"474\":1}}],[\"取消订阅\",{\"1\":{\"637\":1}}],[\"取消息\",{\"1\":{\"581\":2}}],[\"取消消息\",{\"1\":{\"455\":1}}],[\"取消功能的难度没有那么大\",{\"1\":{\"455\":1}}],[\"反悔\",{\"1\":{\"455\":1}}],[\"反压效率\",{\"1\":{\"128\":1}}],[\"跳出该投递任务\",{\"1\":{\"453\":1}}],[\"跳过拉取\",{\"1\":{\"744\":1}}],[\"跳过\",{\"1\":{\"381\":1,\"799\":1}}],[\"扫描已经完成的\",{\"1\":{\"797\":1}}],[\"扫描内存中的\",{\"1\":{\"797\":1}}],[\"扫描一次\",{\"1\":{\"481\":1}}],[\"扫描\",{\"1\":{\"465\":1,\"467\":1,\"481\":1}}],[\"扫描投递任务的状态\",{\"1\":{\"453\":1}}],[\"扫描消息并且检查是否到投递时间的主要逻辑都在这个函数里面\",{\"1\":{\"361\":1}}],[\"限制每个投递任务投递的消息量即可\",{\"1\":{\"452\":1}}],[\"繁忙\",{\"1\":{\"451\":1}}],[\"箭头按顺时针方向以固定频率移动\",{\"1\":{\"451\":1}}],[\"拿到一个索引项后从中获取定时消息存储位置\",{\"1\":{\"450\":1}}],[\"借鉴这个方法\",{\"1\":{\"452\":1}}],[\"借鉴之前索引文件的涉及\",{\"1\":{\"448\":1}}],[\"借鉴了\",{\"1\":{\"394\":1}}],[\"侵入小\",{\"1\":{\"448\":1}}],[\"易于管理\",{\"1\":{\"448\":1}}],[\"易失\",{\"1\":{\"97\":1}}],[\"怎么理解内存中的buffer和cache\",{\"1\":{\"858\":1}}],[\"怎么办\",{\"1\":{\"447\":1}}],[\"怎么提高效率\",{\"1\":{\"2\":1}}],[\"回调\",{\"1\":{\"663\":1}}],[\"回调关闭订单的方法\",{\"1\":{\"441\":1,\"871\":1}}],[\"回想\",{\"1\":{\"447\":1}}],[\"想要摆脱消息默认过期时间的限制\",{\"1\":{\"448\":1}}],[\"想要实现任意时间的定时消息\",{\"1\":{\"446\":1}}],[\"想要优化性能\",{\"1\":{\"407\":1}}],[\"站在开源\",{\"1\":{\"445\":1}}],[\"站在巨人的肩膀上\",{\"0\":{\"445\":1}}],[\"日志\",{\"1\":{\"599\":1}}],[\"日志的打印可能会占用较多\",{\"1\":{\"242\":1}}],[\"日益增长的客户诉求促使我们探究任意时间定时消息的实现\",{\"1\":{\"445\":1}}],[\"绕过排序\",{\"1\":{\"445\":1}}],[\"决定了在服务端对消息进行排序是完全不可接受的\",{\"1\":{\"445\":1}}],[\"√\",{\"1\":{\"442\":1}}],[\"年久失修\",{\"1\":{\"593\":1}}],[\"年\",{\"1\":{\"442\":1,\"457\":1}}],[\"年的消息\",{\"1\":{\"448\":1}}],[\"年的延迟消息\",{\"1\":{\"442\":1}}],[\"年的\",{\"1\":{\"406\":1}}],[\"华为云已经上线分布式消息服务\",{\"1\":{\"457\":1}}],[\"华为云\",{\"0\":{\"457\":1},\"1\":{\"442\":1}}],[\"华为云中间件可靠性技术专家\",{\"1\":{\"136\":1}}],[\"华为云中间件消息产品家族也是唯一一个全面通过验收标准的厂商\",{\"1\":{\"136\":1}}],[\"腾讯云\",{\"1\":{\"442\":1}}],[\"天的消息可能会被老化清除\",{\"1\":{\"877\":1}}],[\"天过期清除\",{\"1\":{\"444\":1}}],[\"天\",{\"1\":{\"442\":1,\"877\":1}}],[\"天池中间件大赛百万队列存储设计总结\",{\"1\":{\"16\":1}}],[\"阿里云\",{\"1\":{\"442\":1}}],[\"普通重平衡\",{\"1\":{\"786\":1}}],[\"普通消息默认重试\",{\"1\":{\"761\":1}}],[\"普通消息可以由客户端并发发送\",{\"1\":{\"548\":1}}],[\"普通消息\",{\"1\":{\"548\":1,\"793\":1}}],[\"普通消息性能\",{\"1\":{\"442\":3}}],[\"普通模式即集群中每个\",{\"1\":{\"532\":1}}],[\"普通模式和物理\",{\"1\":{\"532\":1}}],[\"普通用户\",{\"1\":{\"498\":1}}],[\"普通队列使用\",{\"1\":{\"233\":1}}],[\"普通队列\",{\"0\":{\"233\":1}}],[\"普通队列结构\",{\"0\":{\"204\":1}}],[\"×\",{\"1\":{\"442\":10}}],[\"精度\",{\"1\":{\"442\":1,\"444\":1}}],[\"精确到秒\",{\"1\":{\"307\":1}}],[\"功能时必须用\",{\"1\":{\"507\":1}}],[\"功能领先所有开源消息队列和云化消息队列\",{\"1\":{\"442\":1}}],[\"功能\",{\"1\":{\"442\":1,\"503\":1,\"587\":1}}],[\"功能在\",{\"1\":{\"422\":1}}],[\"客户下单后并不会马上付款\",{\"1\":{\"441\":1,\"871\":1}}],[\"客户端过滤\",{\"0\":{\"848\":1}}],[\"客户端之后\",{\"1\":{\"827\":1}}],[\"客户端的重平衡服务重平衡时会向\",{\"1\":{\"775\":1}}],[\"客户端只需要不断发送\",{\"1\":{\"770\":1}}],[\"客户端只会获取它生产或者消费的\",{\"1\":{\"476\":1}}],[\"客户端代码逻辑较重\",{\"1\":{\"769\":1}}],[\"客户端代码中消费者相关的类图\",{\"1\":{\"629\":1}}],[\"客户端消费进度管理器持久化消费进度\",{\"0\":{\"720\":1}}],[\"客户端自动决定延迟等级\",{\"1\":{\"718\":1}}],[\"客户端要再次对消息进行了过滤\",{\"1\":{\"695\":1,\"749\":1}}],[\"客户端是否提交了消费进度\",{\"1\":{\"693\":1}}],[\"客户端处理返回的消息\",{\"1\":{\"676\":1}}],[\"客户端拉取超时\",{\"1\":{\"691\":1}}],[\"客户端拉取流程设计\",{\"0\":{\"670\":1}}],[\"客户端拉取路由信息\",{\"0\":{\"475\":1}}],[\"客户端实例启动时的定时任务每\",{\"1\":{\"703\":1}}],[\"客户端实例启动时会启动定时任务\",{\"1\":{\"702\":1}}],[\"客户端实例中的所有推模式消费者共用这个拉取线程\",{\"1\":{\"672\":1}}],[\"客户端实例中的重平衡服务进行重平衡\",{\"1\":{\"639\":1}}],[\"客户端实例包含一个消息拉取线程\",{\"1\":{\"672\":1}}],[\"客户端实例的该方法没有具体逻辑\",{\"1\":{\"657\":1}}],[\"客户端实例持有\",{\"1\":{\"649\":1}}],[\"客户端实例\",{\"1\":{\"638\":1,\"640\":1,\"711\":1}}],[\"客户端设计和启动流程详解\",{\"0\":{\"626\":1},\"1\":{\"884\":1}}],[\"客户端就是基于\",{\"1\":{\"615\":1}}],[\"客户端逻辑比较重\",{\"1\":{\"615\":1}}],[\"客户端每一次重启都会从最新消息消费\",{\"1\":{\"610\":1}}],[\"客户端去连接会发现连不上\",{\"1\":{\"595\":1}}],[\"客户端提供了丰富的消息发送\",{\"1\":{\"545\":1}}],[\"客户端做的是向\",{\"1\":{\"544\":1}}],[\"客户端采集到的轨迹上下文提交给线程池处理\",{\"1\":{\"541\":1}}],[\"客户端使用\",{\"1\":{\"507\":1}}],[\"客户端发送请求\",{\"1\":{\"501\":1}}],[\"客户端发起消息消费请求\",{\"1\":{\"277\":1,\"286\":1}}],[\"客户端初始化时注册该\",{\"1\":{\"500\":1}}],[\"客户端初始化\",{\"1\":{\"500\":1}}],[\"客户端需要标明每个请求的用户\",{\"1\":{\"499\":1}}],[\"客户端需要自己定时从\",{\"1\":{\"475\":1}}],[\"客户端路由信息\",{\"0\":{\"488\":1}}],[\"客户端中注册定时任务的方法是\",{\"1\":{\"476\":1}}],[\"客户端中会启动一个定时任务\",{\"1\":{\"475\":1}}],[\"客户端中的路由信息保存在\",{\"1\":{\"470\":1}}],[\"客户端保存的路由信息\",{\"0\":{\"470\":1}}],[\"客户端在被停止期间发送至服务端的消息将会被自动跳过\",{\"1\":{\"610\":1}}],[\"客户端在发送消息时会调用\",{\"1\":{\"422\":1}}],[\"客户端在面对etcd内部错误时\",{\"1\":{\"134\":1}}],[\"客户端请求需要的资源权限\",{\"1\":{\"520\":1}}],[\"客户端请求路由信息\",{\"0\":{\"476\":1}}],[\"客户端请求\",{\"1\":{\"342\":1}}],[\"客户端不需要改变它们生产和订阅的方法\",{\"1\":{\"229\":1}}],[\"客户端连接从节点\",{\"0\":{\"202\":1}}],[\"客户端连接主节点\",{\"0\":{\"201\":1}}],[\"客户端才会收到\",{\"1\":{\"196\":1}}],[\"客户端\",{\"0\":{\"80\":1,\"507\":1,\"513\":1,\"772\":1},\"1\":{\"228\":1,\"461\":1,\"498\":1,\"499\":1,\"506\":1,\"537\":1,\"742\":1,\"755\":1}}],[\"网约车资源\",{\"1\":{\"441\":1,\"871\":1}}],[\"网约车等业务中都会出现的订单场景\",{\"1\":{\"441\":1,\"871\":1}}],[\"网络配置\",{\"1\":{\"480\":1}}],[\"网络上的很多资料都指向一个方案\",{\"1\":{\"451\":1}}],[\"网络通信时都会用到\",{\"1\":{\"410\":1}}],[\"网络通道\",{\"1\":{\"339\":1,\"693\":1}}],[\"网络异常后两个节点交互决策\",{\"1\":{\"192\":1}}],[\"网络可以通过\",{\"1\":{\"168\":1}}],[\"网络分区导致的脑裂等问题做定制检测\",{\"1\":{\"132\":1}}],[\"顶级开源分布式高可用消息队列\",{\"1\":{\"439\":1}}],[\"顶级java才懂的\",{\"1\":{\"15\":1}}],[\"换来的是消费性能大幅提升\",{\"1\":{\"436\":1}}],[\"换句话说\",{\"1\":{\"190\":1}}],[\"造成多线程情况下可能会等待直到超时\",{\"1\":{\"435\":1}}],[\"工作线程用一个死循环\",{\"1\":{\"541\":1}}],[\"工作线程\",{\"1\":{\"541\":1}}],[\"工作线程每次消费一批轨迹数据\",{\"1\":{\"535\":1}}],[\"工作线程每次从队列中\",{\"1\":{\"435\":1}}],[\"工作线程的\",{\"1\":{\"435\":1}}],[\"拼接的逻辑\",{\"1\":{\"429\":1}}],[\"拼接和处理方法\",{\"1\":{\"416\":1}}],[\"寻址间距短\",{\"1\":{\"424\":1}}],[\"寻找优化点\",{\"0\":{\"410\":1,\"416\":1,\"419\":1,\"422\":1,\"428\":1,\"431\":1,\"434\":1}}],[\"寻找java中string\",{\"1\":{\"263\":1}}],[\"释放和申请\",{\"1\":{\"739\":1}}],[\"释放\",{\"1\":{\"738\":1}}],[\"释放锁\",{\"1\":{\"729\":1}}],[\"释放写锁\",{\"1\":{\"473\":1,\"474\":1,\"491\":1,\"492\":1}}],[\"释放时只需要通过移动栈顶指针\",{\"1\":{\"424\":1}}],[\"释放磁盘空间\",{\"1\":{\"383\":1}}],[\"栈无需释放内存和进行随机寻址\",{\"1\":{\"424\":1}}],[\"栈没有碎片\",{\"1\":{\"424\":1}}],[\"栈操作可以被\",{\"1\":{\"424\":1}}],[\"栈上分配的数据\",{\"1\":{\"424\":1}}],[\"栈上存储的数据\",{\"1\":{\"424\":1}}],[\"栈跟踪\",{\"0\":{\"47\":1}}],[\"范围内\",{\"1\":{\"424\":1}}],[\"匹配和重试完成后\",{\"1\":{\"799\":1}}],[\"匹配和消息重试\",{\"0\":{\"783\":1}}],[\"匹配消费到的一批\",{\"1\":{\"799\":1}}],[\"匹配对象\",{\"1\":{\"798\":1}}],[\"匹配\",{\"0\":{\"781\":1,\"794\":1},\"1\":{\"779\":1,\"782\":1,\"796\":1,\"798\":3}}],[\"匹配规则很简单\",{\"1\":{\"424\":1}}],[\"匹配之前创建的镜像策略\",{\"1\":{\"188\":1}}],[\"左右\",{\"1\":{\"437\":1,\"447\":1}}],[\"左右的总耗时\",{\"1\":{\"416\":1}}],[\"左边\",{\"1\":{\"676\":1}}],[\"左边是定时消息到期投递线程\",{\"1\":{\"376\":1}}],[\"左边其实是一个通用的解码方法\",{\"1\":{\"262\":1}}],[\"少了一次拷贝\",{\"1\":{\"414\":1}}],[\"少一次内存拷贝\",{\"1\":{\"414\":1}}],[\"说的不是操作系统层面上的零拷贝\",{\"1\":{\"414\":1}}],[\"说明消息的\",{\"1\":{\"834\":1}}],[\"说明处理队列为空\",{\"1\":{\"750\":1}}],[\"说明该消费组不支持重试\",{\"1\":{\"718\":1}}],[\"说明该文件在不久的将来要被访问\",{\"1\":{\"402\":1}}],[\"说明consumer设置了标志位\",{\"1\":{\"693\":1}}],[\"说明是首次调用\",{\"1\":{\"693\":1}}],[\"说明是重复写入\",{\"1\":{\"285\":1}}],[\"说明了当今企业对消息队列定时消息能力的强烈需求和当下主流消息队列对定时消息能力支持不完美现状\",{\"1\":{\"456\":1}}],[\"说明不需要删除任何文件\",{\"1\":{\"392\":1}}],[\"说明有新的消息可以被拉取\",{\"1\":{\"345\":2}}],[\"说明也有新消息到达\",{\"1\":{\"332\":1}}],[\"说明需要创建新的索引文件\",{\"1\":{\"317\":1}}],[\"说明当前存储单元有效\",{\"1\":{\"291\":1}}],[\"说明这个消息重复生成consumequeue\",{\"1\":{\"285\":1}}],[\"说明\",{\"1\":{\"191\":1,\"192\":1,\"193\":1,\"828\":2}}],[\"说明它们最近处于流控状态\",{\"1\":{\"155\":1}}],[\"月底\",{\"1\":{\"406\":1}}],[\"架构设计\",{\"1\":{\"494\":1}}],[\"架构设计与实现原理\",{\"1\":{\"404\":1}}],[\"架构与案例分析\",{\"0\":{\"129\":1}}],[\"缺乏观测手段\",{\"1\":{\"523\":1}}],[\"缺点则是只能判断出元素大概率存在集合中\",{\"1\":{\"842\":1}}],[\"缺点\",{\"1\":{\"403\":1,\"448\":1}}],[\"缺少统一的框架标准\",{\"1\":{\"127\":1}}],[\"速度才更快\",{\"1\":{\"437\":1}}],[\"速度更快且更稳定\",{\"1\":{\"437\":1}}],[\"速度相较于写文件对应的\",{\"1\":{\"403\":1}}],[\"速度慢于\",{\"1\":{\"97\":1}}],[\"容器\",{\"1\":{\"595\":1}}],[\"容易想到使用一个单独的线程来处理投递逻辑\",{\"1\":{\"450\":1}}],[\"容易出现繁忙\",{\"1\":{\"403\":1}}],[\"容量为\",{\"1\":{\"447\":1}}],[\"容量和时间跨度\",{\"1\":{\"447\":1}}],[\"容错和分布式的应用程序\",{\"1\":{\"112\":1}}],[\"希望能将这些页面都锁定在物理内存中\",{\"1\":{\"402\":1}}],[\"希望能够推动这一领域的标准诞生\",{\"1\":{\"126\":1}}],[\"空间\",{\"1\":{\"402\":1}}],[\"锁容器读写锁\",{\"1\":{\"742\":1}}],[\"锁管理器将锁创建后放入锁容器\",{\"1\":{\"734\":1}}],[\"锁的容器是两层\",{\"1\":{\"732\":1}}],[\"锁定\",{\"1\":{\"748\":1}}],[\"锁定消息队列\",{\"1\":{\"746\":1}}],[\"锁定处理队列失败\",{\"1\":{\"744\":1}}],[\"锁定需要锁定的队列\",{\"1\":{\"742\":1}}],[\"锁定成功的消息队列\",{\"1\":{\"742\":1}}],[\"锁定队列和消费者的关系\",{\"1\":{\"622\":1}}],[\"锁定该文件的\",{\"1\":{\"402\":1}}],[\"锁\",{\"1\":{\"622\":1}}],[\"锁内的操作尽量移动到锁外进行\",{\"1\":{\"437\":1}}],[\"锁内操作\",{\"0\":{\"256\":1}}],[\"防止丢失pullrequest\",{\"1\":{\"690\":1}}],[\"防止请求数据被篡改\",{\"1\":{\"509\":1}}],[\"防止并发修改\",{\"1\":{\"491\":1}}],[\"防止其被交换到\",{\"1\":{\"402\":1}}],[\"防止被放入swap分区\",{\"1\":{\"402\":1}}],[\"防止在写入消息时发生缺页异常\",{\"1\":{\"402\":1}}],[\"防止在消息写入的过程中分配文件\",{\"1\":{\"401\":1}}],[\"阻止操作系统将相关的内存页调度到交换空间\",{\"1\":{\"402\":1}}],[\"阻塞队列\",{\"1\":{\"688\":1}}],[\"阻塞队列的大小可以配置\",{\"1\":{\"375\":1}}],[\"阻塞该延迟等级的消息投递\",{\"1\":{\"380\":1}}],[\"阻塞\",{\"1\":{\"380\":2,\"790\":1}}],[\"阻塞当前延迟等级对应的线程\",{\"1\":{\"374\":1}}],[\"映射的监听\",{\"1\":{\"595\":1}}],[\"映射\",{\"1\":{\"402\":1}}],[\"映射组在比较时首先会比大小\",{\"1\":{\"42\":1}}],[\"映射组在系统内部是作为有序集合存储的\",{\"1\":{\"42\":1}}],[\"起了一个后台线程\",{\"1\":{\"401\":1}}],[\"起始的时候\",{\"1\":{\"126\":1}}],[\"充分利用了\",{\"1\":{\"399\":1}}],[\"虽然是随机读\",{\"1\":{\"398\":1}}],[\"虽然这种场景出现的可能性较小\",{\"1\":{\"236\":1}}],[\"完整消息内容\",{\"1\":{\"838\":1}}],[\"完后解锁\",{\"1\":{\"790\":1}}],[\"完全关闭之前\",{\"1\":{\"480\":1}}],[\"完全是顺序写\",{\"1\":{\"397\":1}}],[\"完成请求体解析和一些参数和权限的校验\",{\"1\":{\"777\":1}}],[\"完成\",{\"1\":{\"651\":1,\"777\":1,\"782\":1,\"783\":1}}],[\"完成消息轨迹的保存\",{\"1\":{\"531\":1}}],[\"完成消息的存储和持久化工作\",{\"1\":{\"222\":1}}],[\"完成消息的存储以及可能的持久化工作等\",{\"1\":{\"204\":1}}],[\"完成了大量预操作\",{\"1\":{\"257\":1}}],[\"完成后它会交换这两个\",{\"1\":{\"244\":1}}],[\"页缓存\",{\"0\":{\"399\":1}}],[\"页缓存等方案加速了\",{\"1\":{\"394\":1}}],[\"页缓存可能会繁忙\",{\"1\":{\"374\":1}}],[\"拥有金融级别稳定性的高性能消息队列\",{\"1\":{\"860\":1}}],[\"拥有强大的消息过滤能力\",{\"1\":{\"823\":1}}],[\"拥有重试机制和死信机制来保证消息消费的可靠性\",{\"1\":{\"620\":1}}],[\"拥有了不错的性能\",{\"1\":{\"445\":1}}],[\"拥有接近\",{\"1\":{\"394\":1}}],[\"拥有该进程字典的进程会被阻塞\",{\"1\":{\"157\":1}}],[\"金融级稳定的高性能消息队列\",{\"1\":{\"394\":1}}],[\"偏移量非法\",{\"1\":{\"695\":1}}],[\"偏移量提交计算\",{\"1\":{\"690\":1}}],[\"偏移量\",{\"0\":{\"816\":1},\"1\":{\"392\":1,\"689\":1}}],[\"真正删除文件是调用了\",{\"1\":{\"390\":1}}],[\"危险情况\",{\"1\":{\"390\":1}}],[\"手工删除文件\",{\"1\":{\"390\":1}}],[\"手动删除是否被触发\",{\"1\":{\"390\":1}}],[\"手动删除\",{\"1\":{\"386\":1}}],[\"且会通过调用业务\",{\"1\":{\"820\":1}}],[\"且它的位置在堆外内存\",{\"1\":{\"820\":1}}],[\"且之前没有拉取过重试消息\",{\"1\":{\"777\":1}}],[\"且消费时长大于\",{\"1\":{\"745\":1}}],[\"且消费者\",{\"1\":{\"615\":1}}],[\"且消费逻辑一致\",{\"1\":{\"609\":1}}],[\"且用户是管理员\",{\"1\":{\"520\":1}}],[\"且具备很高的可靠程度\",{\"1\":{\"462\":1}}],[\"且实现了流控和投递失败的重投\",{\"1\":{\"452\":1}}],[\"且对性能和延迟的要求\",{\"1\":{\"445\":1}}],[\"且延迟精度能够达到\",{\"1\":{\"442\":1}}],[\"且删除分\",{\"1\":{\"390\":1}}],[\"且方便扩展\",{\"1\":{\"293\":1}}],[\"满足的是\",{\"1\":{\"462\":1}}],[\"满足下列条件之一将继续删除\",{\"1\":{\"390\":1}}],[\"满足\",{\"1\":{\"390\":1}}],[\"满足使用前提\",{\"1\":{\"169\":1}}],[\"触发消费进度管理器的持久化方法\",{\"1\":{\"711\":1}}],[\"触发流控\",{\"1\":{\"690\":3}}],[\"触发点\",{\"1\":{\"656\":1}}],[\"触发一次重平衡\",{\"1\":{\"648\":1}}],[\"触发方式分主动触发和定时触发\",{\"1\":{\"648\":1}}],[\"触发上报\",{\"1\":{\"472\":1}}],[\"触发则会设manualdeletefileseveraltimes为20\",{\"1\":{\"390\":1}}],[\"触发\",{\"1\":{\"390\":1}}],[\"机器的时间\",{\"1\":{\"386\":1}}],[\"机器时间的\",{\"1\":{\"386\":1}}],[\"机制\",{\"1\":{\"80\":1,\"403\":1,\"510\":1,\"516\":1}}],[\"正常消费\",{\"1\":{\"620\":1}}],[\"正常关闭\",{\"1\":{\"474\":1}}],[\"正如其名字\",{\"1\":{\"463\":1}}],[\"正在投递\",{\"1\":{\"381\":1}}],[\"正则表达式\",{\"1\":{\"185\":1}}],[\"​\",{\"1\":{\"372\":1}}],[\"出的消息的相对偏移量\",{\"1\":{\"779\":1}}],[\"出一条消息后\",{\"1\":{\"771\":1}}],[\"出问题\",{\"1\":{\"403\":1}}],[\"出处\",{\"1\":{\"372\":1}}],[\"出现重复消费的概率稍大于集群模式\",{\"1\":{\"610\":1}}],[\"出现数据丢失可能会导致出现严重后果\",{\"1\":{\"192\":1}}],[\"出现了性能瓶颈\",{\"1\":{\"155\":1}}],[\"社区在讨论什么\",{\"1\":{\"883\":1}}],[\"社区有一个pr\",{\"1\":{\"368\":1}}],[\"社区已经提出这个错误\",{\"1\":{\"306\":1}}],[\"云原生化的要求催生着一种能够解决这些痛点的新消费模式诞生\",{\"1\":{\"769\":1}}],[\"云原生分布式架构的演进正在朝着组装式架构\",{\"1\":{\"127\":1}}],[\"云服务竞争力体现\",{\"1\":{\"367\":1}}],[\"投递时间戳\",{\"1\":{\"880\":1}}],[\"投递时间点\",{\"1\":{\"365\":1,\"380\":1}}],[\"投递请求\",{\"1\":{\"817\":1}}],[\"投递\",{\"1\":{\"773\":1}}],[\"投递任务状态更新线程\",{\"1\":{\"453\":1}}],[\"投递任务未能放入队列\",{\"1\":{\"375\":1}}],[\"投递不完则到下个任务继续投\",{\"1\":{\"452\":1}}],[\"投递这\",{\"1\":{\"452\":1}}],[\"投递一条消息的逻辑很简单\",{\"1\":{\"450\":1}}],[\"投递线程\",{\"1\":{\"450\":1}}],[\"投递即在定时消息到期后把消息重新投递到\",{\"1\":{\"450\":1}}],[\"投递前永不删除\",{\"1\":{\"448\":1}}],[\"投递的时候再查出来\",{\"1\":{\"880\":1}}],[\"投递的偏移量之前的文件\",{\"1\":{\"384\":1}}],[\"投递的过程被放入阻塞队列\",{\"1\":{\"377\":1}}],[\"投递出错\",{\"1\":{\"381\":1}}],[\"投递异常等原因\",{\"1\":{\"380\":1}}],[\"投递过程状态更新线程\",{\"0\":{\"378\":1}}],[\"投递逻辑\",{\"1\":{\"375\":1}}],[\"投递失败则继续重试\",{\"1\":{\"375\":1}}],[\"投递失败\",{\"1\":{\"365\":1,\"380\":1}}],[\"投递成功则更新\",{\"1\":{\"375\":1,\"378\":1}}],[\"投递成功后更新该等级对应的\",{\"1\":{\"375\":1}}],[\"投递成功\",{\"1\":{\"365\":1}}],[\"投递消息时只需要借助索引文件就可以查找所有该时刻需要投递的消息\",{\"1\":{\"447\":1}}],[\"投递消息\",{\"1\":{\"222\":1,\"365\":2,\"380\":1}}],[\"跟不上\",{\"1\":{\"430\":1}}],[\"跟现在的时间戳比较\",{\"1\":{\"365\":1}}],[\"跟踪事件本身是通过调用\",{\"1\":{\"111\":1}}],[\"跟踪垃圾收集何时进行\",{\"1\":{\"111\":1}}],[\"跟踪所有正在发送的消息\",{\"1\":{\"111\":1}}],[\"跟踪消息与进程执行\",{\"0\":{\"111\":1}}],[\"替换内容中的版本号\",{\"1\":{\"594\":1}}],[\"替换原来的\",{\"1\":{\"414\":1,\"420\":1}}],[\"替换\",{\"1\":{\"414\":1}}],[\"替换消息的topic和queueid为定时消息topic和延迟等级对应的queueid\",{\"1\":{\"363\":1}}],[\"替换成定时消息对应的\",{\"1\":{\"356\":1,\"359\":1,\"363\":1}}],[\"位点管理\",{\"1\":{\"769\":1}}],[\"位数\",{\"1\":{\"426\":1}}],[\"位的\",{\"1\":{\"414\":1}}],[\"位\",{\"1\":{\"414\":1}}],[\"位置之前的消息都是消费成功的\",{\"1\":{\"715\":1}}],[\"位置\",{\"1\":{\"359\":1}}],[\"位串\",{\"1\":{\"34\":1}}],[\"位串生成器或过滤器\",{\"1\":{\"34\":1}}],[\"专门的重试\",{\"1\":{\"771\":1}}],[\"专门用来保存还没有到投递时间的定时消息\",{\"1\":{\"356\":1}}],[\"专门存放延迟消息\",{\"1\":{\"354\":1}}],[\"专业\",{\"1\":{\"2\":1}}],[\"截至目前版本\",{\"1\":{\"353\":1}}],[\"截屏2021\",{\"1\":{\"122\":1}}],[\"二层过滤\",{\"1\":{\"852\":1}}],[\"二进制数组会存到扩展存储中\",{\"1\":{\"828\":1,\"835\":1}}],[\"二进制型与位语法\",{\"0\":{\"48\":1}}],[\"二\",{\"1\":{\"349\":1}}],[\"唤醒的消息发到重试\",{\"1\":{\"800\":1}}],[\"唤醒没有被\",{\"1\":{\"800\":2}}],[\"唤醒队列\",{\"1\":{\"790\":1}}],[\"唤醒重试的时间\",{\"1\":{\"779\":1}}],[\"唤醒重平衡线程\",{\"1\":{\"640\":1,\"642\":1}}],[\"唤醒\",{\"1\":{\"773\":1}}],[\"唤醒本地的重平衡线程\",{\"1\":{\"648\":1}}],[\"唤醒长轮询的消费端请求\",{\"1\":{\"345\":1}}],[\"唤醒对应队列挂起的拉取请求\",{\"1\":{\"335\":1}}],[\"填充responseheader\",{\"1\":{\"693\":1}}],[\"填充进\",{\"1\":{\"477\":1,\"493\":1}}],[\"填充\",{\"1\":{\"477\":1,\"493\":1}}],[\"填充key和value\",{\"1\":{\"342\":1}}],[\"填充空的消息索引\",{\"1\":{\"285\":1}}],[\"响应\",{\"1\":{\"339\":1,\"693\":1}}],[\"何时需要提醒长轮询新消息已经到达\",{\"1\":{\"334\":1}}],[\"校验consumergroup配置是否可消费\",{\"1\":{\"693\":1}}],[\"校验consumergroup配置是否存在\",{\"1\":{\"693\":1}}],[\"校验\",{\"1\":{\"334\":1,\"793\":1}}],[\"校验成功则更新当前文件的最大可用偏移量\",{\"1\":{\"279\":1,\"291\":1}}],[\"线程会定时将任务从\",{\"1\":{\"820\":1}}],[\"线程阻塞等待请求队列中的拉取请求\",{\"1\":{\"639\":1}}],[\"线程的\",{\"1\":{\"639\":1}}],[\"线程关闭之前\",{\"1\":{\"467\":1,\"480\":1}}],[\"线程移到\",{\"0\":{\"433\":1}}],[\"线程中有较大的耗时占比\",{\"1\":{\"431\":1}}],[\"线程池执行\",{\"1\":{\"675\":1}}],[\"线程池异步处理结果\",{\"1\":{\"624\":1}}],[\"线程池处理\",{\"1\":{\"563\":1}}],[\"线程池内部队列\",{\"1\":{\"541\":1}}],[\"线程池中启动了一个状态更新线程\",{\"1\":{\"378\":1}}],[\"线程池为每个延迟等级创建并执行一个\",{\"1\":{\"377\":1}}],[\"线程池之后多线程处理任务\",{\"1\":{\"372\":1}}],[\"线程有新消息到达\",{\"1\":{\"345\":1}}],[\"线程主循环\",{\"1\":{\"335\":1}}],[\"线程\",{\"0\":{\"433\":1},\"1\":{\"332\":1,\"510\":1,\"516\":1}}],[\"立刻拉取最新消息\",{\"1\":{\"348\":1}}],[\"立刻唤醒相应队列的拉取请求\",{\"1\":{\"331\":1}}],[\"立即将拉取请求放入队列\",{\"1\":{\"688\":1}}],[\"立即执行拉取消息请求\",{\"1\":{\"688\":1}}],[\"立即执行重平衡\",{\"1\":{\"640\":1,\"642\":1}}],[\"立即唤醒重平衡线程执行本地重平衡\",{\"1\":{\"656\":1}}],[\"立即唤醒挂起的拉取请求\",{\"1\":{\"334\":1}}],[\"立即唤醒挂起的消息拉取请求\",{\"1\":{\"282\":1,\"347\":1}}],[\"立即重平衡\",{\"1\":{\"648\":1}}],[\"立即停止系统\",{\"1\":{\"21\":1}}],[\"涉及到的类\",{\"0\":{\"328\":1}}],[\"尝试存入\",{\"1\":{\"851\":1}}],[\"尝试将\",{\"1\":{\"779\":1}}],[\"尝试获取队列的消费锁\",{\"1\":{\"745\":1}}],[\"尝试获取缓存的路由信息\",{\"1\":{\"571\":1}}],[\"尝试向\",{\"1\":{\"744\":1}}],[\"尝试给处理队列加锁\",{\"1\":{\"744\":1}}],[\"尝试加锁\",{\"1\":{\"734\":1}}],[\"尝试释放\",{\"1\":{\"733\":1}}],[\"尝试持久化消息消费进度\",{\"1\":{\"695\":1}}],[\"尝试从规避的\",{\"1\":{\"572\":1}}],[\"尝试从存储的消息中拉取消息\",{\"1\":{\"326\":1}}],[\"尝试恢复这些文件\",{\"1\":{\"290\":1}}],[\"受到\",{\"1\":{\"367\":1}}],[\"受\",{\"1\":{\"325\":1}}],[\"受cluster\",{\"1\":{\"192\":1}}],[\"长轮询相关介绍见本文\",{\"1\":{\"683\":1}}],[\"长轮询相关逻辑请移步之前的分析\",{\"1\":{\"426\":1}}],[\"长轮询模式\",{\"1\":{\"349\":1}}],[\"长轮询请求管理线程\",{\"1\":{\"330\":1}}],[\"长轮询等待\",{\"1\":{\"326\":1,\"335\":1}}],[\"长轮询\",{\"1\":{\"325\":1,\"330\":1,\"339\":1,\"693\":1,\"789\":1}}],[\"长轮询和短轮询\",{\"0\":{\"325\":1}}],[\"短信通知\",{\"1\":{\"547\":1}}],[\"短时间内对于生产者和消费者并不会产生太大影响\",{\"1\":{\"462\":1}}],[\"短轮询默认等待\",{\"1\":{\"335\":1}}],[\"短轮询的配置决定\",{\"1\":{\"335\":1}}],[\"短轮询等待时间\",{\"1\":{\"330\":1}}],[\"短轮询等待\",{\"1\":{\"326\":1}}],[\"短轮询\",{\"1\":{\"325\":1}}],[\"短路布尔表达式\",{\"0\":{\"69\":1}}],[\"马上进行下次拉取\",{\"1\":{\"695\":1,\"749\":1}}],[\"马上拉取该消息\",{\"1\":{\"323\":1}}],[\"马海\",{\"1\":{\"136\":1}}],[\"询问是否有新消息可供消费\",{\"1\":{\"323\":1}}],[\"支持的过滤方式\",{\"0\":{\"823\":1}}],[\"支持在配置文件中进行修改\",{\"1\":{\"819\":1}}],[\"支持对重试主题的属性进行过滤\",{\"1\":{\"693\":1}}],[\"支持将重平衡流程在服务端实现\",{\"1\":{\"651\":1}}],[\"支持将统一主题的一批消息打包发送\",{\"1\":{\"564\":1}}],[\"支持两种消息模式\",{\"1\":{\"608\":1}}],[\"支持多种消息发送的方式和特殊消息的发送\",{\"1\":{\"545\":1}}],[\"支持多种消费方式\",{\"1\":{\"321\":1}}],[\"支持消息轨迹的查询\",{\"1\":{\"529\":1}}],[\"支持\",{\"1\":{\"461\":1,\"547\":1,\"723\":1}}],[\"支持取消已经发送的定时消息\",{\"1\":{\"457\":1}}],[\"支持定时也要支持取消\",{\"1\":{\"455\":1}}],[\"支持更大的延迟时间意味着延迟消息更长的保存时间\",{\"1\":{\"444\":1}}],[\"支持任意时间的定时\",{\"1\":{\"443\":1}}],[\"支持最长\",{\"1\":{\"442\":1}}],[\"支持比较灵活的延迟消息\",{\"1\":{\"442\":1}}],[\"支持跨度很大的延迟消息\",{\"1\":{\"442\":1}}],[\"支持发送\",{\"0\":{\"425\":1}}],[\"支持延迟消息异步投递\",{\"0\":{\"373\":1}}],[\"支持延迟消息的异步投递\",{\"1\":{\"370\":1}}],[\"支持了\",{\"1\":{\"293\":1}}],[\"轮询选一个\",{\"1\":{\"789\":1}}],[\"轮询获取一个消息队列\",{\"1\":{\"572\":1}}],[\"轮询队列\",{\"1\":{\"572\":1}}],[\"轮询后会检查每个挂起的拉取请求的挂起时间是否超过挂起时间阈值\",{\"1\":{\"326\":1}}],[\"轮询时间为\",{\"1\":{\"325\":2}}],[\"轮询机制\",{\"0\":{\"319\":1},\"1\":{\"434\":1,\"884\":1}}],[\"轮流与\",{\"1\":{\"37\":1}}],[\"强制删除\",{\"1\":{\"390\":1}}],[\"强制刷盘\",{\"1\":{\"316\":1}}],[\"强制将写满的文件刷盘\",{\"1\":{\"309\":1}}],[\"判断当前消费者是否需要消费该消息\",{\"1\":{\"852\":1}}],[\"判断当前索引数量是否小于最大索引数量\",{\"1\":{\"317\":1}}],[\"判断拉消息的消费者是否可能需要消费到这条消息\",{\"1\":{\"844\":1}}],[\"判断拉取结果\",{\"1\":{\"684\":1}}],[\"判断运算的结果是否都为\",{\"1\":{\"842\":1}}],[\"判断元素在集合中是否大概率存在\",{\"1\":{\"842\":1}}],[\"判断属性存在\",{\"1\":{\"828\":1}}],[\"判断属性不存在\",{\"1\":{\"828\":1}}],[\"判断消息是否包含这个\",{\"1\":{\"825\":1}}],[\"判断消息是否需要执行多队列分发\",{\"1\":{\"817\":1}}],[\"判断消息的事务属性\",{\"1\":{\"284\":1}}],[\"判断消费状态\",{\"1\":{\"750\":1}}],[\"判断消费结果\",{\"1\":{\"715\":1}}],[\"判断broker的订阅关系版本是否最新\",{\"1\":{\"693\":1}}],[\"判断broker权限\",{\"1\":{\"693\":1}}],[\"判断topic是否可读\",{\"1\":{\"693\":1}}],[\"判断要丢弃的队列并丢弃\",{\"1\":{\"657\":1,\"664\":1,\"744\":1}}],[\"判断自己分配到的队列是否变化\",{\"1\":{\"650\":1}}],[\"判断该\",{\"1\":{\"581\":2}}],[\"判断该用户是否有客户端请求的资源的相应操作权限\",{\"1\":{\"511\":1,\"520\":1}}],[\"判断该用户是否配置在权限控制列表中\",{\"1\":{\"511\":1,\"520\":1}}],[\"判断发过来的消息是否已经到达重新消费的重试最大次数\",{\"1\":{\"576\":1}}],[\"判断缓存中该配置文件的全局白名单\",{\"1\":{\"518\":1}}],[\"判断客户端是否传过来了subscriptiondata\",{\"1\":{\"693\":1}}],[\"判断客户端\",{\"1\":{\"511\":2,\"520\":2}}],[\"判断成功则正常返回\",{\"1\":{\"501\":1}}],[\"判断\",{\"1\":{\"491\":1}}],[\"判断其状态\",{\"1\":{\"378\":1}}],[\"判断是否通过过滤\",{\"1\":{\"851\":1}}],[\"判断是否与消费队列中保存的\",{\"1\":{\"834\":1}}],[\"判断是否需要分发构建\",{\"1\":{\"814\":1}}],[\"判断是否需要提交偏移量\",{\"1\":{\"679\":1}}],[\"判断是否\",{\"1\":{\"777\":1}}],[\"判断是否拉磁盘数据\",{\"1\":{\"694\":1}}],[\"判断是否是定时消息\",{\"1\":{\"363\":1}}],[\"判断是否有新消息到达\",{\"1\":{\"343\":1}}],[\"判断是否启用长轮询\",{\"1\":{\"332\":1}}],[\"判断并挂起该拉取请求\",{\"1\":{\"339\":1}}],[\"判断最后一个文件是否写满\",{\"1\":{\"313\":1}}],[\"判断文件列表是否为空\",{\"1\":{\"313\":1}}],[\"先存到一个延迟\",{\"1\":{\"876\":1}}],[\"先判断拉取消息请求是否带有过滤信息\",{\"1\":{\"841\":1}}],[\"先判断文件是否存在\",{\"1\":{\"313\":1}}],[\"先计算消息的\",{\"1\":{\"834\":1}}],[\"先调用\",{\"1\":{\"814\":1,\"844\":1}}],[\"先尝试从消息拉取请求中获取过滤信息\",{\"1\":{\"838\":1}}],[\"先尝试放入内存匹配\",{\"1\":{\"793\":1}}],[\"先尝试将\",{\"1\":{\"780\":1}}],[\"先尝试使用读锁\",{\"1\":{\"313\":1}}],[\"先运行\",{\"1\":{\"768\":1}}],[\"先试着获取\",{\"1\":{\"735\":1}}],[\"先获取锁容器的改动锁\",{\"1\":{\"734\":1}}],[\"先获取或创建死信队列\",{\"1\":{\"708\":1}}],[\"先获延迟等级取对应的\",{\"1\":{\"365\":1}}],[\"先找到\",{\"1\":{\"708\":1}}],[\"先检查处理队列是否被丢弃\",{\"1\":{\"708\":1}}],[\"先根据较少的信息\",{\"1\":{\"838\":1}}],[\"先根据\",{\"1\":{\"694\":1,\"838\":1}}],[\"先根据上一步选择的队列\",{\"1\":{\"562\":1}}],[\"先从内存查找\",{\"1\":{\"691\":1}}],[\"先向\",{\"1\":{\"656\":1}}],[\"先看一下\",{\"1\":{\"629\":1}}],[\"先看一下代码上的改动\",{\"1\":{\"257\":1}}],[\"先更新到内存\",{\"1\":{\"624\":1}}],[\"先了解一下\",{\"1\":{\"606\":1}}],[\"先加载\",{\"1\":{\"467\":1,\"481\":1}}],[\"先发送的不一定先投递\",{\"1\":{\"446\":1}}],[\"先来了解一下\",{\"1\":{\"498\":1}}],[\"先来先投递\",{\"1\":{\"445\":1}}],[\"先来看一下类图\",{\"1\":{\"637\":1}}],[\"先来看一下本次性能优化的所有优化项\",{\"1\":{\"406\":1}}],[\"先来看一下删除\",{\"1\":{\"390\":1}}],[\"先来看看\",{\"1\":{\"320\":1}}],[\"先查本地缓存\",{\"1\":{\"562\":1}}],[\"先查询对应\",{\"1\":{\"398\":1}}],[\"先查出当前\",{\"1\":{\"391\":1}}],[\"依然是通过查看火焰图的方法\",{\"1\":{\"434\":1}}],[\"依次扫描消息是否到期\",{\"1\":{\"377\":1}}],[\"依次加载每个索引文件\",{\"1\":{\"313\":1}}],[\"依赖于一个父\",{\"1\":{\"813\":1}}],[\"依赖于\",{\"1\":{\"80\":1}}],[\"底层存储之那些你不知道的事\",{\"1\":{\"404\":1,\"868\":1}}],[\"底层存储实现\",{\"1\":{\"310\":1}}],[\"底层是一个\",{\"1\":{\"335\":1}}],[\"底层使用内存映射文件\",{\"1\":{\"310\":1}}],[\"符合任意一种都会执行删除逻辑\",{\"1\":{\"386\":1}}],[\"符合以下两种条件之一的拉取请求会被处理并返回\",{\"1\":{\"345\":1}}],[\"符合时间的\",{\"1\":{\"309\":1}}],[\"符号\",{\"1\":{\"25\":1}}],[\"链表越往后\",{\"1\":{\"307\":1}}],[\"链表下一项的逻辑下标\",{\"1\":{\"307\":1}}],[\"部分消息未被消费\",{\"1\":{\"759\":1}}],[\"部分为\",{\"1\":{\"676\":2}}],[\"部分为客户端发送拉取请求\",{\"1\":{\"676\":1}}],[\"部分长度都是固定的\",{\"1\":{\"307\":1}}],[\"部分存储固定数量的索引项\",{\"1\":{\"307\":1}}],[\"部分存储固定数量的\",{\"1\":{\"307\":1}}],[\"部分是定长的\",{\"1\":{\"307\":1}}],[\"槽个数\",{\"1\":{\"307\":1}}],[\"槽和\",{\"1\":{\"307\":1}}],[\"固定大小\",{\"1\":{\"307\":1}}],[\"举例\",{\"1\":{\"307\":1}}],[\"举个例子\",{\"1\":{\"233\":1}}],[\"逻辑或\",{\"1\":{\"828\":1}}],[\"逻辑与\",{\"1\":{\"828\":1}}],[\"逻辑中更新该时间戳\",{\"1\":{\"817\":1}}],[\"逻辑如下\",{\"1\":{\"814\":1}}],[\"逻辑改成了\",{\"1\":{\"726\":1}}],[\"逻辑前\",{\"1\":{\"510\":1}}],[\"逻辑\",{\"1\":{\"509\":1,\"515\":1}}],[\"逻辑消费队列\",{\"1\":{\"336\":1}}],[\"逻辑结构\",{\"0\":{\"306\":1}}],[\"逻辑处理器数\",{\"1\":{\"253\":1}}],[\"越频繁\",{\"1\":{\"444\":1}}],[\"越晚到达的消息在链表越前面\",{\"1\":{\"306\":1}}],[\"越新的消息在链表越前面\",{\"1\":{\"300\":1}}],[\"越来越多的cio\",{\"1\":{\"126\":1}}],[\"得到一个二进制数组\",{\"1\":{\"835\":1}}],[\"得到重平衡后的该消费者分到的消息队列\",{\"1\":{\"663\":1}}],[\"得到分配给当前消费者实例的队列列表\",{\"1\":{\"663\":1}}],[\"得到的位数组\",{\"1\":{\"843\":1}}],[\"得到的整数\",{\"1\":{\"306\":1}}],[\"得到的一个\",{\"1\":{\"300\":1}}],[\"得到\",{\"1\":{\"306\":1,\"424\":1,\"426\":1}}],[\"得出测试结果并输出可视化图表\",{\"1\":{\"130\":2}}],[\"经过上面的分析\",{\"1\":{\"449\":1}}],[\"经过这个改动\",{\"1\":{\"435\":1}}],[\"经过哈希得到的整数\",{\"1\":{\"307\":1}}],[\"经过hash\",{\"1\":{\"306\":1}}],[\"经过\",{\"1\":{\"300\":1,\"433\":1}}],[\"经过一些实践测试\",{\"1\":{\"253\":1}}],[\"形如\",{\"1\":{\"480\":1}}],[\"形式存储数据\",{\"1\":{\"300\":1}}],[\"形成一个组\",{\"1\":{\"206\":1}}],[\"属于内核空间\",{\"1\":{\"400\":1}}],[\"属于\",{\"1\":{\"297\":1}}],[\"属性a存在且属性a的值为abc或a的值不为def\",{\"1\":{\"828\":1}}],[\"属性a存在且属性a的值为abc或def\",{\"1\":{\"828\":1}}],[\"属性a存在且属性a的值小于10或大于100\",{\"1\":{\"828\":1}}],[\"属性a存在且属性a的值大于等于10且小于等于100\",{\"1\":{\"828\":1}}],[\"属性a存在且属性a的值大于100或属性b不存在\",{\"1\":{\"828\":1}}],[\"属性a存在且属性a的值大于100\",{\"1\":{\"828\":1}}],[\"属性a存在\",{\"1\":{\"828\":1}}],[\"属性a不存在\",{\"1\":{\"828\":1}}],[\"属性进行配置\",{\"1\":{\"370\":1}}],[\"属性中\",{\"1\":{\"354\":1}}],[\"属性设置为\",{\"1\":{\"217\":1}}],[\"属性\",{\"0\":{\"52\":1},\"1\":{\"357\":1,\"708\":1,\"760\":1,\"807\":1,\"813\":1,\"814\":1,\"816\":1}}],[\"迦南地\",{\"1\":{\"294\":1}}],[\"留了8字节的保留字段\",{\"1\":{\"293\":1}}],[\"元数据上\",{\"1\":{\"810\":1}}],[\"元数据被更新的次数\",{\"1\":{\"487\":1}}],[\"元数据\",{\"1\":{\"470\":1,\"488\":1}}],[\"元素更多\",{\"1\":{\"293\":1}}],[\"元组会被排序\",{\"1\":{\"98\":1}}],[\"元组里的某一个元素\",{\"1\":{\"98\":1}}],[\"元组里的字段没有名字\",{\"1\":{\"26\":1}}],[\"元组用于保存固定数量的元素\",{\"1\":{\"40\":1}}],[\"元组\",{\"0\":{\"26\":1},\"1\":{\"45\":1,\"111\":1}}],[\"格式化\",{\"0\":{\"427\":1}}],[\"格式\",{\"1\":{\"293\":1}}],[\"删掉不可用的部分\",{\"1\":{\"291\":1}}],[\"删除它的路由信息\",{\"1\":{\"492\":1}}],[\"删除所有最大\",{\"1\":{\"392\":1}}],[\"删除逻辑队列文件\",{\"1\":{\"391\":1}}],[\"删除小于该\",{\"1\":{\"391\":1}}],[\"删除文件数量\",{\"1\":{\"390\":1}}],[\"删除两个文件的间隔\",{\"1\":{\"390\":1}}],[\"删除两个文件的间隔时间\",{\"1\":{\"390\":1}}],[\"删除成功的文件数量\",{\"1\":{\"390\":1}}],[\"删除物理文件的时间间隔\",{\"1\":{\"390\":1}}],[\"删除\",{\"1\":{\"388\":1,\"392\":1,\"474\":1}}],[\"删除该\",{\"1\":{\"387\":1,\"492\":1}}],[\"删除过期的文件\",{\"1\":{\"386\":1}}],[\"删除消息commitlog偏移量offset之前的所有indexfile文件\",{\"1\":{\"315\":1,\"392\":1}}],[\"删除消息时并不会直接删除消息所在的文件\",{\"1\":{\"221\":1}}],[\"删除等\",{\"1\":{\"309\":1}}],[\"删除多余的文件\",{\"1\":{\"279\":1}}],[\"删除了无用的代码\",{\"1\":{\"256\":1}}],[\"删除了大量重复代码\",{\"1\":{\"251\":1}}],[\"物理文件正在被删除\",{\"1\":{\"694\":1}}],[\"物理\",{\"1\":{\"287\":1,\"524\":1,\"532\":1}}],[\"纠正mappedfile逻辑队列索引顺序\",{\"1\":{\"285\":1}}],[\"纠结使用\",{\"1\":{\"2\":1}}],[\"往consumequeue中写入索引项\",{\"1\":{\"285\":1}}],[\"获取排序后的\",{\"1\":{\"799\":1}}],[\"获取发起请求的消费组信息\",{\"1\":{\"786\":1}}],[\"获取一批消息\",{\"1\":{\"772\":1}}],[\"获取的这批消息为空\",{\"1\":{\"750\":1}}],[\"获取成功\",{\"1\":{\"745\":1}}],[\"获取延迟等级\",{\"1\":{\"717\":1}}],[\"获取订阅关系\",{\"1\":{\"708\":1}}],[\"获取订阅数据\",{\"1\":{\"690\":1}}],[\"获取返回结果中第一条消息的消费队列offset\",{\"1\":{\"695\":1,\"749\":1}}],[\"获取返回体\",{\"1\":{\"340\":1}}],[\"获取待拉取的消费队列\",{\"1\":{\"690\":1,\"748\":1}}],[\"获取消费组中所有消费者的\",{\"1\":{\"850\":1}}],[\"获取消费组的订阅配置\",{\"1\":{\"718\":1}}],[\"获取消费锁失败\",{\"1\":{\"745\":1}}],[\"获取消费队列锁\",{\"1\":{\"738\":1}}],[\"获取消费队列最大和最小的逻辑偏移量\",{\"1\":{\"684\":1}}],[\"获取消息的消费索引\",{\"1\":{\"838\":1}}],[\"获取消息的所有\",{\"1\":{\"314\":1}}],[\"获取消息时调用\",{\"1\":{\"838\":1}}],[\"获取消息属性中需要分发的\",{\"1\":{\"814\":1}}],[\"获取消息消费偏移量\",{\"1\":{\"637\":1}}],[\"获取消息\",{\"1\":{\"287\":1,\"694\":1}}],[\"获取队列的订阅信息\",{\"1\":{\"679\":1}}],[\"获取全部的订阅信息\",{\"1\":{\"662\":1}}],[\"获取自己分配到的消息队列\",{\"1\":{\"657\":1}}],[\"获取该消费组下所有的消费者\",{\"1\":{\"657\":1}}],[\"获取该等级的\",{\"1\":{\"377\":1}}],[\"获取它们的重平衡实现并且调用\",{\"1\":{\"657\":1}}],[\"获取它们要生产\",{\"1\":{\"465\":1}}],[\"获取读队列的方法\",{\"1\":{\"636\":1}}],[\"获取主题的路由信息\",{\"1\":{\"570\":1}}],[\"获取对应的\",{\"1\":{\"562\":1}}],[\"获取到\",{\"1\":{\"561\":1}}],[\"获取到broker地址后缓存到本地\",{\"1\":{\"462\":1}}],[\"获取或创建重试\",{\"1\":{\"708\":1}}],[\"获取或创建\",{\"1\":{\"557\":1}}],[\"获取其最近一次修改的时间\",{\"1\":{\"519\":1}}],[\"获取acl配置文件数量并和\",{\"1\":{\"519\":1}}],[\"获取所有订阅该\",{\"1\":{\"835\":1}}],[\"获取所有消费者\",{\"1\":{\"650\":1}}],[\"获取所有\",{\"1\":{\"518\":1,\"790\":1}}],[\"获取所有有效的消息\",{\"1\":{\"365\":1,\"380\":1}}],[\"获取请求用户的访问控制权限\",{\"1\":{\"511\":1,\"520\":1}}],[\"获取账号信息进行权限判断\",{\"1\":{\"507\":1}}],[\"获取consumequeue索引的三个关键属性\",{\"1\":{\"365\":1,\"380\":1}}],[\"获取挂起的拉取请求列表\",{\"1\":{\"345\":2}}],[\"获取索引数据\",{\"1\":{\"317\":1}}],[\"获取hash槽的值\",{\"1\":{\"317\":2}}],[\"获取hash槽位置\",{\"1\":{\"317\":1}}],[\"获取当前消费组内所有消费者的客户端\",{\"1\":{\"663\":1}}],[\"获取当前\",{\"1\":{\"317\":1}}],[\"获取当前载入路径值\",{\"1\":{\"73\":1}}],[\"获取\",{\"1\":{\"314\":1,\"365\":1,\"573\":2,\"581\":2,\"720\":1,\"786\":1,\"790\":1}}],[\"获取最后一个索引文件\",{\"1\":{\"309\":1,\"313\":2}}],[\"获取最新的路由信息\",{\"1\":{\"461\":1}}],[\"获取最新的索引文件\",{\"1\":{\"309\":1}}],[\"获取最新的偏移量\",{\"1\":{\"285\":1}}],[\"定期扫描和更新内部数据\",{\"1\":{\"465\":1}}],[\"定期请求\",{\"1\":{\"461\":1}}],[\"定期向\",{\"1\":{\"461\":1}}],[\"定时时间为当前时间\",{\"1\":{\"873\":1}}],[\"定时投递\",{\"1\":{\"873\":1}}],[\"定时到重试时间\",{\"1\":{\"783\":1}}],[\"定时到唤醒重试时间投递\",{\"1\":{\"780\":1,\"793\":1}}],[\"定时持久化消费进度\",{\"1\":{\"721\":1}}],[\"定时持久化的设计\",{\"1\":{\"710\":1}}],[\"定时持久化的设计方法\",{\"1\":{\"710\":1}}],[\"定时触发\",{\"1\":{\"648\":1}}],[\"定时任务\",{\"1\":{\"632\":1}}],[\"定时任务中记录的offset已经被删除\",{\"1\":{\"365\":1}}],[\"定时刷盘\",{\"1\":{\"624\":1}}],[\"定时上报到\",{\"1\":{\"624\":1}}],[\"定时将内存中的消费进度提交到\",{\"1\":{\"623\":1}}],[\"定时将offsettable持久化\",{\"1\":{\"360\":1,\"364\":1}}],[\"定时调用\",{\"1\":{\"361\":1}}],[\"定时消息更详细的原理可以看这篇文章\",{\"1\":{\"708\":1}}],[\"定时消息已经上线\",{\"0\":{\"457\":1}}],[\"定时消息由于其延迟投递的特性\",{\"1\":{\"455\":1}}],[\"定时消息取消\",{\"0\":{\"455\":1}}],[\"定时消息和普通消息同时大量投递\",{\"1\":{\"451\":1}}],[\"定时消息和延迟消息是消息队列中对于消息的基本概念\",{\"1\":{\"440\":1}}],[\"定时消息和延迟消息是什么\",{\"0\":{\"440\":1}}],[\"定时消息索引的存储方案设计就变得很简单\",{\"1\":{\"447\":1}}],[\"定时消息的存储和老化\",{\"0\":{\"877\":1}}],[\"定时消息的机制会不停扫描定时消息\",{\"1\":{\"708\":1}}],[\"定时消息的投递默认使用异步刷盘的方式\",{\"1\":{\"450\":1}}],[\"定时消息的处理逻辑主要分为两个部分\",{\"1\":{\"450\":1}}],[\"定时消息的顺序\",{\"1\":{\"446\":1}}],[\"定时消息的实现\",{\"1\":{\"445\":1}}],[\"定时消息的精度越高就意味着定时任务执行越频繁\",{\"1\":{\"444\":1}}],[\"定时消息的需求和应用场景\",{\"0\":{\"441\":1}}],[\"定时消息如何投递\",{\"1\":{\"444\":1}}],[\"定时消息还能用于更多其他场景\",{\"1\":{\"441\":1,\"871\":1}}],[\"定时消息在当前的互联网环境中有非常大的需求\",{\"1\":{\"441\":1}}],[\"定时消息投递失败\",{\"1\":{\"451\":1}}],[\"定时消息投递\",{\"0\":{\"450\":1}}],[\"定时消息投递任务\",{\"0\":{\"380\":1}}],[\"定时消息投递线程\",{\"0\":{\"377\":1}}],[\"定时消息时序图\",{\"0\":{\"357\":1}}],[\"定时消息涉及到的类\",{\"0\":{\"356\":1}}],[\"定时消息指消息发送后\",{\"1\":{\"352\":1}}],[\"定时消息指发送一条消息\",{\"1\":{\"352\":1}}],[\"定时消息概念\",{\"0\":{\"352\":1}}],[\"定时消息\",{\"0\":{\"350\":1,\"369\":1},\"1\":{\"370\":1,\"440\":1,\"793\":1,\"871\":1,\"872\":2,\"884\":2}}],[\"定位到对应的消费队列文件\",{\"1\":{\"286\":1}}],[\"定位到对应消息\",{\"1\":{\"277\":1}}],[\"定义了更新\",{\"1\":{\"710\":1}}],[\"定义了\",{\"1\":{\"639\":1}}],[\"定义了初始长度\",{\"1\":{\"261\":1}}],[\"定义临时变量\",{\"1\":{\"518\":1}}],[\"定义\",{\"1\":{\"41\":1}}],[\"定义可以包含在\",{\"1\":{\"41\":1}}],[\"遍历查询到的消息\",{\"1\":{\"798\":1}}],[\"遍历消费到的\",{\"1\":{\"783\":1}}],[\"遍历消费队列索引\",{\"1\":{\"684\":1}}],[\"遍历新分配的\",{\"1\":{\"664\":1,\"744\":1}}],[\"遍历新分配的消息队列\",{\"1\":{\"657\":1}}],[\"遍历每个\",{\"1\":{\"662\":1}}],[\"遍历每个consumequeue执行恢复recover\",{\"1\":{\"279\":1}}],[\"遍历本地缓存的消费者分到的消息队列\",{\"1\":{\"657\":1,\"664\":1,\"744\":1}}],[\"遍历需要的权限与拥有的权限进行对比\",{\"1\":{\"520\":1}}],[\"遍历所有注册的带有\",{\"1\":{\"851\":1}}],[\"遍历所有消费者\",{\"1\":{\"843\":1}}],[\"遍历所有内存中的\",{\"1\":{\"797\":1}}],[\"遍历所有缓存的消息队列\",{\"1\":{\"720\":1}}],[\"遍历所有\",{\"1\":{\"490\":1}}],[\"遍历所有文件\",{\"1\":{\"392\":1}}],[\"遍历所有consumequeue目录下的文件\",{\"1\":{\"273\":1,\"279\":1}}],[\"遍历consumequeue中的所有有效消息\",{\"1\":{\"365\":1,\"380\":1}}],[\"遍历consumequeue刷盘\",{\"1\":{\"289\":1}}],[\"遍历该队列的所有拉取请求\",{\"1\":{\"345\":1}}],[\"遍历拉取请求容器中的每个队列\",{\"1\":{\"343\":1}}],[\"遍历索引链表中的每个索引\",{\"1\":{\"317\":1}}],[\"遍历\",{\"1\":{\"289\":1,\"518\":1,\"797\":1,\"800\":1}}],[\"遍历文件的每个索引项进行校验\",{\"1\":{\"273\":1,\"279\":1,\"291\":1}}],[\"恢复重试消息的主题名\",{\"1\":{\"715\":1}}],[\"恢复\",{\"0\":{\"273\":1,\"279\":1,\"290\":1},\"1\":{\"354\":1,\"356\":1}}],[\"看该消息是否到期\",{\"1\":{\"708\":1}}],[\"看完本文能够对消息消费涉及到的相关类和消费流程有大体的了解\",{\"1\":{\"627\":1}}],[\"看一看它究竟是怎么实现的\",{\"1\":{\"442\":1}}],[\"看一下它支持的版本号列表\",{\"1\":{\"593\":1}}],[\"看一下\",{\"1\":{\"243\":1,\"510\":1}}],[\"看一下源码中如何处理信用的流动和消息的阻塞\",{\"1\":{\"156\":1}}],[\"看作是索引项组成的数组\",{\"1\":{\"269\":1}}],[\"码列表中\",{\"1\":{\"839\":1}}],[\"码是否在过滤规则允许的\",{\"1\":{\"839\":1}}],[\"码可能相同\",{\"1\":{\"834\":1}}],[\"码一致\",{\"1\":{\"834\":1}}],[\"码表\",{\"1\":{\"798\":1}}],[\"码表每一位\",{\"1\":{\"797\":1}}],[\"码表为\",{\"1\":{\"796\":1,\"798\":1}}],[\"码\",{\"1\":{\"269\":1,\"834\":2,\"838\":1,\"839\":2}}],[\"└─0\",{\"1\":{\"269\":1}}],[\"└─b4b690a3\",{\"1\":{\"269\":1}}],[\"├─consumequeue\",{\"1\":{\"269\":1}}],[\"├─commitlog\",{\"1\":{\"269\":1}}],[\"│\",{\"1\":{\"269\":15}}],[\"索引构建线程\",{\"1\":{\"814\":1}}],[\"索引每个\",{\"1\":{\"447\":1}}],[\"索引的\",{\"1\":{\"359\":1}}],[\"索引的逻辑下标\",{\"1\":{\"307\":1}}],[\"索引项个数+1\",{\"1\":{\"317\":1}}],[\"索引项的结构很简单\",{\"1\":{\"275\":1}}],[\"索引服务\",{\"1\":{\"309\":1}}],[\"索引文件被删除\",{\"1\":{\"365\":1}}],[\"索引文件刷盘\",{\"1\":{\"316\":2}}],[\"索引文件列表\",{\"1\":{\"309\":1}}],[\"索引文件涉及到的类\",{\"0\":{\"308\":1}}],[\"索引文件可以有多个\",{\"1\":{\"307\":1}}],[\"索引文件可以通过\",{\"1\":{\"298\":1,\"388\":1}}],[\"索引文件底层使用\",{\"1\":{\"307\":1}}],[\"索引文件中存储着\",{\"1\":{\"302\":1}}],[\"索引文件的刷盘机制并不是采取定时刷盘机制\",{\"1\":{\"303\":1}}],[\"索引文件的\",{\"1\":{\"300\":2,\"447\":1}}],[\"索引文件的应用场景其实比较局限\",{\"1\":{\"298\":1}}],[\"索引文件结构\",{\"0\":{\"300\":1,\"305\":1}}],[\"索引文件作用\",{\"0\":{\"298\":1}}],[\"索引文件是什么\",{\"0\":{\"297\":1}}],[\"索引文件\",{\"0\":{\"295\":1},\"1\":{\"310\":1,\"884\":1}}],[\"索引\",{\"1\":{\"266\":1,\"331\":1}}],[\"又是否成功将消息投递给消费者这些动作\",{\"1\":{\"523\":1}}],[\"又可以称作索引文件\",{\"1\":{\"297\":1}}],[\"又可称作\",{\"1\":{\"147\":1}}],[\"又称作消费队列\",{\"1\":{\"266\":1}}],[\"离物理极限性能还差多远\",{\"1\":{\"263\":1}}],[\"离线并再次恢复时\",{\"1\":{\"210\":1}}],[\"离线后重新上线\",{\"0\":{\"210\":1}}],[\"离线系统的复杂架构不断被融合\",{\"1\":{\"126\":1}}],[\"解锁队列\",{\"1\":{\"778\":1}}],[\"解锁则是将\",{\"1\":{\"734\":1}}],[\"解码时就走具体的实现类而不用反射\",{\"1\":{\"411\":1}}],[\"解码性能\",{\"0\":{\"409\":1}}],[\"解码成\",{\"1\":{\"262\":1}}],[\"解决了消费端异常\",{\"1\":{\"651\":1}}],[\"解决了定时消息顺序问题\",{\"1\":{\"447\":1}}],[\"解决了定时消息排序的问题\",{\"1\":{\"368\":1}}],[\"解决方案不难想到\",{\"1\":{\"326\":1}}],[\"解析消息属性中是否有需要分发的\",{\"1\":{\"814\":1}}],[\"解析请求头\",{\"1\":{\"793\":1}}],[\"解析请求体和一系列校验\",{\"1\":{\"789\":1}}],[\"解析数据版本\",{\"1\":{\"518\":1}}],[\"解析账号权限配置\",{\"1\":{\"518\":1}}],[\"解析全局\",{\"1\":{\"518\":1}}],[\"解析配置\",{\"1\":{\"518\":1}}],[\"解析所有\",{\"1\":{\"518\":1}}],[\"解析策略工厂\",{\"1\":{\"517\":1}}],[\"解析命令行参数\",{\"1\":{\"480\":1}}],[\"解析的性能\",{\"0\":{\"259\":1}}],[\"解析\",{\"1\":{\"154\":1,\"516\":1}}],[\"各个consumergroup的权限\",{\"1\":{\"503\":1}}],[\"各个topic的权限\",{\"1\":{\"503\":1}}],[\"各个注解的含义和用法\",{\"1\":{\"12\":1}}],[\"各实例间相互不进行信息通讯\",{\"1\":{\"461\":1}}],[\"各大开源消息队列和云厂商没有实现完美的定时消息\",{\"1\":{\"444\":1}}],[\"各大云厂商将该功能作为一个竞争力项\",{\"1\":{\"442\":1}}],[\"各大消息队列对定时消息支持的现状\",{\"0\":{\"442\":1}}],[\"各不相同\",{\"1\":{\"262\":1}}],[\"免去了排序的步骤\",{\"1\":{\"447\":1}}],[\"免去了存到\",{\"1\":{\"261\":1}}],[\"免运维\",{\"1\":{\"126\":1}}],[\"至此\",{\"1\":{\"452\":1,\"454\":1}}],[\"至此发送消息的动作才执行完毕\",{\"1\":{\"148\":1}}],[\"至少刷\",{\"1\":{\"289\":1}}],[\"至少会内部扩展\",{\"1\":{\"261\":1}}],[\"懒加载\",{\"0\":{\"258\":1}}],[\"右边\",{\"1\":{\"676\":1}}],[\"右边是投递过程状态更新线程\",{\"1\":{\"376\":1}}],[\"右边是针对消息生产的指令\",{\"1\":{\"262\":1}}],[\"右边是follower\",{\"1\":{\"207\":1}}],[\"右边方法将切分后的字符串直接存到\",{\"1\":{\"261\":1}}],[\"右边新增的的\",{\"1\":{\"257\":1}}],[\"右边绿色新增的代码是原先在锁中的操作\",{\"1\":{\"257\":1}}],[\"能想到的要点主要有如下几点\",{\"1\":{\"530\":1}}],[\"能不能在现有的消息存储中存储\",{\"1\":{\"455\":1}}],[\"能够让\",{\"1\":{\"766\":1}}],[\"能够清晰地表示客户端\",{\"1\":{\"624\":1}}],[\"能够达到\",{\"1\":{\"433\":1}}],[\"能够想到的比较笨的方法是\",{\"1\":{\"324\":1}}],[\"能够帮助发现并应对分布式云这种底座对架构设计以及上层应用带来的诸如可靠\",{\"1\":{\"126\":1}}],[\"能先准备好的数据就先准备好\",{\"1\":{\"256\":1}}],[\"尽量的放到锁的外面去做\",{\"1\":{\"256\":1}}],[\"尽管仲裁队列的吞吐量更高\",{\"1\":{\"237\":1}}],[\"尽管这里是在rabbit\",{\"1\":{\"157\":1}}],[\"理论\",{\"1\":{\"462\":1}}],[\"理论上这里只要往\",{\"1\":{\"256\":1}}],[\"理解与洞察较少\",{\"1\":{\"127\":1}}],[\"既然有\",{\"1\":{\"253\":1}}],[\"既可以是判断函数\",{\"1\":{\"34\":1}}],[\"传输消息\",{\"1\":{\"789\":1}}],[\"传入的参数是客户端发送请求时指定的用户信息\",{\"1\":{\"511\":1}}],[\"传入一个字节\",{\"1\":{\"414\":1}}],[\"传入一个\",{\"1\":{\"414\":1}}],[\"传入\",{\"1\":{\"258\":1,\"402\":1}}],[\"传到\",{\"1\":{\"257\":1}}],[\"传到写\",{\"1\":{\"250\":1}}],[\"传统混沌工程主要关注系统的稳定性\",{\"1\":{\"132\":1}}],[\"达到请求的最大消息数量\",{\"1\":{\"777\":1}}],[\"达到高可用的效果\",{\"1\":{\"461\":1}}],[\"达到更长的延迟时间\",{\"1\":{\"448\":1}}],[\"达到\",{\"1\":{\"435\":1}}],[\"达到消息不丢失\",{\"1\":{\"249\":1}}],[\"达成无限循环的效果\",{\"1\":{\"158\":1}}],[\"移出\",{\"1\":{\"782\":1,\"797\":1}}],[\"移出同步代码块\",{\"1\":{\"246\":1}}],[\"移除消息的\",{\"1\":{\"816\":1}}],[\"移除消费队列\",{\"1\":{\"664\":1,\"744\":1}}],[\"移除前持久化消费的消费进度\",{\"1\":{\"745\":1}}],[\"移除前持久化\",{\"1\":{\"664\":1,\"744\":1}}],[\"移除不再属于当前实例的messagequeue和processqueue\",{\"1\":{\"662\":1}}],[\"移除不再属于当前实例的消息队列和处理队列\",{\"1\":{\"657\":1}}],[\"移除未激活状态的\",{\"1\":{\"481\":1}}],[\"移除掉线的\",{\"1\":{\"467\":1,\"481\":1}}],[\"移除\",{\"0\":{\"243\":1,\"251\":1,\"408\":1},\"1\":{\"474\":2,\"492\":4,\"782\":1}}],[\"移除与\",{\"1\":{\"84\":1}}],[\"移除的意思是b中所有元素都会从a里面去除\",{\"1\":{\"62\":1}}],[\"修改内存配置\",{\"0\":{\"600\":1}}],[\"修改监听端口\",{\"1\":{\"595\":1}}],[\"修改映射到宿主机的\",{\"1\":{\"595\":1}}],[\"修改一下\",{\"1\":{\"595\":1}}],[\"修改\",{\"1\":{\"498\":1,\"595\":1}}],[\"修改过后在火焰图上已经几乎看不到该方法的用时\",{\"1\":{\"417\":1}}],[\"修改后\",{\"1\":{\"257\":1,\"597\":1}}],[\"修改前\",{\"1\":{\"257\":1}}],[\"修改点\",{\"1\":{\"246\":1}}],[\"修改代码\",{\"1\":{\"121\":1}}],[\"故可以换成自旋锁\",{\"1\":{\"245\":1}}],[\"故障延迟机制走不同逻辑\",{\"1\":{\"572\":1}}],[\"故障延迟机制关闭\",{\"1\":{\"572\":1}}],[\"故障延迟机制是为了能够在消息发送的时候尽量避开上次发送失败的\",{\"1\":{\"561\":1}}],[\"故障延迟机制\",{\"0\":{\"561\":1},\"1\":{\"561\":1,\"572\":5}}],[\"故障规避机制\",{\"1\":{\"552\":1}}],[\"故障期间集群表现不一致\",{\"1\":{\"134\":1}}],[\"故障期间是否出现系统不可用\",{\"1\":{\"133\":1}}],[\"故障下是否满足预期的分区顺序性\",{\"1\":{\"133\":1}}],[\"故障恢复情况\",{\"1\":{\"133\":1}}],[\"于是决定分多篇来写\",{\"1\":{\"606\":1}}],[\"于是决定降低一个数量级\",{\"1\":{\"447\":1}}],[\"于是将\",{\"1\":{\"600\":1}}],[\"于是想办法修改\",{\"1\":{\"599\":1}}],[\"于是需要获取\",{\"1\":{\"559\":1}}],[\"于是轨迹数据的采集可以放在钩子函数中进行\",{\"1\":{\"530\":1}}],[\"于是最终决定采用发送一条\",{\"1\":{\"455\":1}}],[\"于是投递的逻辑变成这样\",{\"1\":{\"452\":1}}],[\"于是毅然选择自研存储\",{\"1\":{\"448\":1}}],[\"于是在\",{\"1\":{\"435\":1}}],[\"于是这里改成也使用\",{\"1\":{\"432\":1}}],[\"于是优化成没有反向\",{\"1\":{\"408\":1}}],[\"于是写\",{\"1\":{\"397\":1}}],[\"于是接下来的第二阶段它又可以批量处理\",{\"1\":{\"244\":1}}],[\"于是手动安装\",{\"1\":{\"178\":1}}],[\"另外如果消费消息用时超过了\",{\"1\":{\"771\":1}}],[\"另外一个触发\",{\"1\":{\"472\":1}}],[\"另外有一个\",{\"1\":{\"244\":1}}],[\"另一个触发路由删除逻辑的是\",{\"1\":{\"474\":1}}],[\"另一方面\",{\"1\":{\"394\":1}}],[\"另一种是给映射组添加一个全新的k\",{\"1\":{\"42\":1}}],[\"另一种方式是将调用包裹在`catch`表达式中\",{\"1\":{\"43\":1,\"45\":1}}],[\"另一种方式\",{\"1\":{\"10\":1}}],[\"产生抖动\",{\"1\":{\"401\":1}}],[\"产生待复制的消息\",{\"1\":{\"244\":1}}],[\"产生一个特定的指标输出\",{\"1\":{\"126\":1}}],[\"资源密集\",{\"1\":{\"804\":1}}],[\"资源的概念\",{\"1\":{\"496\":1}}],[\"资源\",{\"1\":{\"242\":1,\"498\":2}}],[\"资深中间件研发工程师\",{\"1\":{\"136\":1}}],[\"资深研发工程师\",{\"1\":{\"136\":1}}],[\"事件预订等等\",{\"1\":{\"441\":1,\"871\":1}}],[\"事件驱动架构设计\",{\"1\":{\"136\":1}}],[\"事务消息\",{\"1\":{\"545\":1,\"548\":1}}],[\"事务消息二阶段处理线程大小\",{\"0\":{\"254\":1}}],[\"事务消息日志优化\",{\"0\":{\"242\":1}}],[\"优点\",{\"1\":{\"403\":1,\"448\":1}}],[\"优先保留最近一段时间最常使用的那些\",{\"1\":{\"399\":1}}],[\"优先级\",{\"1\":{\"231\":1}}],[\"优化过后构建\",{\"1\":{\"432\":1}}],[\"优化性能\",{\"1\":{\"424\":1}}],[\"优化之后完全没有新对象产生\",{\"1\":{\"420\":1}}],[\"优化方法\",{\"0\":{\"414\":1,\"420\":1,\"423\":1,\"429\":1,\"432\":1}}],[\"优化方案\",{\"0\":{\"411\":1,\"435\":1,\"436\":1}}],[\"优化的步骤是根据\",{\"1\":{\"437\":1}}],[\"优化的方法主要通过字符数组运算替代字符串操作\",{\"1\":{\"420\":1}}],[\"优化的方案是尽量减少反射的使用\",{\"1\":{\"411\":1}}],[\"优化的解码方法\",{\"1\":{\"262\":1}}],[\"优化此方法其实对性能没有什么提升\",{\"1\":{\"408\":1}}],[\"优化占用时间高且可以优化的地方\",{\"1\":{\"407\":1}}],[\"优化点主要是预先计算了需要解析成字符串的长度\",{\"1\":{\"261\":1}}],[\"优化前后效果\",{\"1\":{\"261\":1}}],[\"优化掉了字符串末尾的\",{\"1\":{\"260\":1}}],[\"优化字符串格式的属性存储\",{\"1\":{\"260\":1}}],[\"优化\",{\"0\":{\"250\":1,\"256\":1,\"257\":1,\"259\":1,\"261\":1,\"262\":1,\"409\":1},\"1\":{\"261\":2,\"424\":1}}],[\"优化2\",{\"0\":{\"246\":1}}],[\"优化1\",{\"0\":{\"245\":1}}],[\"优化分析\",{\"0\":{\"241\":1}}],[\"了解这个优化之前需要先学习一下前置知识\",{\"1\":{\"247\":1}}],[\"了解这些优化需要对\",{\"1\":{\"240\":1}}],[\"了多少条消息\",{\"1\":{\"154\":1}}],[\"小林coding\",{\"1\":{\"858\":1}}],[\"小结\",{\"0\":{\"437\":1,\"456\":1}}],[\"小于最大偏移量时才能正常拉取\",{\"1\":{\"684\":1}}],[\"小于阈值\",{\"1\":{\"436\":1}}],[\"小于\",{\"1\":{\"392\":1}}],[\"小于consumequeue中保存的最大commitlog物理偏移量\",{\"1\":{\"285\":1}}],[\"小时的索引文件大小就会达到\",{\"1\":{\"447\":1}}],[\"小时内\",{\"1\":{\"442\":1}}],[\"小时就过期\",{\"1\":{\"386\":1}}],[\"小时\",{\"1\":{\"386\":1,\"447\":1,\"700\":1,\"872\":1}}],[\"小消息实时生产的\",{\"1\":{\"240\":1}}],[\"小的数组成的列表\",{\"1\":{\"34\":1}}],[\"交互模式\",{\"1\":{\"691\":1}}],[\"交互流程\",{\"0\":{\"669\":1}}],[\"交互的客户端实例\",{\"1\":{\"470\":1}}],[\"交互\",{\"0\":{\"465\":1}}],[\"交换\",{\"1\":{\"245\":1}}],[\"交换器和仲裁队列一起使用不太合适\",{\"1\":{\"234\":1}}],[\"交付与运维系统的方式变的越发复杂\",{\"1\":{\"126\":1}}],[\"倍左右\",{\"1\":{\"370\":1,\"373\":1}}],[\"倍性能的提升\",{\"1\":{\"262\":1}}],[\"倍\",{\"1\":{\"233\":1,\"234\":1,\"254\":1,\"370\":1}}],[\"条目中的哈希码进行过滤\",{\"1\":{\"694\":1}}],[\"条数据\",{\"1\":{\"244\":4,\"537\":1}}],[\"条消息\",{\"1\":{\"234\":1,\"610\":2,\"708\":1}}],[\"条消息存储到集群中\",{\"1\":{\"233\":1}}],[\"条\",{\"1\":{\"233\":1,\"624\":1,\"738\":1,\"750\":1}}],[\"条件是a\",{\"1\":{\"34\":1}}],[\"惰性队列\",{\"1\":{\"231\":1}}],[\"超时时间\",{\"1\":{\"231\":1}}],[\"超过该时间后\",{\"1\":{\"390\":1}}],[\"超过\",{\"1\":{\"144\":1,\"384\":1}}],[\"总结一下\",{\"1\":{\"699\":1}}],[\"总结一下用到的优化方法主要有\",{\"1\":{\"437\":1}}],[\"总结起来\",{\"1\":{\"229\":1}}],[\"总体利用率达到\",{\"1\":{\"135\":1}}],[\"唯一的创建\",{\"1\":{\"664\":1,\"744\":1}}],[\"唯一的触发点是一个重平衡线程\",{\"1\":{\"648\":1}}],[\"唯一的影响是网络使用率\",{\"1\":{\"229\":1}}],[\"唯一的区别就是在客户端定义队列的时候需要定义成仲裁队列\",{\"1\":{\"229\":1}}],[\"共用一个类\",{\"1\":{\"389\":1}}],[\"共用了一个通用的解析方法\",{\"1\":{\"262\":1}}],[\"共享\",{\"1\":{\"233\":1,\"234\":1}}],[\"共识协议\",{\"1\":{\"228\":1}}],[\"共识协议逐渐成为了工业上大量使用的分布式共识协议\",{\"1\":{\"227\":1}}],[\"共识算法的一个变种\",{\"1\":{\"227\":1}}],[\"共注入十次主节点网络分区故障\",{\"1\":{\"134\":1}}],[\"老消费者的消费任务可能还没有结束\",{\"1\":{\"728\":1}}],[\"老消息都不会被复制\",{\"1\":{\"211\":1}}],[\"老的进度不需要\",{\"1\":{\"664\":1,\"744\":1}}],[\"老的消息不进行同步\",{\"1\":{\"226\":1}}],[\"老版本的延迟消息流程和源码解析可以看这篇文章\",{\"1\":{\"370\":1}}],[\"老版本中\",{\"1\":{\"370\":1}}],[\"几小时或者更多时间去同步消息\",{\"1\":{\"226\":1}}],[\"几分钟以上\",{\"1\":{\"146\":1}}],[\"运算\",{\"1\":{\"842\":2}}],[\"运维人员\",{\"1\":{\"498\":1}}],[\"运维人员必须做出选择\",{\"1\":{\"226\":1}}],[\"运用顺序读写\",{\"1\":{\"394\":1}}],[\"运行的时候不断尝试从队列中取出拉取请求执行消息拉取动作\",{\"1\":{\"672\":1}}],[\"运行的脚本下面添加\",{\"1\":{\"601\":1}}],[\"运行脚本\",{\"1\":{\"601\":1}}],[\"运行脚本之后\",{\"1\":{\"592\":1}}],[\"运行之后会启动两个\",{\"1\":{\"595\":1}}],[\"运行如下命令\",{\"1\":{\"594\":1}}],[\"运行如下代码使用\",{\"1\":{\"7\":1}}],[\"运行机制复杂\",{\"1\":{\"462\":1}}],[\"运行所有消息\",{\"1\":{\"276\":1}}],[\"运行时诊断\",{\"0\":{\"106\":1}}],[\"运行字符串的命令并捕捉结果\",{\"1\":{\"93\":1}}],[\"运行\",{\"1\":{\"74\":1,\"178\":1}}],[\"运行程序的不同方式\",{\"0\":{\"74\":1}}],[\"运行测试\",{\"0\":{\"10\":1}}],[\"避免\",{\"0\":{\"760\":1}}],[\"避免订阅关系不一致导致消息丢失\",{\"0\":{\"759\":1}}],[\"避免同一个服务器上的多个生产者实例名相同\",{\"1\":{\"567\":1}}],[\"避免了对延迟消息重新排序\",{\"1\":{\"445\":1}}],[\"避免动态扩容\",{\"1\":{\"437\":1}}],[\"避免扩容\",{\"1\":{\"429\":1}}],[\"避免无谓的\",{\"0\":{\"426\":1,\"427\":1}}],[\"避免其被多次调用\",{\"0\":{\"421\":1}}],[\"避免每次调用都重新计算和创建字符串对象\",{\"1\":{\"420\":1}}],[\"避免多余对象产生\",{\"1\":{\"420\":1}}],[\"避免多余的字符串对象产生\",{\"1\":{\"420\":1}}],[\"避免多次调用\",{\"1\":{\"416\":1}}],[\"避免一些坑\",{\"1\":{\"383\":1}}],[\"避免消息丢失\",{\"1\":{\"226\":1}}],[\"避免重启应用\",{\"0\":{\"118\":1}}],[\"已知的最大队列数量\",{\"1\":{\"693\":1}}],[\"已投递位移\",{\"1\":{\"452\":1}}],[\"已投递时间\",{\"1\":{\"452\":1}}],[\"已经在磁盘中\",{\"1\":{\"797\":1}}],[\"已经被\",{\"1\":{\"796\":1}}],[\"已经被标记为\",{\"1\":{\"656\":1}}],[\"已经拉取到足够的消息\",{\"1\":{\"790\":1}}],[\"已经获取且未过期\",{\"1\":{\"738\":1}}],[\"已经\",{\"1\":{\"474\":1}}],[\"已经投递的定时消息文件可以被删除\",{\"1\":{\"448\":1}}],[\"已经投递过的那些文件\",{\"1\":{\"387\":1}}],[\"已经支持了异步投递\",{\"1\":{\"445\":1}}],[\"已经放入\",{\"1\":{\"403\":1}}],[\"已经有一个队列复制的实现\",{\"1\":{\"225\":1}}],[\"已废弃\",{\"1\":{\"317\":1}}],[\"已导出函数相当于公共方法\",{\"1\":{\"30\":1}}],[\"保证同一时刻只有一个消费者可以拉取同一个\",{\"1\":{\"790\":1}}],[\"保证同一时间只有一个消费者可以拉取该队列的消息\",{\"1\":{\"773\":1}}],[\"保证同一时间只有一个消费者在消费\",{\"1\":{\"622\":1}}],[\"保证每个消费者都有队列消费\",{\"1\":{\"787\":1}}],[\"保证每个消费者的分配的结果幂等\",{\"1\":{\"647\":1}}],[\"保证处理队列的\",{\"1\":{\"738\":1}}],[\"保证消费线程池中消费这个队列的最多只有一个线程\",{\"1\":{\"738\":1}}],[\"保证消费速度\",{\"1\":{\"724\":1}}],[\"保证该队列消费完之前不拉取新的消息\",{\"1\":{\"727\":1}}],[\"保证就算有多个线程同时消费一个队列\",{\"1\":{\"727\":1}}],[\"保证一个队列同时仅被一个消费线程消费\",{\"0\":{\"727\":1}}],[\"保证顺序性\",{\"1\":{\"724\":1}}],[\"保证所有消费者分配的结果一致\",{\"1\":{\"663\":1}}],[\"保存重试消息到存储\",{\"1\":{\"800\":1}}],[\"保存源消息的\",{\"1\":{\"718\":1}}],[\"保存一个缓存表\",{\"1\":{\"710\":1}}],[\"保存这些消息\",{\"1\":{\"675\":1}}],[\"保存生产者消费者组信息\",{\"1\":{\"638\":1}}],[\"保存路由信息\",{\"1\":{\"638\":1}}],[\"保存元数据\",{\"1\":{\"638\":1}}],[\"保存元组到磁盘\",{\"0\":{\"100\":1}}],[\"保存在\",{\"1\":{\"623\":1,\"773\":1}}],[\"保存在消费者本地\",{\"1\":{\"623\":1}}],[\"保存在磁盘上的一种文件\",{\"1\":{\"297\":1}}],[\"保存在磁盘中\",{\"1\":{\"266\":1}}],[\"保存上报的路由信息\",{\"0\":{\"473\":1,\"491\":1}}],[\"保存时间之内任意时间的延迟消息实现\",{\"1\":{\"368\":1}}],[\"保存时间限制\",{\"1\":{\"367\":1}}],[\"保存时间的限制\",{\"1\":{\"353\":1}}],[\"保存到位数组中\",{\"1\":{\"851\":1}}],[\"保存到消费者过滤信息中\",{\"1\":{\"850\":1}}],[\"保存到消息存储\",{\"1\":{\"576\":1}}],[\"保存到\",{\"1\":{\"359\":1,\"710\":1,\"850\":1}}],[\"保存消息时由保存的偏移量生成\",{\"1\":{\"419\":1}}],[\"保存消息时检查是否是延迟消息\",{\"1\":{\"357\":1}}],[\"保存消息\",{\"1\":{\"357\":1}}],[\"保存该次consumer拉取请求\",{\"1\":{\"342\":1}}],[\"保存\",{\"0\":{\"779\":1},\"1\":{\"342\":1,\"464\":3,\"793\":1}}],[\"保存的消息数据都有一个过期时间\",{\"1\":{\"444\":1}}],[\"保存的\",{\"1\":{\"309\":1}}],[\"保存了一个链表\",{\"1\":{\"451\":1}}],[\"保存了一个\",{\"1\":{\"267\":1,\"638\":1}}],[\"保障数据的高可用和安全性\",{\"1\":{\"225\":1}}],[\"莫属\",{\"1\":{\"225\":1}}],[\"写缓冲区水位配置\",{\"0\":{\"819\":1},\"1\":{\"884\":1}}],[\"写到后面发现消费涉及到的内容太多\",{\"1\":{\"606\":1}}],[\"写队列数量\",{\"1\":{\"484\":1}}],[\"写数据的耗时占比比较大\",{\"1\":{\"431\":1}}],[\"写数据是完全写内存\",{\"1\":{\"403\":1}}],[\"写消息时写堆外内存\",{\"1\":{\"403\":1}}],[\"写入后会在由\",{\"1\":{\"820\":1}}],[\"写入的时候\",{\"1\":{\"820\":1}}],[\"写入索引项\",{\"1\":{\"817\":1}}],[\"写入失败\",{\"1\":{\"817\":1}}],[\"写入consumequeue\",{\"1\":{\"817\":2}}],[\"写入过程首先会获取写锁\",{\"1\":{\"473\":1}}],[\"写入内存中的路由表\",{\"1\":{\"473\":1}}],[\"写入消息时主要面对堆外内存\",{\"1\":{\"403\":1}}],[\"写入一个任意值\",{\"1\":{\"402\":1}}],[\"写入时就从一个固定位置一直写下去\",{\"1\":{\"396\":1}}],[\"写入hash槽\",{\"1\":{\"317\":1}}],[\"写入三个参数\",{\"1\":{\"285\":1}}],[\"写入放大\",{\"0\":{\"232\":1}}],[\"写内存映射文件\",{\"1\":{\"276\":1}}],[\"写一下就好了\",{\"1\":{\"256\":1}}],[\"写之前要先获取一个锁\",{\"1\":{\"253\":1,\"256\":1}}],[\"写\",{\"1\":{\"253\":1,\"256\":1,\"432\":1}}],[\"写请求同步给所有从队列\",{\"1\":{\"226\":1}}],[\"写于\",{\"1\":{\"225\":1}}],[\"写法\",{\"1\":{\"65\":1}}],[\"翻译自\",{\"1\":{\"225\":1}}],[\"仲裁队列使用在内存中\",{\"1\":{\"234\":1}}],[\"仲裁队列的所有消息一直会保存在内存中\",{\"1\":{\"235\":1}}],[\"仲裁队列的磁盘和内存配置与普通队列不同\",{\"1\":{\"232\":1}}],[\"仲裁队列的劣势\",{\"0\":{\"230\":1}}],[\"仲裁队列的优势\",{\"0\":{\"229\":1}}],[\"仲裁队列可以提供更高的性能\",{\"1\":{\"229\":1}}],[\"仲裁队列就是基于\",{\"1\":{\"227\":1}}],[\"仲裁队列旨在解决镜像队列的性能和同步问题\",{\"1\":{\"227\":1}}],[\"仲裁队列\",{\"0\":{\"225\":1,\"227\":1,\"234\":1},\"1\":{\"238\":1}}],[\"仲裁队列将是比传统队列镜像更好的选择\",{\"1\":{\"208\":1}}],[\"特殊消息类型\",{\"0\":{\"548\":1}}],[\"特别提需要确定的几个关键值\",{\"1\":{\"447\":1}}],[\"特别多时的消费速度\",{\"1\":{\"430\":1}}],[\"特别是在写性能要求高的程序时\",{\"1\":{\"2\":1}}],[\"特性就是为了解决\",{\"1\":{\"804\":1}}],[\"特性\",{\"1\":{\"804\":1}}],[\"特性更少\",{\"0\":{\"231\":1}}],[\"特性聚焦\",{\"0\":{\"225\":1},\"1\":{\"238\":1}}],[\"节省存储空间\",{\"1\":{\"816\":1}}],[\"节省消息传输大小\",{\"0\":{\"260\":1}}],[\"节省内存空间`\",{\"1\":{\"223\":1}}],[\"节点也会收到该重试消息\",{\"1\":{\"708\":1}}],[\"节点的重启会丢失所有数据\",{\"1\":{\"226\":1}}],[\"节点间进行队列数据的复制\",{\"1\":{\"225\":1}}],[\"节点记录的状态信息\",{\"1\":{\"207\":1}}],[\"节点为\",{\"1\":{\"207\":1}}],[\"节点时对应广播消息的生命周期结束\",{\"1\":{\"207\":1}}],[\"节点可以清除缓存的消息\",{\"1\":{\"207\":1}}],[\"节点收到自己发送的消息后\",{\"1\":{\"207\":1}}],[\"节点都会对消息进行缓存\",{\"1\":{\"207\":1}}],[\"节点都由一组进程组成\",{\"1\":{\"205\":1}}],[\"节点发出\",{\"1\":{\"207\":1}}],[\"节点中\",{\"1\":{\"205\":1}}],[\"节点中测试程序\",{\"1\":{\"88\":1}}],[\"节点上保持写一个事务日志\",{\"1\":{\"462\":1}}],[\"节点上\",{\"1\":{\"228\":1}}],[\"节点上则是\",{\"1\":{\"205\":1}}],[\"节点上回调处理是\",{\"1\":{\"205\":1}}],[\"节点组成的一个特殊的\",{\"1\":{\"205\":1}}],[\"节点和\",{\"1\":{\"205\":2}}],[\"节点名是在rabbitmqctl\",{\"1\":{\"190\":1}}],[\"节点名称\",{\"1\":{\"190\":1}}],[\"节点列表的所有节点上都初始化一个新的\",{\"1\":{\"102\":1}}],[\"节点里测试程序\",{\"1\":{\"88\":1}}],[\"节点是一个独立的\",{\"1\":{\"87\":1}}],[\"节点\",{\"1\":{\"87\":1,\"102\":1,\"207\":2,\"432\":1,\"708\":1,\"768\":1}}],[\"垃圾数据大小\",{\"1\":{\"221\":1}}],[\"较大的消息会保存在消息存储中\",{\"1\":{\"220\":1}}],[\"非管理员\",{\"1\":{\"498\":1}}],[\"非强制删除\",{\"1\":{\"390\":1}}],[\"非事务消息或commit类型的事务消息才执行分发\",{\"1\":{\"284\":1}}],[\"非全局的消息预取\",{\"1\":{\"231\":1}}],[\"非持久化消息\",{\"1\":{\"231\":1}}],[\"非持久化消息存储\",{\"1\":{\"220\":1}}],[\"非易失\",{\"1\":{\"97\":1}}],[\"大量定时消息的极端情况\",{\"0\":{\"878\":1}}],[\"大量地处理消息\",{\"1\":{\"523\":1}}],[\"大于2000\",{\"1\":{\"690\":1}}],[\"大于\",{\"1\":{\"472\":1,\"485\":1,\"715\":2}}],[\"大于阈值\",{\"1\":{\"436\":1}}],[\"大主流开源消息队列对定时消息的实现都有局限性\",{\"1\":{\"442\":1}}],[\"大部分情况下\",{\"1\":{\"437\":1}}],[\"大小和待消费消息偏移量差来判断\",{\"1\":{\"679\":1}}],[\"大小\",{\"1\":{\"600\":1}}],[\"大小为\",{\"1\":{\"424\":1}}],[\"大小的内存映射文件组成的文件队列\",{\"1\":{\"386\":1}}],[\"大幅度提升了延迟消息的性能\",{\"1\":{\"370\":1}}],[\"大致会经过从内存到磁盘再到内存的流程\",{\"1\":{\"214\":1}}],[\"大脑中最后几块拼图也终于拼上了\",{\"1\":{\"121\":1}}],[\"意味着暂停该消息队列的消息拉取\",{\"1\":{\"695\":1}}],[\"意味着暂时不返回给客户端\",{\"1\":{\"693\":1}}],[\"意味着processqueue中拉取的消息将停止消费\",{\"1\":{\"695\":1}}],[\"意味着将当前消息从\",{\"1\":{\"210\":1}}],[\"意思是把消息\",{\"1\":{\"79\":1}}],[\"管理器\",{\"0\":{\"742\":1}}],[\"管理的分布式锁\",{\"0\":{\"729\":1}}],[\"管理员\",{\"1\":{\"498\":2}}],[\"管理员需要做出决定\",{\"1\":{\"210\":1}}],[\"管理\",{\"1\":{\"461\":1,\"567\":1,\"732\":1}}],[\"管理界面配置\",{\"0\":{\"185\":1}}],[\"现在的延迟消息机制基于\",{\"1\":{\"367\":1}}],[\"现在都移动到了锁外面\",{\"1\":{\"257\":1}}],[\"现在\",{\"1\":{\"210\":1}}],[\"现实世界中的并发\",{\"0\":{\"77\":1}}],[\"设备和\",{\"1\":{\"804\":1}}],[\"设为\",{\"1\":{\"715\":1}}],[\"设为刚创建状态\",{\"1\":{\"631\":1}}],[\"设想这样一个问题\",{\"1\":{\"461\":1}}],[\"设定了\",{\"1\":{\"445\":1}}],[\"设一个布尔值\",{\"1\":{\"423\":1}}],[\"设计思路\",{\"0\":{\"879\":1}}],[\"设计了两层过滤机制\",{\"1\":{\"833\":1}}],[\"设计成有多个\",{\"1\":{\"646\":1}}],[\"设计篇\",{\"1\":{\"542\":1}}],[\"设计与实现\",{\"1\":{\"458\":1}}],[\"设计和实现\",{\"0\":{\"443\":1}}],[\"设计上预留了手动删除的接口\",{\"1\":{\"386\":1}}],[\"设计\",{\"0\":{\"732\":1},\"1\":{\"294\":1,\"305\":1,\"318\":1,\"521\":1,\"625\":1}}],[\"设计缺陷\",{\"0\":{\"210\":1,\"211\":1}}],[\"设置在构造消费队列时\",{\"1\":{\"828\":1,\"835\":1}}],[\"设置成集群名称\",{\"1\":{\"755\":1}}],[\"设置要拉取的偏移量\",{\"1\":{\"748\":1}}],[\"设置之前已经锁定过\",{\"1\":{\"748\":1}}],[\"设置了超时时间\",{\"1\":{\"732\":1}}],[\"设置延迟等级\",{\"1\":{\"717\":1}}],[\"设置延迟level为5\",{\"1\":{\"355\":1}}],[\"设置id\",{\"1\":{\"693\":1}}],[\"设置过滤表达式\",{\"1\":{\"690\":1}}],[\"设置该队列的最新拉取时间为当前时间\",{\"1\":{\"690\":1}}],[\"设置到返回体\",{\"1\":{\"683\":1}}],[\"设置每个队列的拉取流控\",{\"1\":{\"665\":1}}],[\"设置\",{\"1\":{\"657\":1,\"715\":1,\"761\":1,\"796\":1,\"798\":1,\"820\":1}}],[\"设置集群的\",{\"1\":{\"597\":1}}],[\"设置一个存储阈值\",{\"1\":{\"585\":1}}],[\"设置服务状态为\",{\"1\":{\"557\":1,\"567\":1}}],[\"设置状态为\",{\"1\":{\"557\":1}}],[\"设置消费开始时间戳\",{\"1\":{\"715\":1}}],[\"设置消费组名\",{\"1\":{\"540\":1}}],[\"设置消息属性\",{\"1\":{\"829\":1}}],[\"设置消息\",{\"1\":{\"826\":1}}],[\"设置消息的全局唯一\",{\"1\":{\"562\":1,\"573\":1}}],[\"设置消息轨迹类型\",{\"1\":{\"540\":1}}],[\"设置使用\",{\"1\":{\"414\":1}}],[\"设置队列的长度限制非常重要\",{\"1\":{\"235\":1}}],[\"设置为\",{\"1\":{\"198\":1}}],[\"设置专用的检测模型\",{\"1\":{\"128\":1}}],[\"设置输出内容为json\",{\"1\":{\"116\":1}}],[\"设置进程等待接收消息的最长时间\",{\"1\":{\"82\":1}}],[\"鼓励读者熟悉仲裁队列\",{\"1\":{\"208\":1}}],[\"旨在完全代替原有的镜像队列\",{\"1\":{\"208\":1}}],[\"广播\",{\"1\":{\"786\":1}}],[\"广播模式的消费者本地存储进度比较简单\",{\"1\":{\"702\":1}}],[\"广播模式消费进度管理\",{\"0\":{\"702\":1}}],[\"广播模式\",{\"1\":{\"623\":1,\"640\":1,\"642\":1,\"715\":1,\"738\":1,\"786\":1}}],[\"广播模式不支持顺序消费\",{\"1\":{\"622\":1}}],[\"广播模式下服务端不维护消费进度\",{\"1\":{\"610\":1}}],[\"广播模式下\",{\"1\":{\"610\":3,\"701\":1}}],[\"广播模式使用较少\",{\"1\":{\"610\":1}}],[\"广播消费模式下不支持\",{\"1\":{\"610\":2}}],[\"广播消费模式即全部的消息会广播分发到所有的消费者实例\",{\"1\":{\"610\":1}}],[\"广播消费模式\",{\"0\":{\"610\":1},\"1\":{\"610\":1,\"611\":1}}],[\"广播消息发送给节点b\",{\"1\":{\"207\":1}}],[\"广播一条内容为\",{\"1\":{\"207\":1}}],[\"顺带一提\",{\"1\":{\"820\":1}}],[\"顺便补上了之前遗漏的关于\",{\"1\":{\"256\":1}}],[\"顺着节点链表发送\",{\"1\":{\"207\":1}}],[\"顺着链表传送到所有的节点\",{\"1\":{\"206\":1}}],[\"顺序模式下\",{\"1\":{\"707\":1}}],[\"顺序消费模式下重试次数配置无效\",{\"1\":{\"761\":1}}],[\"顺序消费任务以时长计算\",{\"1\":{\"750\":1}}],[\"顺序消费任务\",{\"0\":{\"750\":1}}],[\"顺序消费时使用\",{\"1\":{\"746\":1}}],[\"顺序消费流程\",{\"0\":{\"739\":1}}],[\"顺序消费服务的消费线程池执行消费任务\",{\"1\":{\"739\":1}}],[\"顺序消费服务的定时任务会每\",{\"1\":{\"729\":1}}],[\"顺序消费服务中还包含了消费队列锁\",{\"1\":{\"707\":1}}],[\"顺序消费还有一个敌人\",{\"1\":{\"728\":1}}],[\"顺序消费的消费任务也由拉取任务提交\",{\"1\":{\"726\":1}}],[\"顺序消费的设计的要点主要有两个\",{\"1\":{\"724\":1}}],[\"顺序消费的设计和流程\",{\"1\":{\"723\":1}}],[\"顺序消费的大致原理是依靠两组锁\",{\"1\":{\"622\":1}}],[\"顺序消费\",{\"0\":{\"722\":1},\"1\":{\"744\":1,\"790\":2,\"884\":1}}],[\"顺序消费将会在下一篇进行讲解\",{\"1\":{\"697\":1}}],[\"顺序消费则使用\",{\"1\":{\"622\":1}}],[\"顺序消息逻辑主要在步骤\",{\"1\":{\"723\":1}}],[\"顺序消息\",{\"1\":{\"545\":1,\"610\":1,\"780\":1,\"793\":1}}],[\"顺序消息的配置\",{\"1\":{\"470\":1,\"488\":1}}],[\"顺序生产的方式为串行生产\",{\"1\":{\"622\":1}}],[\"顺序先分配第一个\",{\"1\":{\"617\":1}}],[\"顺序写\",{\"0\":{\"397\":1}}],[\"顺序读写相比于随机读写省去了大部分的寻址时间\",{\"1\":{\"396\":1}}],[\"顺序读写\",{\"0\":{\"396\":1}}],[\"顺序程序的错误处理\",{\"0\":{\"43\":1}}],[\"顺序编程补遗\",{\"0\":{\"49\":1}}],[\"顺序编程\",{\"0\":{\"19\":1}}],[\"仍然可以被写入\",{\"1\":{\"820\":1}}],[\"仍然被阻塞\",{\"1\":{\"160\":1}}],[\"仍会重试\",{\"1\":{\"620\":1}}],[\"仍旧进行协议相关的消息处理\",{\"1\":{\"205\":1}}],[\"综上所述\",{\"1\":{\"201\":1}}],[\"算法实现\",{\"1\":{\"201\":1}}],[\"算数表达式\",{\"0\":{\"51\":1}}],[\"效率更高\",{\"1\":{\"414\":1}}],[\"效率很低\",{\"1\":{\"410\":1}}],[\"效率较高\",{\"1\":{\"201\":1}}],[\"效果是\",{\"1\":{\"166\":1}}],[\"主动触发是由消费者的启动和停止触发的\",{\"1\":{\"656\":1}}],[\"主动触发模式可以通过以下配置来关闭\",{\"1\":{\"648\":1}}],[\"主动触发\",{\"1\":{\"648\":1}}],[\"主动推送消息到消费者\",{\"1\":{\"639\":1}}],[\"主动将消息推给消费者\",{\"1\":{\"672\":1}}],[\"主动将消息\",{\"1\":{\"614\":1}}],[\"主动权由消费者应用控制\",{\"1\":{\"613\":1}}],[\"主动从\",{\"1\":{\"613\":1}}],[\"主动更新后还是找不到路由信息\",{\"1\":{\"573\":1}}],[\"主动拉取\",{\"1\":{\"573\":1}}],[\"主动进行通知\",{\"1\":{\"326\":1}}],[\"主备\",{\"1\":{\"464\":1,\"469\":1}}],[\"主从同步只按顺序同步\",{\"1\":{\"450\":1}}],[\"主从同步\",{\"1\":{\"444\":1}}],[\"主从复制机制会在消息写入\",{\"1\":{\"249\":1}}],[\"主从复制流程概要\",{\"0\":{\"249\":1}}],[\"主从复制线程循环传输数据\",{\"1\":{\"246\":1}}],[\"主从复制和同步刷盘中重量级锁synchronized改为自旋锁\",{\"0\":{\"245\":1}}],[\"主从复制和同步刷盘中的生产消费模式\",{\"0\":{\"244\":1}}],[\"主从复制和同步刷盘都是多线程协作处理的\",{\"1\":{\"244\":1}}],[\"主从复制和同步刷流程中锁的优化\",{\"0\":{\"243\":1}}],[\"主流程上的分支操作\",{\"1\":{\"437\":1}}],[\"主线程直接返回\",{\"1\":{\"435\":1}}],[\"主节点地址\",{\"1\":{\"472\":1,\"490\":1}}],[\"主节点和从节点都会发送心跳和路由信息\",{\"1\":{\"472\":1}}],[\"主节点的角色会变为\",{\"1\":{\"373\":1}}],[\"主节点失效和消费者取消\",{\"0\":{\"198\":1}}],[\"主要为\",{\"1\":{\"852\":1}}],[\"主要用于\",{\"1\":{\"838\":1}}],[\"主要用于管理命令触发的消息消费\",{\"1\":{\"707\":1}}],[\"主要介绍并发消费者的消费和消费进度上报的流程\",{\"1\":{\"697\":1}}],[\"主要提供了通过\",{\"1\":{\"636\":1}}],[\"主要解决了原来\",{\"1\":{\"615\":1}}],[\"主要讲述\",{\"1\":{\"606\":1}}],[\"主要流程\",{\"0\":{\"531\":1}}],[\"主要是启动\",{\"1\":{\"480\":1}}],[\"主要是消息在\",{\"1\":{\"300\":1}}],[\"主要原因是\",{\"1\":{\"462\":1}}],[\"主要包含两个功能\",{\"1\":{\"461\":1}}],[\"主要优化了消息生产的速度和大量队列情况下消息消费的速度\",{\"1\":{\"437\":1}}],[\"主要的思想就是将原先的每条消息都通知一次转化为批通知\",{\"1\":{\"436\":1}}],[\"主要由两部分组成\",{\"1\":{\"222\":1}}],[\"主题路由信息\",{\"1\":{\"573\":1}}],[\"主题\",{\"1\":{\"287\":1,\"342\":1,\"664\":1,\"694\":1,\"744\":1}}],[\"主副本会直接从从副本中断的地方开始复制消息\",{\"1\":{\"229\":1}}],[\"主副本的选举也需要超过半数的副本同意才行\",{\"1\":{\"228\":1}}],[\"主副本再将这些命令复制到从副本\",{\"1\":{\"228\":1}}],[\"主队列和从队列分布在集群上\",{\"1\":{\"226\":1}}],[\"主队列和从队列会分布在集群的不同节点上\",{\"1\":{\"226\":1}}],[\"主队列到从队列的复制\",{\"1\":{\"226\":1}}],[\"主队列才会向生产者发送确认\",{\"1\":{\"226\":1}}],[\"主队列会将自己接收的读\",{\"1\":{\"226\":1}}],[\"主队列选择策略\",{\"0\":{\"193\":1}}],[\"主队列加上镜像\",{\"1\":{\"190\":1}}],[\"建议关闭主动触发\",{\"1\":{\"648\":1}}],[\"建议为消息指定\",{\"1\":{\"526\":1}}],[\"建议至少\",{\"1\":{\"254\":1}}],[\"建议复制到\",{\"1\":{\"195\":1}}],[\"建议设置的副本值为大多数节点n\",{\"1\":{\"190\":1}}],[\"键的方法可以定义主队列选择策略\",{\"1\":{\"193\":1}}],[\"键值对\",{\"1\":{\"40\":1}}],[\"插入和查询\",{\"0\":{\"314\":1}}],[\"插拔网线模拟网络异常的两个测试场景\",{\"1\":{\"192\":1}}],[\"插件可以将消息从一个\",{\"1\":{\"163\":1}}],[\"插件使用\",{\"0\":{\"162\":1},\"1\":{\"238\":1}}],[\"插件\",{\"1\":{\"6\":1,\"121\":1,\"122\":1,\"163\":2,\"168\":1}}],[\"无界\",{\"1\":{\"820\":1}}],[\"无限循环\",{\"1\":{\"688\":1}}],[\"无需等待\",{\"1\":{\"547\":1}}],[\"无需额外开发\",{\"1\":{\"448\":1}}],[\"无需考虑队列类型\",{\"1\":{\"229\":1}}],[\"无论是客户端还是服务端都需要检查一次这个消息的\",{\"1\":{\"424\":1}}],[\"无论我们使用什么语言编写的程序\",{\"1\":{\"399\":1}}],[\"无论什么情况下从节点都将被提升为主节点\",{\"1\":{\"192\":1}}],[\"无动作\",{\"1\":{\"378\":1}}],[\"无法达到任意时间定时\",{\"1\":{\"442\":1}}],[\"无法支持大规模使用\",{\"1\":{\"442\":1}}],[\"无法保证消息投递的顺序\",{\"1\":{\"374\":1}}],[\"无法同时投递多个延迟等级的消息\",{\"1\":{\"360\":1}}],[\"无法被消费者消费\",{\"1\":{\"356\":1}}],[\"无法并行\",{\"1\":{\"253\":1}}],[\"无法给出全面彻底的诊断建议\",{\"1\":{\"127\":1}}],[\"值计算出\",{\"1\":{\"317\":1}}],[\"值的消息可能会被保存到不同的索引文件当中\",{\"1\":{\"307\":1}}],[\"值\",{\"1\":{\"306\":2}}],[\"值得重申的是\",{\"1\":{\"191\":1}}],[\"值查询表\",{\"1\":{\"97\":1}}],[\"您可以手动完全同步队列\",{\"1\":{\"191\":1}}],[\"磁盘的顺序读写性能要远好于随机读写\",{\"1\":{\"396\":1}}],[\"磁盘满了\",{\"1\":{\"390\":1}}],[\"磁盘空间大于85\",{\"1\":{\"390\":1}}],[\"磁盘空间不充足\",{\"1\":{\"390\":1}}],[\"磁盘空间是否不足\",{\"1\":{\"390\":1}}],[\"磁盘空间超过\",{\"1\":{\"384\":1}}],[\"磁盘容量达到\",{\"1\":{\"386\":1}}],[\"磁盘使用\",{\"0\":{\"232\":1}}],[\"磁盘\",{\"1\":{\"195\":1}}],[\"磁盘i\",{\"1\":{\"190\":1,\"858\":1}}],[\"磁盘低水位\",{\"0\":{\"146\":1}}],[\"队列剩余消息\",{\"1\":{\"790\":1}}],[\"队列剩余消息数量\",{\"1\":{\"790\":1}}],[\"队列中的第一个消息延迟\",{\"1\":{\"876\":1}}],[\"队列中的多个消息并发消费\",{\"1\":{\"723\":1}}],[\"队列中消息的逻辑\",{\"1\":{\"798\":1}}],[\"队列中剩余的消息数量\",{\"1\":{\"789\":1}}],[\"队列分配完成后对队列进行解锁和加锁\",{\"1\":{\"744\":1}}],[\"队列分配策略\",{\"1\":{\"658\":1}}],[\"队列间并发消费\",{\"1\":{\"723\":1}}],[\"队列offset\",{\"1\":{\"693\":1}}],[\"队列负载机制\",{\"0\":{\"617\":1}}],[\"队列负载机制与重平衡\",{\"0\":{\"616\":1,\"621\":1}}],[\"队列独占\",{\"1\":{\"615\":1}}],[\"队列级别顺序消息\",{\"1\":{\"548\":1}}],[\"队列信息\",{\"1\":{\"473\":1,\"491\":1}}],[\"队列信息中包含了其所在的\",{\"1\":{\"464\":1}}],[\"队列路由信息发送给\",{\"1\":{\"472\":1}}],[\"队列元数据\",{\"1\":{\"470\":1,\"488\":1}}],[\"队列下的消费\",{\"1\":{\"433\":1}}],[\"队列编号\",{\"1\":{\"342\":1}}],[\"队列id\",{\"1\":{\"287\":1,\"694\":1}}],[\"队列仍然没有办法恢复\",{\"1\":{\"236\":1}}],[\"队列仍然可以提供服务的效果\",{\"1\":{\"225\":1}}],[\"队列的路由信息\",{\"1\":{\"465\":1}}],[\"队列的第一个文件\",{\"1\":{\"386\":1}}],[\"队列的规划和监控边得比普通场景下更为重要\",{\"1\":{\"235\":1}}],[\"队列的master位于节点a上\",{\"1\":{\"192\":1}}],[\"队列消息不断堆积\",{\"1\":{\"235\":1}}],[\"队列长度限制可用\",{\"1\":{\"231\":1}}],[\"队列结构\",{\"0\":{\"222\":1}}],[\"队列索引\",{\"1\":{\"220\":1}}],[\"队列索引和消息存储\",{\"1\":{\"220\":1}}],[\"队列持久化仅仅指的是队列元数据持久化\",{\"1\":{\"217\":1}}],[\"队列持久化\",{\"0\":{\"217\":1}}],[\"队列master进程所在的节点是2进2出\",{\"1\":{\"202\":1}}],[\"队列\",{\"1\":{\"201\":1,\"222\":1,\"231\":1,\"787\":1,\"789\":1,\"791\":1,\"795\":1}}],[\"队列同步是一个阻塞操作\",{\"1\":{\"191\":1}}],[\"队列将自动同步\",{\"1\":{\"191\":1}}],[\"队列将被镜像到该节点\",{\"1\":{\"190\":1}}],[\"队列被镜像到节点名中列出的节点\",{\"1\":{\"190\":1}}],[\"队列跨集群中的所有节点镜像\",{\"1\":{\"190\":1}}],[\"队列镜像将根据配置的镜像提升策略自动提升到主服务器\",{\"1\":{\"190\":1}}],[\"点定时了\",{\"1\":{\"878\":1}}],[\"点删一次\",{\"1\":{\"390\":1}}],[\"点这个小时都是删除文件的时间窗\",{\"1\":{\"390\":1}}],[\"点这一小时中每\",{\"1\":{\"386\":1}}],[\"点开始\",{\"1\":{\"386\":1}}],[\"点指的是\",{\"1\":{\"386\":1}}],[\"点\",{\"1\":{\"384\":1,\"386\":2,\"390\":1}}],[\"点击队列名称可以进入查看队列详细信息\",{\"1\":{\"188\":1}}],[\"点语法\",{\"1\":{\"41\":1}}],[\"镜像\",{\"0\":{\"592\":1}}],[\"镜像准备\",{\"0\":{\"591\":1}}],[\"镜像打包实现\",{\"1\":{\"589\":1}}],[\"镜像已恢复在线\",{\"1\":{\"210\":1}}],[\"镜像到所有节点会增加所有集群节点的负载\",{\"1\":{\"195\":1}}],[\"镜像到所有节点会给所有集群节点带来额外的负担\",{\"1\":{\"190\":1}}],[\"镜像数=节点数\",{\"1\":{\"190\":1}}],[\"镜像策略\",{\"0\":{\"190\":1}}],[\"镜像定义\",{\"1\":{\"185\":1}}],[\"镜像队列会选择一个主队列和多个从队列\",{\"1\":{\"226\":1}}],[\"镜像队列主要的问题是消息同步的性能\",{\"1\":{\"226\":1}}],[\"镜像队列主节点出现故障时\",{\"1\":{\"192\":1}}],[\"镜像队列是实现数据高可用的唯一手段\",{\"1\":{\"225\":1}}],[\"镜像队列master故障后的处理\",{\"1\":{\"212\":1}}],[\"镜像队列有如下几个设计缺陷\",{\"1\":{\"209\":1}}],[\"镜像队列有许多配置参数\",{\"1\":{\"189\":1}}],[\"镜像队列最大的问题是其同步算法造成的低性能\",{\"1\":{\"209\":1}}],[\"镜像队列实践\",{\"0\":{\"208\":1}}],[\"镜像队列同样由这两部分组成\",{\"1\":{\"205\":1}}],[\"镜像队列同时支持生产者确认和事务机制\",{\"1\":{\"196\":1}}],[\"镜像队列结构\",{\"0\":{\"205\":1}}],[\"镜像队列中的\",{\"1\":{\"201\":1}}],[\"镜像队列的性能会比较低下\",{\"1\":{\"226\":1}}],[\"镜像队列的设计缺陷\",{\"0\":{\"226\":1}}],[\"镜像队列的缺点\",{\"0\":{\"209\":1}}],[\"镜像队列的实现原理\",{\"0\":{\"203\":1}}],[\"镜像队列的gm算法实现\",{\"1\":{\"201\":1}}],[\"镜像队列的\",{\"1\":{\"201\":1}}],[\"镜像队列的数据流\",{\"0\":{\"200\":1},\"1\":{\"212\":1}}],[\"镜像队列原理\",{\"0\":{\"199\":1}}],[\"镜像队列显示的蓝色\",{\"1\":{\"188\":1}}],[\"镜像队列配置观测\",{\"0\":{\"188\":1}}],[\"镜像队列概述\",{\"0\":{\"182\":1}}],[\"镜像队列通过将一个队列镜像\",{\"1\":{\"181\":1}}],[\"镜像队列\",{\"0\":{\"180\":1},\"1\":{\"182\":1,\"212\":1,\"238\":1}}],[\"参照\",{\"1\":{\"447\":1}}],[\"参数指定的时间\",{\"1\":{\"777\":1}}],[\"参数\",{\"1\":{\"775\":1}}],[\"参数无效\",{\"1\":{\"758\":1}}],[\"参数来设置开启\",{\"1\":{\"561\":1}}],[\"参数进行配置\",{\"1\":{\"353\":1}}],[\"参数表示是否定时刷盘\",{\"1\":{\"255\":1}}],[\"参数还是改为\",{\"1\":{\"253\":1}}],[\"参数解释\",{\"1\":{\"185\":1}}],[\"参考\",{\"1\":{\"122\":1}}],[\"参考资料\",{\"0\":{\"15\":1,\"161\":1,\"173\":1,\"212\":1,\"224\":1,\"263\":1,\"294\":1,\"318\":1,\"349\":1,\"404\":1,\"458\":1,\"494\":1,\"521\":1,\"542\":1,\"577\":1,\"625\":1,\"801\":1,\"818\":1,\"853\":1,\"858\":1,\"868\":1,\"883\":1}}],[\"副本镜像队列\",{\"1\":{\"233\":1}}],[\"副本镜像\",{\"1\":{\"185\":1}}],[\"副本同键\",{\"1\":{\"98\":1}}],[\"策略使用正则表达式来配置需要应用镜像策略的队列名称\",{\"1\":{\"185\":1}}],[\"推\",{\"1\":{\"765\":1}}],[\"推送\",{\"1\":{\"765\":1}}],[\"推送到客户端\",{\"1\":{\"667\":1}}],[\"推模式并发消费流程\",{\"0\":{\"708\":1}}],[\"推模式并发消费\",{\"0\":{\"706\":1,\"713\":1}}],[\"推模式并发消费主要的步骤为\",{\"1\":{\"699\":1}}],[\"推模式并发消费交互流程\",{\"0\":{\"699\":1}}],[\"推模式下有并发消费和顺序消费两种消费模式\",{\"1\":{\"699\":1}}],[\"推模式消费逻辑从消息拉取开始\",{\"1\":{\"708\":1}}],[\"推模式消费也是通过拉取消息请求来拉取消息\",{\"1\":{\"672\":1}}],[\"推模式消费者在处理消费结果的逻辑中\",{\"1\":{\"704\":1}}],[\"推模式消费者的拉取为异步调用\",{\"1\":{\"681\":1}}],[\"推模式消费者拉取\",{\"0\":{\"672\":1}}],[\"推模式消费者启动或恢复时\",{\"1\":{\"648\":1}}],[\"推模式消费者实际内部也是通过拉取消息的方式进行消息拉取\",{\"1\":{\"639\":1}}],[\"推模式消费者实现相关的类图如下所示\",{\"1\":{\"639\":1}}],[\"推模式消费者实现\",{\"0\":{\"639\":1}}],[\"推模式消费者自动监听推送过来的消息并进行消费\",{\"1\":{\"639\":1}}],[\"推模式消费者消费步骤更简单\",{\"1\":{\"637\":1}}],[\"推模式消费者接口就定义了这些方法\",{\"1\":{\"637\":1}}],[\"推模式消费者接口\",{\"0\":{\"637\":1},\"1\":{\"637\":1}}],[\"推消费者实现\",{\"1\":{\"690\":1}}],[\"推消费者还支持并发消费和顺序消费\",{\"1\":{\"639\":1}}],[\"推荐使用\",{\"1\":{\"658\":2}}],[\"推荐使用异步方式\",{\"1\":{\"547\":1}}],[\"推荐使用同步方式\",{\"1\":{\"547\":1}}],[\"推荐使用可靠的磁盘\",{\"1\":{\"236\":1}}],[\"推出了\",{\"1\":{\"181\":1}}],[\"推动云原生架构不断演进\",{\"1\":{\"136\":1}}],[\"垂直扩容指的是提高\",{\"1\":{\"181\":1}}],[\"存到\",{\"1\":{\"843\":1}}],[\"存到布隆过滤器中\",{\"1\":{\"843\":1}}],[\"存到本地路由表\",{\"1\":{\"491\":1}}],[\"存盘\",{\"1\":{\"797\":1}}],[\"存入位数组\",{\"1\":{\"843\":1}}],[\"存入的原理是\",{\"1\":{\"842\":1}}],[\"存入磁盘\",{\"1\":{\"782\":1}}],[\"存入内存和磁盘\",{\"1\":{\"778\":1}}],[\"存入之后统计数据并返回结果\",{\"1\":{\"718\":1}}],[\"存入属性\",{\"1\":{\"708\":1,\"718\":1}}],[\"存入\",{\"1\":{\"541\":1,\"718\":1,\"843\":1}}],[\"存入轨迹上下文\",{\"1\":{\"540\":1}}],[\"存入调用上下文\",{\"1\":{\"540\":1}}],[\"存活状态信息\",{\"1\":{\"491\":1}}],[\"存活状态\",{\"1\":{\"473\":1,\"474\":1,\"491\":1}}],[\"存在消费队列中消息的\",{\"1\":{\"838\":1}}],[\"存在消息丢失的可能\",{\"1\":{\"610\":1}}],[\"存在一种边界条件\",{\"1\":{\"735\":1}}],[\"存在同时运行的多个任务都是消费同一个队列的可能\",{\"1\":{\"726\":1}}],[\"存在\",{\"1\":{\"530\":1,\"813\":1}}],[\"存在扩容可能性\",{\"1\":{\"429\":1}}],[\"存在性能上限\",{\"1\":{\"181\":1}}],[\"存放其他地方\",{\"1\":{\"675\":1}}],[\"存放消费者的拉取请求\",{\"1\":{\"672\":1}}],[\"存放到消息\",{\"1\":{\"359\":1,\"363\":1}}],[\"存放数据\",{\"1\":{\"307\":1}}],[\"存放一些基本信息\",{\"1\":{\"307\":1}}],[\"存储所有消费者名称经过\",{\"1\":{\"843\":1}}],[\"存储中匹配也由一个线程\",{\"1\":{\"783\":1}}],[\"存储consumer消费进度\",{\"1\":{\"693\":1}}],[\"存储消费者消费进度\",{\"1\":{\"683\":1}}],[\"存储线程池发送任务\",{\"1\":{\"541\":1}}],[\"存储每个消息轨迹的上下文\",{\"1\":{\"541\":1}}],[\"存储时间\",{\"1\":{\"537\":1}}],[\"存储在内存中\",{\"1\":{\"810\":1}}],[\"存储在\",{\"1\":{\"530\":1}}],[\"存储在堆外内存的数据会丢失\",{\"1\":{\"403\":1}}],[\"存储集群中所有\",{\"1\":{\"469\":1}}],[\"存储已经搞定了\",{\"1\":{\"450\":1}}],[\"存储和投递\",{\"1\":{\"450\":1}}],[\"存储最终方案\",{\"0\":{\"449\":1}}],[\"存储设计面临的两个最大的问题就是\",{\"1\":{\"446\":1}}],[\"存储设计是最重要的\",{\"1\":{\"446\":1}}],[\"存储设计\",{\"0\":{\"446\":1,\"532\":1}}],[\"存储包\",{\"1\":{\"347\":1}}],[\"存储\",{\"1\":{\"310\":1,\"490\":1,\"581\":2,\"623\":1}}],[\"存储的\",{\"1\":{\"585\":1}}],[\"存储的每个值是在索引文件中\",{\"1\":{\"307\":1}}],[\"存储的消息的最大物理偏移量\",{\"1\":{\"307\":1}}],[\"存储的消息的最小物理偏移量\",{\"1\":{\"307\":1}}],[\"存储的一部分\",{\"1\":{\"297\":1}}],[\"存储功能\",{\"1\":{\"297\":1}}],[\"存储层查询消息的入口是\",{\"1\":{\"286\":1}}],[\"存储系统的一部分\",{\"1\":{\"266\":1}}],[\"存储模型\",{\"1\":{\"233\":1}}],[\"存储结构\",{\"0\":{\"220\":1,\"307\":1}}],[\"存储机制\",{\"0\":{\"213\":1,\"219\":1},\"1\":{\"238\":1}}],[\"存储数据\",{\"0\":{\"97\":1}}],[\"卸载\",{\"0\":{\"179\":1}}],[\"全局ip白名单\",{\"1\":{\"503\":1}}],[\"全局流控时\",{\"1\":{\"146\":1}}],[\"全局流控\",{\"0\":{\"146\":1}}],[\"全都要\",{\"1\":{\"445\":1}}],[\"全部客户端id\",{\"1\":{\"787\":1}}],[\"全部消息队列\",{\"1\":{\"787\":1}}],[\"全部任务扫描完毕后等待一会\",{\"1\":{\"378\":1}}],[\"全部安装包列表\",{\"1\":{\"178\":1}}],[\"去\",{\"1\":{\"178\":1}}],[\"去除字符串末尾占位符\",{\"0\":{\"260\":1}}],[\"去除\",{\"0\":{\"140\":1,\"424\":1}}],[\"去除换行符\",{\"0\":{\"137\":1},\"1\":{\"141\":1}}],[\"选择最新的\",{\"1\":{\"593\":1}}],[\"选择发送的队列\",{\"1\":{\"572\":1}}],[\"选择队列\",{\"1\":{\"572\":1}}],[\"选择队列的逻辑由\",{\"1\":{\"561\":1}}],[\"选择下一个队列\",{\"1\":{\"561\":1,\"572\":1}}],[\"选择消息队列\",{\"0\":{\"561\":1,\"572\":1},\"1\":{\"558\":1,\"570\":2}}],[\"选择自研路由中心呢\",{\"1\":{\"462\":1}}],[\"选择客户机声明队列连接到的节点\",{\"1\":{\"193\":1}}],[\"选择承载最小绑定主机数量的节点\",{\"1\":{\"193\":1}}],[\"选择\",{\"1\":{\"176\":2}}],[\"选择性接收\",{\"0\":{\"83\":1}}],[\"状态信息\",{\"1\":{\"464\":1,\"469\":1,\"487\":1}}],[\"状态\",{\"1\":{\"171\":2}}],[\"绑定\",{\"1\":{\"170\":2,\"233\":1}}],[\"两种类型的数据\",{\"1\":{\"336\":1}}],[\"两种分布式模型\",{\"0\":{\"87\":1}}],[\"两个消费服务都实现了\",{\"1\":{\"707\":1}}],[\"两个消费服务实现中都包含了\",{\"1\":{\"707\":1}}],[\"两个参数来设置线程池中的线程个数\",{\"1\":{\"758\":1}}],[\"两个参数来记录当前投递状态\",{\"1\":{\"452\":1}}],[\"两个参数分别控制正常关闭\",{\"1\":{\"192\":1}}],[\"两个参数让用户决策是保证队列的可用性\",{\"1\":{\"192\":1}}],[\"两个\",{\"1\":{\"168\":1,\"306\":1}}],[\"间的复制\",{\"1\":{\"166\":1}}],[\"间隔为30秒\",{\"1\":{\"134\":1}}],[\"减少磁盘占用\",{\"1\":{\"450\":1}}],[\"减少通知开销以提升性能\",{\"1\":{\"436\":1}}],[\"减少通知次数\",{\"1\":{\"436\":1}}],[\"减少锁的占用\",{\"1\":{\"403\":1}}],[\"减少了复制\",{\"1\":{\"261\":1}}],[\"减少字节数组拷贝\",{\"0\":{\"250\":1}}],[\"减少消息消费的时延\",{\"1\":{\"164\":1}}],[\"减少信用\",{\"0\":{\"157\":1}}],[\"授予它更多信用\",{\"1\":{\"160\":1}}],[\"都需要实现\",{\"1\":{\"838\":1}}],[\"都需要用用户名和密码新建一个\",{\"1\":{\"504\":1}}],[\"都被设计成先尝试放入内存中匹配\",{\"1\":{\"781\":1}}],[\"都涉及到从存储中\",{\"1\":{\"778\":1}}],[\"都涉及到其他方面的一些取舍\",{\"1\":{\"444\":1}}],[\"都要进行重平衡操作\",{\"1\":{\"769\":1}}],[\"都消费相同的\",{\"1\":{\"609\":1}}],[\"都未启动成功\",{\"1\":{\"599\":1}}],[\"都将会是\",{\"1\":{\"595\":1}}],[\"都可以存储消息轨迹数据\",{\"1\":{\"532\":1}}],[\"都是在消息生产到\",{\"1\":{\"872\":1}}],[\"都是消费失败的\",{\"1\":{\"715\":2}}],[\"都是消费者收到\",{\"1\":{\"656\":1}}],[\"都是构建消费请求\",{\"1\":{\"707\":1}}],[\"都是\",{\"1\":{\"389\":1,\"414\":1}}],[\"都保存所有对应延迟等级的定时消息\",{\"1\":{\"356\":1}}],[\"都对应一个\",{\"1\":{\"266\":1}}],[\"都挂载\",{\"1\":{\"240\":1}}],[\"都会封装成消息进行定时投递\",{\"1\":{\"783\":1}}],[\"都会判断是否持有\",{\"1\":{\"729\":1}}],[\"都会遍历\",{\"1\":{\"474\":1}}],[\"都会有一个消费队列\",{\"1\":{\"387\":1}}],[\"都会进行检查和删除\",{\"1\":{\"386\":1}}],[\"都会进行\",{\"1\":{\"384\":1}}],[\"都会从链表的头部插入\",{\"1\":{\"307\":1}}],[\"都会创建一个\",{\"1\":{\"275\":1}}],[\"都会发送一次消息和接收一次消息\",{\"1\":{\"201\":1}}],[\"都会向rabbit\",{\"1\":{\"159\":1}}],[\"都为\",{\"1\":{\"36\":1}}],[\"增量信息到\",{\"1\":{\"465\":1}}],[\"增加解锁尝试次数\",{\"1\":{\"745\":1}}],[\"增加定时任务\",{\"1\":{\"481\":2}}],[\"增加集群的抗压能力\",{\"1\":{\"462\":1}}],[\"增加维护成本\",{\"1\":{\"448\":1}}],[\"增加信用值\",{\"0\":{\"159\":1}}],[\"增强系统的可观测性\",{\"1\":{\"126\":1}}],[\"则一定不需要消费\",{\"1\":{\"852\":1}}],[\"则消费者名称的位映射\",{\"1\":{\"851\":1}}],[\"则消费逻辑已经结束\",{\"1\":{\"708\":1}}],[\"则为支持重试\",{\"1\":{\"838\":1}}],[\"则为其设置延迟等级\",{\"1\":{\"708\":1}}],[\"则根据过滤信息编译\",{\"1\":{\"841\":1}}],[\"则根据消费组设定的过滤表达式\",{\"1\":{\"835\":1}}],[\"则根据客户端传过来的数据构造subscriptiondata\",{\"1\":{\"693\":1}}],[\"则可以看作类似文件路径的字符串\",{\"1\":{\"810\":1}}],[\"则可以用这种方式构建自己的镜像\",{\"1\":{\"592\":1}}],[\"则再拉取一次重试消息\",{\"1\":{\"789\":1}}],[\"则再次执行\",{\"1\":{\"560\":1}}],[\"则拉取所有队列\",{\"1\":{\"789\":1}}],[\"则拉到一个任务马上进行处理\",{\"1\":{\"436\":1}}],[\"则修改它码表的对应位\",{\"1\":{\"782\":1}}],[\"则修改消息的\",{\"1\":{\"357\":1}}],[\"则先拉取重试\",{\"1\":{\"777\":1}}],[\"则\",{\"1\":{\"771\":1,\"777\":2}}],[\"则放进死信队列\",{\"1\":{\"708\":1}}],[\"则需要将失败的消息发回\",{\"1\":{\"699\":1}}],[\"则需要修改\",{\"1\":{\"599\":1}}],[\"则使用短轮询\",{\"1\":{\"693\":1}}],[\"则通过服务端数据构造subscriptiondata\",{\"1\":{\"693\":1}}],[\"则通过pullmessageprocessor的executerequestwhenwakeup\",{\"1\":{\"335\":1}}],[\"则是标记当前\",{\"1\":{\"820\":1}}],[\"则是\",{\"1\":{\"693\":1}}],[\"则是由\",{\"1\":{\"205\":1}}],[\"则丢弃processqueue\",{\"1\":{\"664\":1,\"744\":1}}],[\"则抛出异常\",{\"1\":{\"573\":1}}],[\"则会返回\",{\"1\":{\"820\":2}}],[\"则会发送信息\",{\"1\":{\"820\":1}}],[\"则会转移到磁盘中\",{\"1\":{\"781\":1}}],[\"则会被放入死信\",{\"1\":{\"700\":1}}],[\"则会抛出异常\",{\"1\":{\"559\":1}}],[\"则会使用默认\",{\"1\":{\"559\":1}}],[\"则会执行一次刷盘\",{\"1\":{\"278\":1}}],[\"则直接放行\",{\"1\":{\"498\":1}}],[\"则从该偏移量开始构建\",{\"1\":{\"814\":1}}],[\"则从该\",{\"1\":{\"585\":1}}],[\"则从nameserver上获取\",{\"1\":{\"571\":1}}],[\"则从\",{\"1\":{\"493\":1,\"573\":1}}],[\"则从存活\",{\"1\":{\"465\":1}}],[\"则返回给消费者消费\",{\"1\":{\"839\":1}}],[\"则返回给消费者\",{\"1\":{\"834\":1,\"848\":1}}],[\"则返回\",{\"1\":{\"491\":1}}],[\"则执行\",{\"1\":{\"814\":1}}],[\"则执行发送之前的钩子函数\",{\"1\":{\"573\":1}}],[\"则执行路由删除逻辑\",{\"1\":{\"474\":1}}],[\"则执行刷盘\",{\"1\":{\"289\":1}}],[\"则关闭与\",{\"1\":{\"474\":1}}],[\"则无法向\",{\"1\":{\"474\":1}}],[\"则跳过\",{\"1\":{\"423\":1,\"735\":1}}],[\"则调用原来的逻辑去获取并且缓存到该\",{\"1\":{\"417\":1}}],[\"则发生缺页中断\",{\"1\":{\"402\":1}}],[\"则删除一条保存最久的消息\",{\"1\":{\"585\":1}}],[\"则删除文件\",{\"1\":{\"390\":1}}],[\"则删除check\",{\"1\":{\"313\":1}}],[\"则认为是过期文件\",{\"1\":{\"390\":1}}],[\"则仍需要等待\",{\"1\":{\"386\":1}}],[\"则等待一会后重新同步投递\",{\"1\":{\"375\":1}}],[\"则更新消费进度\",{\"1\":{\"683\":1,\"693\":1,\"699\":1}}],[\"则更新偏移量\",{\"1\":{\"624\":1}}],[\"则更新\",{\"1\":{\"375\":1}}],[\"则把消息的\",{\"1\":{\"356\":1}}],[\"则创建一个文件\",{\"1\":{\"313\":1}}],[\"则创建一个新的索引文件\",{\"1\":{\"309\":1}}],[\"则新建一个文件<br>\",{\"1\":{\"313\":1}}],[\"则新建一个文件\",{\"1\":{\"313\":1}}],[\"则有多少刷多少\",{\"1\":{\"289\":1}}],[\"则标识这次刷盘必须刷多少个page\",{\"1\":{\"289\":1}}],[\"则进行一次刷盘\",{\"1\":{\"272\":1}}],[\"则指定一阶段处理线程池大小\",{\"1\":{\"254\":1}}],[\"则重启之后队列也会消失\",{\"1\":{\"217\":1}}],[\"则这些消息将丢失\",{\"1\":{\"191\":1}}],[\"则将消息发回给\",{\"1\":{\"700\":1}}],[\"则将该消息的\",{\"1\":{\"354\":1}}],[\"则将在声明客户机连接的节点上创建队列\",{\"1\":{\"190\":1}}],[\"则将队列镜像到所有节点\",{\"1\":{\"190\":1}}],[\"则不会释放它的\",{\"1\":{\"735\":1}}],[\"则不会执行\",{\"1\":{\"567\":1}}],[\"则不等待直接进行第二个任务\",{\"1\":{\"452\":1}}],[\"则不构成错误\",{\"1\":{\"190\":1}}],[\"则不设置\",{\"1\":{\"158\":1}}],[\"则其行为取决于队列是否持久化\",{\"1\":{\"190\":1}}],[\"则表示为同步副本数\",{\"1\":{\"188\":1}}],[\"则该队列会自动创建为镜像队列\",{\"1\":{\"188\":1}}],[\"则各个线程串行执行\",{\"1\":{\"4\":1}}],[\"若当前连接处于blocked状态\",{\"1\":{\"158\":1}}],[\"井且也有若干个对应的队列处于flow状态时\",{\"1\":{\"155\":1}}],[\"负载\",{\"1\":{\"663\":1,\"787\":1}}],[\"负载的消息队列发生变化时调用\",{\"1\":{\"654\":1}}],[\"负载方式\",{\"1\":{\"611\":1,\"617\":1}}],[\"负载过高而引起的此种情形\",{\"1\":{\"155\":2}}],[\"负载过高\",{\"1\":{\"155\":1,\"754\":1}}],[\"负责定时或者立即触发重平衡\",{\"1\":{\"649\":1}}],[\"负责消费消息\",{\"1\":{\"609\":1}}],[\"负责消息消费\",{\"1\":{\"640\":1}}],[\"负责消息轨迹消息的转发\",{\"1\":{\"541\":1}}],[\"负责消息的持久化\",{\"1\":{\"154\":1}}],[\"负责调用\",{\"1\":{\"562\":1}}],[\"负责执行核心的消息发送方法\",{\"1\":{\"558\":1}}],[\"负责更新和提供路由信息\",{\"1\":{\"550\":1}}],[\"负责将\",{\"1\":{\"541\":1}}],[\"负责将消息存入内存\",{\"1\":{\"154\":1}}],[\"负责异步发送轨迹数据\",{\"1\":{\"541\":1}}],[\"负责周期性扫描该\",{\"1\":{\"361\":1}}],[\"负责维护队列中落盘消息的信息\",{\"1\":{\"220\":1}}],[\"负责协议相关的消息处理\",{\"1\":{\"204\":1}}],[\"负责处理消息发送请求\",{\"1\":{\"550\":1}}],[\"负责处理\",{\"1\":{\"154\":1}}],[\"负责接收消费者的消费进度更新请求\",{\"1\":{\"710\":1}}],[\"负责接收\",{\"1\":{\"154\":1}}],[\"负责华为云分布式中间件设计与研发\",{\"1\":{\"136\":1}}],[\"负责使集群节点组成一个待测试的分布式集群\",{\"1\":{\"130\":1}}],[\"尤其是对于\",{\"1\":{\"242\":1}}],[\"尤其是在发送大量较大的持久化消息时\",{\"1\":{\"155\":1}}],[\"尤其是在发送大量较小的持久化消息时\",{\"1\":{\"155\":1}}],[\"尤其是在发送大量较小的非持久化消息时\",{\"1\":{\"155\":1}}],[\"尤其通过强化学习\",{\"1\":{\"127\":1}}],[\"某公司运维团队维护了一个\",{\"1\":{\"498\":1}}],[\"某一时刻要投递的定时消息太多\",{\"1\":{\"452\":1}}],[\"某一时刻的定时消息\",{\"1\":{\"451\":1}}],[\"某些\",{\"1\":{\"155\":1}}],[\"某进程处于流控状态时\",{\"1\":{\"147\":1}}],[\"快\",{\"1\":{\"155\":1}}],[\"快速部署\",{\"0\":{\"588\":1},\"1\":{\"884\":1}}],[\"快速排序\",{\"1\":{\"34\":1}}],[\"快速开始\",{\"0\":{\"5\":1}}],[\"处理队列\",{\"1\":{\"745\":1}}],[\"处理这批消息的消费结果\",{\"1\":{\"738\":1}}],[\"处理这两种消费方式的消费服务也不同\",{\"1\":{\"622\":1}}],[\"处理加锁请求\",{\"1\":{\"734\":1}}],[\"处理结果\",{\"0\":{\"715\":1}}],[\"处理重试消息请求\",{\"1\":{\"708\":1}}],[\"处理消费者消费失败发回的消息\",{\"1\":{\"718\":1}}],[\"处理消费失败的消息\",{\"1\":{\"708\":1,\"715\":2}}],[\"处理消费结果\",{\"1\":{\"707\":1,\"715\":2}}],[\"处理消息重新消费次数\",{\"1\":{\"708\":1}}],[\"处理消息生产请求逻辑如下\",{\"1\":{\"563\":1}}],[\"处理消息消费消息请求时\",{\"1\":{\"428\":1}}],[\"处理消息消费逻辑时\",{\"1\":{\"426\":1}}],[\"处理消息过滤的逻辑\",{\"1\":{\"287\":1}}],[\"处理消息的逻辑并不是往\",{\"1\":{\"253\":1}}],[\"处理消息\",{\"0\":{\"157\":1},\"1\":{\"204\":1}}],[\"处理顺序消费\",{\"1\":{\"690\":1,\"748\":1}}],[\"处理之后再向每个消费者发送消费者数量变化消息\",{\"1\":{\"656\":1}}],[\"处理拉取消息请求\",{\"1\":{\"581\":1}}],[\"处理拉取请求\",{\"1\":{\"332\":1,\"669\":1}}],[\"处理事务\",{\"1\":{\"573\":1}}],[\"处理压缩\",{\"1\":{\"573\":1}}],[\"处理命名空间逻辑\",{\"1\":{\"573\":1}}],[\"处理发送异常\",{\"1\":{\"570\":1}}],[\"处理发送请求\",{\"0\":{\"563\":1,\"574\":1}}],[\"处理同步发送重试\",{\"1\":{\"570\":1}}],[\"处理生产请求\",{\"1\":{\"581\":1}}],[\"处理生产者发来的消息生产请求\",{\"1\":{\"563\":1}}],[\"处理生产逻辑\",{\"1\":{\"541\":1}}],[\"处理请求前执行注册的钩子函数\",{\"1\":{\"501\":1}}],[\"处理请求\",{\"0\":{\"501\":1},\"1\":{\"711\":1}}],[\"处理客户端拉取请求入口\",{\"1\":{\"693\":1}}],[\"处理客户端拉取路由信息请求\",{\"1\":{\"493\":1}}],[\"处理客户端的发送消息请求\",{\"1\":{\"576\":1}}],[\"处理客户端请求入口\",{\"1\":{\"339\":1}}],[\"处理更高效\",{\"1\":{\"414\":1}}],[\"处理该拉取请求\",{\"1\":{\"345\":1}}],[\"处理consumer拉取请求\",{\"1\":{\"340\":1}}],[\"处理client端发送消息线程池的线程数\",{\"1\":{\"253\":1}}],[\"处理\",{\"1\":{\"329\":1,\"334\":2,\"391\":1,\"392\":1,\"471\":1,\"491\":1,\"534\":1,\"561\":1,\"562\":1,\"563\":1,\"789\":1,\"793\":1,\"814\":1}}],[\"处理挂起的拉取消息请求并返回消费者\",{\"1\":{\"326\":1}}],[\"处理一个正常的消息\",{\"1\":{\"261\":1}}],[\"处理过程当中\",{\"1\":{\"249\":1}}],[\"处理比\",{\"1\":{\"155\":1}}],[\"处理缓慢\",{\"1\":{\"155\":1}}],[\"处于不添加额外依赖的考虑\",{\"1\":{\"530\":1}}],[\"处于flow状态时\",{\"1\":{\"155\":1}}],[\"处于flow状态\",{\"1\":{\"155\":7}}],[\"处于blocked状态\",{\"1\":{\"146\":1}}],[\"处于block状态\",{\"1\":{\"146\":1}}],[\"读队列数量\",{\"1\":{\"484\":1}}],[\"读消息时读\",{\"1\":{\"403\":1}}],[\"读和写的区域都是被os智能cache过的热点区域\",{\"1\":{\"399\":1}}],[\"读写权限\",{\"1\":{\"484\":1}}],[\"读写数据时如果没有命中写\",{\"1\":{\"402\":1}}],[\"读写性能比较可以参照这篇文章\",{\"1\":{\"400\":1}}],[\"读写文件的时候\",{\"1\":{\"399\":1}}],[\"读写文件时\",{\"1\":{\"2\":1}}],[\"读写\",{\"1\":{\"394\":1}}],[\"读到的\",{\"1\":{\"250\":1}}],[\"读取消费队列判断是否有消息可以消费\",{\"1\":{\"673\":1}}],[\"读取消息时主要面对\",{\"1\":{\"403\":1}}],[\"读取消息\",{\"0\":{\"398\":1}}],[\"读取metainf\",{\"1\":{\"516\":1}}],[\"读取配置文件\",{\"1\":{\"500\":1}}],[\"读取\",{\"1\":{\"403\":1,\"510\":1,\"516\":1}}],[\"读取文件的时候\",{\"1\":{\"399\":1}}],[\"读取的操作被停止\",{\"1\":{\"154\":1}}],[\"读取进程被阻塞\",{\"1\":{\"154\":1}}],[\"协议时\",{\"1\":{\"810\":1}}],[\"协议中\",{\"1\":{\"810\":1}}],[\"协议的\",{\"1\":{\"810\":1}}],[\"协议的兼容\",{\"1\":{\"804\":1,\"811\":1}}],[\"协议的各种方法\",{\"1\":{\"154\":1}}],[\"协议可能需要的海量队列的场景\",{\"1\":{\"804\":1}}],[\"协议对每一个写请求\",{\"1\":{\"462\":1}}],[\"协议\",{\"1\":{\"237\":1}}],[\"协议比镜像队列的算法更有效率\",{\"1\":{\"229\":1}}],[\"协议下的消息复制\",{\"0\":{\"228\":1}}],[\"协议连接\",{\"1\":{\"168\":1}}],[\"协议数据包\",{\"1\":{\"154\":1}}],[\"将延迟消息先不存到真正的\",{\"1\":{\"876\":1}}],[\"将延迟等级设置为\",{\"1\":{\"718\":1}}],[\"将二进制消息解析成对象\",{\"1\":{\"848\":1}}],[\"将所有没有被过滤的消费者名称计算出的位映射\",{\"1\":{\"851\":1}}],[\"将所有消费者名称经过\",{\"1\":{\"843\":1}}],[\"将所有的节点形成一个循环链表\",{\"1\":{\"206\":1}}],[\"将每次运算结果保存到一个二进制数组的一个下标中\",{\"1\":{\"842\":1}}],[\"将每次负载的结果加入最终结果\",{\"1\":{\"787\":1}}],[\"将其传入\",{\"1\":{\"838\":1}}],[\"将其放入消费队列的扩展存储中\",{\"1\":{\"835\":1}}],[\"将其清空\",{\"1\":{\"160\":1}}],[\"将再次开始返回\",{\"1\":{\"819\":1}}],[\"将开始返回\",{\"1\":{\"819\":1}}],[\"将默认值改为\",{\"1\":{\"819\":1}}],[\"将已经匹配或存盘的\",{\"1\":{\"782\":1}}],[\"将不符合内存中存活条件的\",{\"1\":{\"782\":1}}],[\"将需要\",{\"1\":{\"778\":1}}],[\"将这部分代码重构\",{\"1\":{\"814\":1}}],[\"将这批消息的构建的\",{\"1\":{\"773\":1}}],[\"将这两个文件合并\",{\"1\":{\"221\":1}}],[\"将锁定成功队列的处理队列加锁\",{\"1\":{\"746\":1}}],[\"将它作为重新消费的消息存入消息存储\",{\"1\":{\"708\":1}}],[\"将真正的\",{\"1\":{\"708\":1}}],[\"将内存中的消费进度持久化到磁盘\",{\"1\":{\"702\":1}}],[\"将内存中所有队列的消费偏移量提交到\",{\"1\":{\"623\":1}}],[\"将重新消费次数\",{\"1\":{\"700\":1}}],[\"将重平衡后丢弃的消费队列移除\",{\"1\":{\"654\":1,\"745\":1}}],[\"将由一个消费线程池并行处理消费逻辑\",{\"1\":{\"699\":1}}],[\"将相应置为空\",{\"1\":{\"693\":1}}],[\"将处理队列让消息消费服务处理\",{\"1\":{\"685\":1}}],[\"将处理队列和\",{\"1\":{\"624\":1}}],[\"将要拉取的偏移量与上述偏移量比较\",{\"1\":{\"684\":1}}],[\"将订阅关系发送给\",{\"1\":{\"665\":1}}],[\"将新的队列订阅关系通过发送心跳请求上报给\",{\"1\":{\"657\":1}}],[\"将新的消息自动发送给用户进行消费\",{\"1\":{\"321\":1}}],[\"将新建的\",{\"1\":{\"657\":1,\"664\":1,\"744\":1}}],[\"将用户的\",{\"1\":{\"640\":1,\"642\":1}}],[\"将用户名和签名加入请求\",{\"1\":{\"501\":1}}],[\"将拉取到的一批消息提交给并发消费服务\",{\"1\":{\"699\":1}}],[\"将拉取到的消息放入结果容器中\",{\"1\":{\"790\":1}}],[\"将拉取到的消息放入处理队列\",{\"1\":{\"624\":2,\"685\":1,\"739\":1}}],[\"将拉取到的消息提交到consumemessageservice中供消费者消费\",{\"1\":{\"695\":1,\"749\":1}}],[\"将拉取到的消息存入processqueue\",{\"1\":{\"695\":1,\"749\":1}}],[\"将拉取到的消息解码\",{\"1\":{\"685\":1}}],[\"将拉取请求放入拉取线程继续下次拉取\",{\"1\":{\"685\":1}}],[\"将拉取请求\",{\"1\":{\"639\":1}}],[\"将具体的方法实现都实现在\",{\"1\":{\"638\":1}}],[\"将队列偏移量作为属性存入消息\",{\"1\":{\"816\":1}}],[\"将队列和消费者客户端id\",{\"1\":{\"786\":1}}],[\"将队列按数量平均分配给多个消费者\",{\"1\":{\"617\":1}}],[\"将队列索引持久化\",{\"1\":{\"154\":1}}],[\"将镜像名称改成\",{\"1\":{\"597\":1}}],[\"将当前生产者加入\",{\"1\":{\"567\":1}}],[\"将进入死信队列\",{\"1\":{\"563\":1}}],[\"将生产者的\",{\"1\":{\"755\":1}}],[\"将生产消息的请求发往\",{\"1\":{\"562\":1}}],[\"将生成的签名添加到请求的扩展属性中\",{\"1\":{\"515\":1}}],[\"将一批数据封装成一个发送请求\",{\"1\":{\"541\":1}}],[\"将一个\",{\"1\":{\"548\":1}}],[\"将一个索引文件强制刷盘\",{\"1\":{\"309\":1}}],[\"将一个consumequeue数据写盘\",{\"1\":{\"285\":1}}],[\"将一个队列的压力分散到多个集群\",{\"1\":{\"164\":1}}],[\"将消费组对应的位数据\",{\"1\":{\"851\":1}}],[\"将消费者和消息存储的\",{\"1\":{\"811\":1}}],[\"将消费者注册到客户端实例对象\",{\"1\":{\"640\":1}}],[\"将消费进度保存到缓存表\",{\"1\":{\"721\":1}}],[\"将消费进度缓存\",{\"1\":{\"721\":1}}],[\"将消费进度管理器的内存缓存持久化到磁盘\",{\"1\":{\"703\":1}}],[\"将消费失败的消息发回\",{\"1\":{\"715\":1}}],[\"将消费请求提交给消费线程池\",{\"1\":{\"708\":1}}],[\"将消费到的消息构建\",{\"1\":{\"540\":1}}],[\"将消息分发到一个或多个\",{\"1\":{\"810\":1}}],[\"将消息分批打包成消费请求\",{\"1\":{\"708\":1}}],[\"将消息主动\",{\"1\":{\"765\":1}}],[\"将消息从处理队列移除\",{\"1\":{\"738\":1}}],[\"将消息从拉取到的响应中解码出来\",{\"1\":{\"669\":1}}],[\"将消息的真正\",{\"1\":{\"718\":1}}],[\"将消息发送回重试\",{\"1\":{\"717\":1}}],[\"将消息发送到\",{\"1\":{\"154\":1,\"249\":1}}],[\"将消息发回\",{\"0\":{\"717\":1},\"1\":{\"715\":2,\"738\":1}}],[\"将消息发回给\",{\"1\":{\"707\":1}}],[\"将消息字节数组解码成消息列表并填充msgfoundlist\",{\"1\":{\"695\":1,\"749\":1}}],[\"将消息放入返回体\",{\"1\":{\"683\":1}}],[\"将消息队列和消费者\",{\"1\":{\"657\":1}}],[\"将消息偏移量持久化到磁盘\",{\"1\":{\"623\":1}}],[\"将消息根据\",{\"1\":{\"585\":1}}],[\"将消息保存到存储\",{\"1\":{\"576\":1}}],[\"将消息同步到备\",{\"1\":{\"553\":1}}],[\"将消息轨迹数据分类\",{\"1\":{\"541\":1}}],[\"将消息轨迹交给异步发送者处理\",{\"1\":{\"540\":1}}],[\"将消息定时设置为当前时间往后的\",{\"1\":{\"440\":1}}],[\"将消息存储起来\",{\"1\":{\"544\":1}}],[\"将消息存储\",{\"1\":{\"359\":1}}],[\"将消息封装成dispatchrequest\",{\"1\":{\"282\":1}}],[\"将消息真正存入\",{\"1\":{\"276\":1}}],[\"将轨迹数据打包后提交给发送线程池\",{\"1\":{\"535\":1}}],[\"将会把它放入\",{\"1\":{\"771\":1}}],[\"将会调用\",{\"1\":{\"711\":1}}],[\"将会保存到一个\",{\"1\":{\"534\":1}}],[\"将会按照请求处理的先后顺序分为\",{\"1\":{\"506\":1}}],[\"将数据采集到该上下文中\",{\"1\":{\"534\":1}}],[\"将配置文件中的全局白名单\",{\"1\":{\"518\":1}}],[\"将配置加载到内存\",{\"1\":{\"516\":1}}],[\"将客户端的信息\",{\"1\":{\"640\":1}}],[\"将客户端的\",{\"1\":{\"515\":1}}],[\"将客户端信息上报给\",{\"1\":{\"642\":1}}],[\"将客户端信息\",{\"1\":{\"465\":1}}],[\"将注册一个\",{\"1\":{\"510\":1}}],[\"将权限配置信息加载到内存\",{\"1\":{\"510\":1,\"516\":1}}],[\"将上报的路由信息调用\",{\"1\":{\"473\":1}}],[\"将路由信息保存在内存中\",{\"1\":{\"465\":1}}],[\"将保存关于broker集群的整个路由信息和用于客户端查询的队列信息\",{\"1\":{\"461\":1}}],[\"将该拉取请求放入拉取队列末尾\",{\"1\":{\"727\":1}}],[\"将该消息队列从rebalanceimpl的处理队列中移除\",{\"1\":{\"695\":1}}],[\"将该\",{\"1\":{\"451\":1,\"474\":1}}],[\"将定时消息直接投递到\",{\"1\":{\"450\":1}}],[\"将静态变量位图复制到局部变量中\",{\"1\":{\"424\":1}}],[\"将位图从堆复制到栈里\",{\"1\":{\"424\":1}}],[\"将正则匹配简化成位图查表的过程\",{\"1\":{\"424\":1}}],[\"将常用的指令解码方法抽象出来\",{\"1\":{\"411\":1}}],[\"将于\",{\"1\":{\"409\":1,\"412\":1}}],[\"将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销\",{\"1\":{\"400\":1}}],[\"将磁盘上的物理文件直接映射到用户态的内存地址中\",{\"1\":{\"400\":1}}],[\"将删除的文件从mappedfiles中移除\",{\"1\":{\"390\":1}}],[\"将设置磁盘为不可写\",{\"1\":{\"386\":1}}],[\"将对应延迟等级的消息异步投递时\",{\"1\":{\"375\":1}}],[\"将多次重平衡分配到的队列都分给这个消费者消费\",{\"1\":{\"775\":1}}],[\"将多个消息包装成一个批量消息\",{\"1\":{\"548\":1}}],[\"将多个集群的消息收集到一个集群\",{\"1\":{\"164\":1}}],[\"将多延迟等级延迟消息扫描和投递的任务从单线程执行改为多线程\",{\"0\":{\"372\":1}}],[\"将多延迟等级下同时发送延迟消息的性能提升了\",{\"1\":{\"370\":1}}],[\"将到期的消息重新投递\",{\"1\":{\"360\":1,\"364\":1}}],[\"将原来的\",{\"1\":{\"420\":1}}],[\"将原消息的\",{\"1\":{\"359\":1,\"363\":1}}],[\"将原先用来启动周期性任务的\",{\"1\":{\"370\":1}}],[\"将原先\",{\"1\":{\"257\":1}}],[\"将返回体写入channel\",{\"1\":{\"340\":1}}],[\"将hold的拉取请求唤醒\",{\"1\":{\"340\":1}}],[\"将时间信息符合搜索条件的索引加入到结果列表中\",{\"1\":{\"317\":1}}],[\"将索引存入文件\",{\"1\":{\"317\":1}}],[\"将索引文件按照创建时间升序排序\",{\"1\":{\"313\":1}}],[\"将索引项的三个参数写入\",{\"1\":{\"285\":1}}],[\"将请求分发到具体的\",{\"1\":{\"284\":1}}],[\"将请求分发到\",{\"1\":{\"284\":1}}],[\"将dispatchrequest分发给所有注册dispatcherlist中的commitlogdispatcher进行处理\",{\"1\":{\"282\":1}}],[\"将准备工作放到锁外\",{\"0\":{\"257\":1}}],[\"将\",{\"0\":{\"433\":1},\"1\":{\"256\":2,\"258\":1,\"285\":1,\"334\":1,\"335\":1,\"377\":1,\"435\":1,\"471\":1,\"477\":1,\"491\":1,\"493\":1,\"504\":1,\"505\":1,\"515\":1,\"518\":1,\"557\":1,\"617\":1,\"646\":1,\"769\":1,\"773\":2,\"779\":1,\"791\":2,\"795\":2,\"797\":1,\"841\":1,\"843\":1}}],[\"将文件直接映射到用户内存\",{\"1\":{\"248\":1}}],[\"将持久化和非持久化的消息在磁盘中区分存储\",{\"1\":{\"220\":1}}],[\"将丢弃其所有数据\",{\"1\":{\"211\":1}}],[\"将阻塞这个进程的下游进程id\",{\"1\":{\"158\":1}}],[\"将结果图形化\",{\"0\":{\"14\":1}}],[\"才能将拉转换为推\",{\"1\":{\"639\":1}}],[\"才能进行下一次查询\",{\"1\":{\"326\":1}}],[\"才可以应用改动\",{\"1\":{\"525\":1}}],[\"才会实现\",{\"1\":{\"875\":1}}],[\"才会将\",{\"1\":{\"820\":1}}],[\"才会启动删除过期文件\",{\"1\":{\"384\":1}}],[\"才会向主节点返回写入成功\",{\"1\":{\"373\":1}}],[\"才会执行\",{\"1\":{\"258\":1}}],[\"才会被提升为主节点\",{\"1\":{\"192\":1}}],[\"才允许发送新的消息\",{\"1\":{\"197\":1}}],[\"才将上游进程的信用值加200\",{\"1\":{\"152\":1}}],[\"才恢复\",{\"1\":{\"146\":1}}],[\"默认时间为\",{\"1\":{\"877\":1}}],[\"默认3s\",{\"1\":{\"797\":1}}],[\"默认值\",{\"1\":{\"754\":1,\"771\":1}}],[\"默认一条\",{\"1\":{\"726\":1}}],[\"默认一批只包含一条消息\",{\"1\":{\"699\":1}}],[\"默认提供了重试消费和死信队列功能\",{\"1\":{\"700\":1}}],[\"默认启用长轮询\",{\"1\":{\"693\":1}}],[\"默认采用\",{\"1\":{\"617\":1}}],[\"默认使用集群消费模式\",{\"1\":{\"611\":1}}],[\"默认有\",{\"1\":{\"575\":1,\"624\":1,\"675\":1,\"685\":1}}],[\"默认有18\",{\"1\":{\"354\":1}}],[\"默认消息体超过\",{\"1\":{\"573\":1}}],[\"默认不启用\",{\"1\":{\"572\":1}}],[\"默认机制下\",{\"1\":{\"561\":1}}],[\"默认机制\",{\"1\":{\"561\":1,\"572\":1}}],[\"默认都为\",{\"1\":{\"560\":1}}],[\"默认会重试\",{\"1\":{\"552\":1}}],[\"默认的消息发送超时时间为\",{\"1\":{\"753\":1}}],[\"默认的consumergroup权限\",{\"1\":{\"503\":1}}],[\"默认的topic权限\",{\"1\":{\"503\":1}}],[\"默认的配置文件名\",{\"1\":{\"503\":1}}],[\"默认的配置下每条消息都会打出一条日志\",{\"1\":{\"242\":1}}],[\"默认长度为\",{\"1\":{\"426\":1}}],[\"默认长度是\",{\"1\":{\"261\":1}}],[\"默认关闭\",{\"1\":{\"403\":1}}],[\"默认10s\",{\"1\":{\"797\":1}}],[\"默认100ms\",{\"1\":{\"390\":1}}],[\"默认120s\",{\"1\":{\"390\":1}}],[\"默认72h\",{\"1\":{\"390\":1}}],[\"默认过期时间\",{\"1\":{\"390\":1}}],[\"默认是\",{\"1\":{\"386\":1}}],[\"默认是第一个\",{\"1\":{\"98\":1}}],[\"默认支持的延迟等级为\",{\"1\":{\"353\":1}}],[\"默认true\",{\"1\":{\"339\":1,\"693\":1}}],[\"默认push模式固定15s\",{\"1\":{\"325\":1}}],[\"默认60s\",{\"1\":{\"289\":1}}],[\"默认2\",{\"1\":{\"278\":1}}],[\"默认200\",{\"1\":{\"152\":1}}],[\"默认为消费线程池设置\",{\"1\":{\"699\":1}}],[\"默认为可用内存的\",{\"1\":{\"585\":1}}],[\"默认为关闭状态\",{\"1\":{\"561\":1}}],[\"默认为75\",{\"1\":{\"390\":1}}],[\"默认为2次\",{\"1\":{\"570\":1}}],[\"默认为2分钟\",{\"1\":{\"390\":1}}],[\"默认为2\",{\"1\":{\"289\":1}}],[\"默认为\",{\"1\":{\"278\":1,\"325\":2,\"332\":1,\"665\":1,\"714\":1,\"715\":1,\"717\":1,\"750\":1,\"761\":1}}],[\"默认每批\",{\"1\":{\"708\":1}}],[\"默认每30s从nameserver获取topic路由信息\",{\"1\":{\"568\":1}}],[\"默认每\",{\"1\":{\"255\":1}}],[\"默认\",{\"1\":{\"221\":1,\"278\":1,\"324\":1,\"386\":1,\"390\":1,\"436\":1,\"541\":3,\"559\":1,\"562\":1,\"587\":1,\"611\":1,\"658\":1,\"707\":1,\"732\":1,\"735\":1,\"737\":1,\"738\":1,\"750\":1,\"773\":1,\"817\":1}}],[\"默认情况下\",{\"1\":{\"211\":1,\"255\":1,\"403\":1,\"532\":1}}],[\"默认400\",{\"1\":{\"152\":1}}],[\"信息表\",{\"1\":{\"491\":1}}],[\"信息列表等数据\",{\"1\":{\"470\":1}}],[\"信息\",{\"1\":{\"464\":1,\"473\":1,\"474\":1,\"491\":1,\"492\":1,\"573\":1,\"708\":1,\"814\":1}}],[\"信用值减一的操作仍然在rabbit\",{\"1\":{\"157\":1}}],[\"信用值耗尽后\",{\"1\":{\"155\":1}}],[\"信用值\",{\"1\":{\"154\":1}}],[\"信用证初始化时\",{\"1\":{\"154\":1}}],[\"信用证流控的两个参数可以通过查询环境变量的方式找到\",{\"1\":{\"151\":1}}],[\"信用证配置\",{\"0\":{\"151\":1}}],[\"信号\",{\"1\":{\"43\":1}}],[\"概念和应用场景\",{\"0\":{\"871\":1}}],[\"概念和消费流程\",{\"0\":{\"605\":1},\"1\":{\"884\":1}}],[\"概念简述\",{\"0\":{\"607\":1}}],[\"概要设计\",{\"0\":{\"268\":1,\"299\":1,\"463\":1,\"530\":1,\"580\":1,\"628\":1,\"647\":1,\"668\":1,\"698\":1,\"724\":1,\"770\":1,\"809\":1,\"831\":1}}],[\"概要流程\",{\"0\":{\"150\":1,\"326\":1,\"354\":1}}],[\"概述\",{\"0\":{\"143\":1,\"163\":1,\"215\":1,\"240\":1,\"265\":1,\"296\":1,\"320\":1,\"351\":1,\"370\":1,\"384\":1,\"406\":1,\"460\":1,\"497\":1,\"545\":1,\"861\":1,\"874\":1}}],[\"消除主从复制中不必要的数组拷贝\",{\"0\":{\"247\":1}}],[\"消耗会更大\",{\"1\":{\"242\":1}}],[\"消费模型\",{\"1\":{\"786\":1}}],[\"消费模式之后\",{\"1\":{\"769\":1}}],[\"消费模式的重平衡逻辑是在客户端完成的\",{\"1\":{\"769\":1}}],[\"消费模式的原因\",{\"0\":{\"769\":1}}],[\"消费模式的一个实现\",{\"1\":{\"453\":1}}],[\"消费模式消费某个\",{\"1\":{\"767\":1}}],[\"消费模式主要是用于\",{\"1\":{\"765\":1}}],[\"消费模式用的阻塞队列\",{\"1\":{\"707\":1}}],[\"消费模式探秘\",{\"1\":{\"625\":1,\"801\":1}}],[\"消费模式开发\",{\"1\":{\"615\":1}}],[\"消费模式\",{\"0\":{\"322\":1,\"763\":1},\"1\":{\"375\":1,\"401\":1,\"435\":1,\"436\":1,\"535\":1,\"624\":1,\"672\":1,\"675\":1,\"678\":1,\"765\":1,\"884\":1}}],[\"消费和匹配\",{\"1\":{\"783\":1}}],[\"消费由于要根据\",{\"1\":{\"783\":1}}],[\"消费重试\",{\"1\":{\"773\":1}}],[\"消费重试次数\",{\"0\":{\"761\":1}}],[\"消费这批消息\",{\"1\":{\"772\":1}}],[\"消费较为相似\",{\"1\":{\"772\":1}}],[\"消费较慢\",{\"1\":{\"693\":1}}],[\"消费提供了一个接口\",{\"1\":{\"771\":1}}],[\"消费也沿用了这个设计\",{\"1\":{\"771\":1}}],[\"消费引入了消息不可见时间\",{\"1\":{\"771\":1}}],[\"消费一次请求可以拉取一批消息\",{\"1\":{\"771\":1}}],[\"消费一批\",{\"1\":{\"726\":1}}],[\"消费主要的设计思想是将繁重的客户端逻辑如重平衡\",{\"1\":{\"770\":1}}],[\"消费主要的原因是由于\",{\"1\":{\"769\":1}}],[\"消费接口用\",{\"1\":{\"769\":1}}],[\"消费能力\",{\"1\":{\"769\":1}}],[\"消费导致的可能的消息堆积问题和横向扩展能力问题\",{\"1\":{\"769\":1}}],[\"消费暂不支持切换\",{\"1\":{\"766\":1}}],[\"消费切换为使用\",{\"1\":{\"766\":1}}],[\"消费都是由客户端完成重平衡\",{\"1\":{\"765\":1}}],[\"消费很像\",{\"1\":{\"765\":1}}],[\"消费幂等\",{\"0\":{\"757\":1}}],[\"消费前钩子函数\",{\"1\":{\"750\":1}}],[\"消费前后添加自定义的逻辑\",{\"1\":{\"530\":1}}],[\"消费锁\",{\"1\":{\"735\":2,\"738\":2}}],[\"消费任务中添加的消息队列锁保证了同一消费者中的顺序消费\",{\"1\":{\"728\":1}}],[\"消费任务结束时释放锁\",{\"1\":{\"727\":1}}],[\"消费任务开始时获取锁\",{\"1\":{\"727\":1}}],[\"消费任务由拉取任务提交\",{\"1\":{\"726\":1}}],[\"消费上下文信息\",{\"1\":{\"715\":1}}],[\"消费状态判断和处理\",{\"1\":{\"715\":1}}],[\"消费状态\",{\"1\":{\"715\":1}}],[\"消费状态码\",{\"1\":{\"537\":1}}],[\"消费后\",{\"1\":{\"715\":1}}],[\"消费后更新\",{\"1\":{\"615\":1}}],[\"消费逻辑会概率性消费到重试\",{\"1\":{\"773\":1}}],[\"消费逻辑\",{\"1\":{\"715\":1}}],[\"消费请求\",{\"1\":{\"715\":1}}],[\"消费请求运行\",{\"0\":{\"715\":1},\"1\":{\"715\":1}}],[\"消费请求队列\",{\"1\":{\"707\":1}}],[\"消费请求由\",{\"1\":{\"563\":1}}],[\"消费失败后发到\",{\"1\":{\"770\":1}}],[\"消费失败后将消息发回\",{\"1\":{\"769\":1}}],[\"消费失败统计数据更新\",{\"1\":{\"715\":1}}],[\"消费失败\",{\"1\":{\"715\":2}}],[\"消费失败则将消息发回\",{\"1\":{\"707\":1}}],[\"消费失败则将失败的消息发回\",{\"1\":{\"699\":1}}],[\"消费失败的消息将会过一段时间后重新消费\",{\"1\":{\"700\":1}}],[\"消费结果处理方法\",{\"1\":{\"707\":1}}],[\"消费结果处理\",{\"1\":{\"699\":1,\"750\":1}}],[\"消费正常\",{\"1\":{\"693\":1}}],[\"消费分成如下几个步骤\",{\"1\":{\"645\":1,\"667\":1,\"697\":1,\"723\":1}}],[\"消费服务内部维护一个线程池\",{\"1\":{\"640\":1}}],[\"消费线程池顺序消费任务流程\",{\"0\":{\"738\":1}}],[\"消费线程池顺序消费设计\",{\"0\":{\"737\":1}}],[\"消费线程池顺序消费逻辑\",{\"0\":{\"736\":1}}],[\"消费线程池顺序消费\",{\"0\":{\"726\":1}}],[\"消费线程池逻辑\",{\"0\":{\"725\":1}}],[\"消费线程池从阻塞队列\",{\"1\":{\"708\":1}}],[\"消费线程池\",{\"1\":{\"707\":1}}],[\"消费线程池执行真正的消息消费逻辑\",{\"1\":{\"639\":1}}],[\"消费线程池的每个消费线程会尝试从消费任务队列中获取消费请求\",{\"1\":{\"624\":1}}],[\"消费完后解锁\",{\"1\":{\"735\":1}}],[\"消费完成后\",{\"1\":{\"624\":1}}],[\"消费完一批消息后将消息消费进度存在本地内存\",{\"1\":{\"623\":1}}],[\"消费流程以重平衡为起点\",{\"1\":{\"739\":1}}],[\"消费流程最后\",{\"1\":{\"711\":1}}],[\"消费流程\",{\"0\":{\"624\":1,\"771\":1}}],[\"消费进度\",{\"1\":{\"799\":1}}],[\"消费进度提交\",{\"1\":{\"770\":1}}],[\"消费进度更新流程\",{\"0\":{\"711\":1}}],[\"消费进度管理器的\",{\"1\":{\"711\":1}}],[\"消费进度管理类设计\",{\"0\":{\"710\":1}}],[\"消费进度管理\",{\"0\":{\"709\":1,\"719\":1}}],[\"消费进度管理设计\",{\"0\":{\"701\":1}}],[\"消费进度上报\",{\"0\":{\"696\":1},\"1\":{\"884\":1}}],[\"消费进度保存在\",{\"1\":{\"640\":1,\"642\":1}}],[\"消费进度保存在消费者本地\",{\"1\":{\"640\":1,\"642\":1}}],[\"消费进度保存和提交\",{\"0\":{\"623\":1}}],[\"消费进度在客户端维护\",{\"1\":{\"610\":1}}],[\"消费消息锁解锁\",{\"1\":{\"750\":1}}],[\"消费消息锁\",{\"1\":{\"750\":1}}],[\"消费消息耗时较长的情况下\",{\"1\":{\"735\":1}}],[\"消费消息服务接口定义了\",{\"1\":{\"707\":1}}],[\"消费消息逻辑会调用\",{\"1\":{\"639\":1}}],[\"消费消息\",{\"0\":{\"808\":1},\"1\":{\"625\":1}}],[\"消费消息的顺序和消息发送的顺序一致\",{\"1\":{\"622\":1}}],[\"消费消息时重平衡\",{\"0\":{\"735\":1}}],[\"消费消息时\",{\"1\":{\"398\":1}}],[\"消费端高可靠\",{\"0\":{\"619\":1}}],[\"消费端的请求\",{\"1\":{\"537\":1}}],[\"消费只是通过客户端\",{\"1\":{\"614\":1}}],[\"消费\",{\"0\":{\"765\":1,\"766\":1},\"1\":{\"614\":1,\"775\":1,\"798\":1}}],[\"消费其实也是由\",{\"1\":{\"614\":1}}],[\"消费组客户端\",{\"1\":{\"787\":1}}],[\"消费组线程数\",{\"0\":{\"758\":1}}],[\"消费组名称\",{\"1\":{\"708\":2,\"718\":1}}],[\"消费组级别配置\",{\"1\":{\"648\":1}}],[\"消费组中的消费者共同消费订阅的\",{\"1\":{\"616\":1}}],[\"消费组的引入是用来在消费消息时更好地进行负载均衡和容错\",{\"1\":{\"609\":1}}],[\"消费组是一个逻辑概念\",{\"1\":{\"609\":1}}],[\"消费组\",{\"0\":{\"609\":1},\"1\":{\"663\":1,\"742\":1,\"783\":2,\"787\":1,\"851\":1}}],[\"消费组概念与消费模式\",{\"0\":{\"608\":1}}],[\"消费涉及到地概念\",{\"1\":{\"606\":1}}],[\"消费涉及到的模式和特性\",{\"1\":{\"606\":1}}],[\"消费成功的消息数量的\",{\"1\":{\"715\":1}}],[\"消费成功则更新消费进度\",{\"1\":{\"707\":1}}],[\"消费成功则将这批消息从处理队列中移除\",{\"1\":{\"699\":1}}],[\"消费成功则提交消费位点\",{\"1\":{\"620\":1}}],[\"消费成功\",{\"1\":{\"537\":1,\"715\":2}}],[\"消费相关的数据\",{\"1\":{\"530\":1}}],[\"消费索引\",{\"1\":{\"432\":1}}],[\"消费速度较快\",{\"1\":{\"699\":1}}],[\"消费速度太慢\",{\"1\":{\"678\":1}}],[\"消费速度从\",{\"1\":{\"430\":2}}],[\"消费速度只有\",{\"1\":{\"430\":1}}],[\"消费速度可以跟上生产速度\",{\"1\":{\"430\":1}}],[\"消费的消息\",{\"1\":{\"798\":1}}],[\"消费的时刻\",{\"1\":{\"795\":1}}],[\"消费的流程与\",{\"1\":{\"772\":1}}],[\"消费的重平衡在\",{\"1\":{\"775\":1}}],[\"消费的重平衡是在\",{\"1\":{\"765\":1}}],[\"消费的重试间隔时间会随着重试次数而增加\",{\"1\":{\"771\":1}}],[\"消费的特性是重平衡后每个消费者都分配到消费一定数量的队列\",{\"1\":{\"769\":1}}],[\"消费的机制导致它存在一些痛点\",{\"1\":{\"769\":1}}],[\"消费的行为和\",{\"1\":{\"765\":1}}],[\"消费的当前队列的已经消费的最大的offset值\",{\"1\":{\"691\":1}}],[\"消费的\",{\"1\":{\"430\":1,\"465\":1}}],[\"消费的过程都是顺序读\",{\"1\":{\"398\":1}}],[\"消费时间差\",{\"1\":{\"798\":1}}],[\"消费时消费全部队列\",{\"1\":{\"787\":1}}],[\"消费时将拉消息的动作替换成\",{\"1\":{\"765\":1}}],[\"消费时将会调用订阅时注册的消费监听器中的业务方法\",{\"1\":{\"699\":1}}],[\"消费时申请独占消息队列消费锁对象\",{\"1\":{\"750\":1}}],[\"消费时可以通过设置\",{\"1\":{\"715\":1}}],[\"消费时的轮询机制流程\",{\"1\":{\"326\":1}}],[\"消费时\",{\"1\":{\"323\":1,\"434\":1}}],[\"消费过程中的轮询机制是啥\",{\"1\":{\"320\":1}}],[\"消费队列过滤\",{\"1\":{\"835\":2}}],[\"消费队列锁\",{\"1\":{\"622\":1}}],[\"消费队列的最大offset\",{\"1\":{\"345\":1}}],[\"消费队列最大offset比消费者拉取请求的offset大\",{\"1\":{\"345\":2}}],[\"消费队列中没有任何消息\",{\"1\":{\"339\":1}}],[\"消费队列consumequeue\",{\"1\":{\"294\":1}}],[\"消费队列\",{\"1\":{\"271\":1,\"838\":1}}],[\"消费队列文件\",{\"0\":{\"264\":1},\"1\":{\"884\":1}}],[\"消费某一\",{\"1\":{\"267\":1}}],[\"消费来重新开始消费\",{\"1\":{\"198\":1}}],[\"消费者名称\",{\"1\":{\"852\":1}}],[\"消费者注册\",{\"1\":{\"850\":1}}],[\"消费者上报心跳\",{\"1\":{\"841\":1}}],[\"消费者就通过\",{\"1\":{\"771\":1}}],[\"消费者无法无限扩展\",{\"1\":{\"769\":1}}],[\"消费者无法消费到未到期的定时消息\",{\"1\":{\"356\":1}}],[\"消费者提供\",{\"1\":{\"758\":1}}],[\"消费者解锁\",{\"0\":{\"743\":1}}],[\"消费者在重平衡后\",{\"1\":{\"729\":1}}],[\"消费者执行消费逻辑时\",{\"1\":{\"723\":1}}],[\"消费者本地进度存储\",{\"1\":{\"710\":1}}],[\"消费者更新消费进度\",{\"0\":{\"704\":1}}],[\"消费者端\",{\"1\":{\"710\":1}}],[\"消费者端仅保存一个消费进度内存缓存表\",{\"1\":{\"703\":1}}],[\"消费者端有定时任务\",{\"1\":{\"623\":1}}],[\"消费者之间不需要共享消费进度\",{\"1\":{\"701\":1}}],[\"消费者拉取成功结果处理\",{\"0\":{\"685\":1}}],[\"消费者拉取消息模式\",{\"0\":{\"612\":1}}],[\"消费者拉取消息\",{\"0\":{\"677\":1,\"687\":1},\"1\":{\"606\":1,\"645\":1,\"667\":1,\"697\":1,\"723\":1}}],[\"消费者收到\",{\"1\":{\"675\":1}}],[\"消费者重平衡后\",{\"1\":{\"733\":1}}],[\"消费者重平衡\",{\"1\":{\"662\":1}}],[\"消费者停止时\",{\"1\":{\"656\":1}}],[\"消费者订阅的所有\",{\"1\":{\"653\":1}}],[\"消费者特性\",{\"1\":{\"651\":1}}],[\"消费者按\",{\"1\":{\"650\":1}}],[\"消费者关机时\",{\"1\":{\"648\":1}}],[\"消费者系列的第六篇\",{\"1\":{\"723\":1}}],[\"消费者系列的第五篇\",{\"1\":{\"697\":1}}],[\"消费者系列的第四篇\",{\"1\":{\"667\":1}}],[\"消费者系列的第三篇\",{\"1\":{\"645\":1}}],[\"消费者系列的第二篇\",{\"1\":{\"627\":1}}],[\"消费者实现\",{\"0\":{\"638\":1}}],[\"消费者和命令工具都扩展了它\",{\"1\":{\"636\":1}}],[\"消费者和下游服务\",{\"1\":{\"235\":1}}],[\"消费者类的设计中将会有一个消费者接口\",{\"1\":{\"636\":1}}],[\"消费者接口提供一些共用方法\",{\"1\":{\"636\":1}}],[\"消费者接口\",{\"0\":{\"636\":1}}],[\"消费者的处理线程池处理拉取完成的回调\",{\"1\":{\"669\":1}}],[\"消费者的\",{\"1\":{\"656\":1,\"760\":1}}],[\"消费者的启动主要涉及上面讲到的\",{\"1\":{\"630\":1}}],[\"消费者的钩子类是\",{\"1\":{\"534\":1}}],[\"消费者客户端如何实现通过拉取来模拟推的效果\",{\"1\":{\"667\":1}}],[\"消费者客户端类设计\",{\"0\":{\"634\":1}}],[\"消费者客户端启动\",{\"0\":{\"630\":1}}],[\"消费者客户端设计\",{\"0\":{\"629\":1}}],[\"消费者启动时\",{\"1\":{\"656\":1,\"832\":1}}],[\"消费者启动时唤醒重平衡服务\",{\"1\":{\"624\":1}}],[\"消费者启动\",{\"0\":{\"632\":1,\"640\":1},\"1\":{\"642\":1}}],[\"消费者启动过程中会向\",{\"1\":{\"465\":1}}],[\"消费者中有一个定时线程\",{\"1\":{\"623\":1}}],[\"消费者线程池提交的偏移量是线程池消费的这一批消息中偏移量最小的消息的偏移量\",{\"1\":{\"623\":1}}],[\"消费者向\",{\"1\":{\"623\":2}}],[\"消费者数量大于队列数量\",{\"1\":{\"787\":1}}],[\"消费者数量小于等于队列数量\",{\"1\":{\"787\":1}}],[\"消费者数量发生变化\",{\"1\":{\"648\":1}}],[\"消费者数量是否发生变化\",{\"1\":{\"618\":1}}],[\"消费者数量无法无限扩展\",{\"1\":{\"615\":1}}],[\"消费者发送拉取消息请求\",{\"1\":{\"581\":1}}],[\"消费者并不马上收到消息\",{\"1\":{\"548\":1}}],[\"消费者信息\",{\"1\":{\"541\":1,\"640\":1}}],[\"消费者采集时为消费者\",{\"1\":{\"537\":2}}],[\"消费者开启消息轨迹\",{\"0\":{\"527\":1}}],[\"消费者使用消息拉取线程\",{\"1\":{\"678\":1}}],[\"消费者使用\",{\"0\":{\"505\":1}}],[\"消费者消费失败\",{\"0\":{\"717\":1}}],[\"消费者消费一批消息完成之后\",{\"1\":{\"623\":1}}],[\"消费者消费\",{\"1\":{\"615\":1}}],[\"消费者消费消息\",{\"1\":{\"606\":1,\"645\":1,\"667\":1,\"697\":1,\"723\":1}}],[\"消费者消费后\",{\"1\":{\"537\":1}}],[\"消费者消费前\",{\"1\":{\"537\":1}}],[\"消费者消费这些任务\",{\"1\":{\"375\":1}}],[\"消费者消费时查询\",{\"1\":{\"356\":1}}],[\"消费者可以消费到\",{\"1\":{\"872\":1}}],[\"消费者可以消费到该消息\",{\"1\":{\"354\":1}}],[\"消费者可能希望知道这将会发生\",{\"1\":{\"198\":1}}],[\"消费者才可消费\",{\"1\":{\"352\":1}}],[\"消费者不立即能够消费\",{\"1\":{\"352\":1}}],[\"消费者调用\",{\"1\":{\"332\":1,\"436\":1}}],[\"消费者是在不断轮询\",{\"1\":{\"323\":1}}],[\"消费者组装拉取请求\",{\"1\":{\"669\":1}}],[\"消费者组会自动订阅重试\",{\"1\":{\"620\":1}}],[\"消费者组中的消费者实例会根据预设的负载均衡算法对\",{\"1\":{\"614\":1}}],[\"消费者组\",{\"1\":{\"287\":1,\"620\":2,\"689\":1,\"694\":1,\"718\":1}}],[\"消费者\",{\"0\":{\"605\":1,\"626\":1,\"644\":1,\"666\":1,\"696\":1,\"722\":1,\"756\":1,\"827\":1,\"830\":1},\"1\":{\"244\":1,\"354\":1,\"461\":1,\"884\":6}}],[\"消费者正在处理数据的同时\",{\"1\":{\"244\":1}}],[\"消费者连接到\",{\"1\":{\"201\":1}}],[\"消费者直接连接\",{\"1\":{\"201\":1}}],[\"消费者预取\",{\"0\":{\"149\":1}}],[\"消息属性\",{\"1\":{\"838\":1}}],[\"消息详情过滤\",{\"1\":{\"835\":1}}],[\"消息分发\",{\"1\":{\"814\":1}}],[\"消息分发的逻辑主要在\",{\"1\":{\"814\":1}}],[\"消息需要分发的新偏移量也放入消息属性\",{\"1\":{\"814\":1}}],[\"消息生产时构建布隆过滤器数据\",{\"0\":{\"851\":1}}],[\"消息生产和消费\",{\"0\":{\"813\":1}}],[\"消息生产者\",{\"1\":{\"541\":1}}],[\"消息对应的真正消息\",{\"1\":{\"800\":1}}],[\"消息根据\",{\"1\":{\"798\":1}}],[\"消息放到\",{\"1\":{\"798\":1}}],[\"消息放入\",{\"1\":{\"783\":1}}],[\"消息放入内存\",{\"1\":{\"780\":1}}],[\"消息和\",{\"1\":{\"798\":1}}],[\"消息后\",{\"1\":{\"795\":1}}],[\"消息请求\",{\"1\":{\"789\":1,\"793\":1}}],[\"消息重试\",{\"1\":{\"781\":1}}],[\"消息接口每次只允许\",{\"1\":{\"780\":1}}],[\"消息接受流程\",{\"1\":{\"625\":1}}],[\"消息方法\",{\"0\":{\"778\":1}}],[\"消息则从\",{\"1\":{\"773\":1,\"783\":1}}],[\"消息匹配后的最新位点\",{\"1\":{\"778\":1}}],[\"消息匹配\",{\"1\":{\"773\":1,\"798\":1}}],[\"消息匹配成功后删除\",{\"1\":{\"773\":1}}],[\"消息定时到\",{\"1\":{\"773\":1}}],[\"消息也一样\",{\"1\":{\"773\":1}}],[\"消息给消费者的效果\",{\"1\":{\"765\":1}}],[\"消息来实现类似于\",{\"1\":{\"765\":1}}],[\"消息调用监听器的方法进行消费\",{\"1\":{\"715\":1}}],[\"消息将会被放入死信队列\",{\"1\":{\"700\":1}}],[\"消息将进入\",{\"1\":{\"576\":1}}],[\"消息表达式类型\",{\"1\":{\"690\":1}}],[\"消息处理队列\",{\"1\":{\"689\":1,\"714\":1}}],[\"消息处理线程\",{\"1\":{\"244\":1}}],[\"消息选择器\",{\"1\":{\"637\":1}}],[\"消息拉取时过滤\",{\"0\":{\"852\":1}}],[\"消息拉取成功\",{\"0\":{\"749\":1}}],[\"消息拉取操作\",{\"1\":{\"748\":1}}],[\"消息拉取任务将拉取到的消息都放到消息队列对应的处理队列中\",{\"1\":{\"737\":1}}],[\"消息拉取到后存入处理队列\",{\"1\":{\"708\":1}}],[\"消息拉取模式\",{\"1\":{\"690\":1}}],[\"消息拉取最大条数\",{\"1\":{\"690\":1}}],[\"消息拉取最大数量\",{\"1\":{\"684\":1}}],[\"消息拉取偏移量\",{\"1\":{\"690\":1}}],[\"消息拉取流控检查\",{\"1\":{\"679\":1}}],[\"消息拉取被流控\",{\"1\":{\"678\":1}}],[\"消息拉取逻辑处理完成会更新拉取请求下次拉取的偏移量\",{\"1\":{\"678\":1}}],[\"消息拉取线程从拉取任务队列中获取任务并执行拉取\",{\"1\":{\"739\":1}}],[\"消息拉取线程\",{\"0\":{\"688\":1}}],[\"消息拉取线程用了生产\",{\"1\":{\"672\":1}}],[\"消息拉取线程应用生产\",{\"1\":{\"624\":1}}],[\"消息拉取\",{\"0\":{\"666\":1,\"747\":1,\"748\":1},\"1\":{\"632\":1,\"884\":1}}],[\"消息拉取请求主要包含拉取消息所需要的元数据\",{\"1\":{\"689\":1}}],[\"消息拉取请求\",{\"0\":{\"689\":1},\"1\":{\"339\":1,\"693\":1}}],[\"消息被负载均衡到了同一个消费组的多个消费者实例上\",{\"1\":{\"611\":1}}],[\"消息被消费\",{\"1\":{\"223\":1}}],[\"消息被消费后会被删除\",{\"1\":{\"221\":1}}],[\"消息堆积报警和订阅关系查询功能\",{\"1\":{\"610\":1}}],[\"消息体和\",{\"1\":{\"555\":1}}],[\"消息体长度\",{\"1\":{\"537\":1}}],[\"消息类型\",{\"1\":{\"537\":1}}],[\"消息偏移量\",{\"1\":{\"537\":1}}],[\"消息轨迹存放的\",{\"1\":{\"541\":1}}],[\"消息轨迹待发送数据队列\",{\"1\":{\"541\":1}}],[\"消息轨迹异步转发器\",{\"1\":{\"541\":1}}],[\"消息轨迹数据列表\",{\"1\":{\"541\":1}}],[\"消息轨迹数据发送\",{\"0\":{\"541\":1}}],[\"消息轨迹数据采集\",{\"0\":{\"538\":1}}],[\"消息轨迹数据模型\",{\"0\":{\"537\":1}}],[\"消息轨迹的模型类是\",{\"1\":{\"537\":1}}],[\"消息轨迹的数据可以封装成消息\",{\"1\":{\"530\":1}}],[\"消息轨迹保存在一个默认的\",{\"1\":{\"532\":1}}],[\"消息轨迹关注是否被生产和消费\",{\"1\":{\"530\":1}}],[\"消息轨迹\",{\"0\":{\"522\":1},\"1\":{\"542\":1,\"693\":1,\"718\":1,\"884\":1}}],[\"消息投递毫秒级精度\",{\"1\":{\"457\":1}}],[\"消息投递线程和任务状态更新线程是生产\",{\"1\":{\"453\":1}}],[\"消息投递成功\",{\"1\":{\"381\":1}}],[\"消息是需要落盘的\",{\"1\":{\"445\":1}}],[\"消息到磁盘\",{\"1\":{\"793\":1}}],[\"消息到达消息队列服务端后不会马上投递\",{\"1\":{\"440\":1}}],[\"消息到期之后会从\",{\"1\":{\"367\":1}}],[\"消息时尝试从内存\",{\"1\":{\"782\":1}}],[\"消息时会先添加\",{\"1\":{\"782\":1}}],[\"消息时支持不同的\",{\"0\":{\"425\":1}}],[\"消息时去遍历\",{\"1\":{\"267\":1}}],[\"消息发送到\",{\"1\":{\"810\":1}}],[\"消息发送结果\",{\"1\":{\"573\":1}}],[\"消息发送超时时间\",{\"1\":{\"573\":1}}],[\"消息发送模式\",{\"1\":{\"573\":1}}],[\"消息发送实现\",{\"0\":{\"570\":1}}],[\"消息发送逻辑由\",{\"1\":{\"562\":1}}],[\"消息发送重试机制\",{\"1\":{\"552\":1}}],[\"消息发送流程\",{\"0\":{\"550\":1},\"1\":{\"577\":1}}],[\"消息发送的流程涉及到\",{\"1\":{\"550\":1}}],[\"消息发送的\",{\"1\":{\"549\":1}}],[\"消息发送后\",{\"1\":{\"548\":1}}],[\"消息发送方式和特殊消息\",{\"0\":{\"546\":1}}],[\"消息发送高性能\",{\"1\":{\"544\":1}}],[\"消息发送并不仅仅牵扯到客户端操作\",{\"1\":{\"544\":1}}],[\"消息发送设计和原理详解\",{\"0\":{\"543\":1},\"1\":{\"884\":1}}],[\"消息发送时没有设置\",{\"1\":{\"847\":1}}],[\"消息发送时根据路由表进行\",{\"1\":{\"469\":1}}],[\"消息发送时由客户端生产\",{\"1\":{\"419\":1}}],[\"消息发送应该弱依赖注册中心\",{\"1\":{\"462\":1}}],[\"消息发送\",{\"0\":{\"558\":1,\"569\":1},\"1\":{\"410\":1,\"537\":1,\"573\":1}}],[\"消息发送是异步的\",{\"1\":{\"79\":1}}],[\"消息读取时\",{\"1\":{\"403\":1}}],[\"消息读写都通过\",{\"1\":{\"403\":1}}],[\"消息写入时将写入\",{\"1\":{\"403\":1}}],[\"消息并不会直接投递成功\",{\"1\":{\"375\":1}}],[\"消息可能重复投递\",{\"1\":{\"374\":1}}],[\"消息可能未达到服务器就发送完毕\",{\"1\":{\"148\":1}}],[\"消息异步保存\",{\"1\":{\"363\":1}}],[\"消息队列加锁\",{\"0\":{\"746\":1}}],[\"消息队列解锁\",{\"0\":{\"745\":1}}],[\"消息队列锁定状态表\",{\"1\":{\"742\":1}}],[\"消息队列锁\",{\"1\":{\"727\":1}}],[\"消息队列的权限控制需求也也越来越迫切\",{\"1\":{\"496\":1}}],[\"消息队列\",{\"1\":{\"442\":1,\"585\":1,\"610\":1,\"691\":1,\"714\":1,\"745\":1,\"790\":1}}],[\"消息队列高手课\",{\"1\":{\"404\":1}}],[\"消息队列id\",{\"1\":{\"345\":1}}],[\"消息队列存储机制源码分析\",{\"1\":{\"224\":1}}],[\"消息topic\",{\"1\":{\"345\":1}}],[\"消息消费队列扩展属性\",{\"1\":{\"838\":1}}],[\"消息消费时间\",{\"1\":{\"750\":1}}],[\"消息消费后钩子函数\",{\"1\":{\"750\":1}}],[\"消息消费后调用\",{\"1\":{\"540\":1}}],[\"消息消费监听器执行真正的消费业务逻辑\",{\"1\":{\"750\":1}}],[\"消息消费监听器\",{\"1\":{\"707\":1}}],[\"消息消费类设计\",{\"0\":{\"707\":1}}],[\"消息消费偏移量间隔流控\",{\"1\":{\"690\":1}}],[\"消息消费大小流控\",{\"1\":{\"690\":1}}],[\"消息消费数量流控\",{\"1\":{\"690\":1}}],[\"消息消费服务从处理队列中获取消息并消费\",{\"1\":{\"675\":1}}],[\"消息消费前调用\",{\"1\":{\"540\":1}}],[\"消息消费的信息\",{\"1\":{\"523\":1}}],[\"消息消费的延迟变高\",{\"1\":{\"435\":1}}],[\"消息消费的轮询机制指的是在\",{\"1\":{\"434\":1}}],[\"消息消费方式\",{\"0\":{\"321\":1}}],[\"消息消费\",{\"0\":{\"319\":1,\"696\":1},\"1\":{\"349\":1,\"625\":1,\"884\":2}}],[\"消息存到\",{\"1\":{\"811\":1,\"814\":1}}],[\"消息存入\",{\"1\":{\"814\":1}}],[\"消息存入磁盘\",{\"1\":{\"797\":1}}],[\"消息存入commitlog之后重新分发到index文件的\",{\"1\":{\"314\":1}}],[\"消息存储模块\",{\"1\":{\"868\":1}}],[\"消息存储的方案取舍\",{\"0\":{\"448\":1}}],[\"消息存储的实现\",{\"1\":{\"356\":1}}],[\"消息存储过期\",{\"1\":{\"446\":1}}],[\"消息存储逻辑\",{\"1\":{\"363\":1}}],[\"消息存储到\",{\"1\":{\"307\":1}}],[\"消息存储之概要设计\",{\"1\":{\"294\":1}}],[\"消息存储文件\",{\"1\":{\"256\":1}}],[\"消息存储\",{\"1\":{\"220\":1}}],[\"消息越老\",{\"1\":{\"307\":1}}],[\"消息过滤流程\",{\"1\":{\"853\":1}}],[\"消息过滤相关\",{\"1\":{\"690\":1}}],[\"消息过滤相关逻辑\",{\"1\":{\"683\":1}}],[\"消息过滤表达式\",{\"1\":{\"637\":1,\"690\":1}}],[\"消息过滤服务器列表\",{\"1\":{\"490\":1}}],[\"消息过滤匹配\",{\"1\":{\"345\":1}}],[\"消息过滤\",{\"0\":{\"821\":1,\"844\":1},\"1\":{\"287\":1,\"334\":1,\"693\":1,\"694\":1,\"848\":1,\"853\":1,\"884\":1}}],[\"消息过滤器\",{\"1\":{\"287\":1,\"637\":1,\"694\":1}}],[\"消息大小\",{\"1\":{\"269\":1}}],[\"消息大小size和消息tag的hashcode值\",{\"1\":{\"267\":1}}],[\"消息在队列中的逻辑偏移量\",{\"1\":{\"287\":1,\"694\":1}}],[\"消息在consumequeue中的逻辑偏移量\",{\"1\":{\"285\":1}}],[\"消息在commitlog存储的大小\",{\"1\":{\"285\":1}}],[\"消息在\",{\"1\":{\"269\":1,\"306\":1,\"307\":1}}],[\"消息在投递到匹配的队列后会给发送方返回一个确认请求\",{\"1\":{\"148\":1}}],[\"消息保存时间与索引文件最早消息保存时间的差值\",{\"1\":{\"306\":1}}],[\"消息保存到\",{\"1\":{\"270\":1,\"301\":1}}],[\"消息保存\",{\"0\":{\"253\":1}}],[\"消息复制和主副本选举的操作\",{\"1\":{\"228\":1}}],[\"消息要经历多个生命周期\",{\"1\":{\"223\":1}}],[\"消息又从磁盘回到内存中\",{\"1\":{\"223\":1}}],[\"消息实际经历了一个ram\",{\"1\":{\"223\":1}}],[\"消息内容和索引都在disk上\",{\"1\":{\"223\":1}}],[\"消息索引文件\",{\"1\":{\"336\":1}}],[\"消息索引在disk和ram上都有\",{\"1\":{\"223\":1}}],[\"消息索引保存在ram中\",{\"1\":{\"223\":1}}],[\"消息才会在重启之后仍然存在\",{\"1\":{\"218\":1}}],[\"消息的两层过滤与\",{\"1\":{\"844\":1}}],[\"消息的主要步骤有两步\",{\"1\":{\"814\":1}}],[\"消息的码表以完成\",{\"1\":{\"798\":1}}],[\"消息的匹配\",{\"1\":{\"796\":1}}],[\"消息的起始偏移量\",{\"1\":{\"778\":1,\"791\":1}}],[\"消息的消费可能出现失败\",{\"1\":{\"620\":1}}],[\"消息的路由指的是发送消息时需要先获取\",{\"1\":{\"549\":1}}],[\"消息的轨迹数据\",{\"1\":{\"537\":1}}],[\"消息的丢失是不能被接收的\",{\"1\":{\"454\":1}}],[\"消息的模式\",{\"1\":{\"323\":1}}],[\"消息的分发请求\",{\"1\":{\"284\":1}}],[\"消息的\",{\"1\":{\"269\":1,\"307\":1,\"777\":1,\"796\":1}}],[\"消息的内容保存在disk上\",{\"1\":{\"223\":2}}],[\"消息的内容和消息索引都在ram中\",{\"1\":{\"223\":1}}],[\"消息的生命周期有4个状态\",{\"1\":{\"223\":1}}],[\"消息的持久化\",{\"0\":{\"218\":1}}],[\"消息的存储机制\",{\"1\":{\"214\":1}}],[\"消息的广播\",{\"0\":{\"207\":1}}],[\"消息回到\",{\"1\":{\"207\":1}}],[\"消息会保存到死信\",{\"1\":{\"620\":1}}],[\"消息会被消费者发回\",{\"1\":{\"620\":1}}],[\"消息会被先保存到\",{\"1\":{\"276\":1}}],[\"消息会被发送到本地的\",{\"1\":{\"166\":1}}],[\"消息会顺着节点链表经过所有的\",{\"1\":{\"207\":1}}],[\"消息\",{\"0\":{\"259\":1,\"555\":1,\"564\":1,\"776\":1,\"780\":1,\"788\":1,\"792\":1},\"1\":{\"207\":1,\"231\":1,\"573\":1,\"714\":1,\"726\":1,\"750\":1,\"777\":1,\"778\":1,\"780\":1,\"783\":4,\"790\":1,\"793\":1,\"796\":1,\"798\":4,\"799\":1}}],[\"消息从\",{\"1\":{\"207\":1}}],[\"消息广播\",{\"1\":{\"181\":1}}],[\"消息不会被复制\",{\"1\":{\"167\":1}}],[\"消息中间件\",{\"1\":{\"0\":1,\"15\":1,\"16\":1,\"112\":1,\"124\":1,\"136\":1,\"140\":1,\"161\":1,\"173\":1,\"179\":1,\"212\":1,\"224\":1,\"237\":1,\"263\":1,\"294\":1,\"318\":1,\"349\":2,\"368\":1,\"381\":1,\"392\":1,\"404\":1,\"437\":1,\"458\":1,\"494\":1,\"521\":1,\"542\":1,\"577\":1,\"587\":1,\"604\":1,\"625\":2,\"643\":1,\"665\":1,\"695\":1,\"721\":1,\"750\":1,\"762\":1,\"801\":1,\"818\":1,\"820\":1,\"853\":1,\"854\":1,\"858\":1,\"868\":1,\"883\":1}}],[\"端过滤\",{\"0\":{\"847\":1}}],[\"端消息拉取请求的入口\",{\"1\":{\"838\":1}}],[\"端消费进度管理器\",{\"0\":{\"721\":1}}],[\"端消费进度管理器会定时将消费进度表持久化到磁盘\",{\"1\":{\"711\":1}}],[\"端心跳处理方法调用\",{\"1\":{\"837\":1}}],[\"端有一个专门的消费者过滤信息管理器\",{\"1\":{\"832\":1}}],[\"端完成\",{\"1\":{\"775\":1}}],[\"端重平衡入口为\",{\"1\":{\"775\":1}}],[\"端重平衡\",{\"0\":{\"775\":1,\"785\":1},\"1\":{\"786\":1}}],[\"端发起请求\",{\"1\":{\"772\":1}}],[\"端发送心跳\",{\"1\":{\"832\":1}}],[\"端发送查询请求\",{\"1\":{\"775\":1}}],[\"端发送请求\",{\"1\":{\"772\":1}}],[\"端发送持久化请求\",{\"1\":{\"703\":1}}],[\"端发送信号给所有消费者触发\",{\"1\":{\"650\":1}}],[\"端并非毫无办法\",{\"1\":{\"771\":1}}],[\"端会为这批消息保存一个\",{\"1\":{\"771\":1}}],[\"端来分配每次拉取请求要拉取的队列并返回消息\",{\"1\":{\"770\":1}}],[\"端做的\",{\"1\":{\"765\":1}}],[\"端被设了过期时间\",{\"1\":{\"729\":1}}],[\"端控制延迟时间\",{\"1\":{\"718\":1}}],[\"端控制延迟等级\",{\"1\":{\"717\":1}}],[\"端处理拉取消息请求时\",{\"1\":{\"841\":1}}],[\"端处理拉取请求\",{\"0\":{\"682\":1}}],[\"端处理拉取请求从存储中查询消息返回\",{\"1\":{\"676\":1}}],[\"端处理消费者的拉取消息请求时执行\",{\"1\":{\"833\":1}}],[\"端处理是由\",{\"1\":{\"777\":1}}],[\"端处理客户端发回的消息\",{\"0\":{\"718\":1}}],[\"端将延迟等级设置为重试消费次数\",{\"1\":{\"717\":1}}],[\"端存储\",{\"1\":{\"710\":1}}],[\"端存储着所有的消息\",{\"1\":{\"708\":1}}],[\"端也有一个消费进度管理器\",{\"1\":{\"711\":1}}],[\"端也有一个对应的消费进度管理器\",{\"1\":{\"710\":1}}],[\"端也包含一个消费进度内存缓存表\",{\"1\":{\"703\":1}}],[\"端也先放到内存\",{\"1\":{\"624\":1}}],[\"端比较好\",{\"1\":{\"701\":1}}],[\"端响应后会调用\",{\"1\":{\"675\":1}}],[\"端拉取结果的响应\",{\"1\":{\"675\":1}}],[\"端拉取流程设计\",{\"0\":{\"673\":1}}],[\"端收到拉取请求后要做的就是将消息从磁盘中查询出来\",{\"1\":{\"673\":1}}],[\"端\",{\"0\":{\"776\":1,\"780\":1,\"781\":1,\"788\":1,\"792\":1,\"794\":1},\"1\":{\"622\":1,\"669\":1,\"703\":1,\"734\":1,\"770\":1,\"834\":1,\"839\":1}}],[\"端口进入\",{\"1\":{\"601\":1}}],[\"端口的行为就像一个\",{\"1\":{\"91\":1}}],[\"端高可用\",{\"0\":{\"553\":1}}],[\"端和客户端都需要进行一些配置\",{\"1\":{\"524\":1}}],[\"端记录消息的方式\",{\"1\":{\"523\":1}}],[\"端调用底层\",{\"1\":{\"514\":1}}],[\"端配置\",{\"0\":{\"503\":1,\"525\":1}}],[\"端需要先在配置文件\",{\"1\":{\"499\":1}}],[\"端需要将消息根据投递时间排序后投递\",{\"1\":{\"356\":1}}],[\"端共同完成\",{\"1\":{\"499\":1}}],[\"端保存的路由信息\",{\"0\":{\"469\":1}}],[\"端只需要在消息上额外设置延迟等级即可\",{\"1\":{\"355\":1}}],[\"端通过\",{\"1\":{\"353\":1}}],[\"端不断地从数据存储对象\",{\"1\":{\"336\":1}}],[\"端参数\",{\"1\":{\"325\":1}}],[\"端无法监听和做出处理\",{\"1\":{\"147\":1}}],[\"端的高可用是用数据同步的方式\",{\"1\":{\"553\":1}}],[\"端的流程\",{\"1\":{\"355\":1}}],[\"端的\",{\"1\":{\"147\":1,\"732\":1,\"773\":1}}],[\"生产消息\",{\"0\":{\"807\":1}}],[\"生产消息样例\",{\"1\":{\"577\":1}}],[\"生产消息和消费消息\",{\"1\":{\"182\":1}}],[\"生产\",{\"1\":{\"433\":1,\"707\":1}}],[\"生产和消费的对象是异步投递的任务\",{\"1\":{\"375\":1}}],[\"生产者需要知道消息要发往哪个\",{\"1\":{\"559\":1}}],[\"生产者启动\",{\"0\":{\"557\":1,\"566\":1}}],[\"生产者类图\",{\"0\":{\"556\":1}}],[\"生产者高可用\",{\"0\":{\"552\":1}}],[\"生产者每\",{\"1\":{\"550\":1}}],[\"生产者采集时为生产者的\",{\"1\":{\"537\":1}}],[\"生产者采集时为\",{\"1\":{\"537\":1}}],[\"生产者或消费者组名称\",{\"1\":{\"537\":1}}],[\"生产者或消费者启动时\",{\"1\":{\"465\":1}}],[\"生产者的钩子类是\",{\"1\":{\"534\":1}}],[\"生产者开启消息轨迹\",{\"0\":{\"526\":1}}],[\"生产者使用\",{\"0\":{\"504\":1}}],[\"生产者第一次发送消息时\",{\"1\":{\"465\":1}}],[\"生产者在消息发送时如果出现失败\",{\"1\":{\"552\":1}}],[\"生产者在发送消息前后的钩子函数中分别添加消息轨迹采集逻辑\",{\"1\":{\"531\":1}}],[\"生产者在发送消息时为消息指定发送时间\",{\"1\":{\"352\":1}}],[\"生产者在第一次发送消息的时候从\",{\"1\":{\"462\":1}}],[\"生产者将消息发送到消息队列服务端\",{\"1\":{\"440\":2}}],[\"生产者将被完全阻塞\",{\"1\":{\"146\":1}}],[\"生产者线程将消息\",{\"1\":{\"436\":1}}],[\"生产者线程负责将到期的消息创建投递任务\",{\"1\":{\"375\":1}}],[\"生产者发送了\",{\"1\":{\"610\":1}}],[\"生产者发送生产请求\",{\"1\":{\"581\":1}}],[\"生产者发送消息时\",{\"1\":{\"354\":1,\"550\":1}}],[\"生产者发送一条消息\",{\"1\":{\"201\":1}}],[\"生产者可以不受影响的继续添加数据\",{\"1\":{\"244\":1}}],[\"生产者和消费者使用\",{\"1\":{\"504\":1}}],[\"生产者和消费者信息上报给\",{\"1\":{\"465\":1}}],[\"生产者和消费者仍然是操作通知任务\",{\"1\":{\"436\":1}}],[\"生产者和消费者\",{\"1\":{\"228\":1,\"568\":1}}],[\"生产者消费者连接的节点是3进3出\",{\"1\":{\"202\":1}}],[\"生产者\",{\"0\":{\"752\":1,\"826\":1,\"829\":1},\"1\":{\"201\":1,\"354\":1,\"461\":1,\"550\":1,\"636\":1,\"640\":1}}],[\"生产者会一直被阻塞\",{\"1\":{\"197\":1}}],[\"生产者进行当前消息确认的前提是该消息被全部镜像接收\",{\"1\":{\"196\":1}}],[\"生产者确认和事务\",{\"0\":{\"196\":1}}],[\"生成布隆过滤器的位数据\",{\"1\":{\"850\":1}}],[\"生成布隆过滤器位数组\",{\"0\":{\"843\":1}}],[\"生成的文件\",{\"1\":{\"841\":1}}],[\"生成的\",{\"1\":{\"834\":1}}],[\"生成的索引顺序就会与\",{\"1\":{\"450\":1}}],[\"生成消费者过滤信息\",{\"1\":{\"850\":1}}],[\"生成消费索引\",{\"1\":{\"814\":1}}],[\"生成消息的消费索引之后\",{\"1\":{\"814\":1}}],[\"生成随机数\",{\"1\":{\"789\":1}}],[\"生成规则与生产者一样\",{\"1\":{\"760\":1}}],[\"生成时会拼接消费者的\",{\"1\":{\"760\":1}}],[\"生成时会拼接\",{\"1\":{\"755\":1}}],[\"生成拉取请求\",{\"1\":{\"640\":1}}],[\"生成一个新消息\",{\"1\":{\"700\":1}}],[\"生成一个\",{\"1\":{\"639\":1,\"777\":1}}],[\"生成一个比\",{\"1\":{\"34\":1}}],[\"生成\",{\"1\":{\"594\":1,\"755\":1,\"814\":1,\"839\":1,\"843\":2,\"844\":1,\"851\":1}}],[\"生成索引\",{\"1\":{\"354\":1}}],[\"生成式ai等能力可以进一步解决目前随机故障注入\",{\"1\":{\"127\":1}}],[\"生成器的写法是\",{\"1\":{\"34\":1}}],[\"生成器\",{\"1\":{\"34\":2}}],[\"源码\",{\"1\":{\"868\":1}}],[\"源码分析之\",{\"1\":{\"521\":1}}],[\"源码分析rocketmq消息过滤机制下篇\",{\"1\":{\"853\":1}}],[\"源码分析rocketmq消息轨迹\",{\"1\":{\"542\":1}}],[\"源码分析rocketmq消息pull\",{\"1\":{\"349\":1}}],[\"源码分析rocketmq\",{\"1\":{\"521\":1}}],[\"源码不在此处展示\",{\"1\":{\"285\":1}}],[\"源码比较熟悉\",{\"1\":{\"240\":1}}],[\"源码剖析\",{\"0\":{\"239\":1,\"382\":1,\"405\":1,\"459\":1,\"478\":1,\"495\":1,\"543\":1,\"859\":1},\"1\":{\"884\":6}}],[\"源码解析\",{\"0\":{\"142\":1,\"156\":1,\"280\":1,\"311\":1,\"337\":1,\"350\":1,\"362\":1,\"379\":1,\"389\":1,\"512\":1,\"536\":1,\"565\":1,\"626\":1,\"641\":1,\"644\":1,\"659\":1,\"666\":1,\"686\":1,\"696\":1,\"712\":1,\"722\":1,\"740\":1,\"763\":1,\"784\":1,\"802\":1,\"815\":1,\"821\":1,\"845\":1,\"855\":1,\"869\":1},\"1\":{\"238\":1,\"872\":1,\"884\":9}}],[\"源代码中\",{\"1\":{\"41\":2}}],[\"^\",{\"1\":{\"424\":1}}],[\"^表示所有队列都是镜像队列\",{\"1\":{\"185\":1}}],[\"^mirror\",{\"1\":{\"186\":1,\"187\":1}}],[\"^m\",{\"1\":{\"139\":1}}],[\"^g\",{\"1\":{\"98\":1}}],[\"十六制为0x0a\",{\"1\":{\"138\":1}}],[\"十六进制代码为0x0d\",{\"1\":{\"138\":1}}],[\"十进制ascii代码是10\",{\"1\":{\"138\":1}}],[\"十进制ascii代码是13\",{\"1\":{\"138\":1}}],[\"显然延迟\",{\"1\":{\"445\":1}}],[\"显示的\",{\"1\":{\"188\":1}}],[\"显示换行符\",{\"0\":{\"139\":1}}],[\"显示\",{\"0\":{\"137\":1},\"1\":{\"141\":1}}],[\"显式调用包括\",{\"1\":{\"43\":1}}],[\"擅长混沌工程\",{\"1\":{\"136\":1}}],[\"擅长中间件性能优化\",{\"1\":{\"136\":1}}],[\"喜欢大道至简的设计理念\",{\"1\":{\"136\":1}}],[\"嘉浩\",{\"1\":{\"136\":1}}],[\"思莹\",{\"1\":{\"136\":1}}],[\"作者简介\",{\"1\":{\"136\":1}}],[\"作为表达式编译的入口\",{\"1\":{\"841\":1}}],[\"作为金融级的业务消息中间件\",{\"1\":{\"823\":1}}],[\"作为重试消息\",{\"1\":{\"718\":1}}],[\"作为延迟消息放入消息存储\",{\"1\":{\"700\":1}}],[\"作为消费的回调类\",{\"1\":{\"622\":1}}],[\"作为消息的生产者和消费者\",{\"1\":{\"461\":1}}],[\"作为\",{\"1\":{\"464\":1}}],[\"作为服务发现来说就应该是为可用性而设计\",{\"1\":{\"462\":1}}],[\"作为路由中心\",{\"1\":{\"462\":2}}],[\"作为一个折衷的方案\",{\"1\":{\"875\":1}}],[\"作为一个底座\",{\"1\":{\"443\":1}}],[\"作为一个配置开关\",{\"1\":{\"403\":1}}],[\"作为该项标准的主要贡献者\",{\"1\":{\"136\":1}}],[\"作为名称来注册进程\",{\"1\":{\"84\":1}}],[\"作为扩展名\",{\"1\":{\"30\":1}}],[\"作为占位符\",{\"1\":{\"26\":1}}],[\"稳坐钓鱼船\",{\"1\":{\"136\":1}}],[\"努力将它打造成分布式系统韧性架构的压舱石\",{\"1\":{\"136\":1}}],[\"加快处理性能\",{\"1\":{\"839\":1}}],[\"加快生态建设\",{\"1\":{\"136\":1}}],[\"加锁\",{\"0\":{\"743\":1}}],[\"加锁的过程是向\",{\"1\":{\"734\":1}}],[\"加\",{\"1\":{\"738\":1}}],[\"加解锁流程\",{\"0\":{\"734\":1}}],[\"加解锁时机\",{\"0\":{\"733\":1}}],[\"加入锁定状态表\",{\"1\":{\"742\":1}}],[\"加入失败列表\",{\"1\":{\"715\":1}}],[\"加入消息拉取线程\",{\"1\":{\"657\":1,\"664\":1,\"744\":1}}],[\"加入\",{\"1\":{\"567\":1}}],[\"加入到\",{\"1\":{\"508\":1,\"514\":1}}],[\"加入到credit\",{\"1\":{\"158\":1}}],[\"加写锁\",{\"1\":{\"473\":1,\"474\":1,\"491\":1,\"492\":2}}],[\"加载单个文件的配置\",{\"1\":{\"519\":1}}],[\"加载到缓存中\",{\"1\":{\"518\":1}}],[\"加载所有的验证器\",{\"1\":{\"510\":1,\"516\":1}}],[\"加载配置到内存\",{\"1\":{\"500\":1}}],[\"加载访问验证器\",{\"1\":{\"500\":1}}],[\"加载\",{\"1\":{\"480\":1,\"481\":1,\"510\":1,\"516\":1}}],[\"加载命令行中指定的属性\",{\"1\":{\"480\":1}}],[\"加载至内存\",{\"1\":{\"402\":1}}],[\"加载是否成功\",{\"1\":{\"313\":1}}],[\"加载这些文件\",{\"1\":{\"273\":1,\"279\":1}}],[\"加速比效率\",{\"1\":{\"135\":2}}],[\"助力信通院颁发了国内首个\",{\"1\":{\"136\":1}}],[\"未锁定\",{\"1\":{\"748\":1}}],[\"未缓存该\",{\"1\":{\"573\":1}}],[\"未开启长轮询\",{\"1\":{\"344\":1}}],[\"未开启发送方确认时\",{\"1\":{\"148\":1}}],[\"未找到消息直接返回消息未找到\",{\"1\":{\"339\":1,\"693\":1}}],[\"未来\",{\"1\":{\"136\":1}}],[\"未来规划\",{\"0\":{\"136\":1}}],[\"未导出函数相当于私有方法\",{\"1\":{\"30\":1}}],[\"新引入的\",{\"1\":{\"765\":1}}],[\"新消费者注册\",{\"1\":{\"850\":1}}],[\"新消费者开始消费\",{\"1\":{\"728\":1}}],[\"新消息来了创建异步任务并唤醒线程\",{\"1\":{\"435\":1}}],[\"新创建的重试消息是定时消息\",{\"1\":{\"708\":1}}],[\"新创建的队列按照规则成为镜像队列\",{\"1\":{\"182\":1}}],[\"新建消费者时构造\",{\"1\":{\"631\":1}}],[\"新建消费者\",{\"0\":{\"631\":1}}],[\"新建一个\",{\"1\":{\"507\":1,\"664\":1,\"744\":1}}],[\"新建\",{\"1\":{\"498\":1,\"504\":1,\"505\":1,\"629\":1}}],[\"新增\",{\"1\":{\"795\":1}}],[\"新增了\",{\"1\":{\"420\":1,\"819\":1}}],[\"新增1个分区的平均时间约20ms\",{\"1\":{\"135\":1}}],[\"新的改动将延迟消息的到期投递模式改为可配置\",{\"1\":{\"370\":1}}],[\"新的消息到达\",{\"1\":{\"348\":1}}],[\"新的队列镜像将随着时间的推移成为主服务器的精确副本\",{\"1\":{\"191\":1}}],[\"新的信用值\",{\"1\":{\"155\":1}}],[\"新队列镜像将不接收现有消息\",{\"1\":{\"191\":1}}],[\"新镜像同步策略\",{\"0\":{\"191\":1}}],[\"新编译的版本则成为当前版\",{\"1\":{\"57\":1}}],[\"展示了消息消费整个流程的调用关系\",{\"1\":{\"639\":1}}],[\"展示了在不同规模下\",{\"1\":{\"135\":1}}],[\"展开后\",{\"1\":{\"63\":1}}],[\"扩容和\",{\"0\":{\"427\":1}}],[\"扩容可能会发生多次\",{\"1\":{\"426\":1}}],[\"扩容\",{\"0\":{\"426\":1}}],[\"扩容的损耗\",{\"1\":{\"261\":1}}],[\"扩展\",{\"1\":{\"636\":1}}],[\"扩展了最大定时时长\",{\"1\":{\"872\":1}}],[\"扩展了客户端配置类\",{\"1\":{\"629\":1}}],[\"扩展了\",{\"1\":{\"361\":1}}],[\"扩展列表\",{\"1\":{\"27\":1}}],[\"扩到\",{\"1\":{\"135\":1}}],[\"扩缩代价\",{\"1\":{\"135\":2}}],[\"实战与进阶\",{\"1\":{\"625\":1}}],[\"实例\",{\"1\":{\"556\":1,\"557\":1,\"567\":1}}],[\"实例是\",{\"1\":{\"467\":1}}],[\"实际已经保存到磁盘\",{\"1\":{\"796\":1}}],[\"实际上它们可以实现相同的效果\",{\"1\":{\"872\":1}}],[\"实际上投递方法执行后可以抽象成一个投递任务\",{\"1\":{\"453\":1}}],[\"实际上消费时是一个随机读的过程\",{\"1\":{\"398\":1}}],[\"实际上\",{\"1\":{\"323\":1}}],[\"实际上性能开销相当大\",{\"1\":{\"256\":1}}],[\"实际\",{\"1\":{\"245\":1}}],[\"实验结束后\",{\"1\":{\"135\":1}}],[\"实现任意时间的定时的要点在于知道在某一时刻需要投递哪些消息\",{\"1\":{\"880\":1}}],[\"实现思想\",{\"0\":{\"811\":1}}],[\"实现发送请求\",{\"1\":{\"680\":1}}],[\"实现了一些基本的\",{\"1\":{\"841\":1}}],[\"实现了多语言轻量化客户端\",{\"1\":{\"769\":1}}],[\"实现了\",{\"1\":{\"638\":1,\"710\":1,\"804\":1}}],[\"实现了消息读写在内存级别的读写分离\",{\"1\":{\"403\":1}}],[\"实现类中包含了客户端实例\",{\"1\":{\"629\":1}}],[\"实现不同请求线程池的隔离\",{\"1\":{\"575\":1}}],[\"实现原理\",{\"0\":{\"506\":1}}],[\"实现定时消息取消的实现要点是保存一个需要取消的定时消息\",{\"1\":{\"455\":1}}],[\"实现定时消息延迟投递的主要逻辑\",{\"1\":{\"356\":1}}],[\"实现的重点就是\",{\"1\":{\"814\":1}}],[\"实现的新消费者\",{\"1\":{\"656\":1}}],[\"实现的肩膀上\",{\"1\":{\"445\":1}}],[\"实现的序列化协议\",{\"1\":{\"413\":1}}],[\"实现其中一个\",{\"1\":{\"440\":1}}],[\"实现现高性能\",{\"0\":{\"395\":1}}],[\"实现高性能定时消息\",{\"0\":{\"438\":1},\"1\":{\"884\":1}}],[\"实现高性能\",{\"1\":{\"394\":1}}],[\"实现有一定难度\",{\"1\":{\"367\":1}}],[\"实现amqp协议的逻辑功能\",{\"1\":{\"222\":1}}],[\"实现真正的韧性架构毫无疑问是现代分布式系统的演进方向\",{\"1\":{\"128\":1}}],[\"实现真正意义上的秒级rto\",{\"1\":{\"126\":1}}],[\"实现\",{\"0\":{\"32\":1},\"1\":{\"614\":1,\"778\":1,\"810\":1,\"838\":1}}],[\"除此之外\",{\"1\":{\"441\":1,\"871\":1}}],[\"除非系统内存不够用\",{\"1\":{\"399\":1}}],[\"除可靠性外\",{\"1\":{\"135\":1}}],[\"除以\",{\"1\":{\"24\":2}}],[\"该数据只会暂时存储到\",{\"1\":{\"820\":1}}],[\"该数值可以通过\",{\"1\":{\"307\":2}}],[\"该配置项为\",{\"1\":{\"754\":1}}],[\"该配置默认会自动获取主机\",{\"1\":{\"595\":1}}],[\"该机制默认不开启\",{\"1\":{\"754\":1}}],[\"该机制在\",{\"1\":{\"464\":1}}],[\"该队列新分配到负载的\",{\"1\":{\"745\":1}}],[\"该消费者负载的队列列表\",{\"1\":{\"787\":1}}],[\"该消费者负载的所有消息队列\",{\"1\":{\"653\":1}}],[\"该消息投递之后消费者会收到并重试消费\",{\"1\":{\"708\":1}}],[\"该消息之后会发送到延迟消息的\",{\"1\":{\"708\":1}}],[\"该逻辑由\",{\"1\":{\"675\":1}}],[\"该逻辑在\",{\"1\":{\"559\":1}}],[\"该模式的消费实时性较高\",{\"1\":{\"614\":1}}],[\"该对象创建时默认状态为\",{\"1\":{\"567\":1}}],[\"该列表在消息生产时永远只有\",{\"1\":{\"537\":1}}],[\"该功能默认关闭\",{\"1\":{\"525\":1}}],[\"该账号未设置任何访问规则\",{\"1\":{\"520\":1}}],[\"该账号拥有的资源权限\",{\"1\":{\"520\":1}}],[\"该参数目前设置为5秒\",{\"1\":{\"519\":1}}],[\"该服务的核心逻辑如下\",{\"1\":{\"519\":1}}],[\"该服务是一个线程\",{\"1\":{\"519\":1}}],[\"该服务线程\",{\"1\":{\"336\":1}}],[\"该服务线程会从\",{\"1\":{\"335\":1}}],[\"该改动在服务端nettyserverconfig和客户端配置nettyclientconfig中新增了如下配置项\",{\"1\":{\"819\":1}}],[\"该改动依赖\",{\"1\":{\"425\":1}}],[\"该改动要在\",{\"1\":{\"414\":1}}],[\"该提交未合入\",{\"1\":{\"409\":1,\"412\":1,\"433\":1}}],[\"该文件最后一次写入过后\",{\"1\":{\"390\":1}}],[\"该文件可以看作\",{\"1\":{\"266\":1}}],[\"该条consumequeue索引对应的消息如果未到投递时间\",{\"1\":{\"365\":1,\"380\":1}}],[\"该索引主要包含消息在\",{\"1\":{\"356\":1}}],[\"该线程池默认有\",{\"1\":{\"723\":1}}],[\"该线程中用生产\",{\"1\":{\"678\":1}}],[\"该线程应用了生产\",{\"1\":{\"401\":1}}],[\"该线程循环扫描对应的\",{\"1\":{\"356\":1}}],[\"该线程扫描对应的延迟等级\",{\"1\":{\"354\":1}}],[\"该线程负责将存储到\",{\"1\":{\"331\":1}}],[\"该类是\",{\"1\":{\"329\":1}}],[\"该方法逻辑为\",{\"1\":{\"777\":1}}],[\"该方法逻辑如下\",{\"1\":{\"477\":1,\"493\":1,\"657\":1}}],[\"该方法将消费消息的请求提交到消费线程池\",{\"1\":{\"639\":1}}],[\"该方法将\",{\"1\":{\"639\":1}}],[\"该方法中初始化一个\",{\"1\":{\"426\":1}}],[\"该方法的\",{\"1\":{\"416\":1}}],[\"该方法的调用关系如下图所示\",{\"1\":{\"287\":1}}],[\"该方法调用线程池\",{\"1\":{\"340\":1}}],[\"该方法在长轮询收到新消息时调用\",{\"1\":{\"334\":1}}],[\"该方法主要完成如下操作\",{\"1\":{\"334\":1}}],[\"该方法每隔\",{\"1\":{\"289\":1}}],[\"该mappedfile起始物理偏移量\",{\"1\":{\"285\":1}}],[\"该mappedfile被写过的位置\",{\"1\":{\"285\":1}}],[\"该函数的大致逻辑如下\",{\"1\":{\"285\":1}}],[\"该\",{\"1\":{\"260\":1,\"354\":1,\"491\":1,\"664\":1,\"744\":1}}],[\"该优化主要是减少冗余代码\",{\"1\":{\"251\":1}}],[\"该值默认为\",{\"1\":{\"220\":1}}],[\"该协议能够保证组播消息的原子性\",{\"1\":{\"206\":1}}],[\"该情况下队列的主副本所在的节点与生产者\",{\"1\":{\"201\":1}}],[\"该情况下吞吐量达到130万\",{\"1\":{\"135\":1}}],[\"该节点称为队列主服务器\",{\"1\":{\"193\":1}}],[\"该策略为所有\",{\"1\":{\"185\":1}}],[\"该进程会被阻塞\",{\"1\":{\"154\":1}}],[\"该问题我们也已经report给etcd社区\",{\"1\":{\"134\":1}}],[\"该插件可以做到绝大部分的新增\",{\"1\":{\"121\":1}}],[\"业务团队无法直接创建和修改\",{\"1\":{\"498\":1}}],[\"业务仍处于未恢复状态\",{\"1\":{\"134\":1}}],[\"业务创新更加专注\",{\"1\":{\"126\":1}}],[\"导致队列一直上锁\",{\"1\":{\"732\":1}}],[\"导致服务之间是不连通的\",{\"1\":{\"462\":1}}],[\"导致\",{\"1\":{\"451\":1}}],[\"导致删除时间并不是现实时间\",{\"1\":{\"386\":1}}],[\"导致数据无法正常的投递到正确的消费队列\",{\"1\":{\"365\":1}}],[\"导致内存相关的问题\",{\"1\":{\"226\":1}}],[\"导致在客户端优先连接的节点为主节点\",{\"1\":{\"134\":1}}],[\"导出声明\",{\"1\":{\"30\":1}}],[\"图\",{\"1\":{\"226\":2,\"228\":1}}],[\"图中未画出\",{\"1\":{\"820\":1}}],[\"图中3\",{\"1\":{\"154\":1}}],[\"图中2\",{\"1\":{\"154\":1}}],[\"图中1\",{\"1\":{\"154\":1}}],[\"图7\",{\"1\":{\"135\":1}}],[\"图7是具体的弹性评测结果部分截图\",{\"1\":{\"135\":1}}],[\"图6\",{\"1\":{\"135\":1}}],[\"图6为各指标随着实验时间的变化情况\",{\"1\":{\"135\":1}}],[\"图5\",{\"1\":{\"135\":1}}],[\"图5为三节点集群上的一个\",{\"1\":{\"135\":1}}],[\"图4\",{\"1\":{\"134\":1}}],[\"图3\",{\"1\":{\"134\":1}}],[\"图2\",{\"1\":{\"134\":1}}],[\"图1\",{\"1\":{\"129\":1}}],[\"单项\",{\"1\":{\"573\":1}}],[\"单\",{\"1\":{\"548\":1}}],[\"单向\",{\"1\":{\"545\":1,\"547\":1,\"681\":1,\"691\":1}}],[\"单队列处于飞行状态的消息数限制为2万条\",{\"1\":{\"442\":1}}],[\"单独启动\",{\"0\":{\"597\":1}}],[\"单独创建一个目录\",{\"1\":{\"269\":2}}],[\"单独成为一个分区时的表现\",{\"1\":{\"134\":1}}],[\"单独成为一个分区的场景下\",{\"1\":{\"134\":1}}],[\"单个消费者速度有限\",{\"1\":{\"609\":1}}],[\"单个\",{\"1\":{\"256\":1}}],[\"单线程处理复制结果\",{\"1\":{\"244\":1}}],[\"单线程执行\",{\"1\":{\"11\":1}}],[\"单节点的压力被分散\",{\"1\":{\"181\":1}}],[\"单节点的\",{\"1\":{\"181\":1}}],[\"单元的伸缩能力\",{\"1\":{\"135\":1}}],[\"计算出这条消息是否匹配\",{\"1\":{\"835\":1}}],[\"计算出系统的\",{\"1\":{\"133\":1}}],[\"计算队列还剩下的消息数量\",{\"1\":{\"790\":1}}],[\"计算队列剩余的消息数量\",{\"1\":{\"778\":1}}],[\"计算要\",{\"1\":{\"790\":1}}],[\"计算\",{\"1\":{\"778\":1,\"798\":1}}],[\"计算本次消费请求任务执行时长\",{\"1\":{\"750\":1}}],[\"计算本次期望写入consumequeue的物理偏移量\",{\"1\":{\"285\":1}}],[\"计算异常\",{\"1\":{\"748\":1}}],[\"计算拉取偏移量\",{\"1\":{\"748\":1}}],[\"计算并设置本次拉取任务消息队列的拉取偏移量\",{\"1\":{\"748\":1}}],[\"计算并从偏移量存储中读取下次拉取的偏移量\",{\"1\":{\"657\":1,\"664\":1,\"744\":1}}],[\"计算和记录拉取用时\",{\"1\":{\"695\":1,\"749\":1}}],[\"计算挂起时间\",{\"1\":{\"693\":1}}],[\"计算下次拉取建议的\",{\"1\":{\"683\":1}}],[\"计算当前\",{\"1\":{\"664\":1,\"744\":1}}],[\"计算压力越大\",{\"1\":{\"444\":1}}],[\"计算文件应该被删除的时间\",{\"1\":{\"390\":1}}],[\"计算放置索引的绝对偏移量\",{\"1\":{\"317\":1}}],[\"计算key的hash值\",{\"1\":{\"317\":1}}],[\"计算的逻辑在\",{\"1\":{\"285\":1}}],[\"计算的逻辑放到\",{\"1\":{\"258\":1}}],[\"计算应该写入\",{\"1\":{\"285\":1}}],[\"计算右侧\",{\"1\":{\"23\":1}}],[\"韧性\",{\"1\":{\"132\":1}}],[\"韧性架构\",{\"1\":{\"128\":1,\"136\":1}}],[\"韧性架构进一步发展\",{\"1\":{\"127\":1}}],[\"度量模型会计算出集群的\",{\"1\":{\"135\":1}}],[\"度量模型会根据实验中故障注入情况与系统表现\",{\"1\":{\"133\":1}}],[\"度量模型会对系统的表现进行分析\",{\"1\":{\"133\":1}}],[\"度量模型\",{\"0\":{\"133\":1},\"1\":{\"130\":1}}],[\"模板\",{\"1\":{\"589\":1}}],[\"模式重平衡\",{\"1\":{\"786\":1,\"787\":1}}],[\"模式时引入了\",{\"1\":{\"775\":1}}],[\"模式不同\",{\"1\":{\"775\":1}}],[\"模式拉取消息\",{\"1\":{\"766\":1}}],[\"模式指的是\",{\"1\":{\"765\":1}}],[\"模式消费\",{\"1\":{\"765\":1}}],[\"模式消费和\",{\"1\":{\"765\":1}}],[\"模式消费的以下痛点\",{\"1\":{\"615\":1}}],[\"模式并发消费流程\",{\"1\":{\"624\":1}}],[\"模式共同使用\",{\"1\":{\"615\":1}}],[\"模式默认配置下\",{\"1\":{\"600\":1}}],[\"模式前保证有足够的可用内存\",{\"1\":{\"599\":1}}],[\"模式的重平衡与\",{\"1\":{\"775\":1}}],[\"模式的过滤选择功能\",{\"1\":{\"637\":1}}],[\"模式的\",{\"0\":{\"599\":1}}],[\"模式下可允许被共享的队列数\",{\"1\":{\"787\":1}}],[\"模式下使用\",{\"1\":{\"615\":1}}],[\"模式下性能提升了\",{\"1\":{\"373\":1}}],[\"模式下性能很差\",{\"1\":{\"370\":1}}],[\"模式下\",{\"1\":{\"373\":1,\"615\":1}}],[\"模式下存在性能瓶颈\",{\"1\":{\"373\":1}}],[\"模式下的投递性能\",{\"0\":{\"373\":1}}],[\"模式实现\",{\"1\":{\"349\":1}}],[\"模式如何进行消息的查询\",{\"1\":{\"324\":1}}],[\"模式或\",{\"1\":{\"324\":1}}],[\"模式内部也用了\",{\"1\":{\"323\":1}}],[\"模式原理\",{\"0\":{\"323\":1}}],[\"模式是如何做到能够立即消费新的消息\",{\"1\":{\"322\":1}}],[\"模式\",{\"1\":{\"321\":3,\"322\":1,\"766\":1,\"768\":1,\"772\":2,\"852\":1}}],[\"模式和\",{\"1\":{\"190\":1,\"321\":1}}],[\"模式识别有深刻的理解与研究\",{\"1\":{\"136\":1}}],[\"模拟的业务流量速率为1000\",{\"1\":{\"134\":1}}],[\"模型\",{\"1\":{\"130\":1}}],[\"模块使用\",{\"1\":{\"555\":1}}],[\"模块的实现原理\",{\"1\":{\"506\":1}}],[\"模块的使用和实现原理\",{\"1\":{\"496\":1}}],[\"模块的外部函数\",{\"1\":{\"60\":1}}],[\"模块实现了一套简单访问控制功能\",{\"1\":{\"496\":1}}],[\"模块实现的是一种可靠的组播通信协议\",{\"1\":{\"206\":1}}],[\"模块会在实验中监测被测集群的表现\",{\"1\":{\"130\":2}}],[\"模块名和行号\",{\"1\":{\"106\":1}}],[\"模块名必须与存放该模块的主文件名相同\",{\"1\":{\"30\":1}}],[\"模块属性的语法是\",{\"1\":{\"52\":1}}],[\"模块声明\",{\"1\":{\"30\":1,\"53\":1}}],[\"模块保存在扩展名为\",{\"1\":{\"30\":1}}],[\"模块是erlang的基本代码单元\",{\"1\":{\"30\":1}}],[\"模块\",{\"0\":{\"30\":1,\"464\":1},\"1\":{\"464\":1,\"496\":1,\"510\":1,\"516\":1}}],[\"模块与函数\",{\"0\":{\"29\":1}}],[\"演练结束后\",{\"1\":{\"130\":2}}],[\"演练过程中\",{\"1\":{\"130\":1}}],[\"组成\",{\"1\":{\"541\":1,\"556\":1}}],[\"组成的列表\",{\"1\":{\"34\":1}}],[\"组播\",{\"1\":{\"201\":1}}],[\"组件会对实验中的业务和非业务数据进行自动化分析\",{\"1\":{\"130\":1}}],[\"组件定义的执行流程控制客户端对集群进行操作\",{\"1\":{\"130\":1}}],[\"根据拉取结果\",{\"1\":{\"848\":1}}],[\"根据拉取消息的消费者信息\",{\"1\":{\"844\":1}}],[\"根据拉取的状态进行判断\",{\"1\":{\"685\":1}}],[\"根据完整消息来判断消息是否匹配过滤规则\",{\"1\":{\"838\":1}}],[\"根据重平衡策略名称获取策略\",{\"1\":{\"786\":1}}],[\"根据集群的负载来选择\",{\"1\":{\"754\":1}}],[\"根据偏移量从\",{\"1\":{\"718\":1}}],[\"根据名称查询主节点地址\",{\"1\":{\"717\":1}}],[\"根据服务端下一次校对的偏移量尝试更新消息消费进度\",{\"1\":{\"695\":1}}],[\"根据属性进行过滤\",{\"1\":{\"694\":1}}],[\"根据getmessageresult状态码推算response状态码\",{\"1\":{\"693\":1}}],[\"根据主从同步延迟计算下一次从主或从节点拉取\",{\"1\":{\"693\":1}}],[\"根据主题名称\",{\"1\":{\"691\":1}}],[\"根据brokername\",{\"1\":{\"691\":1}}],[\"根据过滤类型构建拉取时的系统标记\",{\"1\":{\"690\":1}}],[\"根据从存储查询消息的结果\",{\"1\":{\"683\":1}}],[\"根据请求发送的交互模式\",{\"1\":{\"681\":1}}],[\"根据请求的队列\",{\"1\":{\"777\":1}}],[\"根据请求的\",{\"1\":{\"581\":2}}],[\"根据请求的主题获取该主题的路由信息\",{\"1\":{\"493\":1}}],[\"根据队列找到对应的消费队列\",{\"1\":{\"673\":1}}],[\"根据配置\",{\"1\":{\"658\":1}}],[\"根据配置同步或者异步投递\",{\"1\":{\"377\":1}}],[\"根据推和拉模式的不同\",{\"1\":{\"649\":1}}],[\"根据注册的\",{\"1\":{\"624\":1}}],[\"根据是否启用\",{\"1\":{\"572\":1}}],[\"根据是否配置自动重试来执行重试或者直接跳过\",{\"1\":{\"378\":1}}],[\"根据不同种类的请求做不同类型的处理\",{\"1\":{\"464\":1}}],[\"根据文件过期时间来删除文件\",{\"1\":{\"390\":1}}],[\"根据结果更新状态\",{\"1\":{\"381\":1}}],[\"根据任务的执行状态来更新\",{\"1\":{\"375\":1}}],[\"根据consumequeue的有效延迟消息逻辑offset\",{\"1\":{\"365\":1,\"380\":1}}],[\"根据delaylevel查找对应的延迟消息consumequeue\",{\"1\":{\"365\":1,\"380\":1}}],[\"根据store中获取的最大偏移量\",{\"1\":{\"343\":1}}],[\"根据topic和queueid从容器中取出挂起的拉取请求列表\",{\"1\":{\"345\":1}}],[\"根据topic和queueid构造map的key\",{\"1\":{\"342\":1}}],[\"根据topic和message\",{\"1\":{\"309\":1,\"314\":2}}],[\"根据上面的活动图来看一下\",{\"1\":{\"326\":1}}],[\"根据轮询设定的超时阈值大小的不同\",{\"1\":{\"324\":1}}],[\"根据key的hash值计算hash槽的绝对位置\",{\"1\":{\"317\":1}}],[\"根据逻辑偏移量从\",{\"1\":{\"287\":2,\"694\":1}}],[\"根据期望的偏移量找到对应的内存映射文件\",{\"1\":{\"285\":1}}],[\"根据\",{\"1\":{\"284\":1,\"287\":1,\"314\":1,\"317\":2,\"345\":1,\"462\":1,\"474\":1,\"492\":1,\"541\":1,\"557\":1,\"573\":2,\"658\":1,\"663\":1,\"783\":1,\"796\":1,\"800\":1,\"819\":1,\"847\":1,\"852\":2}}],[\"根据消费队列判断消息是否匹配过滤规则\",{\"1\":{\"838\":1}}],[\"根据消费队列过滤时\",{\"1\":{\"834\":1}}],[\"根据消费队列索引从\",{\"1\":{\"684\":1}}],[\"根据消费结果设置返回状态\",{\"1\":{\"738\":1}}],[\"根据消费状态判定返回结果\",{\"1\":{\"708\":1}}],[\"根据消费组\",{\"1\":{\"693\":1}}],[\"根据消费者类型不同有着不同的实现\",{\"1\":{\"654\":1}}],[\"根据消费的\",{\"1\":{\"271\":1}}],[\"根据消息属性精确匹配的性能消耗比较大\",{\"1\":{\"833\":1}}],[\"根据消息的属性和\",{\"1\":{\"835\":1}}],[\"根据消息的\",{\"1\":{\"823\":1}}],[\"根据消息的偏移量和消息的大小从\",{\"1\":{\"287\":1,\"694\":1}}],[\"根据消息发回请求中带的物理偏移量\",{\"1\":{\"708\":1}}],[\"根据消息发送方式进行网络传输\",{\"1\":{\"573\":1}}],[\"根据消息发送方式\",{\"1\":{\"573\":1}}],[\"根据消息发送方式调用\",{\"1\":{\"562\":1}}],[\"根据消息发送的\",{\"1\":{\"201\":1}}],[\"根据消息队列从本地缓存查询对应的\",{\"1\":{\"680\":1}}],[\"根据消息分发请求构建索引\",{\"1\":{\"309\":1,\"314\":1}}],[\"根据消息在\",{\"1\":{\"267\":1}}],[\"根据镜像队列的机制\",{\"1\":{\"202\":1}}],[\"根据openchaos内置的算法来计算出要弹到的目标规模\",{\"1\":{\"135\":1}}],[\"根据设置的并发数建立相应个数的客户端\",{\"1\":{\"130\":1}}],[\"根据国内外科技媒体调研统计\",{\"1\":{\"126\":1}}],[\"控制包\",{\"1\":{\"820\":1}}],[\"控制\",{\"1\":{\"325\":1,\"386\":1,\"820\":2}}],[\"控制器\",{\"1\":{\"480\":1}}],[\"控制器在模型中载入需要测试的分布式系统的驱动\",{\"1\":{\"130\":1}}],[\"控制器负责调度引擎层的组件进行工作\",{\"1\":{\"130\":1}}],[\"控制节点根据\",{\"1\":{\"130\":1}}],[\"控制面对整个流程进行控制\",{\"1\":{\"130\":1}}],[\"控制台执行\",{\"1\":{\"123\":1}}],[\"控制台不用关\",{\"1\":{\"123\":1}}],[\"控制台粘贴即可\",{\"1\":{\"123\":1}}],[\"控制台\",{\"1\":{\"123\":1}}],[\"检测配置文件的变更\",{\"1\":{\"510\":1,\"516\":1}}],[\"检测模型与度量模型\",{\"0\":{\"131\":1}}],[\"检测模型\",{\"0\":{\"132\":1},\"1\":{\"130\":1}}],[\"检索系统的查全率与查准率\",{\"1\":{\"128\":1}}],[\"检查给定的\",{\"1\":{\"843\":1}}],[\"检查处理队列是否丢弃\",{\"1\":{\"738\":1}}],[\"检查处理队列中还未被消费的消息\",{\"1\":{\"679\":1}}],[\"检查队列是否被丢弃和消费者是否挂起\",{\"1\":{\"679\":1}}],[\"检查队列数量\",{\"1\":{\"618\":1}}],[\"检查是否已经\",{\"1\":{\"797\":1}}],[\"检查是否是刚创建状态\",{\"1\":{\"640\":1}}],[\"检查是否有消息到达\",{\"1\":{\"344\":1}}],[\"检查生产者处于运行状态\",{\"1\":{\"570\":1}}],[\"检查配置\",{\"1\":{\"557\":1}}],[\"检查的字符串的每一个字符是否在位图中\",{\"1\":{\"424\":1}}],[\"检查通过正则表达式匹配来进行\",{\"1\":{\"424\":1}}],[\"检查重试次数\",{\"1\":{\"381\":1}}],[\"检查所有已经挂起的长轮询请求\",{\"1\":{\"343\":1}}],[\"检查所有挂起的拉取请求\",{\"1\":{\"335\":1}}],[\"检查轮询条件\",{\"1\":{\"335\":1}}],[\"检查消费结果\",{\"1\":{\"738\":1}}],[\"检查消费成功与否\",{\"1\":{\"708\":1}}],[\"检查消费者配置是否合法\",{\"1\":{\"642\":1}}],[\"检查消费者配置信息是否合法\",{\"1\":{\"640\":1}}],[\"检查消费者状态\",{\"1\":{\"642\":1}}],[\"检查消费队列中是否有新消息到达\",{\"1\":{\"326\":1}}],[\"检查消息是否含有重试\",{\"1\":{\"708\":1}}],[\"检查消息合法性检查\",{\"1\":{\"576\":1}}],[\"检查消息合理性\",{\"1\":{\"563\":1}}],[\"检查消息\",{\"1\":{\"282\":1}}],[\"检查索引文件列表最后一个文件是否存在以及是否满\",{\"1\":{\"309\":1}}],[\"检查周期flushintervalconsumequeue可配置\",{\"1\":{\"278\":1}}],[\"检查\",{\"1\":{\"84\":1,\"171\":2,\"461\":1,\"474\":1,\"567\":1,\"715\":1,\"718\":2}}],[\"针对资源能进行的操作\",{\"1\":{\"498\":1}}],[\"针对\",{\"1\":{\"406\":1}}],[\"针对一些分布式系统特有属性\",{\"1\":{\"128\":1}}],[\"针对分布式系统韧性能力\",{\"1\":{\"128\":1}}],[\"针对异常的编程样式\",{\"0\":{\"46\":1}}],[\"弹性的含义不仅包括实例节点的伸缩能力\",{\"1\":{\"135\":1}}],[\"弹性检测模型会根据指定的预期值与当前系统表现\",{\"1\":{\"135\":1}}],[\"弹性也是分布式系统需要重点关注的能力\",{\"1\":{\"135\":1}}],[\"弹性案例分析\",{\"0\":{\"135\":1}}],[\"弹性伸缩与冷启效率\",{\"1\":{\"128\":1}}],[\"弹性\",{\"1\":{\"128\":1}}],[\"弹性等一系列韧性架构的挑战\",{\"1\":{\"126\":1}}],[\"需要建立这样的一个索引结构\",{\"1\":{\"880\":1}}],[\"需要开启配置项才会存储扩展属性\",{\"1\":{\"838\":1}}],[\"需要进一步匹配\",{\"1\":{\"834\":1}}],[\"需要进行修改\",{\"1\":{\"595\":1}}],[\"需要进行访问控制的对象\",{\"1\":{\"498\":1}}],[\"需要进行数据的同步或者恢复\",{\"1\":{\"226\":1}}],[\"需要设置如下配置\",{\"1\":{\"828\":1}}],[\"需要设置\",{\"1\":{\"828\":1}}],[\"需要显式指定拉取或订阅的队列信息才可以\",{\"1\":{\"813\":1}}],[\"需要针对每个\",{\"1\":{\"783\":1}}],[\"需要被唤醒时做检查\",{\"1\":{\"773\":1}}],[\"需要等待第一个消息先投递\",{\"1\":{\"876\":1}}],[\"需要等待下一次重平衡时再尝试解锁\",{\"1\":{\"745\":1}}],[\"需要等待一会然后重新投递\",{\"1\":{\"377\":1}}],[\"需要锁定的队列\",{\"1\":{\"742\":1}}],[\"需要保证一个队列最多仅被一个线程消费\",{\"1\":{\"727\":1}}],[\"需要保存消费进度\",{\"1\":{\"623\":1}}],[\"需要重试\",{\"1\":{\"715\":1,\"798\":1}}],[\"需要重新启动\",{\"1\":{\"211\":1}}],[\"需要定义哪些方法\",{\"1\":{\"637\":1}}],[\"需要修改\",{\"1\":{\"601\":1}}],[\"需要同时改动\",{\"1\":{\"600\":1}}],[\"需要先引入消费组的概念\",{\"1\":{\"608\":1}}],[\"需要先修改\",{\"1\":{\"597\":1}}],[\"需要先初始化它的\",{\"1\":{\"417\":1}}],[\"需要安装完成\",{\"1\":{\"590\":1}}],[\"需要把消息发回去\",{\"1\":{\"568\":1}}],[\"需要从中选择一个队列进行发送\",{\"1\":{\"561\":1}}],[\"需要处理客户端发送来的生产请求\",{\"1\":{\"544\":1}}],[\"需要放在\",{\"1\":{\"503\":1}}],[\"需要提交申请由运维团队审批\",{\"1\":{\"498\":1}}],[\"需要流控\",{\"1\":{\"453\":1}}],[\"需要的格子数太多怎么办\",{\"1\":{\"451\":1}}],[\"需要投递的消息都查出来放到时间轮里面\",{\"1\":{\"451\":1}}],[\"需要触发的所有任务\",{\"1\":{\"451\":1}}],[\"需要新增两种存储\",{\"1\":{\"449\":1}}],[\"需要实际压测\",{\"1\":{\"437\":1}}],[\"需要注意\",{\"1\":{\"386\":1}}],[\"需要注意的是value也是一个map类型\",{\"1\":{\"517\":1}}],[\"需要注意的是\",{\"1\":{\"353\":1,\"622\":1,\"820\":1}}],[\"需要将每个逻辑判断内容放入括号内\",{\"1\":{\"828\":1}}],[\"需要将生产者分别注册到多个\",{\"1\":{\"755\":1}}],[\"需要将\",{\"1\":{\"595\":1}}],[\"需要将异步投递的任务放入处理队列\",{\"1\":{\"375\":1}}],[\"需要将消息同步给所有的\",{\"1\":{\"201\":1}}],[\"需要做流控\",{\"1\":{\"374\":1}}],[\"需要唤醒挂起的拉取请求\",{\"1\":{\"332\":1}}],[\"需要刷盘的索引文件\",{\"1\":{\"316\":1}}],[\"需要刷盘的数据超过getflushconsumequeueleastpages\",{\"1\":{\"278\":1}}],[\"需要有对应的规划和措施\",{\"1\":{\"235\":1}}],[\"需要超过半数的队列副本都将消息写入磁盘以后才会向生产者进行确认\",{\"1\":{\"228\":1}}],[\"需要超过半数的副本同意\",{\"1\":{\"228\":1}}],[\"需要在一瞬间投递\",{\"1\":{\"878\":1}}],[\"需要在\",{\"1\":{\"177\":1}}],[\"需要在两个集群都开启\",{\"1\":{\"163\":1}}],[\"需要解决的本质问题\",{\"0\":{\"128\":1}}],[\"需要一些\",{\"1\":{\"103\":1}}],[\"他本身的启动方法并没有什么逻辑\",{\"1\":{\"640\":1}}],[\"他们的监听\",{\"1\":{\"595\":1}}],[\"他们之中的消息顺序就是固定的\",{\"1\":{\"445\":1}}],[\"他们可以使用参数\",{\"1\":{\"198\":1}}],[\"他提出并带领团队创造了openchaos这一新兴项目\",{\"1\":{\"127\":1}}],[\"他是一个\",{\"1\":{\"67\":1}}],[\"还未投递的消息是否到期\",{\"1\":{\"876\":1}}],[\"还未提交\",{\"1\":{\"425\":1}}],[\"还要从\",{\"1\":{\"820\":1}}],[\"还要修改\",{\"1\":{\"595\":1}}],[\"还可以包含大量轻量级队列\",{\"1\":{\"811\":1}}],[\"还可恶意针对分布式基础软件如消息或缓存等的主备倒换\",{\"1\":{\"132\":1}}],[\"还没有被匹配的\",{\"1\":{\"773\":1,\"781\":1}}],[\"还有一个消费锁\",{\"1\":{\"729\":1}}],[\"还有一些\",{\"1\":{\"253\":1}}],[\"还存在重平衡的可能性\",{\"1\":{\"701\":1}}],[\"还需要重试消费\",{\"1\":{\"708\":1}}],[\"还需要将消费进度让其他消费者知道\",{\"1\":{\"623\":1}}],[\"还需要完备的监测系统\",{\"1\":{\"127\":1}}],[\"还包含白名单概念\",{\"1\":{\"498\":1}}],[\"还包含如弹性\",{\"1\":{\"132\":1}}],[\"还剩下最后的问题是流控和消息的重投\",{\"1\":{\"452\":1}}],[\"还支持按客户端\",{\"1\":{\"496\":1}}],[\"还支持延迟消息的取消\",{\"1\":{\"442\":1}}],[\"还支持通过消息存储时间来查询具体消息\",{\"1\":{\"271\":1}}],[\"还用自旋锁可能就不合适了\",{\"1\":{\"253\":1}}],[\"还会将消息发送给队列所有的\",{\"1\":{\"201\":1}}],[\"还是要修改\",{\"1\":{\"598\":1}}],[\"还是在之后一段时间都避开该\",{\"1\":{\"552\":1}}],[\"还是消费方没有消费成功\",{\"1\":{\"523\":1}}],[\"还是可以充分利用page\",{\"1\":{\"398\":1}}],[\"还是上面那个例子\",{\"1\":{\"234\":1}}],[\"还是保证队列的一致性\",{\"1\":{\"192\":1}}],[\"还是\",{\"1\":{\"2\":4}}],[\"很难支持百万级别甚至更多数量\",{\"1\":{\"804\":1}}],[\"很难形成统一的评测标准\",{\"1\":{\"127\":1}}],[\"很多操作最终都是调用它来做的\",{\"1\":{\"638\":1}}],[\"很多网站\",{\"1\":{\"496\":1}}],[\"很多时候\",{\"1\":{\"38\":1}}],[\"很明显\",{\"1\":{\"448\":1}}],[\"很大机会会被虚拟机分配至物理机器的高速寄存器中存储\",{\"1\":{\"424\":1}}],[\"很高的场景下\",{\"1\":{\"261\":1}}],[\"仅\",{\"1\":{\"842\":1}}],[\"仅支持单个队列中的消息的顺序消费\",{\"1\":{\"723\":1}}],[\"仅支持固定等级的延迟消息\",{\"1\":{\"442\":1}}],[\"仅有集群模式能使用顺序消费\",{\"1\":{\"622\":1}}],[\"仅定义了\",{\"1\":{\"515\":1}}],[\"仅仅是一个队列\",{\"1\":{\"813\":1}}],[\"仅仅是遍历客户端上注册的所有消费者\",{\"1\":{\"657\":1}}],[\"仅仅为了启动\",{\"1\":{\"600\":1}}],[\"仅仅处理其他模块的请求\",{\"1\":{\"463\":1}}],[\"仅仅用于消息的查询\",{\"1\":{\"388\":1}}],[\"仅仅让新的消息复制到这个重新上线的镜像队列\",{\"1\":{\"226\":1}}],[\"仅通过观察系统应对故障的表现是有局限的\",{\"1\":{\"127\":1}}],[\"仅此而已\",{\"1\":{\"23\":1}}],[\"面向有更多复杂特性的分布式系统\",{\"1\":{\"127\":1}}],[\"同一进程中多个生产者发送消息到多个集群\",{\"0\":{\"755\":1}}],[\"同一消费组中的每个消费者应保持一致\",{\"1\":{\"653\":1}}],[\"同一\",{\"1\":{\"611\":1,\"760\":1}}],[\"同一队列积累的拉取请求\",{\"1\":{\"335\":1}}],[\"同样用生产\",{\"1\":{\"436\":1}}],[\"同样一次最多删\",{\"1\":{\"386\":1}}],[\"同样地\",{\"1\":{\"228\":1}}],[\"同样\",{\"1\":{\"207\":2,\"378\":1}}],[\"同样也是缓存\",{\"1\":{\"710\":1}}],[\"同样也会将消息对外发送两次\",{\"1\":{\"201\":1}}],[\"同样也包含具体业务\",{\"1\":{\"135\":1}}],[\"同样的\",{\"1\":{\"196\":1}}],[\"同步消息的基准是\",{\"1\":{\"708\":1}}],[\"同步发送共重试timestotal次\",{\"1\":{\"570\":1}}],[\"同步发送的重试逻辑即在\",{\"1\":{\"560\":1}}],[\"同步发送和异步发送的重试次数分别由\",{\"1\":{\"560\":1}}],[\"同步等待\",{\"1\":{\"547\":1}}],[\"同步标记\",{\"1\":{\"484\":1}}],[\"同步投递\",{\"1\":{\"380\":1,\"381\":1}}],[\"同步复制\",{\"1\":{\"373\":1}}],[\"同步和异步的消息存储函数\",{\"1\":{\"359\":1}}],[\"同步保存消息的方法即是异步方法调用get\",{\"1\":{\"363\":1}}],[\"同步保存批量消息\",{\"1\":{\"251\":1}}],[\"同步保存单条消息\",{\"1\":{\"251\":1}}],[\"同步的问题被解决\",{\"1\":{\"229\":1}}],[\"同步的影响就会抱很大\",{\"1\":{\"226\":1}}],[\"同步还会消耗内存\",{\"1\":{\"226\":1}}],[\"同步很快结束\",{\"1\":{\"226\":1}}],[\"同步是阻塞的\",{\"1\":{\"226\":1}}],[\"同步会导致集群中与内存相关的问题\",{\"1\":{\"211\":1}}],[\"同步将会需要很长时间\",{\"1\":{\"211\":1}}],[\"同步阻塞\",{\"0\":{\"211\":1}}],[\"同步\",{\"1\":{\"166\":1,\"210\":1,\"541\":1,\"545\":1,\"547\":2,\"573\":1,\"681\":1,\"691\":1}}],[\"同时水位线还分为高水位线和低水位线\",{\"1\":{\"820\":1}}],[\"同时删除messagequeue\",{\"1\":{\"664\":1,\"744\":1}}],[\"同时包含消费者启动流程\",{\"1\":{\"627\":1}}],[\"同时消费者端缓存\",{\"1\":{\"623\":1}}],[\"同时启动\",{\"0\":{\"601\":1}}],[\"同时更新路由信息表\",{\"1\":{\"474\":1}}],[\"同时缓存了路由信息\",{\"1\":{\"470\":1}}],[\"同时触发\",{\"1\":{\"465\":1}}],[\"同时再加上定期的将内存数据镜像\",{\"1\":{\"462\":1}}],[\"同时最多只能满足两个点\",{\"1\":{\"462\":1}}],[\"同时还具备基本等同于普通消息的性能表现\",{\"1\":{\"442\":1}}],[\"同时还会发送一次对消息的\",{\"1\":{\"201\":1}}],[\"同时生产和消费\",{\"1\":{\"407\":1}}],[\"同时在第一次试图删除该文件时记录当前时间戳\",{\"1\":{\"390\":1}}],[\"同时向4个延迟等级发送延迟消息\",{\"1\":{\"372\":2}}],[\"同时向\",{\"1\":{\"372\":1}}],[\"同时从本地缓存变量\",{\"1\":{\"336\":1}}],[\"同时将参数\",{\"1\":{\"253\":1}}],[\"同时这个\",{\"1\":{\"155\":1}}],[\"同时\",{\"1\":{\"127\":1,\"160\":1,\"229\":1,\"271\":1,\"510\":1,\"516\":1,\"782\":1,\"820\":1}}],[\"同键表\",{\"1\":{\"98\":1}}],[\"硬件\",{\"1\":{\"127\":1}}],[\"倾向于构造以黑盒随机为主的故障类型\",{\"1\":{\"127\":1}}],[\"目录下\",{\"1\":{\"594\":1}}],[\"目录下所有acl配置文件和\",{\"1\":{\"519\":1}}],[\"目录下的\",{\"1\":{\"269\":1}}],[\"目录\",{\"1\":{\"518\":1}}],[\"目录中\",{\"1\":{\"269\":1}}],[\"目前还不能在broker配置文件中设置\",{\"1\":{\"519\":1}}],[\"目前\",{\"1\":{\"136\":1}}],[\"目前市面上绝大部分混沌工程工具\",{\"1\":{\"127\":1}}],[\"目标代码块\",{\"1\":{\"30\":1}}],[\"良药虽好\",{\"0\":{\"127\":1}}],[\"到期则投递到真正的\",{\"1\":{\"876\":1}}],[\"到队列\",{\"1\":{\"790\":1}}],[\"到队列中\",{\"1\":{\"436\":1}}],[\"到内存\",{\"1\":{\"790\":1}}],[\"到的消息\",{\"1\":{\"778\":1}}],[\"到消息\",{\"1\":{\"777\":1}}],[\"到达水位线后\",{\"1\":{\"820\":1}}],[\"到达高水位线后调用\",{\"1\":{\"820\":1}}],[\"到达唤醒重试时间\",{\"1\":{\"781\":1}}],[\"到达\",{\"1\":{\"761\":1}}],[\"到那时同一个消费组中的订阅关系必须一致\",{\"1\":{\"759\":1}}],[\"到底是生产方没有发送\",{\"1\":{\"523\":1}}],[\"到磁盘来保证数据的一致性和持久性\",{\"1\":{\"462\":1}}],[\"到了设置的每天固定删除时间\",{\"1\":{\"390\":1}}],[\"到投递时间时执行\",{\"1\":{\"365\":1,\"380\":1}}],[\"到\",{\"1\":{\"309\":1,\"777\":1,\"780\":1,\"782\":1}}],[\"到其他节点的方式来提升消息的高可用性\",{\"1\":{\"181\":1}}],[\"到2025年\",{\"1\":{\"126\":1}}],[\"到编译器选项列表中\",{\"1\":{\"53\":1}}],[\"混沌工程的最基本流程是在生产环境小规模定期自动化执行试验\",{\"1\":{\"127\":1}}],[\"混沌工程思想给我们带来了一定程度的启发\",{\"1\":{\"126\":1}}],[\"混沌故障\",{\"1\":{\"126\":1}}],[\"混沌故障引入到催生未来架构变革的多云多活参考架构的制定\",{\"1\":{\"126\":1}}],[\"国内由信通院牵头的混沌工程实验室也在如火如荼地推动该领域的飞速发展\",{\"1\":{\"126\":1}}],[\"企业的数字化升级不断加快\",{\"1\":{\"126\":1}}],[\"安全性是仲裁队列的主要目标\",{\"1\":{\"237\":1}}],[\"安全性等特性的检测模型\",{\"1\":{\"132\":1}}],[\"安全\",{\"1\":{\"126\":1,\"128\":1}}],[\"安装包到本地\",{\"1\":{\"592\":1}}],[\"安装包\",{\"1\":{\"178\":1}}],[\"安装包下载\",{\"1\":{\"176\":1}}],[\"安装包安装\",{\"0\":{\"176\":1}}],[\"安装方法是用\",{\"1\":{\"175\":1}}],[\"安装\",{\"0\":{\"174\":1,\"175\":1,\"177\":1,\"178\":1},\"1\":{\"122\":1,\"176\":1,\"177\":1,\"238\":1}}],[\"安装使用方式可以在网上搜索\",{\"1\":{\"121\":1}}],[\"安装插件的情况下可以直接运行测试\",{\"1\":{\"10\":1}}],[\"安装插件\",{\"0\":{\"6\":1}}],[\"融合架构是这几年被提的最多的一个词\",{\"1\":{\"126\":1}}],[\"催生新架构的不断演进\",{\"1\":{\"126\":1}}],[\"多批\",{\"1\":{\"714\":1}}],[\"多语言支持不友好\",{\"1\":{\"615\":1}}],[\"多见于关机恢复的场景\",{\"1\":{\"285\":1}}],[\"多线程处理比较好\",{\"1\":{\"253\":1}}],[\"多个消费者共同消费一个\",{\"1\":{\"701\":1}}],[\"多个消费任务提交到消费线程池\",{\"1\":{\"624\":1}}],[\"多个字符串\",{\"1\":{\"420\":1}}],[\"多个\",{\"1\":{\"244\":1,\"807\":1}}],[\"多少个镜像才是最优的\",{\"0\":{\"195\":1}}],[\"多租共池等等无不在逼迫我们重新审视老式架构的合理性\",{\"1\":{\"126\":1}}],[\"多进程串行执行\",{\"1\":{\"9\":1}}],[\"极致弹性\",{\"1\":{\"126\":1}}],[\"按策略分配\",{\"1\":{\"663\":1}}],[\"按预设的策略将队列分配给消费者\",{\"1\":{\"650\":1}}],[\"按消息轨迹存储协议进行编码\",{\"1\":{\"541\":1}}],[\"按\",{\"1\":{\"397\":1,\"541\":2,\"617\":1}}],[\"按时间查询\",{\"1\":{\"309\":1}}],[\"按此步骤创建镜像策略\",{\"1\":{\"185\":1}}],[\"按需付费\",{\"1\":{\"126\":1}}],[\"按照重试次数来修改下一次的可见时间\",{\"1\":{\"771\":1}}],[\"按照订阅组配置重定向\",{\"1\":{\"693\":1}}],[\"按照相同规则对批量消息进行解码\",{\"1\":{\"564\":1}}],[\"按照轮询的方式选择队列\",{\"1\":{\"561\":1}}],[\"按照erlang的惯例\",{\"1\":{\"61\":1}}],[\"按照如上所示的流程进行基准测试\",{\"1\":{\"4\":1}}],[\"微服务\",{\"1\":{\"126\":1}}],[\"微基准测试工具\",{\"1\":{\"15\":1}}],[\"第三个参数\",{\"1\":{\"526\":1,\"527\":1}}],[\"第2版\",{\"1\":{\"404\":1,\"494\":1}}],[\"第二层则执行精确的过滤匹配\",{\"1\":{\"842\":1}}],[\"第二层过滤\",{\"1\":{\"835\":1}}],[\"第二点需要用到多个锁来保证\",{\"1\":{\"724\":1}}],[\"第二版\",{\"1\":{\"577\":1}}],[\"第二次使用默认主题查询\",{\"1\":{\"571\":1}}],[\"第二个参数即启用消息轨迹\",{\"1\":{\"526\":1,\"527\":1}}],[\"第二个场景就需要对定时消息的投递做流控和失败重试\",{\"1\":{\"451\":1}}],[\"第二份是修改后的\",{\"1\":{\"257\":1}}],[\"第二部分中\",{\"1\":{\"125\":1}}],[\"第一层利用布隆过滤器判断这个消息是否大概率要被对应的消费者拉取\",{\"1\":{\"842\":1}}],[\"第一层根据消费队列过滤主要是用来在许多消费组之间筛选出有可能匹配的消费组\",{\"1\":{\"835\":1}}],[\"第一点可以在并发消费的基础上修改消费线程池的逻辑\",{\"1\":{\"724\":1}}],[\"第一次拉取\",{\"1\":{\"748\":1}}],[\"第一次查询\",{\"1\":{\"559\":1}}],[\"第一次调用该方法时尝试从\",{\"1\":{\"417\":1}}],[\"第一次拒绝删除之后能保留文件的最大时间\",{\"1\":{\"390\":1}}],[\"第一次执行会报如下错误\",{\"1\":{\"176\":1}}],[\"第一阶段生产者\",{\"1\":{\"244\":1}}],[\"第一个场景下\",{\"1\":{\"451\":1}}],[\"第一个元素称为列表头\",{\"1\":{\"27\":1}}],[\"第一个进程执行测试\",{\"1\":{\"11\":1}}],[\"热更新一下就行\",{\"1\":{\"123\":1}}],[\"服务端收到\",{\"1\":{\"773\":1}}],[\"服务端收到请求后也会对请求参数进行排序\",{\"1\":{\"509\":1}}],[\"服务端实现\",{\"0\":{\"773\":1}}],[\"服务端交互\",{\"0\":{\"772\":1}}],[\"服务端技术栈\",{\"1\":{\"625\":1}}],[\"服务端接收到后\",{\"1\":{\"564\":1}}],[\"服务端处理请求\",{\"1\":{\"501\":1}}],[\"服务端配置\",{\"1\":{\"480\":1}}],[\"服务\",{\"1\":{\"123\":1,\"519\":1,\"598\":1}}],[\"服务器拉取一批消息\",{\"1\":{\"637\":1}}],[\"服务器地址\",{\"1\":{\"487\":1}}],[\"服务器在收到客户端的请求之后\",{\"1\":{\"286\":1}}],[\"服务器目录\",{\"1\":{\"176\":1}}],[\"服务器或集群\",{\"1\":{\"168\":1}}],[\"服务器\",{\"0\":{\"80\":1},\"1\":{\"112\":1}}],[\"任意的定时时间\",{\"0\":{\"876\":1}}],[\"任意时间定时\",{\"0\":{\"880\":1}}],[\"任意时间定时消息\",{\"0\":{\"869\":1}}],[\"任意时间定时消息特性提供领先业界的定时消息体验\",{\"1\":{\"457\":1}}],[\"任意时间定时消息的主要难点有以下几个\",{\"1\":{\"875\":1}}],[\"任意时间定时消息的实现存在一定的难点\",{\"1\":{\"875\":1}}],[\"任意时间定时消息的难点\",{\"0\":{\"875\":1}}],[\"任意时间定时消息的使用\",{\"0\":{\"873\":1}}],[\"任意时间定时消息的设计和实现\",{\"1\":{\"456\":1}}],[\"任意时间定时消息的面纱\",{\"1\":{\"442\":1}}],[\"任意时间定时消息实现\",{\"0\":{\"368\":1}}],[\"任意时间延时消息原理讲解\",{\"1\":{\"458\":1}}],[\"任意时间的定时消息或延迟消息\",{\"1\":{\"457\":1}}],[\"任意时间的定时消息\",{\"1\":{\"439\":1}}],[\"任何功能都可以用消息来触发\",{\"1\":{\"455\":1}}],[\"任何运行旧版代码的进程都会被终止\",{\"1\":{\"57\":1}}],[\"任务的新增和取消都是\",{\"1\":{\"451\":1}}],[\"任务扔到一个队列中\",{\"1\":{\"435\":1}}],[\"任务不断从阻塞队列头部获取异步投递过程对象\",{\"1\":{\"378\":1}}],[\"任务\",{\"1\":{\"377\":1,\"378\":2}}],[\"任务有点重\",{\"1\":{\"253\":1}}],[\"任务执行\",{\"1\":{\"123\":1}}],[\"任凭风浪起\",{\"1\":{\"136\":1}}],[\"观察火焰图中时间占比较高的方法进行针对性优化\",{\"1\":{\"437\":1}}],[\"观察\",{\"1\":{\"123\":1}}],[\"复用一个拉取请求\",{\"1\":{\"688\":1}}],[\"复制到镜像\",{\"1\":{\"210\":1}}],[\"复制到另一个\",{\"1\":{\"163\":1}}],[\"复制的过程是非阻塞的\",{\"1\":{\"229\":1}}],[\"复制的目的端被称为\",{\"1\":{\"163\":1}}],[\"复制的源端被称为\",{\"1\":{\"163\":1}}],[\"复制命令\",{\"1\":{\"123\":1}}],[\"复赛\",{\"1\":{\"16\":1}}],[\"随机地址被映射到了内存\",{\"1\":{\"248\":1}}],[\"随机选择一个节点\",{\"1\":{\"193\":1}}],[\"随后服务端会在存储中查询一批消息\",{\"1\":{\"773\":1}}],[\"随后生产者会启动定时任务\",{\"1\":{\"559\":1}}],[\"随后选择一个\",{\"1\":{\"559\":1}}],[\"随后保存消息\",{\"1\":{\"550\":1}}],[\"随后将这些匹配的消费组的名称通过布隆过滤器进行计算\",{\"1\":{\"835\":1}}],[\"随后将消息发送给\",{\"1\":{\"550\":1}}],[\"随后将轨迹信息交给一个异步线程池处理\",{\"1\":{\"531\":1}}],[\"随后会将签名和用户名加入到请求扩展属性中\",{\"1\":{\"509\":1}}],[\"随后马上发一条延迟\",{\"1\":{\"445\":1}}],[\"随后构建出\",{\"1\":{\"336\":1}}],[\"随后进行恢复操作recoverconsumequeue\",{\"1\":{\"279\":1}}],[\"随后进程可以继续发送消息\",{\"1\":{\"160\":1}}],[\"随后使用查出来的phyoffset和size到commitlog中查询消息并返回\",{\"1\":{\"277\":1}}],[\"随后由一个独立线程defaultmessagestore\",{\"1\":{\"276\":1}}],[\"随后为这个\",{\"1\":{\"269\":1}}],[\"随后再次执行\",{\"1\":{\"178\":1}}],[\"随后再执行\",{\"1\":{\"176\":1}}],[\"随后更新\",{\"1\":{\"177\":1}}],[\"随后执行\",{\"1\":{\"176\":1}}],[\"随后到\",{\"1\":{\"123\":1}}],[\"随着发送失败次数的增多\",{\"1\":{\"561\":1}}],[\"随着消息队列的使用场景越来越广泛\",{\"1\":{\"496\":1}}],[\"随着时间轮跳动就不断地触发投递任务\",{\"1\":{\"451\":1}}],[\"随着开源之夏2022活动的召开\",{\"1\":{\"136\":1}}],[\"随着codeless组合式应用快速发展\",{\"1\":{\"126\":1}}],[\"随着serverless\",{\"1\":{\"126\":1}}],[\"随时调试任务\",{\"1\":{\"123\":1}}],[\"随时想测某个方法时\",{\"1\":{\"123\":1}}],[\"随意调用方法\",{\"1\":{\"122\":1}}],[\"开关和多队列转发开关\",{\"1\":{\"806\":1}}],[\"开发人员\",{\"1\":{\"498\":1}}],[\"开发量大\",{\"1\":{\"448\":1}}],[\"开发量较小\",{\"1\":{\"448\":1}}],[\"开源的延迟消息实现经过\",{\"1\":{\"445\":1}}],[\"开源\",{\"1\":{\"445\":1,\"452\":1}}],[\"开源版本的做法是\",{\"1\":{\"445\":1}}],[\"开源版本\",{\"1\":{\"445\":1}}],[\"开源顶级项目apache\",{\"1\":{\"127\":1}}],[\"开启这两项相当于开启了第一层过滤\",{\"1\":{\"835\":1}}],[\"开启消息轨迹的文档\",{\"1\":{\"524\":1}}],[\"开启一个消费者消费订单取消\",{\"1\":{\"441\":1,\"871\":1}}],[\"开启\",{\"1\":{\"403\":1,\"561\":1,\"806\":1}}],[\"开启强制删除\",{\"1\":{\"386\":1}}],[\"开启文件删除\",{\"1\":{\"386\":1}}],[\"开启长轮询\",{\"1\":{\"344\":1}}],[\"开启长轮询的情况下\",{\"1\":{\"326\":1}}],[\"开启定时刷盘\",{\"0\":{\"255\":1}}],[\"开销比较大的工作\",{\"1\":{\"253\":1}}],[\"开始\",{\"1\":{\"761\":1}}],[\"开始拉取\",{\"1\":{\"657\":1,\"664\":1,\"744\":1}}],[\"开始拉取消息\",{\"1\":{\"654\":1}}],[\"开始拉取新队列\",{\"1\":{\"650\":1}}],[\"开始消费流程\",{\"1\":{\"640\":1}}],[\"开始支持访问权限控制\",{\"1\":{\"496\":1}}],[\"开始扫描\",{\"1\":{\"377\":1}}],[\"开始扫描新的消息\",{\"1\":{\"375\":1}}],[\"开始扫描后面的消息\",{\"1\":{\"365\":1}}],[\"开始的\",{\"1\":{\"307\":1}}],[\"开始遍历\",{\"1\":{\"267\":1}}],[\"开始引入了自旋锁并作为默认值\",{\"1\":{\"253\":1}}],[\"开始起飞\",{\"0\":{\"123\":1}}],[\"开头的所有队列进行镜像\",{\"1\":{\"186\":1}}],[\"开头的队列创建\",{\"1\":{\"185\":1}}],[\"开放电信平台\",{\"1\":{\"112\":1}}],[\"下不同消费者的\",{\"1\":{\"760\":1}}],[\"下次重新消费的延迟等级根据该值来确定\",{\"1\":{\"718\":1}}],[\"下一次选择队列时会避开发送失败队列所在的\",{\"1\":{\"549\":1}}],[\"下一代高可用队列\",{\"0\":{\"227\":1}}],[\"下所有队列\",{\"1\":{\"786\":2}}],[\"下所有的队列\",{\"1\":{\"775\":1}}],[\"下所有acl配置文件\",{\"1\":{\"518\":1}}],[\"下所有消息在\",{\"1\":{\"267\":1}}],[\"下存储的消息位置信息链表\",{\"1\":{\"447\":1}}],[\"下的并发消费无法避免\",{\"1\":{\"723\":1}}],[\"下的所有队列和消费者列表进行排序\",{\"1\":{\"663\":1}}],[\"下的所有队列\",{\"1\":{\"653\":1,\"663\":1}}],[\"下的一条消息只会被同一消费组中的一个消费者消费\",{\"1\":{\"611\":1}}],[\"下的模板\",{\"1\":{\"594\":1}}],[\"下的影响\",{\"1\":{\"455\":1}}],[\"下的消息的位置信息\",{\"1\":{\"447\":1}}],[\"下的性能提升了\",{\"1\":{\"370\":1}}],[\"下有\",{\"1\":{\"445\":1}}],[\"下个任务从该\",{\"1\":{\"375\":1}}],[\"下标\",{\"1\":{\"317\":1}}],[\"下载后复制到服务器上安装\",{\"1\":{\"178\":1}}],[\"下\",{\"1\":{\"174\":1,\"240\":1,\"755\":1}}],[\"下游\",{\"1\":{\"235\":1}}],[\"下游集群配置\",{\"0\":{\"171\":1}}],[\"下游的集群\",{\"1\":{\"166\":1}}],[\"下游进程分别为前三个进程\",{\"1\":{\"154\":1}}],[\"下游进程处理完一条消息时\",{\"1\":{\"152\":1}}],[\"下面简单介绍一下几种特殊消息类型\",{\"1\":{\"548\":1}}],[\"下面看一下它的逻辑\",{\"1\":{\"778\":1}}],[\"下面看一下它们的具体结构\",{\"1\":{\"469\":1}}],[\"下面看一下\",{\"1\":{\"517\":1}}],[\"下面为示例配置文件\",{\"1\":{\"503\":1}}],[\"下面以单个\",{\"1\":{\"483\":1}}],[\"下面以一个延迟等级的处理为例\",{\"1\":{\"376\":1}}],[\"下面不会超过\",{\"1\":{\"426\":1}}],[\"下面来分析一下这几个方案的优缺点\",{\"1\":{\"448\":1}}],[\"下面来逐条剖析\",{\"1\":{\"406\":1}}],[\"下面来详细分析一下\",{\"1\":{\"394\":1}}],[\"下面来详细解释一下这些配置参数的意义\",{\"1\":{\"189\":1}}],[\"下面讲一下rocketmq中发送定时消息\",{\"1\":{\"354\":1}}],[\"下面分析\",{\"1\":{\"280\":1}}],[\"下面的代码第一份是修改前的\",{\"1\":{\"257\":1}}],[\"下面这张图对比了普通\",{\"1\":{\"248\":1}}],[\"下面会从源码层面来详细分析一下优化点和优化的原因\",{\"1\":{\"240\":1}}],[\"下面是权限验证的步骤\",{\"1\":{\"511\":1}}],[\"下面是配置的具体取值\",{\"1\":{\"503\":1}}],[\"下面是\",{\"1\":{\"499\":1,\"838\":1}}],[\"下面是开源\",{\"1\":{\"445\":1}}],[\"下面是该策略的可选参数列表\",{\"1\":{\"193\":1}}],[\"下面是利用\",{\"1\":{\"134\":1}}],[\"下面我们看看投递的设计\",{\"1\":{\"450\":1}}],[\"下面我们将揭开华为云\",{\"1\":{\"442\":1}}],[\"下面我们以rabbit\",{\"1\":{\"156\":1}}],[\"下面我们把这个模型简化\",{\"1\":{\"154\":1}}],[\"下面可以总结出判断性能瓶颈在何处的结论\",{\"1\":{\"155\":1}}],[\"下图表示推模式消费者的消息拉取流程\",{\"1\":{\"676\":1}}],[\"下图为\",{\"1\":{\"775\":1}}],[\"下图为一个简单的示意图\",{\"1\":{\"207\":1}}],[\"下图为更详细的实验结果\",{\"1\":{\"134\":1}}],[\"下图中\",{\"1\":{\"188\":1}}],[\"下图每个橙色组件都是一个\",{\"1\":{\"154\":1}}],[\"下午1\",{\"1\":{\"122\":1}}],[\"下划线\",{\"1\":{\"25\":1}}],[\"担心安全问题的话可以只在本地开启\",{\"1\":{\"122\":1}}],[\"方便后续消息的过滤匹配\",{\"1\":{\"841\":1}}],[\"方便后续调用网络请求\",{\"1\":{\"567\":1}}],[\"方便使用者进行对比分析\",{\"1\":{\"133\":1}}],[\"方案比较复杂\",{\"1\":{\"436\":1}}],[\"方式调用直接申请堆外内存中\",{\"1\":{\"403\":1}}],[\"方式构建项目\",{\"1\":{\"8\":1}}],[\"方法判断该消息\",{\"1\":{\"839\":1}}],[\"方法设置\",{\"1\":{\"826\":1}}],[\"方法设置消费者允许存在的的最大未ack消息数量\",{\"1\":{\"149\":1}}],[\"方法来通知上层应用\",{\"1\":{\"820\":1}}],[\"方法进行分发\",{\"1\":{\"814\":1}}],[\"方法如其名\",{\"1\":{\"783\":1}}],[\"方法是\",{\"1\":{\"820\":1}}],[\"方法是该处理线程的入口\",{\"1\":{\"783\":1}}],[\"方法是锁内操作\",{\"1\":{\"257\":1}}],[\"方法每\",{\"1\":{\"782\":1}}],[\"方法执行消费逻辑\",{\"1\":{\"708\":1}}],[\"方法执行重试\",{\"1\":{\"381\":1}}],[\"方法不断从阻塞队列中读取拉取请求来执行拉取\",{\"1\":{\"678\":1}}],[\"方法可以直接跳过等待\",{\"1\":{\"660\":1}}],[\"方法可以实现\",{\"1\":{\"400\":1}}],[\"方法为\",{\"1\":{\"654\":1}}],[\"方法注册消息队列变更时的回调方法\",{\"1\":{\"637\":1}}],[\"方法处理客户端的消息拉取请求\",{\"1\":{\"683\":1}}],[\"方法处理发送请求\",{\"1\":{\"576\":1}}],[\"方法处理该请求\",{\"1\":{\"332\":1}}],[\"方法完成验证账号是否有该资源访问权限的逻辑\",{\"1\":{\"520\":1}}],[\"方法完成加载指定acl配置文件内容的功能\",{\"1\":{\"518\":1}}],[\"方法重新加载该配置文件\",{\"1\":{\"519\":1}}],[\"方法重新加载所有配置文件\",{\"1\":{\"519\":1}}],[\"方法重新加载所有配置文件的数据\",{\"1\":{\"519\":1}}],[\"方法重新尝试发起pull消息的rpc请求\",{\"1\":{\"335\":1}}],[\"方法用来监控\",{\"1\":{\"519\":1}}],[\"方法会尝试从\",{\"1\":{\"782\":1}}],[\"方法会遍历消费进度缓存表\",{\"1\":{\"711\":1}}],[\"方法会报错\",{\"1\":{\"642\":1}}],[\"方法会获取\",{\"1\":{\"518\":1}}],[\"方法会将上一步返回的\",{\"1\":{\"515\":1}}],[\"方法会在\",{\"1\":{\"336\":1}}],[\"方法使用\",{\"1\":{\"515\":1}}],[\"方法发送一次心跳包\",{\"1\":{\"472\":1}}],[\"方法消费\",{\"1\":{\"436\":1}}],[\"方法开销非常大\",{\"1\":{\"428\":1}}],[\"方法逻辑里面包含了大量字符串和\",{\"1\":{\"419\":1}}],[\"方法内部大量使用反射来设置属性\",{\"1\":{\"410\":1}}],[\"方法内部也是使用\",{\"1\":{\"261\":1}}],[\"方法在一个异常流程中被调用\",{\"1\":{\"408\":1}}],[\"方法即实现文件预热的功能\",{\"1\":{\"402\":1}}],[\"方法即消息投递的逻辑\",{\"1\":{\"377\":1}}],[\"方法调用了\",{\"1\":{\"390\":1}}],[\"方法调用\",{\"1\":{\"389\":1}}],[\"方法保存消息\",{\"1\":{\"357\":1}}],[\"方法检查匹配的情况并对达到唤醒时间还没有成功匹配的消息重试\",{\"1\":{\"783\":1}}],[\"方法检查是否有请求需要唤醒\",{\"1\":{\"335\":1}}],[\"方法检查挂起的请求是否有消息可以拉取\",{\"1\":{\"332\":1}}],[\"方法加了锁\",{\"1\":{\"335\":1}}],[\"方法唤醒拉取请求\",{\"1\":{\"332\":1}}],[\"方法唤醒主从复制线程\",{\"1\":{\"246\":1}}],[\"方法循环等待轮询时间\",{\"1\":{\"332\":1}}],[\"方法将\",{\"1\":{\"782\":1}}],[\"方法将消费进度更新到其内存缓存表\",{\"1\":{\"711\":1}}],[\"方法将拉取到消息的处理队列提交消费服务处理\",{\"1\":{\"708\":1}}],[\"方法将该请求挂起\",{\"1\":{\"332\":1}}],[\"方法将刚刚保存的消息存入\",{\"1\":{\"276\":1}}],[\"方法创建了\",{\"1\":{\"420\":1}}],[\"方法创建或者获取最新的索引文件\",{\"1\":{\"309\":1}}],[\"方法创建索引\",{\"1\":{\"309\":1,\"314\":1}}],[\"方法查找所有\",{\"1\":{\"309\":1}}],[\"方法的结果\",{\"0\":{\"415\":1}}],[\"方法的类是\",{\"1\":{\"389\":1}}],[\"方法的效率很低\",{\"1\":{\"262\":1}}],[\"方法的\",{\"1\":{\"261\":1}}],[\"方法替换原来的\",{\"1\":{\"261\":1}}],[\"方法被调用\",{\"1\":{\"258\":1}}],[\"方法抽到了加锁之前\",{\"1\":{\"257\":1}}],[\"方法中循环发送执行发送逻辑\",{\"1\":{\"560\":1}}],[\"方法中执行\",{\"1\":{\"541\":1}}],[\"方法中就包含了权限验证的逻辑\",{\"1\":{\"510\":1}}],[\"方法中启动\",{\"1\":{\"472\":1}}],[\"方法中根据消费\",{\"1\":{\"436\":1}}],[\"方法中后面的逻辑\",{\"1\":{\"423\":1}}],[\"方法中会有反向\",{\"1\":{\"408\":1}}],[\"方法中会进行提醒\",{\"1\":{\"334\":1}}],[\"方法中也会查询\",{\"1\":{\"332\":1}}],[\"方法中已经生成并保存\",{\"1\":{\"285\":1}}],[\"方法中\",{\"1\":{\"285\":1,\"326\":1,\"340\":1,\"511\":1,\"520\":1,\"534\":2}}],[\"方法中使用\",{\"1\":{\"257\":1}}],[\"方法中的操作移动到了锁外\",{\"1\":{\"257\":1}}],[\"方法中只做了添加数据到列表的操作\",{\"1\":{\"245\":1}}],[\"方法做了以下这些事\",{\"1\":{\"249\":1}}],[\"方法等待\",{\"1\":{\"246\":1}}],[\"方法\",{\"0\":{\"251\":1,\"654\":1},\"1\":{\"157\":1,\"251\":1,\"261\":1,\"276\":1,\"281\":1,\"329\":1,\"332\":3,\"334\":2,\"335\":1,\"340\":1,\"347\":1,\"389\":1,\"390\":2,\"402\":1,\"408\":1,\"414\":1,\"420\":1,\"422\":1,\"467\":1,\"474\":1,\"476\":1,\"477\":2,\"480\":1,\"481\":1,\"493\":2,\"501\":1,\"508\":1,\"510\":1,\"511\":1,\"514\":2,\"518\":1,\"560\":1,\"575\":1,\"639\":6,\"656\":1,\"657\":1,\"679\":1,\"688\":1,\"708\":2,\"711\":3,\"768\":1,\"814\":1,\"841\":1,\"843\":2,\"844\":1}}],[\"方法或\",{\"1\":{\"122\":1}}],[\"再进行精确判断\",{\"1\":{\"839\":1}}],[\"再根据完整的消息信息做精确过滤\",{\"1\":{\"838\":1}}],[\"再将处理结果写入到\",{\"1\":{\"820\":1}}],[\"再将它重新放入队列\",{\"1\":{\"672\":1}}],[\"再看\",{\"1\":{\"819\":1}}],[\"再看一下这个方法\",{\"1\":{\"157\":1}}],[\"再判断是否可以释放\",{\"1\":{\"735\":1}}],[\"再提交\",{\"1\":{\"714\":1}}],[\"再提交到消费者消费线程池进行消费\",{\"1\":{\"689\":1}}],[\"再定时持久化\",{\"1\":{\"710\":1}}],[\"再次判断锁定情况尝试拉取\",{\"1\":{\"748\":1}}],[\"再次查询\",{\"1\":{\"559\":1}}],[\"再次拉取消息\",{\"1\":{\"334\":1,\"340\":1}}],[\"再\",{\"1\":{\"496\":1}}],[\"再执行\",{\"1\":{\"451\":1,\"838\":1}}],[\"再加上一个分隔符\",{\"1\":{\"426\":1}}],[\"再关闭内存映射\",{\"1\":{\"390\":1}}],[\"再往前遍历时间更不符合\",{\"1\":{\"314\":1}}],[\"再结合图中的情况\",{\"1\":{\"201\":1}}],[\"再到后来\",{\"1\":{\"126\":1}}],[\"再比如写着写着突然对某个资源的响应内容不确定\",{\"1\":{\"121\":1}}],[\"再由所有需要这些定义的模块包含此文件\",{\"1\":{\"61\":1}}],[\"过一段时间将会再次收到这些消息进行消费\",{\"1\":{\"699\":1}}],[\"过一\",{\"1\":{\"451\":1}}],[\"过期后保留的时间\",{\"1\":{\"390\":1}}],[\"过期\",{\"1\":{\"390\":1}}],[\"过期文件删除机制\",{\"0\":{\"382\":1},\"1\":{\"884\":1}}],[\"过期删除\",{\"0\":{\"315\":1}}],[\"过高时\",{\"1\":{\"374\":1}}],[\"过滤模式\",{\"1\":{\"848\":1}}],[\"过滤一样\",{\"1\":{\"844\":1}}],[\"过滤逻辑\",{\"1\":{\"841\":1}}],[\"过滤进行初筛\",{\"1\":{\"839\":1}}],[\"过滤的主方法\",{\"1\":{\"838\":1}}],[\"过滤的逻辑都在\",{\"1\":{\"838\":1}}],[\"过滤主要用到\",{\"1\":{\"838\":1}}],[\"过滤只用到\",{\"1\":{\"838\":1}}],[\"过滤专用\",{\"1\":{\"838\":1}}],[\"过滤信息管理器\",{\"1\":{\"850\":1}}],[\"过滤信息由消费者发送心跳时有\",{\"1\":{\"837\":1}}],[\"过滤信息的保存位置不同\",{\"1\":{\"837\":1}}],[\"过滤信息的注册也是由消费这发送心跳触发\",{\"1\":{\"837\":1}}],[\"过滤信息的注册\",{\"0\":{\"832\":1}}],[\"过滤信息和\",{\"1\":{\"837\":1}}],[\"过滤信息注册\",{\"0\":{\"837\":1}}],[\"过滤不会进行进一步的匹配\",{\"1\":{\"834\":1}}],[\"过滤更灵活\",{\"1\":{\"828\":1}}],[\"过滤比\",{\"1\":{\"828\":1}}],[\"过滤是最简单的一种过滤方法\",{\"1\":{\"825\":1}}],[\"过滤类型\",{\"1\":{\"691\":1}}],[\"过滤表达式\",{\"1\":{\"691\":1,\"837\":1}}],[\"过滤\",{\"0\":{\"825\":1,\"834\":1,\"835\":1,\"839\":1,\"840\":1,\"846\":1,\"849\":1},\"1\":{\"685\":1,\"693\":1,\"828\":1,\"834\":1,\"835\":1,\"838\":1,\"847\":1,\"852\":1}}],[\"过滤消息\",{\"1\":{\"545\":1}}],[\"过滤tag的hashcode\",{\"1\":{\"285\":1}}],[\"过滤器接口\",{\"0\":{\"838\":1}}],[\"过滤器\",{\"1\":{\"34\":2}}],[\"过程很长\",{\"1\":{\"121\":1}}],[\"探索\",{\"0\":{\"121\":1}}],[\"重发\",{\"1\":{\"799\":1,\"800\":1}}],[\"重发到重试\",{\"1\":{\"799\":1}}],[\"重复\",{\"1\":{\"757\":1}}],[\"重复使用\",{\"1\":{\"657\":1}}],[\"重定向到另外一台机器\",{\"1\":{\"693\":1}}],[\"重分配策略\",{\"1\":{\"649\":1}}],[\"重置消费位点\",{\"1\":{\"610\":1}}],[\"重平衡策略\",{\"1\":{\"787\":1}}],[\"重平衡策略名\",{\"1\":{\"786\":1}}],[\"重平衡可能会将一个队列的消费负载从一个消费者切换到另一个消费者\",{\"1\":{\"728\":1}}],[\"重平衡完毕之后开始拉取消息\",{\"1\":{\"772\":1}}],[\"重平衡完\",{\"1\":{\"688\":1}}],[\"重平衡完成后\",{\"1\":{\"653\":1}}],[\"重平衡会创建拉取请求\",{\"1\":{\"678\":1}}],[\"重平衡将为消费者负载的队列创建拉取请求并放入队列\",{\"1\":{\"672\":1}}],[\"重平衡后向\",{\"1\":{\"739\":1}}],[\"重平衡后尝试释放\",{\"1\":{\"735\":1}}],[\"重平衡后该消费者新分配到的的消息队列\",{\"1\":{\"664\":1,\"744\":1}}],[\"重平衡后更新处理队列\",{\"0\":{\"744\":1},\"1\":{\"734\":1}}],[\"重平衡后更新\",{\"1\":{\"664\":1,\"744\":1}}],[\"重平衡后更新订阅的队列和处理队列表\",{\"0\":{\"664\":1}}],[\"重平衡后调用拉取消息方法\",{\"1\":{\"640\":1}}],[\"重平衡入口\",{\"0\":{\"662\":1}}],[\"重平衡队列分配策略\",{\"0\":{\"658\":1}}],[\"重平衡触发\",{\"0\":{\"656\":1}}],[\"重平衡方法会可以细分为对每个\",{\"1\":{\"654\":1}}],[\"重平衡方法\",{\"1\":{\"654\":1}}],[\"重平衡时\",{\"1\":{\"744\":1}}],[\"重平衡时顺序消费\",{\"0\":{\"728\":1}}],[\"重平衡时可能将队列分配给组内其他消费者会设置\",{\"1\":{\"715\":1}}],[\"重平衡时对这些队列应用重分配策略进行分配\",{\"1\":{\"653\":1}}],[\"重平衡时遍历这些\",{\"1\":{\"653\":1}}],[\"重平衡流程\",{\"0\":{\"650\":1,\"655\":1,\"657\":1}}],[\"重平衡线程调用客户端实例的重平衡方法\",{\"1\":{\"657\":1}}],[\"重平衡线程\",{\"0\":{\"660\":1},\"1\":{\"649\":1,\"656\":1}}],[\"重平衡线程每\",{\"1\":{\"648\":1,\"656\":1}}],[\"重平衡实现类中包含重平衡的一系列逻辑\",{\"1\":{\"654\":1}}],[\"重平衡实现类\",{\"0\":{\"652\":1}}],[\"重平衡实现\",{\"0\":{\"661\":1},\"1\":{\"649\":2}}],[\"重平衡主要涉及两个类\",{\"1\":{\"649\":1}}],[\"重平衡类设计\",{\"0\":{\"649\":1}}],[\"重平衡的主要逻辑其实与在客户端重平衡类似\",{\"1\":{\"775\":1}}],[\"重平衡的实际逻辑在实现类中\",{\"1\":{\"649\":1}}],[\"重平衡的触发\",{\"0\":{\"648\":1}}],[\"重平衡的含义\",{\"0\":{\"646\":1}}],[\"重平衡服务执行重平衡\",{\"1\":{\"772\":1}}],[\"重平衡服务会周期性\",{\"1\":{\"624\":1}}],[\"重平衡服务是客户端开始消费的起点\",{\"1\":{\"624\":1}}],[\"重平衡\",{\"0\":{\"618\":1,\"644\":1},\"1\":{\"606\":1,\"632\":1,\"645\":1,\"663\":1,\"667\":1,\"675\":1,\"697\":1,\"723\":1,\"728\":1,\"884\":1}}],[\"重要的消息通知\",{\"1\":{\"547\":1}}],[\"重投\",{\"0\":{\"454\":1}}],[\"重投递时\",{\"1\":{\"359\":1}}],[\"重投递线程会扫描是否有新消息被保存到\",{\"1\":{\"270\":1,\"301\":1}}],[\"重投递消息的过程就是为了建立消息的索引文件\",{\"1\":{\"270\":1,\"301\":1}}],[\"重试最多30次\",{\"1\":{\"817\":1}}],[\"重试消息\",{\"0\":{\"800\":1}}],[\"重试消费需要消费者将消费失败的消息发回给\",{\"1\":{\"708\":1}}],[\"重试消费需要在消费结果处理的步骤中进行判断\",{\"1\":{\"700\":1}}],[\"重试消费\",{\"0\":{\"716\":1},\"1\":{\"707\":1}}],[\"重试消费设计\",{\"0\":{\"700\":1}}],[\"重试队列\",{\"1\":{\"783\":1}}],[\"重试逻辑为先从\",{\"1\":{\"783\":1}}],[\"重试等逻辑放到\",{\"1\":{\"770\":1}}],[\"重试等逻辑\",{\"1\":{\"769\":1}}],[\"重试时间间隔可以用\",{\"1\":{\"761\":1}}],[\"重试实践按照延迟等级每次重试会递增\",{\"1\":{\"761\":1}}],[\"重试次数\",{\"1\":{\"800\":1}}],[\"重试次数设为\",{\"1\":{\"753\":1}}],[\"重试次数为\",{\"1\":{\"753\":1,\"761\":1}}],[\"重试的时间从\",{\"1\":{\"761\":1}}],[\"重试的时间间隔也会相应发生变化\",{\"1\":{\"620\":1}}],[\"重试的时间间隔逐渐变长\",{\"1\":{\"620\":1}}],[\"重试的\",{\"1\":{\"620\":1}}],[\"重试发送\",{\"1\":{\"560\":1}}],[\"重试机制\",{\"0\":{\"560\":1},\"1\":{\"620\":1}}],[\"重试投递时采用同步投递\",{\"1\":{\"378\":1}}],[\"重试\",{\"0\":{\"620\":1},\"1\":{\"374\":1,\"560\":1,\"708\":1,\"777\":1,\"783\":2,\"800\":1}}],[\"重新进行\",{\"1\":{\"663\":1}}],[\"重新分配之后\",{\"1\":{\"657\":1,\"662\":1}}],[\"重新拉取\",{\"1\":{\"639\":1}}],[\"重新消费次数\",{\"1\":{\"717\":1,\"718\":2}}],[\"重新消费\",{\"1\":{\"637\":2}}],[\"重新被放入拉取请求队列\",{\"1\":{\"624\":1}}],[\"重新执行上述负载算法\",{\"1\":{\"618\":1}}],[\"重新从\",{\"1\":{\"559\":1}}],[\"重新load\",{\"1\":{\"519\":1}}],[\"重新加载配置\",{\"1\":{\"516\":1}}],[\"重新加载\",{\"1\":{\"481\":1}}],[\"重新加载索引文件\",{\"1\":{\"313\":2}}],[\"重新投递消息到commitlog\",{\"1\":{\"365\":1,\"380\":1}}],[\"重新放回hold列表中\",{\"1\":{\"345\":1}}],[\"重新编译某个模块时\",{\"1\":{\"57\":1}}],[\"重启后不会清空\",{\"1\":{\"220\":1}}],[\"重启后清空\",{\"1\":{\"220\":1}}],[\"重启等情况下的数据丢失\",{\"1\":{\"216\":1}}],[\"重启的时间相对较长\",{\"1\":{\"120\":1}}],[\"谁拖垮了效率\",{\"0\":{\"120\":1}}],[\"项目就应用了\",{\"1\":{\"804\":1}}],[\"项目是\",{\"1\":{\"596\":1}}],[\"项目已经将\",{\"1\":{\"595\":1}}],[\"项目中增加依赖\",{\"1\":{\"122\":1}}],[\"项目\",{\"1\":{\"119\":1}}],[\"本来消息会在中间这个时间点再一次的可见的\",{\"1\":{\"771\":1}}],[\"本想一篇文章写完\",{\"1\":{\"606\":1}}],[\"本身的实现非常轻量\",{\"1\":{\"462\":1}}],[\"本身的机制达到\",{\"1\":{\"445\":1}}],[\"本次拉取消息的消费者的过滤信息\",{\"1\":{\"843\":1}}],[\"本次要发送的数据\",{\"1\":{\"541\":1}}],[\"本次操作无需权限验证\",{\"1\":{\"520\":1}}],[\"本次和上次的性能优化主要由快手的黄理老师提交\",{\"1\":{\"406\":1}}],[\"本次删除的文件数量\",{\"1\":{\"390\":1}}],[\"本次改动将延迟消息的写入改成可配置同步或异步写入\",{\"1\":{\"373\":1}}],[\"本次优化中也包含了生产和消费性能的提升\",{\"1\":{\"406\":1}}],[\"本次优化单独定义了解析发送消息请求头的方法\",{\"1\":{\"262\":1}}],[\"本次优化减少了需要进入同步代码块的次数\",{\"1\":{\"246\":1}}],[\"本次对刷盘相关的参数也进行了调整\",{\"1\":{\"255\":1}}],[\"本次修改点是在主从复制的\",{\"1\":{\"249\":1}}],[\"本次测试的测试方法\",{\"1\":{\"11\":1}}],[\"本文会涉及\",{\"1\":{\"667\":1}}],[\"本文着重介绍推模式下\",{\"1\":{\"667\":1}}],[\"本文着重讲解定时消息异步投递的逻辑\",{\"1\":{\"370\":1}}],[\"本文是\",{\"1\":{\"627\":1,\"645\":1,\"667\":1,\"697\":1,\"723\":1}}],[\"本文作为消费系列的第一篇\",{\"1\":{\"606\":1}}],[\"本文第一节从定时消息的定义和需求出发\",{\"1\":{\"456\":1}}],[\"本文介绍的是步骤\",{\"1\":{\"697\":1}}],[\"本文介绍\",{\"1\":{\"496\":1}}],[\"本文介绍如何在\",{\"1\":{\"439\":1}}],[\"本文介绍了\",{\"1\":{\"437\":1}}],[\"本文详细分析一下三种存储文件的过期删除机制\",{\"1\":{\"383\":1}}],[\"本文主要讲解的是另一个改动\",{\"1\":{\"370\":1}}],[\"本文主要讨论基于信用证的进程内流控实现\",{\"1\":{\"147\":1}}],[\"本文将会详解\",{\"1\":{\"406\":1}}],[\"本文将介绍\",{\"1\":{\"214\":1}}],[\"本文将讲解镜像队列的使用方法和原理\",{\"1\":{\"181\":1}}],[\"本文讲解\",{\"1\":{\"174\":1}}],[\"本文首先以现今分布式系统的复杂性和稳定性的需求引出混沌工程概念\",{\"1\":{\"125\":1}}],[\"本地缓存的\",{\"1\":{\"664\":1,\"744\":1}}],[\"本地缓存变量中取pullrequest请求\",{\"1\":{\"335\":1}}],[\"本地消费成功才会提交\",{\"1\":{\"615\":1}}],[\"本地构建的最大意义在于\",{\"1\":{\"592\":1}}],[\"本地构建\",{\"0\":{\"592\":1}}],[\"本地构建或者从\",{\"1\":{\"591\":1}}],[\"本地没有缓存\",{\"1\":{\"559\":1}}],[\"本地变量\",{\"1\":{\"424\":1}}],[\"本地不希望任务在跑\",{\"1\":{\"123\":1}}],[\"本地开发时有两个操作最耗时\",{\"1\":{\"120\":1}}],[\"本方法最适用于\",{\"1\":{\"119\":1}}],[\"前\",{\"1\":{\"735\":1,\"797\":1,\"814\":1}}],[\"前置检查\",{\"1\":{\"683\":1}}],[\"前置知识\",{\"0\":{\"244\":1}}],[\"前面说到消息轨迹数据也以消息的形式发送到\",{\"1\":{\"541\":1}}],[\"前面说到\",{\"1\":{\"534\":1}}],[\"前文曾就\",{\"1\":{\"406\":1}}],[\"前一个文件异步刷盘\",{\"1\":{\"313\":1}}],[\"前者表示分布式系统并行化的性能和效果\",{\"1\":{\"135\":1}}],[\"前提\",{\"0\":{\"119\":1}}],[\"前最好先安装一下配套的\",{\"1\":{\"6\":1}}],[\"找不到\",{\"1\":{\"796\":1}}],[\"找不到则从\",{\"1\":{\"691\":1}}],[\"找到对应消息\",{\"1\":{\"695\":1,\"749\":1}}],[\"找到对应\",{\"1\":{\"474\":1,\"492\":1}}],[\"找到对应的消费队列索引\",{\"1\":{\"684\":1}}],[\"找到对应的\",{\"1\":{\"474\":1,\"492\":1}}],[\"找到数据在磁盘上的物理位置\",{\"1\":{\"396\":1}}],[\"找到索引链表绝对位置\",{\"1\":{\"317\":1}}],[\"找到\",{\"1\":{\"116\":2,\"573\":1}}],[\"找出应该执行哪一段表达式序列\",{\"1\":{\"44\":1}}],[\"对零拷贝的使用\",{\"0\":{\"855\":1}}],[\"对需要查询的数据进行\",{\"1\":{\"842\":1}}],[\"对要插入的元素进行\",{\"1\":{\"842\":1}}],[\"对没有\",{\"1\":{\"783\":1}}],[\"对成功消费的消息\",{\"1\":{\"772\":1}}],[\"对消费失败的消息不会重复消费\",{\"1\":{\"715\":1}}],[\"对消息进行tag模式过滤\",{\"1\":{\"695\":1,\"749\":1}}],[\"对该\",{\"1\":{\"663\":1}}],[\"对所有消费者执行一次重平衡检查\",{\"1\":{\"660\":1}}],[\"对每隔消费者负载不同\",{\"1\":{\"658\":1}}],[\"对每个主题的队列进行重平衡\",{\"1\":{\"662\":1}}],[\"对每个\",{\"1\":{\"657\":1}}],[\"对每个consumequeue执行恢复操作\",{\"1\":{\"273\":1}}],[\"对比分配给自己的消息队列是否发生变化\",{\"1\":{\"663\":1}}],[\"对比之前的负载来判断是否要改变队列进行消息拉取\",{\"1\":{\"653\":1}}],[\"对比定时消息的实现\",{\"1\":{\"455\":1}}],[\"对请求参数验计算签名\",{\"1\":{\"511\":1,\"520\":1}}],[\"对请求\",{\"1\":{\"501\":1}}],[\"对字符串和字节数组操作时减少创建和拷贝\",{\"1\":{\"437\":1}}],[\"对延迟消息做了很大的优化\",{\"1\":{\"370\":1}}],[\"对其执行\",{\"1\":{\"335\":1}}],[\"对其定义进行延伸扩展\",{\"1\":{\"128\":1}}],[\"对\",{\"0\":{\"663\":1},\"1\":{\"276\":1,\"397\":1,\"414\":1,\"417\":1,\"431\":1,\"654\":1,\"718\":1,\"804\":1}}],[\"对于队列数据重复保存的问题\",{\"1\":{\"811\":1}}],[\"对于上面两个痛点\",{\"1\":{\"811\":1}}],[\"对于没有成功\",{\"1\":{\"799\":1}}],[\"对于已经到重试时间的\",{\"1\":{\"783\":1}}],[\"对于匹配完成或者存盘的\",{\"1\":{\"782\":1}}],[\"对于集群模式\",{\"1\":{\"775\":1}}],[\"对于广播模式\",{\"1\":{\"775\":1}}],[\"对于超过\",{\"1\":{\"773\":1}}],[\"对于长时间没有\",{\"1\":{\"771\":1}}],[\"对于顺序消费情况\",{\"1\":{\"748\":1}}],[\"对于重试消息\",{\"1\":{\"738\":1}}],[\"对于对分配到的队列尝试请求\",{\"1\":{\"733\":1}}],[\"对于要丢弃的队列\",{\"1\":{\"733\":1}}],[\"对于要多次计算的操作\",{\"1\":{\"437\":1}}],[\"对于新分配到的队列\",{\"1\":{\"729\":1}}],[\"对于新分配的\",{\"1\":{\"657\":1,\"664\":1,\"744\":1}}],[\"对于消费失败的消息\",{\"1\":{\"637\":1}}],[\"对于消息的存储\",{\"1\":{\"530\":1}}],[\"对于消息轨迹数据量较大的场景\",{\"1\":{\"524\":1}}],[\"对于批量消息\",{\"1\":{\"573\":1}}],[\"对于每条消息较小且消息较多的场景\",{\"1\":{\"564\":1}}],[\"对于每个延迟等级\",{\"1\":{\"445\":1}}],[\"对于每个\",{\"1\":{\"398\":1}}],[\"对于客户端消息发送\",{\"1\":{\"545\":1}}],[\"对于异步投递\",{\"1\":{\"453\":1}}],[\"对于流控也不需要重新投递这么多任务\",{\"1\":{\"452\":1}}],[\"对于任意时间定时消息的投递\",{\"1\":{\"452\":1}}],[\"对于定时消息的投递\",{\"1\":{\"451\":1}}],[\"对于定时消息\",{\"1\":{\"447\":1}}],[\"对于单队列支持任意时间定时消息的难点是消息的顺序问题\",{\"1\":{\"445\":1}}],[\"对于这些取舍\",{\"1\":{\"444\":1}}],[\"对于磁盘\",{\"1\":{\"437\":1}}],[\"对于写\",{\"1\":{\"414\":1}}],[\"对于写字符串\",{\"1\":{\"414\":1}}],[\"对于\",{\"1\":{\"398\":1,\"462\":1,\"773\":2,\"834\":1,\"835\":1}}],[\"对于机械硬盘来说\",{\"1\":{\"396\":1}}],[\"对于同一个\",{\"1\":{\"275\":1}}],[\"对于一条要投递到多个队列的消息\",{\"1\":{\"233\":1}}],[\"对于持久化消息\",{\"1\":{\"223\":1}}],[\"对于3个或更多节点的集群\",{\"1\":{\"195\":1}}],[\"对于分布式系统韧性的观测更需要一个简单直观的分析报告\",{\"1\":{\"133\":1}}],[\"对队列名称以\",{\"1\":{\"186\":1}}],[\"对分布式系统一致性算法\",{\"1\":{\"136\":1}}],[\"对底层基础设施\",{\"1\":{\"127\":1}}],[\"对象组成\",{\"1\":{\"841\":1}}],[\"对象启动客户端的各种服务\",{\"1\":{\"632\":1}}],[\"对象还没有被创建出来\",{\"1\":{\"631\":1}}],[\"对象中的\",{\"1\":{\"631\":1}}],[\"对象只是一个壳\",{\"1\":{\"629\":1}}],[\"对象时会在内部一个创建\",{\"1\":{\"629\":1}}],[\"对象编码\",{\"1\":{\"477\":1,\"493\":1}}],[\"对象构造时需要拷贝一遍\",{\"1\":{\"420\":1}}],[\"对象\",{\"1\":{\"420\":1,\"477\":2,\"493\":2,\"504\":1,\"510\":1,\"516\":1,\"555\":1,\"629\":1,\"631\":2,\"632\":1,\"844\":1}}],[\"对象和\",{\"1\":{\"420\":1}}],[\"对象并执行方法\",{\"1\":{\"116\":1}}],[\"对象方法\",{\"0\":{\"115\":1}}],[\"对应一个固定的延迟时长\",{\"1\":{\"876\":1}}],[\"对应数据是否在\",{\"1\":{\"843\":1}}],[\"对应服务端结果\",{\"1\":{\"695\":2}}],[\"对应18个延迟等级\",{\"1\":{\"356\":1}}],[\"对应延迟1分钟\",{\"1\":{\"355\":1}}],[\"对应消息在\",{\"1\":{\"302\":1}}],[\"对应的队列的消息\",{\"1\":{\"777\":1}}],[\"对应的队列信息\",{\"1\":{\"663\":1}}],[\"对应的处理类为pullmessageprocessor\",{\"1\":{\"277\":1,\"286\":1}}],[\"对应的\",{\"1\":{\"206\":2}}],[\"对应的值达到\",{\"1\":{\"157\":1}}],[\"对应\",{\"1\":{\"21\":1,\"445\":1,\"810\":1}}],[\"文档\",{\"0\":{\"114\":1},\"1\":{\"318\":1}}],[\"文件需要增加以下的配置项\",{\"1\":{\"806\":1}}],[\"文件做如下修改\",{\"1\":{\"600\":1}}],[\"文件未找到\",{\"1\":{\"599\":1}}],[\"文件映射端口改了之外\",{\"1\":{\"595\":1}}],[\"文件是用来以不同部署方式启动\",{\"1\":{\"594\":1}}],[\"文件夹\",{\"1\":{\"594\":2}}],[\"文件创建后\",{\"1\":{\"402\":1}}],[\"文件预热\",{\"0\":{\"402\":1}}],[\"文件通道\",{\"1\":{\"400\":1}}],[\"文件的大小默认是\",{\"1\":{\"401\":1}}],[\"文件的io几乎等同于内存的io\",{\"1\":{\"399\":1}}],[\"文件的过期删除\",{\"1\":{\"391\":1}}],[\"文件异步生成\",{\"1\":{\"397\":1}}],[\"文件过期时间\",{\"1\":{\"390\":2}}],[\"文件将被强制删除\",{\"1\":{\"390\":1}}],[\"文件可以拒绝删除\",{\"1\":{\"390\":1}}],[\"文件保证使用的镜像名称正确\",{\"1\":{\"595\":1}}],[\"文件保留时间\",{\"1\":{\"390\":2}}],[\"文件保存在\",{\"1\":{\"269\":1}}],[\"文件删除线程会检查所有的\",{\"1\":{\"388\":1}}],[\"文件删除线程就会检查所有\",{\"1\":{\"387\":1}}],[\"文件删除的条件有以下几种\",{\"1\":{\"386\":1}}],[\"文件中\",{\"1\":{\"851\":1}}],[\"文件中的\",{\"1\":{\"309\":1,\"386\":1}}],[\"文件中的最小单元是索引项\",{\"1\":{\"269\":1}}],[\"文件中取出一条消息\",{\"1\":{\"287\":1,\"694\":1}}],[\"文件结构\",{\"0\":{\"269\":1,\"275\":1}}],[\"文件编程\",{\"0\":{\"94\":1}}],[\"文件\",{\"1\":{\"16\":1,\"266\":1,\"285\":1,\"368\":1,\"391\":1,\"392\":1,\"510\":1,\"516\":2,\"597\":1,\"598\":1,\"841\":1,\"858\":1}}],[\"笔记\",{\"0\":{\"113\":1},\"1\":{\"141\":1}}],[\"介绍消息拉取的流程\",{\"1\":{\"667\":1}}],[\"介绍消费者重平衡\",{\"1\":{\"645\":1}}],[\"介绍消费者相关类与调用关系\",{\"1\":{\"627\":1}}],[\"介绍了openchaos的架构\",{\"1\":{\"125\":1}}],[\"介绍\",{\"0\":{\"112\":1},\"1\":{\"510\":1}}],[\"做了判断\",{\"1\":{\"436\":1}}],[\"做了更进一步的性能优化\",{\"1\":{\"406\":1}}],[\"做了一系列性能优化\",{\"1\":{\"406\":1}}],[\"做了一些性能优化\",{\"1\":{\"240\":1}}],[\"做什么\",{\"1\":{\"111\":1}}],[\"做模式匹配\",{\"1\":{\"83\":1}}],[\"请谨慎选择\",{\"1\":{\"610\":1}}],[\"请点击使用\",{\"1\":{\"457\":1}}],[\"请求要求的数量\",{\"1\":{\"777\":1}}],[\"请求指定了队列\",{\"1\":{\"777\":1}}],[\"请求处理入口\",{\"0\":{\"777\":1}}],[\"请求处理机制会按照业务逻辑进行处理器的拆分\",{\"1\":{\"563\":1}}],[\"请求后\",{\"1\":{\"773\":1}}],[\"请求后触发\",{\"1\":{\"656\":1}}],[\"请求给\",{\"1\":{\"772\":2}}],[\"请求中带有重平衡策略\",{\"1\":{\"772\":1}}],[\"请求中包含了消息的全部信息\",{\"1\":{\"544\":1}}],[\"请求和更新自己负载的消费队列的\",{\"1\":{\"729\":1}}],[\"请求不到则等到下次重平衡再次请求\",{\"1\":{\"729\":1}}],[\"请求到\",{\"1\":{\"720\":1}}],[\"请求的队列id是否合法\",{\"1\":{\"693\":1}}],[\"请求的操作就会执行\",{\"1\":{\"111\":1}}],[\"请求码\",{\"1\":{\"563\":1}}],[\"请求码为requestcode\",{\"1\":{\"277\":1,\"286\":1}}],[\"请求体中包含\",{\"1\":{\"472\":1}}],[\"请求\",{\"1\":{\"465\":1,\"472\":1,\"729\":1,\"770\":1}}],[\"请求消息头解码性能\",{\"0\":{\"262\":1}}],[\"请注意\",{\"1\":{\"34\":1,\"62\":1}}],[\"等于和不等于\",{\"1\":{\"828\":1}}],[\"等于文件最后修改的时间\",{\"1\":{\"390\":1}}],[\"等价于<\",{\"1\":{\"828\":1}}],[\"等价于>=\",{\"1\":{\"828\":1}}],[\"等到\",{\"1\":{\"750\":1}}],[\"等到下一次重平衡\",{\"1\":{\"735\":1}}],[\"等信息组合计算生成一个字符串\",{\"1\":{\"419\":1}}],[\"等消息队列有较大的不同\",{\"1\":{\"214\":1}}],[\"等待1s继续写入\",{\"1\":{\"817\":1}}],[\"等待重新消费\",{\"1\":{\"717\":1,\"738\":1}}],[\"等待重试\",{\"1\":{\"441\":1,\"871\":1}}],[\"等待pullinterval毫秒后重新拉取\",{\"1\":{\"695\":1,\"749\":1}}],[\"等待一会再开始新一个投递任务\",{\"1\":{\"453\":1}}],[\"等待一定时间\",{\"1\":{\"344\":1}}],[\"等待0\",{\"1\":{\"380\":1,\"381\":1}}],[\"等待下一次消息队列重新负载\",{\"1\":{\"695\":1}}],[\"等待下次检查\",{\"1\":{\"345\":1}}],[\"等待下游进程授予更多信用\",{\"1\":{\"155\":1}}],[\"等待的时间根据长轮询\",{\"1\":{\"335\":1}}],[\"等待\",{\"1\":{\"246\":1,\"365\":1,\"660\":1,\"748\":3,\"791\":1,\"798\":1}}],[\"等待ack的消息数量\",{\"1\":{\"223\":1}}],[\"等待进一步修复\",{\"1\":{\"134\":1}}],[\"等\",{\"1\":{\"112\":1,\"220\":1}}],[\"等等\",{\"1\":{\"111\":1,\"204\":1}}],[\"等模式进行匹配\",{\"1\":{\"37\":1}}],[\"告诉内核即将要访问这部分文件\",{\"1\":{\"402\":1}}],[\"告诉系统要跟踪什么进程\",{\"1\":{\"111\":1}}],[\"告诉我们异常错误是如何生成的\",{\"1\":{\"44\":1}}],[\"转入磁盘等待匹配\",{\"1\":{\"773\":1}}],[\"转发\",{\"1\":{\"276\":1}}],[\"转\",{\"1\":{\"261\":2}}],[\"转储至文件\",{\"0\":{\"109\":1}}],[\"转义序列\",{\"0\":{\"59\":1}}],[\"给消费者\",{\"1\":{\"614\":1,\"765\":1}}],[\"给操作系统建议\",{\"1\":{\"402\":1}}],[\"给程序添加打印语句是最常见的调试形式\",{\"1\":{\"108\":1}}],[\"给两个整数做除法时\",{\"1\":{\"24\":1}}],[\"错误示例\",{\"1\":{\"828\":1}}],[\"错误发生在\",{\"1\":{\"106\":1}}],[\"错误消息之后是栈跟踪信息\",{\"1\":{\"106\":1}}],[\"测量\",{\"1\":{\"105\":1}}],[\"测试时也可以不依赖\",{\"1\":{\"123\":1}}],[\"测试仅仅需要模式匹配和=\",{\"1\":{\"30\":1}}],[\"测试结果\",{\"1\":{\"11\":1}}],[\"测试模式\",{\"1\":{\"11\":1}}],[\"测试模式为计算测试方法的吞吐量\",{\"1\":{\"9\":1}}],[\"测试\",{\"0\":{\"172\":1},\"1\":{\"11\":1}}],[\"测试执行\",{\"1\":{\"9\":1}}],[\"测试方法\",{\"1\":{\"4\":1,\"9\":1}}],[\"～\",{\"1\":{\"105\":1}}],[\"统计\",{\"1\":{\"693\":1}}],[\"统计各个函数被调用的次数\",{\"1\":{\"105\":1}}],[\"统计每秒操作数\",{\"1\":{\"11\":1}}],[\"调整消息发送几个参数的默认值\",{\"0\":{\"252\":1}}],[\"调度编排系统的精准调度\",{\"1\":{\"128\":1}}],[\"调试器\",{\"0\":{\"110\":1}}],[\"调试并行程序时\",{\"1\":{\"108\":1}}],[\"调试\",{\"0\":{\"108\":1}}],[\"调试方法\",{\"0\":{\"107\":1}}],[\"调试与跟踪\",{\"0\":{\"104\":1}}],[\"调用时才会返回为\",{\"1\":{\"820\":1}}],[\"调用时用\",{\"1\":{\"332\":1}}],[\"调用消费者\",{\"1\":{\"708\":1}}],[\"调用注册的监听器执行消费逻辑\",{\"1\":{\"699\":1}}],[\"调用客户端\",{\"1\":{\"680\":1}}],[\"调用重平衡策略\",{\"1\":{\"649\":1}}],[\"调用并代理到\",{\"1\":{\"632\":1}}],[\"调用存储模块将消息存储\",{\"1\":{\"563\":1}}],[\"调用它内部的\",{\"1\":{\"556\":1}}],[\"调用它的进程就会在跟踪事件发生时收到跟踪消息\",{\"1\":{\"111\":1}}],[\"调用这个方法\",{\"1\":{\"345\":1}}],[\"调用该类的\",{\"1\":{\"329\":1}}],[\"调用该索引文件的\",{\"1\":{\"309\":1,\"314\":1}}],[\"调用符合条件的索引文件\",{\"1\":{\"309\":1}}],[\"调用defaultmessagestore\",{\"1\":{\"279\":1}}],[\"调用\",{\"1\":{\"204\":1,\"246\":1,\"284\":1,\"309\":1,\"332\":3,\"335\":1,\"357\":1,\"361\":1,\"414\":1,\"467\":1,\"472\":1,\"476\":1,\"477\":2,\"480\":1,\"493\":2,\"514\":1,\"519\":1,\"639\":2,\"660\":1,\"679\":1,\"708\":2,\"711\":2,\"733\":1,\"734\":1,\"746\":1,\"820\":1,\"839\":1}}],[\"调用credit\",{\"1\":{\"157\":1,\"160\":1}}],[\"调用的总是最新版模块里的最新版函数\",{\"1\":{\"57\":1}}],[\"调用函数\",{\"1\":{\"30\":1}}],[\"影响\",{\"0\":{\"99\":1}}],[\"λ\",{\"1\":{\"98\":1}}],[\"异步拉取消息的流程主要分为\",{\"1\":{\"669\":1}}],[\"异步处理生产者发送过来的请求\",{\"1\":{\"563\":1}}],[\"异步和单向\",{\"1\":{\"547\":1}}],[\"异步\",{\"1\":{\"545\":1,\"547\":1,\"573\":1,\"681\":1,\"690\":1,\"691\":1,\"695\":1,\"749\":1}}],[\"异步发送回调函数\",{\"1\":{\"573\":1}}],[\"异步发送只执行一次\",{\"1\":{\"570\":1}}],[\"异步发送的重试逻辑在\",{\"1\":{\"560\":1}}],[\"异步发送是最为广泛使用的发送方式\",{\"1\":{\"547\":1}}],[\"异步发送是使用最广泛的发送方式\",{\"1\":{\"547\":1}}],[\"异步发送请求\",{\"1\":{\"541\":1}}],[\"异步发送线程池\",{\"1\":{\"541\":1}}],[\"异步转发队列长度\",{\"1\":{\"541\":1}}],[\"异步实现消息轨迹数据的发送\",{\"1\":{\"541\":1}}],[\"异步消息投递后\",{\"1\":{\"377\":1}}],[\"异步投递任务由一个阻塞队列来承载\",{\"1\":{\"453\":1}}],[\"异步投递过程状态更新任务\",{\"0\":{\"381\":1}}],[\"异步投递\",{\"1\":{\"380\":1}}],[\"异步投递详解\",{\"0\":{\"376\":1}}],[\"异步投递采用了生产\",{\"1\":{\"375\":1}}],[\"异步投递逻辑\",{\"0\":{\"375\":1}}],[\"异步投递的逻辑相比于同步投递有一些不同\",{\"1\":{\"375\":1}}],[\"异步投递的两个主要缺点是\",{\"1\":{\"374\":1}}],[\"异步投递的注意点\",{\"0\":{\"374\":1},\"1\":{\"374\":1}}],[\"异步投递支持\",{\"0\":{\"369\":1},\"1\":{\"872\":1,\"884\":1}}],[\"异步写入在\",{\"1\":{\"373\":1}}],[\"异步执行请求处理和返回\",{\"1\":{\"340\":1}}],[\"异步提交重新pull消息的请求任务\",{\"1\":{\"340\":1}}],[\"异步保存批量消息\",{\"1\":{\"251\":1}}],[\"异步保存单条消息\",{\"1\":{\"251\":1}}],[\"异常退出时\",{\"1\":{\"403\":1}}],[\"异常恢复时\",{\"1\":{\"309\":1}}],[\"异常故障情况下从节点是否提升为主节点\",{\"1\":{\"192\":1}}],[\"异常错误如果发生在\",{\"1\":{\"45\":1}}],[\"异键或同键表\",{\"1\":{\"103\":1}}],[\"异键表\",{\"1\":{\"98\":1}}],[\"损坏会尝试修复\",{\"1\":{\"97\":1}}],[\"内没有匹配成功\",{\"1\":{\"773\":1}}],[\"内获取不到\",{\"1\":{\"735\":1}}],[\"内可能会进行重平衡\",{\"1\":{\"656\":1}}],[\"内投不完\",{\"1\":{\"452\":1}}],[\"内要投递的消息\",{\"1\":{\"452\":1}}],[\"内\",{\"1\":{\"442\":1}}],[\"内的\",{\"1\":{\"798\":1}}],[\"内的一批\",{\"1\":{\"783\":1}}],[\"内的负载均衡\",{\"1\":{\"469\":1}}],[\"内的定时消息\",{\"1\":{\"444\":1}}],[\"内的数据刷盘至物理磁盘上\",{\"1\":{\"399\":1}}],[\"内的消息\",{\"1\":{\"309\":1}}],[\"内核线程将\",{\"1\":{\"399\":1}}],[\"内如果没有执行过刷盘操作\",{\"1\":{\"278\":1}}],[\"内部不断尝试从阻塞队列中获取拉去请求进行拉取操作\",{\"1\":{\"675\":1}}],[\"内部有一个阻塞队列\",{\"1\":{\"672\":1}}],[\"内部构造一个\",{\"1\":{\"631\":1}}],[\"内部仅仅多了消息列表\",{\"1\":{\"564\":1}}],[\"内部的大部分方法都通过调用代理\",{\"1\":{\"629\":1}}],[\"内部的\",{\"1\":{\"556\":1}}],[\"内部注册了一个\",{\"1\":{\"556\":1}}],[\"内部包装了一个\",{\"1\":{\"556\":1}}],[\"内部包含字符串的拷贝\",{\"1\":{\"426\":1}}],[\"内部保存了一个二级\",{\"1\":{\"464\":1}}],[\"内部保存该\",{\"1\":{\"275\":1}}],[\"内部用\",{\"1\":{\"413\":1}}],[\"内部可以不用反射而是直接进行字段赋值\",{\"1\":{\"411\":1}}],[\"内部只有一个线程同步执行\",{\"1\":{\"360\":1}}],[\"内部调用\",{\"1\":{\"357\":1,\"841\":1}}],[\"内部调用了\",{\"1\":{\"276\":1}}],[\"内部遍历所有dispatcherlist中的分发器\",{\"1\":{\"283\":1}}],[\"内部使用二分查找算法\",{\"1\":{\"271\":1}}],[\"内部\",{\"1\":{\"244\":1}}],[\"内部会创建对应的\",{\"1\":{\"201\":1}}],[\"内存匹配服务是否开启\",{\"1\":{\"795\":1}}],[\"内存匹配未开启\",{\"1\":{\"791\":1}}],[\"内存匹配逻辑由一个线程\",{\"1\":{\"782\":1}}],[\"内存匹配\",{\"0\":{\"782\":1}}],[\"内存匹配性能较高\",{\"1\":{\"781\":1}}],[\"内存中不处理\",{\"1\":{\"796\":1}}],[\"内存中仅保存\",{\"1\":{\"796\":1}}],[\"内存中\",{\"1\":{\"695\":1}}],[\"内存中当前消费队列的消费进度\",{\"1\":{\"690\":1}}],[\"内存\",{\"1\":{\"600\":1}}],[\"内存无法承受会导致程序崩溃\",{\"1\":{\"451\":1}}],[\"内存级读写分离\",{\"0\":{\"403\":1}}],[\"内存映射\",{\"1\":{\"400\":2}}],[\"内存映射文件\",{\"0\":{\"859\":1},\"1\":{\"400\":1}}],[\"内存映射文件队列组成的\",{\"1\":{\"396\":1}}],[\"内存映射文件mmap\",{\"0\":{\"248\":1}}],[\"内存使用\",{\"0\":{\"235\":1}}],[\"内存不足\",{\"1\":{\"223\":1}}],[\"内存和磁盘的流控相当于全局流控\",{\"1\":{\"146\":1}}],[\"内存高水位\",{\"0\":{\"146\":1},\"1\":{\"235\":1}}],[\"内存占用也小很多\",{\"1\":{\"97\":1}}],[\"内置可扩展的模型支持\",{\"1\":{\"128\":1}}],[\"内置函数apply\",{\"1\":{\"50\":1}}],[\"内置函数\",{\"0\":{\"35\":1},\"1\":{\"46\":1}}],[\"查出消费索引后\",{\"1\":{\"838\":1}}],[\"查出完整消息后\",{\"1\":{\"838\":1}}],[\"查出完整消息\",{\"1\":{\"838\":1}}],[\"查出这批消息中要重试消息对应的真实消息\",{\"1\":{\"773\":1}}],[\"查询的原理是\",{\"1\":{\"842\":1}}],[\"查询的最大消息数量\",{\"1\":{\"287\":1,\"694\":1}}],[\"查询要分发的队列的逻辑偏移量\",{\"1\":{\"816\":1}}],[\"查询要分发的\",{\"1\":{\"814\":1}}],[\"查询一批\",{\"1\":{\"798\":1}}],[\"查询对应的真正消息\",{\"1\":{\"783\":1}}],[\"查询自己的分配结果\",{\"1\":{\"775\":1}}],[\"查询是否加锁等操作\",{\"1\":{\"732\":1}}],[\"查询发回的消息\",{\"1\":{\"718\":1}}],[\"查询和持久化消费进度的方法\",{\"1\":{\"710\":1}}],[\"查询偏移量\",{\"1\":{\"679\":1}}],[\"查询所有注册的\",{\"1\":{\"624\":1}}],[\"查询轨迹结果\",{\"1\":{\"528\":1}}],[\"查询轨迹\",{\"1\":{\"528\":1}}],[\"查询该\",{\"1\":{\"417\":1}}],[\"查询保存时间在\",{\"1\":{\"309\":1}}],[\"查询到消息在\",{\"1\":{\"298\":1,\"388\":1}}],[\"查询到消息在存储中的位置\",{\"1\":{\"220\":1}}],[\"查询\",{\"0\":{\"816\":1},\"1\":{\"287\":1,\"550\":1,\"559\":1,\"562\":1,\"680\":1,\"746\":1,\"798\":1,\"800\":1}}],[\"查询并解析消息\",{\"1\":{\"282\":1}}],[\"查询出相应的\",{\"1\":{\"271\":1}}],[\"查询消息的能力\",{\"1\":{\"298\":1}}],[\"查询消息结果\",{\"1\":{\"287\":1,\"694\":1}}],[\"查询消息\",{\"0\":{\"271\":1,\"277\":1,\"286\":1},\"1\":{\"287\":1}}],[\"查找topic配置信息\",{\"1\":{\"693\":1}}],[\"查找路由信息\",{\"0\":{\"571\":1}}],[\"查找主题路由信息\",{\"1\":{\"570\":1}}],[\"查找的\",{\"1\":{\"408\":1}}],[\"查找的key\",{\"1\":{\"317\":1}}],[\"查找时是否加锁\",{\"1\":{\"317\":1}}],[\"查找时间是恒定的\",{\"1\":{\"97\":1}}],[\"查找消息的能力\",{\"1\":{\"447\":1}}],[\"查找消息的结束时间\",{\"1\":{\"317\":1}}],[\"查找消息的开始时间\",{\"1\":{\"317\":1}}],[\"查找消息最大时间\",{\"1\":{\"314\":1}}],[\"查找消息最小时间\",{\"1\":{\"314\":1}}],[\"查找索引对应的message符合时间的indexfile\",{\"1\":{\"314\":1}}],[\"查找索引对应的\",{\"1\":{\"309\":1,\"310\":1,\"317\":1}}],[\"查找\",{\"0\":{\"408\":1,\"559\":1},\"1\":{\"284\":1,\"408\":1,\"558\":1,\"717\":1,\"783\":1,\"817\":1}}],[\"查找所有匹配的\",{\"1\":{\"201\":1}}],[\"查看\",{\"1\":{\"599\":1}}],[\"查看集群状态\",{\"1\":{\"598\":1}}],[\"查看可选版本列表\",{\"1\":{\"592\":1}}],[\"查看消息轨迹\",{\"0\":{\"528\":1,\"529\":1}}],[\"查看到构造消费索引的方法中包含了\",{\"1\":{\"434\":1}}],[\"查看其执行状态并执行对应操作\",{\"1\":{\"381\":1}}],[\"查看属性中是否有延迟等级信息\",{\"1\":{\"354\":1}}],[\"查看是否超时\",{\"1\":{\"345\":1}}],[\"查看当前节点状态\",{\"1\":{\"178\":1}}],[\"查看允许的最大进程数量\",{\"1\":{\"81\":1}}],[\"查看结果\",{\"0\":{\"11\":1}}],[\"常被用于分散压力和集群消息转移\",{\"1\":{\"167\":1}}],[\"常驻内存\",{\"1\":{\"97\":1}}],[\"常用做法是将元组第一个元素设为一个原子\",{\"1\":{\"26\":1}}],[\"套接字编程\",{\"0\":{\"95\":1}}],[\"套接字来编写运行在不可信环境中的分布式应用程序\",{\"1\":{\"87\":1}}],[\"脚本\",{\"0\":{\"93\":1}}],[\"改成\",{\"1\":{\"599\":1}}],[\"改成最新的官方镜像地址\",{\"1\":{\"595\":1}}],[\"改成宿主机\",{\"1\":{\"595\":1}}],[\"改成异步投递后\",{\"1\":{\"370\":1}}],[\"改变\",{\"1\":{\"718\":1}}],[\"改变生产者的\",{\"1\":{\"567\":1}}],[\"改变开发环境\",{\"0\":{\"73\":1}}],[\"改动\",{\"1\":{\"465\":1}}],[\"改动背景\",{\"0\":{\"413\":1}}],[\"改动后\",{\"1\":{\"372\":2}}],[\"改动后的性能变化\",{\"1\":{\"372\":1}}],[\"改动前\",{\"1\":{\"372\":1}}],[\"改动解析\",{\"0\":{\"371\":1}}],[\"改动主要移除了事务消息中的日志打印\",{\"1\":{\"242\":1}}],[\"改为宿主机的\",{\"1\":{\"595\":2}}],[\"改为使用\",{\"1\":{\"370\":1}}],[\"改为了\",{\"1\":{\"253\":1}}],[\"改为\",{\"1\":{\"91\":1,\"246\":2,\"372\":2}}],[\"通信\",{\"1\":{\"632\":1,\"638\":1}}],[\"通信的中介\",{\"1\":{\"556\":1}}],[\"通信模块\",{\"1\":{\"464\":1}}],[\"通信协议\",{\"0\":{\"409\":1},\"1\":{\"263\":1}}],[\"通俗地说\",{\"1\":{\"399\":1}}],[\"通道\",{\"1\":{\"340\":1}}],[\"通知消息消费长轮询线程\",{\"1\":{\"282\":1,\"347\":1}}],[\"通知机制\",{\"1\":{\"246\":1}}],[\"通常以\",{\"1\":{\"841\":1}}],[\"通常以集群的方式部署\",{\"1\":{\"461\":1}}],[\"通常这些消费者都消费同一类消息\",{\"1\":{\"609\":1}}],[\"通常\",{\"1\":{\"307\":1,\"825\":1}}],[\"通常情况下\",{\"1\":{\"226\":1}}],[\"通常队列由两部分组成\",{\"1\":{\"204\":1}}],[\"通常会阻塞较长时间\",{\"1\":{\"146\":1}}],[\"通常运行在数据同一个局域网的集群上\",{\"1\":{\"87\":1}}],[\"通过执行\",{\"1\":{\"841\":1}}],[\"通过这两个过滤方法\",{\"1\":{\"838\":1}}],[\"通过设置过滤表达式的方式进行过滤\",{\"1\":{\"823\":1}}],[\"通过下列样式进行配置\",{\"1\":{\"820\":1}}],[\"通过客户端的封装让用户使用时感觉像是\",{\"1\":{\"672\":1}}],[\"通过比较签名的方式进行验证\",{\"1\":{\"509\":1}}],[\"通过固定几个延迟等级的方式\",{\"1\":{\"445\":1}}],[\"通过系统调用\",{\"1\":{\"402\":2}}],[\"通过jna方法访问一些native的系统调用\",{\"1\":{\"402\":1}}],[\"通过jna将内存页锁定在物理内存中\",{\"1\":{\"402\":1}}],[\"通过写入\",{\"1\":{\"402\":1}}],[\"通过对文件预热\",{\"1\":{\"402\":1}}],[\"通过业务线程池pullmessageexecutor\",{\"1\":{\"340\":1}}],[\"通过该通道向消息拉取客户端发送响应结果\",{\"1\":{\"339\":1,\"693\":1}}],[\"通过hash槽绝对位置\",{\"1\":{\"317\":1}}],[\"通过hash槽下表计算出hash槽的绝对位置\",{\"1\":{\"317\":1}}],[\"通过\",{\"1\":{\"317\":2,\"398\":1,\"461\":1,\"563\":1,\"623\":1,\"648\":1}}],[\"通过死信交换器将这些消息转发到死信队列中\",{\"1\":{\"235\":1}}],[\"通过发送时设置消息的\",{\"1\":{\"218\":1}}],[\"通过将每个消费者的分配策略设置成一致\",{\"1\":{\"647\":1}}],[\"通过将部分消息放到磁盘上来\",{\"1\":{\"223\":1}}],[\"通过将队列的\",{\"1\":{\"217\":1}}],[\"通过将单个节点的队列相对平均地分配到集群的不同节点\",{\"1\":{\"181\":1}}],[\"通过定时向所有节点发送心跳的方式检测断开的情况\",{\"1\":{\"197\":1}}],[\"通过在策略中设置\",{\"1\":{\"193\":1}}],[\"通过镜像队列\",{\"1\":{\"181\":1}}],[\"通过调用get\",{\"1\":{\"157\":1}}],[\"通过channel\",{\"1\":{\"149\":1}}],[\"通过分析源码\",{\"1\":{\"134\":1}}],[\"通过查看实验过程信息\",{\"1\":{\"134\":1}}],[\"通过全链路压测\",{\"1\":{\"126\":1}}],[\"通过可分可合的设计与部署方式去适配各种业务场景\",{\"1\":{\"126\":1}}],[\"通过端口对象与外部程序通信\",{\"1\":{\"91\":1}}],[\"通过使用关卡\",{\"1\":{\"36\":1}}],[\"通过它\",{\"1\":{\"21\":1}}],[\"系统生成的路径是\",{\"1\":{\"594\":1}}],[\"系统级别的\",{\"1\":{\"356\":1}}],[\"系统会自动安装依赖包\",{\"1\":{\"176\":1}}],[\"系统管理的轻量级进程\",{\"1\":{\"156\":1}}],[\"系统表现出的性能以及弹性变更的花销与效率\",{\"1\":{\"135\":1}}],[\"系统在整个实验过程中的响应时间等\",{\"1\":{\"133\":1}}],[\"系统的可观测性\",{\"1\":{\"127\":1}}],[\"系统边界\",{\"1\":{\"127\":1}}],[\"系统\",{\"1\":{\"87\":1,\"356\":1}}],[\"程序虚拟页面直接映射到页缓存上\",{\"1\":{\"400\":1}}],[\"程序退出时强制刷盘\",{\"1\":{\"289\":1}}],[\"程序是如何使用时间的\",{\"1\":{\"105\":1}}],[\"程序接口\",{\"0\":{\"92\":1}}],[\"程序在\",{\"1\":{\"87\":1}}],[\"程序执行一条接收语句时才会读取邮箱\",{\"1\":{\"79\":1}}],[\"尾递归\",{\"1\":{\"85\":1}}],[\"尾递归的说明\",{\"0\":{\"85\":1}}],[\"尾是t\",{\"1\":{\"27\":1}}],[\"带超时的接收\",{\"0\":{\"82\":1}}],[\"带有可选的关卡\",{\"1\":{\"37\":1}}],[\"发到重试队列\",{\"1\":{\"800\":2}}],[\"发请求解锁该队列\",{\"1\":{\"745\":1}}],[\"发请求解除注册\",{\"1\":{\"648\":1}}],[\"发请求\",{\"1\":{\"734\":2,\"746\":1}}],[\"发请求进行加解锁\",{\"1\":{\"732\":1}}],[\"发回\",{\"1\":{\"637\":1,\"717\":1}}],[\"发生故障时\",{\"1\":{\"553\":1}}],[\"发给异步发送者处理\",{\"1\":{\"540\":1}}],[\"发给所有进程\",{\"1\":{\"79\":1}}],[\"发往消息队列中的消息存在一些可观测性上的问题\",{\"1\":{\"523\":1}}],[\"发起一次请求\",{\"1\":{\"465\":1}}],[\"发起\",{\"1\":{\"464\":1}}],[\"发布\",{\"1\":{\"406\":1}}],[\"发布一条消息后\",{\"1\":{\"233\":1}}],[\"发布页面下载对应的\",{\"1\":{\"178\":1}}],[\"发出后\",{\"1\":{\"206\":1}}],[\"发过来的消息时\",{\"1\":{\"154\":1}}],[\"发送重平衡请求\",{\"1\":{\"850\":1}}],[\"发送重试\",{\"0\":{\"753\":1}}],[\"发送缓冲区\",{\"1\":{\"820\":2}}],[\"发送缓冲区中的数据会分包发送给对端\",{\"1\":{\"820\":1}}],[\"发送到\",{\"1\":{\"781\":1}}],[\"发送锁定队列请求\",{\"1\":{\"744\":1,\"746\":1}}],[\"发送消费进度更新和持久化的请求\",{\"1\":{\"711\":1}}],[\"发送消息的时候通过设置\",{\"1\":{\"807\":1}}],[\"发送消息的请求header会类似如\",{\"1\":{\"262\":1}}],[\"发送消息处理器处理\",{\"0\":{\"576\":1}}],[\"发送消息实现\",{\"1\":{\"570\":1}}],[\"发送消息后\",{\"1\":{\"559\":1}}],[\"发送消息时\",{\"1\":{\"547\":3}}],[\"发送消息时可以从18个延迟等级中选一个\",{\"1\":{\"353\":1}}],[\"发送消息是\",{\"1\":{\"544\":1}}],[\"发送消息轨迹的消息生产者\",{\"1\":{\"541\":1}}],[\"发送消息\",{\"0\":{\"562\":1,\"573\":1},\"1\":{\"80\":1,\"172\":2,\"558\":1,\"570\":2,\"754\":1,\"873\":1}}],[\"发送异常消息\",{\"1\":{\"683\":1}}],[\"发送给\",{\"1\":{\"669\":1,\"711\":1}}],[\"发送注销请求\",{\"1\":{\"656\":1}}],[\"发送的重平衡请求时触发\",{\"1\":{\"656\":1}}],[\"发送的消息队列\",{\"1\":{\"573\":1}}],[\"发送的拉取请求时\",{\"1\":{\"329\":1}}],[\"发送失败后的\",{\"1\":{\"754\":1}}],[\"发送失败\",{\"1\":{\"570\":1}}],[\"发送成功\",{\"1\":{\"570\":1}}],[\"发送前需要做的就是将多条普通消息体编码\",{\"1\":{\"564\":1}}],[\"发送一次消息失败后\",{\"1\":{\"561\":2}}],[\"发送一个查询请求\",{\"1\":{\"324\":1}}],[\"发送大概率还是会失败\",{\"1\":{\"552\":1}}],[\"发送路由信息\",{\"1\":{\"550\":1}}],[\"发送效率最高\",{\"1\":{\"548\":1}}],[\"发送线程不阻塞\",{\"1\":{\"547\":1}}],[\"发送线程池将这些轨迹消息发送给指定的\",{\"1\":{\"535\":1}}],[\"发送逻辑采用生产\",{\"1\":{\"535\":1}}],[\"发送命令的前后\",{\"1\":{\"514\":1}}],[\"发送权限\",{\"1\":{\"498\":1}}],[\"发送\",{\"0\":{\"501\":1},\"1\":{\"498\":1,\"537\":1,\"560\":1,\"720\":1,\"754\":1,\"772\":1,\"779\":1}}],[\"发送请求给\",{\"1\":{\"708\":1,\"720\":1}}],[\"发送请求到\",{\"1\":{\"657\":1}}],[\"发送请求解除注册\",{\"1\":{\"656\":1}}],[\"发送请求让所有消费者重平衡\",{\"1\":{\"648\":1}}],[\"发送请求等\",{\"1\":{\"629\":1}}],[\"发送请求前执行\",{\"1\":{\"501\":1}}],[\"发送请求获取最新的路由信息\",{\"1\":{\"475\":1}}],[\"发送请求\",{\"1\":{\"465\":1,\"501\":1,\"544\":1,\"638\":1,\"681\":1,\"691\":1,\"720\":1,\"729\":1,\"734\":1,\"739\":1}}],[\"发送心跳给\",{\"1\":{\"657\":1}}],[\"发送心跳标识消费者的数量变化\",{\"1\":{\"656\":1}}],[\"发送心跳等\",{\"1\":{\"640\":1,\"643\":1}}],[\"发送心跳请求\",{\"1\":{\"490\":1,\"656\":1}}],[\"发送心跳包\",{\"1\":{\"472\":1,\"474\":1,\"490\":1}}],[\"发送心跳包的定时任务在\",{\"1\":{\"472\":1}}],[\"发送心跳\",{\"1\":{\"461\":1,\"465\":1,\"557\":1,\"567\":1,\"656\":1}}],[\"发送心跳的间隔可以用\",{\"1\":{\"197\":1}}],[\"发送了\",{\"1\":{\"451\":1}}],[\"发送拉取请求\",{\"1\":{\"332\":1}}],[\"发送拉取消息请求\",{\"1\":{\"326\":1}}],[\"发送参数优化\",{\"0\":{\"253\":1}}],[\"发送bump\",{\"1\":{\"160\":1}}],[\"发送方确认开启后\",{\"1\":{\"148\":1}}],[\"发送方确认\",{\"0\":{\"148\":1}}],[\"发现\",{\"1\":{\"599\":1}}],[\"发现如果是用\",{\"1\":{\"595\":1}}],[\"发现创建消费索引的\",{\"1\":{\"431\":1}}],[\"发现每次主节点被分区时\",{\"1\":{\"134\":1}}],[\"发现在主节点网络断开\",{\"1\":{\"134\":1}}],[\"接下来是拉消费者和推消费者接口\",{\"1\":{\"637\":1}}],[\"接受\",{\"1\":{\"461\":1}}],[\"接受消息后再解析成map\",{\"1\":{\"260\":1}}],[\"接近于\",{\"1\":{\"442\":3}}],[\"接口的\",{\"1\":{\"639\":2}}],[\"接口来执行消息消费\",{\"1\":{\"639\":1}}],[\"接口很简单\",{\"1\":{\"636\":1}}],[\"接口提供了客户端的一些基本的管理接口\",{\"1\":{\"636\":1}}],[\"接口\",{\"1\":{\"411\":1,\"556\":1,\"638\":1,\"675\":1,\"710\":1,\"838\":1}}],[\"接口调用过来很麻烦\",{\"1\":{\"121\":1}}],[\"接口技术\",{\"0\":{\"90\":1}}],[\"接收缓冲区\",{\"1\":{\"820\":1}}],[\"接收客户端的参数之后根据这些参数进行重平衡\",{\"1\":{\"775\":1}}],[\"接收拉取请求后从存储中查询消息并返回\",{\"1\":{\"606\":1,\"645\":1,\"667\":1,\"697\":1,\"723\":1}}],[\"接收到客户端请求后根据配置的权限匹配\",{\"1\":{\"499\":1}}],[\"接收到来自白名单中\",{\"1\":{\"498\":1}}],[\"接收到\",{\"1\":{\"473\":1}}],[\"接收到的数据存在一个\",{\"1\":{\"249\":1}}],[\"接收方法中\",{\"1\":{\"147\":1}}],[\"接收并打印出任何发给它的消息\",{\"1\":{\"85\":1}}],[\"接收一个函数作为参数\",{\"1\":{\"80\":1}}],[\"接收消息的权限\",{\"1\":{\"498\":1}}],[\"接收消息时\",{\"1\":{\"262\":1}}],[\"接收消息\",{\"1\":{\"80\":1}}],[\"接收发送给某个进程的消息\",{\"1\":{\"79\":1}}],[\"接着处理列表尾\",{\"1\":{\"27\":1}}],[\"向consumer返回应答\",{\"1\":{\"693\":1}}],[\"向broker处理服务启注册钩子函数\",{\"1\":{\"516\":1}}],[\"向所有消费者发送重平衡请求\",{\"1\":{\"850\":1}}],[\"向所有\",{\"1\":{\"490\":1}}],[\"向每个\",{\"1\":{\"472\":1}}],[\"向索引文件插入新的索引项\",{\"1\":{\"317\":2}}],[\"向master上报slave当前的offset\",{\"1\":{\"249\":1}}],[\"向消费者投递消息\",{\"1\":{\"204\":1}}],[\"向端口发送data\",{\"1\":{\"91\":1}}],[\"向\",{\"1\":{\"79\":1,\"465\":5,\"475\":1,\"557\":1,\"567\":1,\"629\":1,\"638\":1,\"640\":1,\"643\":1,\"648\":1,\"650\":1,\"656\":1,\"691\":1,\"720\":1,\"729\":1,\"734\":2,\"746\":2,\"772\":1,\"817\":1}}],[\"向载入路径的末端添加一个新目录\",{\"1\":{\"73\":1}}],[\"向载入路径的开头添加一个新目录\",{\"1\":{\"73\":1}}],[\"要理解水位线\",{\"1\":{\"820\":1}}],[\"要消费\",{\"1\":{\"813\":1}}],[\"要被重试的消息\",{\"1\":{\"800\":1}}],[\"要支持一种新语言的客户端就必须实现完整的重平衡逻辑\",{\"1\":{\"769\":1}}],[\"要锁定的队列中已经锁定的队列\",{\"1\":{\"742\":1}}],[\"要锁定的消息队列\",{\"1\":{\"742\":1,\"746\":1}}],[\"要从\",{\"1\":{\"694\":1}}],[\"要拉取的逻辑偏移量\",{\"1\":{\"669\":1}}],[\"要解决这个问题只能通过划分领域\",{\"1\":{\"462\":1}}],[\"要把这一\",{\"1\":{\"451\":1}}],[\"要同时投递\",{\"1\":{\"451\":1}}],[\"要等待\",{\"1\":{\"326\":1}}],[\"要补充空的消息索引\",{\"1\":{\"285\":1}}],[\"要使用消息轨迹\",{\"1\":{\"524\":1}}],[\"要使用\",{\"1\":{\"163\":1,\"417\":1}}],[\"要在\",{\"1\":{\"103\":1}}],[\"要用到\",{\"1\":{\"80\":1}}],[\"要改变其他某个进程的内存\",{\"1\":{\"77\":1}}],[\"要附上模块名\",{\"1\":{\"30\":1}}],[\"比较多时\",{\"1\":{\"430\":1}}],[\"比较少时\",{\"1\":{\"430\":1}}],[\"比较第一个\",{\"1\":{\"392\":1}}],[\"比较它的最大\",{\"1\":{\"388\":1}}],[\"比较时间信息\",{\"1\":{\"317\":1}}],[\"比较上次刷盘时间与当前时间差距\",{\"1\":{\"289\":1}}],[\"比较好\",{\"1\":{\"253\":1}}],[\"比较数据类型\",{\"0\":{\"70\":1}}],[\"比如在\",{\"1\":{\"878\":1}}],[\"比如通过修改消息拉取线程\",{\"1\":{\"727\":1}}],[\"比如保存路由和客户端信息\",{\"1\":{\"629\":1}}],[\"比如当消费者数量变化\",{\"1\":{\"618\":1}}],[\"比如当前最新版本为\",{\"1\":{\"592\":1}}],[\"比如消息生产的请求由\",{\"1\":{\"563\":1}}],[\"比如用户先发了一条延迟\",{\"1\":{\"445\":1}}],[\"比如每\",{\"1\":{\"444\":1}}],[\"比如使用了内存映射文件的方案进行读写\",{\"1\":{\"394\":1}}],[\"比如投递时页缓存繁忙或者其他原因导致一次投递失败\",{\"1\":{\"374\":1}}],[\"比如basic\",{\"1\":{\"157\":1}}],[\"比如处理路由逻辑\",{\"1\":{\"155\":1}}],[\"比如引入故障或者系统的扩缩容\",{\"1\":{\"130\":1}}],[\"比如\",{\"1\":{\"111\":1,\"547\":1,\"804\":1}}],[\"比如缺乏预热的步骤\",{\"1\":{\"3\":1}}],[\"进入到\",{\"1\":{\"594\":1}}],[\"进入死信队列\",{\"1\":{\"576\":1}}],[\"进入上述网页\",{\"1\":{\"176\":1}}],[\"进而产生不同的\",{\"1\":{\"755\":1}}],[\"进而调用\",{\"1\":{\"332\":1,\"347\":1}}],[\"进而从\",{\"1\":{\"298\":1,\"388\":1}}],[\"进而到\",{\"1\":{\"271\":1}}],[\"进一步的\",{\"1\":{\"126\":1}}],[\"进行更新\",{\"1\":{\"837\":1}}],[\"进行精确匹配过滤\",{\"1\":{\"835\":1}}],[\"进行过滤逻辑判断\",{\"1\":{\"844\":1}}],[\"进行过滤\",{\"1\":{\"823\":1}}],[\"进行消费\",{\"1\":{\"811\":1}}],[\"进行消息拉取\",{\"1\":{\"739\":1}}],[\"进行消息的存储\",{\"1\":{\"205\":1}}],[\"进行标记\",{\"1\":{\"798\":1}}],[\"进行设置\",{\"1\":{\"718\":1}}],[\"进行拉取\",{\"1\":{\"675\":1}}],[\"进行下一次拉取\",{\"1\":{\"657\":1}}],[\"进行检查或者是收到\",{\"1\":{\"656\":1}}],[\"进行重平衡的检查\",{\"1\":{\"656\":1}}],[\"进行重平衡的方法\",{\"1\":{\"654\":1}}],[\"进行重平衡后需要判断并更新消费者的负载\",{\"1\":{\"654\":1}}],[\"进行重平衡\",{\"0\":{\"663\":1},\"1\":{\"653\":1,\"656\":1,\"657\":2}}],[\"进行均匀的订阅\",{\"1\":{\"614\":1}}],[\"进行开发和验证\",{\"1\":{\"589\":1}}],[\"进行心跳检测等\",{\"1\":{\"567\":1}}],[\"进行网络传输\",{\"1\":{\"562\":1,\"573\":1}}],[\"进行发送\",{\"1\":{\"559\":1}}],[\"进行比较是否相等\",{\"1\":{\"519\":1}}],[\"进行权限控制的流程\",{\"1\":{\"499\":1}}],[\"进行权限判断\",{\"1\":{\"499\":1}}],[\"进行采样\",{\"1\":{\"431\":1}}],[\"进行拼接\",{\"1\":{\"426\":1}}],[\"进行操作\",{\"1\":{\"414\":1}}],[\"进行序列化反序列化\",{\"1\":{\"413\":1}}],[\"进行一次粗粒度的过滤\",{\"1\":{\"838\":1}}],[\"进行一次重平衡\",{\"1\":{\"656\":1}}],[\"进行一次检查\",{\"1\":{\"384\":1}}],[\"进行一次判断\",{\"1\":{\"272\":1}}],[\"进行扫描\",{\"1\":{\"276\":1}}],[\"进行调用\",{\"1\":{\"205\":1}}],[\"进行安全和协调的处理等\",{\"1\":{\"154\":1}}],[\"进行路由解析\",{\"1\":{\"154\":1}}],[\"进行通信\",{\"1\":{\"154\":1}}],[\"进行自愈风险分析与优化建议\",{\"1\":{\"127\":1}}],[\"进行浏览\",{\"0\":{\"96\":1}}],[\"进行运算时\",{\"1\":{\"2\":1}}],[\"进程进行广播同步将消息发送给\",{\"1\":{\"201\":1}}],[\"进程将消息发送给队列的\",{\"1\":{\"201\":1}}],[\"进程发送的\",{\"1\":{\"201\":1}}],[\"进程发送消息\",{\"1\":{\"79\":1}}],[\"进程所在节点会收到两次\",{\"1\":{\"201\":1}}],[\"进程收到消息后\",{\"1\":{\"201\":1}}],[\"进程都在远端节点上\",{\"1\":{\"201\":1}}],[\"进程外\",{\"1\":{\"201\":1}}],[\"进程除了将消息发送给队列的\",{\"1\":{\"201\":1}}],[\"进程中\",{\"1\":{\"201\":1}}],[\"进程从\",{\"1\":{\"201\":1}}],[\"进程解除阻塞\",{\"0\":{\"160\":1}}],[\"进程阻塞\",{\"0\":{\"158\":1}}],[\"进程成为性能瓶颈\",{\"1\":{\"155\":1}}],[\"进程会持续追踪它从\",{\"1\":{\"154\":1}}],[\"进程接收\",{\"1\":{\"154\":1}}],[\"进程开始处理一条消息\",{\"1\":{\"154\":1}}],[\"进程与操作系统的进程不同\",{\"1\":{\"152\":1}}],[\"进程的运作\",{\"1\":{\"155\":1}}],[\"进程的处理顺序如下\",{\"1\":{\"147\":1}}],[\"进程的流控\",{\"1\":{\"147\":1}}],[\"进程间只通过消息来通信\",{\"1\":{\"144\":1}}],[\"进程内流控可能在1秒钟内触发多次\",{\"1\":{\"155\":1}}],[\"进程内流控是阻塞在\",{\"1\":{\"147\":1}}],[\"进程内流控是针对\",{\"1\":{\"147\":1}}],[\"进程内流控的阻塞时间通常很短\",{\"1\":{\"147\":1}}],[\"进程内流控不会影响到消费端\",{\"1\":{\"147\":1}}],[\"进程内流控指的是这4种进程之间的流控\",{\"1\":{\"147\":1}}],[\"进程内流控\",{\"0\":{\"142\":1,\"147\":1},\"1\":{\"238\":1}}],[\"进程\",{\"1\":{\"91\":1,\"154\":3,\"156\":1,\"201\":6,\"419\":1}}],[\"进程很轻巧\",{\"0\":{\"81\":1}}],[\"进程标识符\",{\"1\":{\"80\":1}}],[\"进程字典\",{\"0\":{\"67\":1}}],[\"进制\",{\"1\":{\"65\":1}}],[\"kitchen\",{\"1\":{\"810\":1}}],[\"kong\",{\"1\":{\"625\":1}}],[\"kubernetes\",{\"1\":{\"594\":2}}],[\"kvconfig\",{\"1\":{\"464\":1,\"467\":1,\"470\":1,\"477\":1,\"480\":1,\"481\":1,\"488\":1,\"493\":2}}],[\"kvconfigmanager\",{\"1\":{\"464\":2,\"481\":2}}],[\"kv\",{\"1\":{\"464\":2,\"467\":1,\"481\":3}}],[\"karray\",{\"1\":{\"343\":4}}],[\"kafka和rocketmq底层存储之那些你不知道的事\",{\"1\":{\"858\":1}}],[\"kafka如何实现高性能io\",{\"1\":{\"404\":1}}],[\"kafka\",{\"0\":{\"855\":1},\"1\":{\"135\":1,\"136\":1,\"214\":1,\"394\":3,\"404\":1,\"442\":1,\"461\":1,\"462\":1,\"656\":1,\"855\":1,\"868\":1}}],[\"kb\",{\"1\":{\"176\":2}}],[\"k\",{\"0\":{\"433\":1},\"1\":{\"65\":1,\"262\":3,\"406\":1,\"410\":1,\"414\":3,\"448\":1,\"842\":2,\"843\":3}}],[\"kernel\",{\"1\":{\"61\":1}}],[\"keyidx\",{\"1\":{\"793\":1}}],[\"keybuilder\",{\"1\":{\"789\":3,\"790\":1,\"793\":1,\"799\":1,\"800\":2}}],[\"key=\",{\"1\":{\"721\":1}}],[\"key为acl配置文件的绝对路径\",{\"1\":{\"519\":1}}],[\"keychanged\",{\"1\":{\"481\":4}}],[\"key已经存在\",{\"1\":{\"317\":1}}],[\"keyhashread\",{\"1\":{\"317\":2}}],[\"keyhashcode\",{\"1\":{\"317\":1}}],[\"keyhash\",{\"1\":{\"317\":7}}],[\"key1\",{\"1\":{\"260\":1}}],[\"keyset\",{\"1\":{\"314\":3,\"343\":1}}],[\"keys\",{\"1\":{\"67\":1,\"314\":4,\"537\":1}}],[\"key\",{\"1\":{\"42\":1,\"67\":6,\"125\":1,\"157\":5,\"159\":2,\"201\":1,\"240\":1,\"256\":2,\"298\":2,\"300\":6,\"302\":1,\"306\":5,\"307\":3,\"309\":3,\"310\":3,\"314\":12,\"317\":13,\"335\":1,\"342\":3,\"343\":2,\"345\":2,\"388\":1,\"410\":1,\"417\":5,\"428\":1,\"447\":6,\"480\":1,\"481\":1,\"485\":1,\"503\":2,\"504\":4,\"505\":4,\"515\":2,\"517\":1,\"526\":2,\"541\":12,\"559\":1,\"585\":1,\"675\":1,\"721\":7,\"783\":1,\"795\":1,\"798\":2,\"816\":3,\"880\":1}}],[\"keep\",{\"1\":{\"21\":2}}],[\"碰到\",{\"1\":{\"63\":1}}],[\"宏控制流\",{\"0\":{\"64\":1}}],[\"宏语法模板\",{\"1\":{\"63\":1}}],[\"宏\",{\"0\":{\"63\":1}}],[\"使得用户普通的消息数据与消息轨迹数据的物理io完全隔离\",{\"1\":{\"524\":1}}],[\"使得对文件的操作不用再需要拷贝到pagecache\",{\"1\":{\"248\":1}}],[\"使程序对文件的顺序读写速度几乎接近于内存\",{\"1\":{\"399\":1}}],[\"使随机读写文件和读写内存拥有相似的速度\",{\"1\":{\"248\":1}}],[\"使编译自动化\",{\"0\":{\"75\":1}}],[\"使a和b相加\",{\"1\":{\"62\":1}}],[\"使预处理器能找到正确的文件\",{\"1\":{\"61\":1}}],[\"使用命令行方式切换\",{\"0\":{\"767\":1}}],[\"使用异步发送可以避免上游调用超时\",{\"1\":{\"753\":1}}],[\"使用异步而非同步\",{\"1\":{\"437\":1}}],[\"使用服务器端校正的偏移量进行下一次消息的拉取\",{\"1\":{\"695\":1}}],[\"使用批量发送可以提升发送效率\",{\"1\":{\"564\":1}}],[\"使用示例\",{\"0\":{\"524\":1}}],[\"使用日志等\",{\"1\":{\"523\":1}}],[\"使用spi机制加载配置的accessvalidator实现类\",{\"1\":{\"516\":1}}],[\"使用方法\",{\"0\":{\"502\":1,\"805\":1,\"824\":1}}],[\"使用方法和注意事项\",{\"0\":{\"183\":1}}],[\"使用第三方\",{\"1\":{\"448\":1}}],[\"使用索引文件解决定时消息顺序问题\",{\"0\":{\"447\":1}}],[\"使用索引项中的\",{\"1\":{\"287\":2}}],[\"使用延迟消息\",{\"1\":{\"440\":1}}],[\"使用定时消息\",{\"1\":{\"440\":1}}],[\"使用容器时在初始化时指定长度\",{\"1\":{\"437\":1}}],[\"使用更高效的容器\",{\"1\":{\"437\":1}}],[\"使用字符来匹配\",{\"1\":{\"424\":1}}],[\"使用缓存\",{\"1\":{\"420\":1}}],[\"使用火焰图可以清晰地看出当前耗时比较多的方法\",{\"1\":{\"407\":1}}],[\"使用写锁创建文件\",{\"1\":{\"313\":1}}],[\"使用函数式接口\",{\"1\":{\"258\":1}}],[\"使用的内存映射文件\",{\"1\":{\"247\":1}}],[\"使用了双\",{\"1\":{\"244\":1}}],[\"使用仲裁队列可以在\",{\"1\":{\"225\":1}}],[\"使用信用证机制限制消息生产的速度\",{\"1\":{\"197\":1}}],[\"使用策略\",{\"1\":{\"185\":1}}],[\"使用和原理详解\",{\"0\":{\"180\":1},\"1\":{\"238\":1}}],[\"使用前提\",{\"0\":{\"168\":1}}],[\"使用场景最广泛的消息类型\",{\"1\":{\"548\":1}}],[\"使用场景\",{\"0\":{\"164\":1}}],[\"使用结构化和关联日志\",{\"1\":{\"126\":1}}],[\"使用姿势\",{\"0\":{\"124\":1}}],[\"使用arthas显式执行代码\",{\"0\":{\"118\":1}}],[\"使用磁盘存储\",{\"1\":{\"97\":1}}],[\"使用注册进程的方法\",{\"1\":{\"84\":1}}],[\"使用一个消费线程池进行消费\",{\"1\":{\"723\":1}}],[\"使用一个进程来运行测试\",{\"1\":{\"9\":1}}],[\"使用一些工具可以对该结果进行可视化\",{\"1\":{\"3\":1}}],[\"使用锁还是\",{\"1\":{\"2\":1}}],[\"使用\",{\"0\":{\"7\":1,\"169\":1,\"430\":1,\"528\":1,\"529\":1,\"588\":1,\"596\":1},\"1\":{\"2\":3,\"3\":1,\"6\":1,\"9\":1,\"40\":2,\"80\":1,\"123\":1,\"166\":1,\"190\":1,\"360\":1,\"370\":1,\"400\":1,\"414\":1,\"480\":2,\"600\":1,\"884\":1}}],[\"引用的用途是创建独一无二的标签\",{\"1\":{\"68\":1}}],[\"引用\",{\"0\":{\"68\":1},\"1\":{\"60\":1,\"68\":1,\"245\":1}}],[\"引用当前模块的本地函数\",{\"1\":{\"60\":1}}],[\"引用在当前或外部模块里定义的某个函数\",{\"1\":{\"60\":1}}],[\"引入原因\",{\"0\":{\"804\":1}}],[\"引入分布式锁是最好的选择\",{\"1\":{\"729\":1}}],[\"引入的新消费形式\",{\"1\":{\"615\":1}}],[\"引入第三方组件\",{\"1\":{\"448\":1}}],[\"引入了轻量级队列\",{\"1\":{\"804\":1}}],[\"引入了延迟故障规避机制\",{\"1\":{\"754\":1}}],[\"引入了\",{\"1\":{\"403\":1}}],[\"引入了新的订阅表达式写法\",{\"1\":{\"827\":1}}],[\"引入了新的\",{\"1\":{\"293\":1}}],[\"引入了一套基于信用证的流控实现\",{\"1\":{\"147\":1,\"150\":1}}],[\"引入事件总线如apache\",{\"1\":{\"126\":1}}],[\"引入\",{\"0\":{\"769\":1},\"1\":{\"36\":1,\"267\":1,\"769\":2}}],[\"引入依赖\",{\"0\":{\"8\":1}}],[\"哪些失败了\",{\"1\":{\"715\":1}}],[\"哪些消息被发送到哪个消费者的信息就丢失了\",{\"1\":{\"198\":1}}],[\"哪怕当代码在模块里运行时重新编译了该模块也是如此\",{\"1\":{\"57\":1}}],[\"哪个更快\",{\"1\":{\"2\":1}}],[\"时计算的\",{\"1\":{\"852\":1}}],[\"时才使用布隆过滤器进行第一层过滤\",{\"1\":{\"842\":1}}],[\"时提交的写请求将被放入队列\",{\"1\":{\"819\":1}}],[\"时使用\",{\"1\":{\"814\":1}}],[\"时就会有严重的数据放大\",{\"1\":{\"810\":1}}],[\"时就已经计算出来并保存到\",{\"1\":{\"285\":1}}],[\"时可以进行通配\",{\"1\":{\"810\":1}}],[\"时可以用下面的语法\",{\"1\":{\"61\":1}}],[\"时要通过句柄来定位到它\",{\"1\":{\"771\":1}}],[\"时指定消息发送成功后的回调函数\",{\"1\":{\"547\":1}}],[\"时指向一个特定的数据库\",{\"1\":{\"102\":1}}],[\"时原先用的是\",{\"1\":{\"432\":1}}],[\"时间小于阈值\",{\"1\":{\"797\":1}}],[\"时间戳\",{\"1\":{\"537\":1}}],[\"时间超限\",{\"1\":{\"492\":1}}],[\"时间复杂度\",{\"1\":{\"451\":1}}],[\"时间轮看似一个完美的解决方案\",{\"1\":{\"451\":1}}],[\"时间轮保存在内存里面\",{\"1\":{\"451\":1}}],[\"时间轮常被用做定时器的实现\",{\"1\":{\"451\":1}}],[\"时间轮\",{\"1\":{\"451\":1}}],[\"时间\",{\"1\":{\"386\":1,\"434\":1,\"440\":2,\"790\":1,\"791\":1,\"799\":1}}],[\"时间到达\",{\"1\":{\"386\":1}}],[\"时删\",{\"1\":{\"386\":1}}],[\"时会上锁\",{\"1\":{\"397\":1}}],[\"时会强制删除文件\",{\"1\":{\"384\":1}}],[\"时会触发垃圾回收\",{\"1\":{\"221\":1}}],[\"时被写入\",{\"1\":{\"347\":1}}],[\"时序图\",{\"0\":{\"332\":1}}],[\"时用的是\",{\"1\":{\"322\":1}}],[\"时的重平衡情况\",{\"1\":{\"775\":1}}],[\"时的\",{\"1\":{\"135\":1}}],[\"时\",{\"0\":{\"421\":1,\"430\":1},\"1\":{\"57\":1,\"135\":1,\"152\":1,\"158\":1,\"166\":1,\"234\":1,\"267\":1,\"276\":1,\"360\":1,\"386\":3,\"559\":2,\"646\":1,\"656\":1,\"769\":1,\"835\":1}}],[\"代理名称通过ha\",{\"1\":{\"185\":1}}],[\"代理的个数由ha\",{\"1\":{\"185\":1}}],[\"代码\",{\"0\":{\"867\":1}}],[\"代码切换\",{\"0\":{\"768\":1}}],[\"代码硬编码属性\",{\"1\":{\"437\":1}}],[\"代码中添加相关属性\",{\"1\":{\"229\":1}}],[\"代码中提供获取\",{\"1\":{\"122\":1}}],[\"代码就可以随写随测\",{\"1\":{\"122\":1}}],[\"代码热变更方面\",{\"1\":{\"121\":1}}],[\"代码随写随测\",{\"1\":{\"120\":1}}],[\"代码深层次的一个方法\",{\"1\":{\"120\":1}}],[\"代码的性能分析工具\",{\"0\":{\"105\":1}}],[\"代码某处的erlang语法要求单个表达式\",{\"1\":{\"55\":1}}],[\"代表\",{\"1\":{\"65\":1}}],[\"代表函数的数据类型是\",{\"1\":{\"31\":1}}],[\"块表达式\",{\"0\":{\"55\":1}}],[\"指明要消费的\",{\"1\":{\"808\":1}}],[\"指明镜像队列的模式\",{\"1\":{\"185\":1}}],[\"指\",{\"1\":{\"614\":1}}],[\"指消费者主动拉取消息进行消费\",{\"1\":{\"613\":1}}],[\"指令的加速\",{\"1\":{\"424\":1}}],[\"指内存映射文件\",{\"1\":{\"400\":1}}],[\"指向下一个链表元素\",{\"1\":{\"317\":1}}],[\"指向下一条消息位置的指针\",{\"1\":{\"306\":1}}],[\"指向rabbit\",{\"1\":{\"159\":1}}],[\"指引进行安装\",{\"1\":{\"177\":1}}],[\"指定集群和需要切换的消费组\",{\"1\":{\"767\":1}}],[\"指定队列负载算法\",{\"1\":{\"631\":1}}],[\"指定\",{\"1\":{\"559\":1,\"560\":1}}],[\"指定用户名和密码\",{\"1\":{\"499\":1}}],[\"指定配置文件路径\",{\"1\":{\"480\":1}}],[\"指定了\",{\"1\":{\"332\":1}}],[\"指定了要跟踪的事件\",{\"1\":{\"111\":1}}],[\"指定要被\",{\"1\":{\"169\":1}}],[\"指定要对哪些代码应用跟踪模式\",{\"1\":{\"111\":1}}],[\"指定模块的版本号\",{\"1\":{\"53\":1}}],[\"指带有\",{\"1\":{\"30\":1}}],[\"列举了哪些函数要导入到模块中\",{\"1\":{\"53\":1}}],[\"列表保存着具体消息的轨迹信息\",{\"1\":{\"537\":1}}],[\"列表里面\",{\"1\":{\"508\":1,\"514\":1}}],[\"列表里的每个元素代表了一个unicode字符\",{\"1\":{\"28\":1}}],[\"列表中的索引文件\",{\"1\":{\"309\":1}}],[\"列表操作\",{\"0\":{\"62\":1}}],[\"列表推导里的生成器部分起着过滤器的作用\",{\"1\":{\"34\":1}}],[\"列表推导的常规形式\",{\"1\":{\"34\":1}}],[\"列表推导\",{\"0\":{\"34\":1},\"1\":{\"34\":1}}],[\"列表求和函数\",{\"1\":{\"33\":1}}],[\"列表处理\",{\"0\":{\"33\":1}}],[\"列表尾作为y\",{\"1\":{\"27\":1}}],[\"列表\",{\"0\":{\"27\":1},\"1\":{\"464\":1,\"467\":1,\"469\":1,\"472\":1,\"481\":1,\"491\":1,\"508\":1,\"514\":1,\"540\":1,\"799\":1}}],[\"预先根据这些消费组的过滤表达式进行一次精确匹配\",{\"1\":{\"835\":1}}],[\"预先定义需要继续挂起的拉取请求列表\",{\"1\":{\"345\":1}}],[\"预设了多种负载算法供不同场景下的消费\",{\"1\":{\"617\":1}}],[\"预加载到时间轮\",{\"0\":{\"451\":1}}],[\"预测行为\",{\"1\":{\"424\":1}}],[\"预分配文件\",{\"0\":{\"401\":1}}],[\"预制宏\",{\"1\":{\"63\":1}}],[\"预处理器会展开源文件里所有的宏\",{\"1\":{\"58\":1}}],[\"预处理器\",{\"0\":{\"58\":1}}],[\"预定义模块属性\",{\"0\":{\"53\":1}}],[\"预热\",{\"1\":{\"11\":1}}],[\"预热执行\",{\"1\":{\"9\":1}}],[\"应该立刻将客户端offset重置为0\",{\"1\":{\"693\":1}}],[\"应该从哪里开始拉取消息\",{\"1\":{\"664\":1,\"744\":1}}],[\"应该大于\",{\"1\":{\"254\":1}}],[\"应该保存预处理器的输出\",{\"1\":{\"58\":1}}],[\"应当避免\",{\"1\":{\"242\":1}}],[\"应当尽量避免使用apply\",{\"1\":{\"50\":1}}],[\"应用都有自己的权限控制系统\",{\"1\":{\"496\":1}}],[\"应用程序的读取线程会被阻塞\",{\"1\":{\"399\":1}}],[\"应用程序在写入文件的时候\",{\"1\":{\"399\":1}}],[\"应用程序实际操作的都是\",{\"1\":{\"399\":1}}],[\"应用\",{\"1\":{\"4\":1,\"135\":1}}],[\"里面的消息将会重试\",{\"1\":{\"781\":1}}],[\"里面的消息是否到达投递时间\",{\"1\":{\"445\":1}}],[\"里面是该\",{\"1\":{\"451\":1}}],[\"里面消息的延迟等级相同\",{\"1\":{\"445\":1}}],[\"里面采用生产\",{\"1\":{\"435\":1}}],[\"里面都会执行一个新的定时任务\",{\"1\":{\"361\":1}}],[\"里面一写\",{\"1\":{\"253\":1}}],[\"里面\",{\"1\":{\"249\":1}}],[\"里\",{\"1\":{\"106\":1}}],[\"里表示这些表\",{\"1\":{\"103\":1}}],[\"里调用\",{\"0\":{\"93\":1}}],[\"里的逻辑偏移量怎么已经被计算出来了\",{\"1\":{\"285\":1}}],[\"里的数据拷贝进去\",{\"1\":{\"249\":1}}],[\"里的表是一个包含若干行的\",{\"1\":{\"103\":1}}],[\"里的\",{\"1\":{\"45\":1}}],[\"里没有字符串\",{\"1\":{\"28\":1}}],[\"捕捉一切可能的异常错误\",{\"1\":{\"46\":1}}],[\"捕捉异常错误\",{\"0\":{\"45\":1}}],[\"捕获异常\",{\"0\":{\"44\":1}}],[\"像是它的强化版\",{\"1\":{\"44\":1}}],[\"具有全量数据\",{\"1\":{\"192\":1}}],[\"具有一个值\",{\"1\":{\"44\":1}}],[\"具体顺序生产和消费代码见\",{\"1\":{\"622\":1}}],[\"具体地说\",{\"1\":{\"563\":1}}],[\"具体选择队列的方式是轮询\",{\"1\":{\"549\":1}}],[\"具体完成监控acl配置文件变化的是\",{\"1\":{\"519\":1}}],[\"具体模块的初始化和启动\",{\"1\":{\"480\":1}}],[\"具体压测结果请看\",{\"1\":{\"437\":1}}],[\"具体修改如上两图所示\",{\"1\":{\"432\":1}}],[\"具体可以看\",{\"1\":{\"422\":1}}],[\"具体优化方法\",{\"0\":{\"417\":1}}],[\"具体存储结构和内容如图所示\",{\"1\":{\"307\":1}}],[\"具体为\",{\"1\":{\"306\":1}}],[\"具体的原理可以看\",{\"1\":{\"872\":1}}],[\"具体的原理是用原来\",{\"1\":{\"594\":1}}],[\"具体的做法是引入一个新的锁\",{\"1\":{\"735\":1}}],[\"具体的做法是\",{\"1\":{\"447\":1,\"835\":1}}],[\"具体的做法是开启\",{\"1\":{\"407\":1}}],[\"具体的方法为\",{\"1\":{\"755\":1}}],[\"具体的方法很简单\",{\"1\":{\"423\":1}}],[\"具体的方法是用\",{\"1\":{\"510\":1,\"516\":1}}],[\"具体的方法是通过\",{\"1\":{\"499\":1}}],[\"具体的方法是消除了\",{\"1\":{\"414\":1}}],[\"具体的方法是调用\",{\"1\":{\"332\":1}}],[\"具体的实现方法是\",{\"1\":{\"285\":1}}],[\"具体的解析可以看\",{\"1\":{\"12\":1}}],[\"具体是哪个变为mirror\",{\"1\":{\"192\":1}}],[\"此批消息到达上限\",{\"1\":{\"694\":1}}],[\"此处不再赘述\",{\"1\":{\"193\":1}}],[\"此处如果用红色显示\",{\"1\":{\"188\":1}}],[\"此外还需要实现拉消息\",{\"1\":{\"769\":1}}],[\"此外还包含了一些抽象方法\",{\"1\":{\"654\":1}}],[\"此外还有两个拉模式消费者\",{\"1\":{\"656\":1}}],[\"此外还有一个重要的域即重分配策略类\",{\"1\":{\"653\":1}}],[\"此外还有以下一些原因\",{\"1\":{\"462\":1}}],[\"此外还有必要用惰性队列作为仲裁队列的死信队列\",{\"1\":{\"235\":1}}],[\"此外有一个故障延迟机制\",{\"1\":{\"549\":1}}],[\"此外\",{\"1\":{\"193\":1,\"201\":1,\"242\":1,\"442\":1,\"498\":1,\"530\":1,\"595\":1,\"623\":1,\"639\":1,\"769\":2,\"771\":1,\"811\":1}}],[\"此外它还能提供简单明了的基准测试结果输出\",{\"1\":{\"3\":1}}],[\"此种情形最易显现\",{\"1\":{\"155\":3}}],[\"此时已经切换为\",{\"1\":{\"772\":1}}],[\"此时其他消费者会重新消费该消息\",{\"1\":{\"715\":1}}],[\"此时也会触发重平衡\",{\"1\":{\"656\":1}}],[\"此时需人工介入处理\",{\"1\":{\"620\":1}}],[\"此时就开始重平衡\",{\"1\":{\"656\":1}}],[\"此时就需要重新进行负载均衡\",{\"1\":{\"618\":1}}],[\"此时就可以实现批量化写入\",{\"1\":{\"403\":1}}],[\"此时调用\",{\"1\":{\"519\":1}}],[\"此时会调用\",{\"1\":{\"519\":1}}],[\"此时会略微增加消费时延\",{\"1\":{\"436\":1}}],[\"此时会拒绝写入新的消息\",{\"1\":{\"386\":1}}],[\"此时会删除过期的\",{\"1\":{\"386\":1}}],[\"此时\",{\"1\":{\"375\":1,\"453\":1,\"632\":1}}],[\"此时并未刷盘\",{\"1\":{\"285\":1}}],[\"此时消费者才可以消费到这条消息\",{\"1\":{\"440\":1}}],[\"此时消费者消费不到\",{\"1\":{\"285\":1}}],[\"此时消息还没从内存刷到磁盘\",{\"1\":{\"285\":1}}],[\"此时从队列重新上线\",{\"1\":{\"226\":1}}],[\"此时第二个致命的设计缺陷显露了出来\",{\"1\":{\"211\":1}}],[\"此时b节点内部会重启\",{\"1\":{\"192\":1}}],[\"此时出现网络异常\",{\"1\":{\"192\":1}}],[\"此时该进程会暂时阻塞消息的生产\",{\"1\":{\"147\":1}}],[\"此时cpu\",{\"1\":{\"135\":1}}],[\"此时异常会被转化为一个描述错误的元组\",{\"1\":{\"43\":1,\"45\":1}}],[\"此实验规格下的\",{\"1\":{\"135\":1}}],[\"此方法对以下一些场景有奇效\",{\"1\":{\"123\":1}}],[\"会检查消息属性\",{\"1\":{\"814\":1}}],[\"会检查挂起的请求中是否有可以进行拉取的数据\",{\"1\":{\"330\":1}}],[\"会消费\",{\"1\":{\"783\":1}}],[\"会消耗时间\",{\"1\":{\"396\":1}}],[\"会发送到\",{\"1\":{\"779\":1}}],[\"会继续后面的逻辑放入磁盘\",{\"1\":{\"779\":1}}],[\"会保存一批获取到的消息的起始偏移量和相对偏移量\",{\"1\":{\"778\":1}}],[\"会返回内存中\",{\"1\":{\"778\":1}}],[\"会返回重平衡的结果\",{\"1\":{\"772\":1}}],[\"会出现有的队列重复消费\",{\"1\":{\"760\":1}}],[\"会尝试向\",{\"1\":{\"729\":1}}],[\"会放入死信队列\",{\"1\":{\"718\":1}}],[\"会被同步到从\",{\"1\":{\"708\":1}}],[\"会被作为配置文件保存\",{\"1\":{\"360\":1}}],[\"会收到消费者端的请求\",{\"1\":{\"703\":1}}],[\"会让消费者端的管理器向\",{\"1\":{\"703\":1}}],[\"会等待一段时间后将拉取请求放入队列\",{\"1\":{\"678\":1}}],[\"会向\",{\"1\":{\"656\":1,\"832\":1}}],[\"会向长轮询线程发送提醒\",{\"1\":{\"331\":1}}],[\"会更新订阅的\",{\"1\":{\"656\":1}}],[\"会初始化一些服务和参数\",{\"1\":{\"632\":1}}],[\"会初始化并且创建一个目录结构来保存\",{\"1\":{\"102\":1}}],[\"会引发重平衡\",{\"1\":{\"621\":1}}],[\"会进行一次检查\",{\"1\":{\"618\":1}}],[\"会进行重投递\",{\"1\":{\"270\":1,\"301\":1}}],[\"会启动\",{\"1\":{\"597\":1}}],[\"会启动过期文件清理的定时任务\",{\"1\":{\"389\":1}}],[\"会拉取相应版本的\",{\"1\":{\"592\":1}}],[\"会悲观地认为\",{\"1\":{\"561\":1}}],[\"会规避上一次发送的\",{\"1\":{\"561\":1}}],[\"会轮询所有队列进行发送\",{\"1\":{\"561\":1}}],[\"会请求\",{\"1\":{\"550\":1}}],[\"会先执行\",{\"1\":{\"838\":1}}],[\"会先将需要\",{\"1\":{\"820\":1}}],[\"会先在\",{\"1\":{\"773\":1}}],[\"会先在本地查询\",{\"1\":{\"550\":1}}],[\"会先查询队列索引\",{\"1\":{\"220\":1}}],[\"会构建一个轨迹上下文\",{\"1\":{\"534\":1}}],[\"会观察配置文件改动并且自动重新加载\",{\"1\":{\"500\":1}}],[\"会遍历\",{\"1\":{\"472\":1}}],[\"会立即发送\",{\"1\":{\"465\":1}}],[\"会立刻执行删除\",{\"1\":{\"383\":1}}],[\"会造成其消费的队列的消息堆积\",{\"1\":{\"769\":1}}],[\"会造成其他\",{\"1\":{\"754\":1}}],[\"会造成\",{\"1\":{\"426\":1}}],[\"会对其进行预热\",{\"1\":{\"402\":1}}],[\"会对集群节点根据不同的观测特性引入对应的事件\",{\"1\":{\"130\":1}}],[\"会提前准备好下一个文件的分配\",{\"1\":{\"401\":1}}],[\"会提取列表头作为x\",{\"1\":{\"27\":1}}],[\"会阻止删除\",{\"1\":{\"390\":1}}],[\"会阻塞整个队列\",{\"1\":{\"211\":1}}],[\"会把\",{\"1\":{\"878\":1}}],[\"会把没有过期文件也删掉\",{\"1\":{\"386\":1}}],[\"会把内存映射文件中的数据强制写到磁盘\",{\"1\":{\"316\":1}}],[\"会删除未过期的文件\",{\"1\":{\"390\":1}}],[\"会删除\",{\"1\":{\"384\":1}}],[\"会计算出消息的真正投递时间\",{\"1\":{\"359\":1}}],[\"会判断是否是长轮询\",{\"1\":{\"326\":1}}],[\"会重试创建3次\",{\"1\":{\"309\":1}}],[\"会创建一个新的索引文件来保存\",{\"1\":{\"307\":1}}],[\"会强制刷盘\",{\"1\":{\"289\":1}}],[\"会从\",{\"1\":{\"285\":1,\"309\":1}}],[\"会根据消息的\",{\"1\":{\"559\":1}}],[\"会根据topic和queueid定位到对应的消费队列\",{\"1\":{\"286\":1}}],[\"会根据topic和queueid定位到对应的\",{\"1\":{\"277\":1}}],[\"会根据用户关注的不同观测特性引入对应的事件\",{\"1\":{\"130\":1}}],[\"会执行\",{\"1\":{\"276\":1}}],[\"会执行如下加粗逻辑\",{\"1\":{\"157\":1}}],[\"会为每个分配到的新队列创建一个消息拉取请求\",{\"1\":{\"624\":1}}],[\"会为每个\",{\"1\":{\"269\":1}}],[\"会为前三种进程分配信用值\",{\"1\":{\"152\":1}}],[\"会将引用次数设置为负数\",{\"1\":{\"390\":1}}],[\"会将请求加入到\",{\"1\":{\"335\":1}}],[\"会将响应码设置为\",{\"1\":{\"334\":1,\"339\":1}}],[\"会将\",{\"1\":{\"262\":1,\"426\":1,\"451\":1,\"841\":1}}],[\"会将较小的消息体直接全量保存到队列索引\",{\"1\":{\"220\":1}}],[\"会将模块mod里的func函数应用到arg1\",{\"1\":{\"50\":1}}],[\"会随着系统的负载而在几种不同的存储状态中不断地流动\",{\"1\":{\"214\":1}}],[\"会使消息丢失的概率加大\",{\"1\":{\"211\":1}}],[\"会使得服务器\",{\"1\":{\"155\":1}}],[\"会再次广播\",{\"1\":{\"207\":1}}],[\"会导致新的任务需要等待前一个任务执行结束\",{\"1\":{\"372\":1}}],[\"会导致从该位置中取不到数据\",{\"1\":{\"365\":1}}],[\"会导致查询结果错误\",{\"1\":{\"306\":1}}],[\"会导致生产者生产阻塞\",{\"1\":{\"197\":1}}],[\"会导致该进程邮箱过大\",{\"1\":{\"144\":1}}],[\"会调用\",{\"1\":{\"474\":1,\"679\":1}}],[\"会调用pullmessageprocessor\",{\"1\":{\"345\":1}}],[\"会调用grant方法授予rabbit\",{\"1\":{\"159\":1}}],[\"会调用credit\",{\"1\":{\"158\":1}}],[\"会授予rabbit\",{\"1\":{\"159\":1}}],[\"会给\",{\"1\":{\"154\":1}}],[\"会给上有进程发一个ack消息\",{\"1\":{\"152\":1}}],[\"会在根目录下创建一个\",{\"1\":{\"594\":1}}],[\"会在本次消息发送过程中避开该\",{\"1\":{\"561\":1}}],[\"会在初始化时加载目录中的所有配置文件\",{\"1\":{\"510\":1,\"516\":1}}],[\"会在每个\",{\"1\":{\"462\":1}}],[\"会在每次进入mfa指定的函数时进行测试\",{\"1\":{\"111\":1}}],[\"会在在其\",{\"1\":{\"354\":1}}],[\"会在讲解优化点前补充一些前置知识\",{\"1\":{\"240\":1}}],[\"会在信用证系统种进行\",{\"1\":{\"154\":1}}],[\"会在\",{\"1\":{\"102\":1}}],[\"会触发异常\",{\"1\":{\"43\":1}}],[\"崩溃性错误\",{\"1\":{\"43\":1}}],[\"把这个索引结构以文件的形式实现\",{\"1\":{\"880\":1}}],[\"把这个文件做成可扩展的文件队列即可\",{\"1\":{\"447\":1}}],[\"把已经全部\",{\"1\":{\"797\":1}}],[\"把已经匹配或存盘的\",{\"1\":{\"797\":1}}],[\"把超时的\",{\"1\":{\"782\":1}}],[\"把消费失败的消息发回\",{\"1\":{\"717\":2}}],[\"把消息全部已经投递的\",{\"1\":{\"388\":1}}],[\"把commitoffset位去掉\",{\"1\":{\"691\":1}}],[\"把重平衡逻辑从客户端移到了服务端\",{\"1\":{\"615\":1}}],[\"把其中默认的\",{\"1\":{\"595\":1}}],[\"把定时消息查出来重新投递\",{\"1\":{\"367\":1}}],[\"把真正的\",{\"1\":{\"363\":1}}],[\"把它当中已经\",{\"1\":{\"797\":1}}],[\"把它保存到\",{\"1\":{\"249\":1}}],[\"把它存放在数据里并在后面用于比较是否相等\",{\"1\":{\"68\":1}}],[\"把\",{\"1\":{\"234\":1,\"773\":1,\"814\":1,\"854\":1}}],[\"把相连进程的\",{\"1\":{\"91\":1}}],[\"把未匹配的消息加入队列供以后处理\",{\"1\":{\"83\":1}}],[\"把调用封装在一个\",{\"1\":{\"43\":1}}],[\"把列表的头与尾分隔开\",{\"1\":{\"27\":1}}],[\"被定时的消息\",{\"1\":{\"880\":1}}],[\"被调用后\",{\"1\":{\"820\":1}}],[\"被调用函数可能会抛出这个异常错误\",{\"1\":{\"43\":1}}],[\"被丢弃则放弃消费\",{\"1\":{\"708\":1}}],[\"被动触发\",{\"1\":{\"656\":1}}],[\"被多个消费者同时消费来加快消费速率\",{\"1\":{\"646\":1}}],[\"被关闭\",{\"1\":{\"492\":1}}],[\"被客户端拉取\",{\"1\":{\"465\":1}}],[\"被认为是不可信数据\",{\"1\":{\"403\":1}}],[\"被其他线程占用\",{\"1\":{\"386\":1}}],[\"被删除\",{\"1\":{\"367\":1}}],[\"被\",{\"1\":{\"335\":1,\"465\":1}}],[\"被putmessagepositioninfowrapper调用\",{\"1\":{\"285\":1}}],[\"被用于做线程之间的异步通知\",{\"1\":{\"246\":1}}],[\"被正确安装\",{\"1\":{\"178\":1}}],[\"被追踪的信息保存在rabbit\",{\"1\":{\"157\":1}}],[\"被阻塞\",{\"1\":{\"155\":1}}],[\"被称为该表的键\",{\"1\":{\"98\":1}}],[\"被执行\",{\"1\":{\"37\":1}}],[\"忘掉\",{\"1\":{\"41\":1}}],[\"让定时消息不受老化时间的限制\",{\"1\":{\"877\":1}}],[\"让这条消息的可见时间推迟了\",{\"1\":{\"771\":1}}],[\"让这个队列不可用\",{\"1\":{\"211\":1}}],[\"让它们切换对应消费者组和\",{\"1\":{\"768\":1}}],[\"让其他队列也有被消费到的机会\",{\"1\":{\"726\":1}}],[\"让其保存消息在定时消息存储中的位点\",{\"1\":{\"450\":1}}],[\"让同一\",{\"1\":{\"723\":1}}],[\"让用户在使用时感觉像\",{\"1\":{\"639\":1}}],[\"让生产者发送消息时也能够查询到\",{\"1\":{\"559\":1}}],[\"让他能够在发送请求时起作用\",{\"1\":{\"508\":1}}],[\"让我们来设想这两个场景\",{\"1\":{\"451\":1}}],[\"让消费进度管理器更新消费进度\",{\"1\":{\"711\":1}}],[\"让消费服务消费\",{\"1\":{\"669\":1}}],[\"让消费者可以消费\",{\"1\":{\"450\":1}}],[\"让消息看似主动从\",{\"1\":{\"667\":1}}],[\"让消息必须保存在磁盘中\",{\"1\":{\"214\":1}}],[\"让工作线程去处理\",{\"1\":{\"435\":1}}],[\"让挂起的拉取请求立刻进行处理\",{\"1\":{\"326\":1}}],[\"让挂起的拉取请求立刻进行拉取操作\",{\"1\":{\"326\":1}}],[\"让整个镜像队列仍然保持可用\",{\"1\":{\"226\":1}}],[\"让整个队列有很好的弹性\",{\"1\":{\"223\":1}}],[\"让应用\",{\"1\":{\"126\":1}}],[\"让任何进程都能与该进程通信\",{\"1\":{\"84\":1}}],[\"让\",{\"1\":{\"41\":1,\"144\":1,\"720\":2,\"729\":1}}],[\"就保存着\",{\"1\":{\"837\":1}}],[\"就意味着同一条消息会保存到多个\",{\"1\":{\"810\":1}}],[\"就必定存在并发消费\",{\"1\":{\"723\":1}}],[\"就需要在从节点也启动一个\",{\"1\":{\"450\":1}}],[\"就不能把这个位设为有效\",{\"1\":{\"691\":1}}],[\"就不会进行对应消费组的重平衡主动触发\",{\"1\":{\"648\":1}}],[\"就不可避免地变低\",{\"1\":{\"444\":1}}],[\"就不走\",{\"1\":{\"423\":1}}],[\"就变成了一个串行化的操作\",{\"1\":{\"397\":1}}],[\"就触发请求再次执行\",{\"1\":{\"343\":1}}],[\"就唤醒该请求\",{\"1\":{\"335\":1}}],[\"就向\",{\"1\":{\"324\":1}}],[\"就是在同一时刻定时了超大量的消息\",{\"1\":{\"878\":1}}],[\"就是在这里的对面的\",{\"1\":{\"820\":1}}],[\"就是它这批消息需要被尝试重试\",{\"1\":{\"773\":1}}],[\"就是重平衡实现\",{\"1\":{\"657\":1}}],[\"就是这样做的\",{\"1\":{\"636\":1}}],[\"就是这么做的\",{\"1\":{\"326\":1}}],[\"就是我们实际消费中需要新建的消费者对象\",{\"1\":{\"629\":1}}],[\"就是为了解决这些问题设计的\",{\"1\":{\"461\":1}}],[\"就是为了解决消息排序的问题\",{\"1\":{\"356\":1}}],[\"就是检查这个名称的字符是否在一些字符范围内\",{\"1\":{\"424\":1}}],[\"就是操作系统在内存中给磁盘上的文件建立的缓存\",{\"1\":{\"399\":1}}],[\"就是移动磁头\",{\"1\":{\"396\":1}}],[\"就是\",{\"1\":{\"347\":1}}],[\"就是新的消息写入后\",{\"1\":{\"326\":1}}],[\"就是用来创建\",{\"1\":{\"276\":1}}],[\"就是把锁内干的事情\",{\"1\":{\"256\":1}}],[\"就完事的\",{\"1\":{\"253\":1}}],[\"就知道该操作命令都同步到了所有的\",{\"1\":{\"206\":1}}],[\"就设置套接字属性为\",{\"1\":{\"158\":1}}],[\"就可以拉取消息进行消费\",{\"1\":{\"808\":1}}],[\"就可以识别\",{\"1\":{\"807\":1}}],[\"就可以通过偏移量查询到这条消息的完整信息\",{\"1\":{\"708\":1}}],[\"就可以定义出相应的方法\",{\"1\":{\"637\":1}}],[\"就可以知道整个\",{\"1\":{\"461\":1}}],[\"就可以实现高性能高可靠的定时消息\",{\"1\":{\"445\":1}}],[\"就可以达到另一个的效果\",{\"1\":{\"440\":1}}],[\"就可以随着栈帧出栈而自动销毁\",{\"1\":{\"424\":1}}],[\"就可以用该项中的偏移量从\",{\"1\":{\"356\":1}}],[\"就可以在启动时关闭任务注册功能\",{\"1\":{\"123\":1}}],[\"就可以使用\",{\"1\":{\"41\":1}}],[\"就会在分发时构建\",{\"1\":{\"813\":1}}],[\"就会造成二阶段消息丢失导致大量回查\",{\"1\":{\"254\":1}}],[\"就会阻塞上游进程向它发送消息\",{\"1\":{\"152\":1}}],[\"就会把它们放到包含文件里\",{\"1\":{\"61\":1}}],[\"就会被转换成一个描述此错误的\",{\"1\":{\"45\":1}}],[\"就会被广播给当前进程链接的所有进程\",{\"1\":{\"43\":1}}],[\"就会使用默认值throw\",{\"1\":{\"44\":1}}],[\"就会执行\",{\"1\":{\"38\":1}}],[\"就会发生异常错误\",{\"1\":{\"37\":1}}],[\"字节\",{\"1\":{\"834\":1}}],[\"字符数组\",{\"1\":{\"420\":1}}],[\"字符的整数代码\",{\"1\":{\"65\":1}}],[\"字符串列表中包含消息的\",{\"1\":{\"839\":1}}],[\"字符串的\",{\"1\":{\"839\":1}}],[\"字符串的方法\",{\"1\":{\"414\":1}}],[\"字符串计算出的\",{\"1\":{\"834\":1}}],[\"字符串换成\",{\"1\":{\"420\":1}}],[\"字符串操作的\",{\"1\":{\"420\":1}}],[\"字符串采用这种格式存储\",{\"1\":{\"260\":1}}],[\"字符串\",{\"0\":{\"28\":1},\"1\":{\"503\":2,\"839\":1}}],[\"字段都是固定的\",{\"1\":{\"410\":1}}],[\"字段\",{\"1\":{\"41\":1,\"257\":1,\"503\":1,\"556\":2}}],[\"创建重试主题\",{\"1\":{\"718\":1}}],[\"创建定时任务\",{\"1\":{\"711\":1}}],[\"创建定时任务后直接返回\",{\"1\":{\"365\":1,\"380\":1}}],[\"创建拉取消息成功的回调\",{\"1\":{\"679\":1}}],[\"创建拉取消息接口调用包装类\",{\"1\":{\"640\":1,\"642\":1}}],[\"创建客户端实例\",{\"1\":{\"642\":1}}],[\"创建或获取已经创建的客户端实例\",{\"1\":{\"640\":1}}],[\"创建或获取最新的索引文件\",{\"1\":{\"309\":1,\"314\":1}}],[\"创建和初始化一些对象\",{\"1\":{\"640\":1}}],[\"创建和注册broker请求处理类\",{\"1\":{\"575\":1}}],[\"创建和更新\",{\"1\":{\"41\":1}}],[\"创建主题\",{\"1\":{\"559\":1}}],[\"创建消息轨迹上下文\",{\"1\":{\"540\":1}}],[\"创建消息轨迹异步发送者\",{\"1\":{\"539\":1}}],[\"创建消息key的索引\",{\"1\":{\"314\":1}}],[\"创建请求\",{\"1\":{\"501\":1}}],[\"创建uniquekey的索引\",{\"1\":{\"314\":1}}],[\"创建索引\",{\"1\":{\"314\":1}}],[\"创建新的mapedfile时报错或者超时\",{\"1\":{\"817\":1}}],[\"创建新的\",{\"1\":{\"664\":1,\"744\":1}}],[\"创建新的文件\",{\"1\":{\"309\":1}}],[\"创建新的队列\",{\"1\":{\"188\":1}}],[\"创建新索引文件时如果创建失败\",{\"1\":{\"309\":1}}],[\"创建结果对象时将\",{\"1\":{\"258\":1}}],[\"创建完的策略如下图显示\",{\"1\":{\"185\":1}}],[\"创建名为\",{\"1\":{\"102\":1}}],[\"创建初始数据库\",{\"0\":{\"102\":1}}],[\"创建进程\",{\"1\":{\"80\":1}}],[\"创建一个新的消息对象\",{\"1\":{\"708\":1,\"718\":1}}],[\"创建一个新的并发进程来执行\",{\"1\":{\"79\":1}}],[\"创建一个周期性定时任务\",{\"1\":{\"360\":1,\"364\":1}}],[\"创建一个线程\",{\"1\":{\"356\":1,\"445\":1}}],[\"创建一个空的request队列\",{\"1\":{\"342\":1}}],[\"创建一个并行进程来执行\",{\"1\":{\"79\":1}}],[\"创建\",{\"0\":{\"313\":1},\"1\":{\"41\":2,\"42\":1,\"68\":1,\"170\":4,\"171\":2,\"261\":1,\"309\":1,\"400\":1,\"465\":1,\"472\":1,\"567\":1,\"664\":1,\"744\":1}}],[\"创建列表\",{\"1\":{\"32\":1}}],[\"记录消费失败的消息\",{\"1\":{\"718\":1}}],[\"记录消费时的轨迹\",{\"1\":{\"541\":1}}],[\"记录客户端拉取的消息记录\",{\"1\":{\"693\":1}}],[\"记录保存的消息总大小\",{\"1\":{\"585\":1}}],[\"记录这个队列扫描的偏移量\",{\"1\":{\"365\":1}}],[\"记录定义\",{\"1\":{\"103\":1}}],[\"记录其实就是元组的另一种形式\",{\"1\":{\"40\":1}}],[\"记录\",{\"0\":{\"40\":1},\"1\":{\"103\":1}}],[\"归集器\",{\"0\":{\"39\":1},\"1\":{\"39\":1}}],[\"相对于起始偏移量\",{\"1\":{\"778\":1}}],[\"相对于长轮询通知\",{\"1\":{\"693\":1}}],[\"相对应地\",{\"1\":{\"509\":1}}],[\"相等则遍历每个acl配置文件\",{\"1\":{\"519\":1}}],[\"相同会导致\",{\"1\":{\"760\":1}}],[\"相同\",{\"0\":{\"760\":1},\"1\":{\"760\":2}}],[\"相同的\",{\"1\":{\"518\":1}}],[\"相同名称的\",{\"1\":{\"422\":1}}],[\"相当于将所有需要过滤的消费者名称存入布隆过滤器\",{\"1\":{\"843\":1}}],[\"相当于一个\",{\"1\":{\"416\":1,\"417\":1}}],[\"相当于最后带\",{\"1\":{\"38\":1}}],[\"相关消息属性\",{\"1\":{\"806\":1}}],[\"相关类设计\",{\"0\":{\"675\":1}}],[\"相关的类\",{\"1\":{\"510\":1}}],[\"相关的类有\",{\"1\":{\"280\":1}}],[\"相关信息移除\",{\"1\":{\"474\":1}}],[\"相关操作的源码实现\",{\"1\":{\"280\":1}}],[\"相邻的节点会接管以保证本次广播的消息会复制到所有的节点\",{\"1\":{\"206\":1}}],[\"相邻的节点保证当前广播的消息会复制到新的节点上\",{\"1\":{\"206\":1}}],[\"相反如果b节点成为赢家\",{\"1\":{\"192\":1}}],[\"相较于传统混沌工程\",{\"1\":{\"132\":1}}],[\"相应的表达式序列就会执行\",{\"1\":{\"37\":1}}],[\"执行逻辑上面讲过\",{\"1\":{\"739\":1}}],[\"执行具体消费逻辑\",{\"1\":{\"715\":1}}],[\"执行结果处理函数\",{\"1\":{\"708\":1}}],[\"执行真正消费业务逻辑\",{\"1\":{\"708\":1}}],[\"执行真正的业务逻辑\",{\"1\":{\"699\":1}}],[\"执行hook\",{\"1\":{\"693\":1}}],[\"执行拉取消息请求\",{\"1\":{\"688\":1}}],[\"执行拉取任务\",{\"1\":{\"624\":1}}],[\"执行长轮询逻辑\",{\"1\":{\"683\":1}}],[\"执行分配策略的重分配方法\",{\"1\":{\"657\":1}}],[\"执行消费后钩子函数\",{\"1\":{\"708\":1,\"715\":1,\"738\":1}}],[\"执行消费前钩子函数\",{\"1\":{\"708\":1,\"715\":1,\"738\":1}}],[\"执行消费请求的\",{\"1\":{\"708\":1}}],[\"执行消费逻辑\",{\"1\":{\"637\":1,\"715\":1,\"738\":1}}],[\"执行消费业务逻辑\",{\"1\":{\"624\":1}}],[\"执行消息消费后钩子函数\",{\"1\":{\"708\":1}}],[\"执行消息轨迹的消费钩子\",{\"1\":{\"683\":1}}],[\"执行消息发送前的钩子函数\",{\"1\":{\"573\":1}}],[\"执行消息发送后的钩子函数\",{\"1\":{\"562\":1}}],[\"执行消息压缩和事务\",{\"1\":{\"573\":1}}],[\"执行消息拉取\",{\"1\":{\"331\":1}}],[\"执行重平衡方法\",{\"1\":{\"624\":1}}],[\"执行重投递逻辑\",{\"1\":{\"270\":1,\"301\":1}}],[\"执行客户端同步发送方法\",{\"1\":{\"573\":1}}],[\"执行所有\",{\"1\":{\"573\":1}}],[\"执行启动逻辑\",{\"1\":{\"567\":1}}],[\"执行发送之后的钩子函数\",{\"1\":{\"573\":1}}],[\"执行发送之前的钩子函数\",{\"1\":{\"562\":1}}],[\"执行发送\",{\"1\":{\"547\":1,\"556\":1}}],[\"执行处理请求前被调用\",{\"1\":{\"516\":1}}],[\"执行权限判断\",{\"1\":{\"501\":1}}],[\"执行该方法\",{\"1\":{\"480\":1}}],[\"执行新的handleputresulttask\",{\"1\":{\"378\":1}}],[\"执行一个新的\",{\"1\":{\"365\":1}}],[\"执行一次扫描\",{\"1\":{\"782\":1}}],[\"执行一次定时任务投递这\",{\"1\":{\"444\":1}}],[\"执行一次\",{\"1\":{\"289\":1,\"389\":1,\"782\":1}}],[\"执行入口\",{\"1\":{\"361\":1}}],[\"执行刷盘\",{\"1\":{\"289\":1}}],[\"执行刷盘有两个阈值\",{\"1\":{\"278\":1}}],[\"执行每个分发器的dispatch方法\",{\"1\":{\"283\":1}}],[\"执行如下命令安装\",{\"1\":{\"176\":1}}],[\"执行层与被测组件层\",{\"1\":{\"130\":1}}],[\"执行带参数的方法\",{\"1\":{\"116\":2}}],[\"执行无参数\",{\"1\":{\"116\":1}}],[\"执行静态方法和\",{\"0\":{\"115\":1}}],[\"执行\",{\"1\":{\"38\":1,\"480\":1}}],[\"一层过滤\",{\"1\":{\"852\":1}}],[\"一开始的默认低水位为\",{\"1\":{\"819\":1}}],[\"一批消息的结果\",{\"1\":{\"791\":1}}],[\"一批消息消费时加锁\",{\"1\":{\"735\":1}}],[\"一批任务只需要一次\",{\"1\":{\"436\":1}}],[\"一批任务\",{\"1\":{\"435\":1}}],[\"一段时间后进行重新消费\",{\"1\":{\"699\":1}}],[\"一致性哈希\",{\"1\":{\"658\":1}}],[\"一\",{\"1\":{\"625\":1}}],[\"一组在\",{\"1\":{\"622\":1}}],[\"一一对应\",{\"1\":{\"556\":1}}],[\"一起发送\",{\"1\":{\"548\":1}}],[\"一般不能删除数据\",{\"1\":{\"842\":1}}],[\"一般不会用到该消费者的重平衡机制\",{\"1\":{\"656\":1}}],[\"一般无需开启\",{\"1\":{\"754\":1}}],[\"一般来说消息消费很快\",{\"1\":{\"773\":1}}],[\"一般来说一个启动的客户端进程只有一个\",{\"1\":{\"556\":1}}],[\"一般来说用户会有自己的角色\",{\"1\":{\"496\":1}}],[\"一般来说\",{\"1\":{\"444\":1}}],[\"一般创建进程时\",{\"1\":{\"84\":1}}],[\"一方面\",{\"1\":{\"394\":1}}],[\"一次拉取任务执行完\",{\"1\":{\"688\":1}}],[\"一次发送一批消息轨迹数据\",{\"1\":{\"541\":1}}],[\"一次发送最大消息大小\",{\"1\":{\"541\":1}}],[\"一次发送的请求包含数据条数\",{\"1\":{\"541\":1}}],[\"一次\",{\"1\":{\"451\":1}}],[\"一次最多删除10个文件\",{\"1\":{\"390\":1}}],[\"一次最多删除\",{\"1\":{\"390\":1}}],[\"一次最多删\",{\"1\":{\"386\":1}}],[\"一次是生产者对应的\",{\"1\":{\"201\":1}}],[\"一次是生产者发送的\",{\"1\":{\"201\":1}}],[\"一次是队列的\",{\"1\":{\"201\":1}}],[\"一次是队列\",{\"1\":{\"201\":1}}],[\"一些秒杀场景可能慢\",{\"1\":{\"447\":1}}],[\"一些特性的基础\",{\"1\":{\"443\":1}}],[\"一些虚机的时间与现实时间不一致\",{\"1\":{\"386\":1}}],[\"一些规则\",{\"1\":{\"231\":1}}],[\"一定时间内未执行刷盘\",{\"1\":{\"289\":1}}],[\"一直从上一条消息末尾位置开始循环扫描新消息\",{\"1\":{\"282\":1}}],[\"一条消息\",{\"1\":{\"780\":1,\"793\":1}}],[\"一条消息没有被成功消费\",{\"1\":{\"523\":1}}],[\"一条消息从生产到消费\",{\"1\":{\"202\":1}}],[\"一条消息从生产者到消费\",{\"1\":{\"201\":1}}],[\"一条将要投递到多个队列的消息\",{\"1\":{\"233\":1}}],[\"一旦消息发送失败\",{\"1\":{\"754\":1}}],[\"一旦文件内容改变\",{\"1\":{\"517\":1}}],[\"一旦发现新的索引项\",{\"1\":{\"356\":1}}],[\"一旦发现匹配\",{\"1\":{\"37\":1}}],[\"一旦有新消息到达\",{\"1\":{\"323\":1}}],[\"一旦使用者耗尽了仅存在于主服务器上的消息\",{\"1\":{\"191\":1}}],[\"一旦调用了\",{\"1\":{\"111\":1}}],[\"一种是配置文件的内容发生变化\",{\"1\":{\"519\":1}}],[\"一种是将现有键k的值更新为新值v\",{\"1\":{\"42\":1}}],[\"一种好的做法是在发送消息到别的进程之前先把它打印出来\",{\"1\":{\"108\":1}}],[\"一个消费者实例即是一个消费者进程\",{\"1\":{\"609\":1}}],[\"一个消息文件中可能包含延迟\",{\"1\":{\"448\":1}}],[\"一个工作线程负责消费客户端实例提交过来的轨迹数据\",{\"1\":{\"535\":1}}],[\"一个每\",{\"1\":{\"467\":2,\"481\":2}}],[\"一个队列只支持一个延迟时间\",{\"1\":{\"442\":1}}],[\"一个队列主队列和一个队列镜像\",{\"1\":{\"190\":1}}],[\"一个文件写满了就开启一个新文件顺序读写下去\",{\"1\":{\"396\":1}}],[\"一个负责对\",{\"1\":{\"205\":1}}],[\"一个负责消息广播的\",{\"1\":{\"205\":1}}],[\"一个进程的flow状态会导致它的上游进程进入flow状态\",{\"1\":{\"155\":1}}],[\"一个ftp服务器和一个\",{\"1\":{\"112\":1}}],[\"一个\",{\"1\":{\"103\":1,\"267\":1,\"426\":1,\"451\":1,\"491\":1,\"585\":1,\"723\":1,\"811\":1}}],[\"一个迭代也是测试数据统计的最小单元\",{\"1\":{\"4\":1}}],[\"直接消费\",{\"1\":{\"750\":1}}],[\"直接消费消息的方法\",{\"1\":{\"707\":1}}],[\"直接将所有拉取的消息构造成一个消费请求并提交\",{\"1\":{\"714\":1}}],[\"直接运行如下命令\",{\"1\":{\"599\":1}}],[\"直接使用官方打包好的镜像\",{\"1\":{\"596\":1}}],[\"直接通过\",{\"1\":{\"520\":2}}],[\"直接传入\",{\"1\":{\"414\":1}}],[\"直接从队列中移除\",{\"1\":{\"381\":1}}],[\"直接返回消息未找到\",{\"1\":{\"345\":2}}],[\"直接返回该文件\",{\"1\":{\"309\":1,\"313\":1}}],[\"直接返回\",{\"1\":{\"285\":2,\"314\":1,\"547\":1,\"775\":1,\"796\":2,\"847\":1,\"852\":1}}],[\"直接get\",{\"1\":{\"262\":1}}],[\"直接用\",{\"1\":{\"123\":1}}],[\"直接执行静态方法\",{\"0\":{\"117\":1}}],[\"直接连接远程计算机上运行的erlang系统\",{\"1\":{\"21\":1}}],[\"直到下降到低水位线\",{\"1\":{\"820\":1}}],[\"直到i\",{\"1\":{\"819\":1}}],[\"直到30次都失败\",{\"1\":{\"817\":1}}],[\"直到超过请求的\",{\"1\":{\"777\":1}}],[\"直到消费时间到期\",{\"1\":{\"737\":1}}],[\"直到消息被消费或者从内存中删除\",{\"1\":{\"235\":1}}],[\"直到该队列的消息消费完或者超过最大消费时间\",{\"1\":{\"726\":1}}],[\"直到该消息投递成功\",{\"1\":{\"454\":1}}],[\"直到该任务投递成功\",{\"1\":{\"380\":1}}],[\"直到新消息来唤醒线程\",{\"1\":{\"435\":1}}],[\"直到重新投递成功\",{\"1\":{\"374\":1}}],[\"直到轮询时间超过设定的阈值才会返回\",{\"1\":{\"324\":1}}],[\"直到读完或者读到查询消息数的最大值\",{\"1\":{\"287\":1,\"694\":1}}],[\"直到所有镜像都授予它信用值\",{\"1\":{\"197\":1}}],[\"直到\",{\"1\":{\"160\":1,\"547\":1}}],[\"直到获得新的信用值\",{\"1\":{\"154\":1}}],[\"直到对应项恢复正常\",{\"1\":{\"146\":1}}],[\"直到某个关卡成功为止\",{\"1\":{\"38\":1}}],[\"直到匹配成功\",{\"1\":{\"37\":1,\"44\":1}}],[\"假设它的值为\",{\"1\":{\"37\":1}}],[\"假设需要测试分别向两种列表中添加\",{\"1\":{\"9\":1}}],[\"`pwd`\",{\"1\":{\"600\":9}}],[\"`caculatearea`\",{\"1\":{\"80\":1}}],[\"`case`\",{\"1\":{\"37\":1}}],[\"`receive`\",{\"1\":{\"80\":1}}],[\"`spawn`\",{\"1\":{\"80\":1}}],[\"`erlang\",{\"1\":{\"43\":1}}],[\"`exit\",{\"1\":{\"43\":1}}],[\"`\",{\"1\":{\"43\":3,\"80\":2}}],[\"`throw\",{\"1\":{\"43\":1}}],[\"`if`\",{\"1\":{\"38\":1}}],[\"`为真的元素`x`组成的列表\",{\"1\":{\"37\":1}}],[\"`filter`\",{\"1\":{\"37\":1}}],[\"`g1\",{\"1\":{\"36\":1}}],[\"`guardexpr1\",{\"1\":{\"36\":1}}],[\"序列化协议编码\",{\"1\":{\"414\":1}}],[\"序列化协议\",{\"1\":{\"414\":1}}],[\"序列化协议才能生效\",{\"1\":{\"414\":1}}],[\"序列化协议有俩\",{\"1\":{\"413\":1}}],[\"序列\",{\"1\":{\"36\":1}}],[\"为后缀名\",{\"1\":{\"841\":1}}],[\"为它们提交消息消费进度\",{\"1\":{\"797\":1}}],[\"为他们提交消息偏移量\",{\"1\":{\"782\":1}}],[\"为生产者设置不同的\",{\"1\":{\"755\":1}}],[\"为重试消息恢复真正的\",{\"1\":{\"750\":1}}],[\"为队列新建锁定标识\",{\"1\":{\"742\":1}}],[\"为已有的\",{\"1\":{\"734\":1}}],[\"为每隔队列发送持久化消费进度请求给\",{\"1\":{\"720\":1}}],[\"为每个消费队列初始化消费队列锁\",{\"1\":{\"737\":1}}],[\"为每个消费者配置固定的消息队列\",{\"1\":{\"658\":1}}],[\"为每个消息构建消费队列时\",{\"1\":{\"814\":1}}],[\"为每个消息队列都初始化一把锁\",{\"1\":{\"727\":1}}],[\"为每个消息队列都向\",{\"1\":{\"711\":1}}],[\"为每个消息创建全局唯一\",{\"1\":{\"419\":1}}],[\"为每个消息节省了1字节传输大小\",{\"1\":{\"260\":1}}],[\"为每个\",{\"1\":{\"445\":1,\"664\":1,\"744\":1}}],[\"为每个延迟等级创建一个deliverdelayedmessagetimertask\",{\"1\":{\"360\":1,\"364\":1}}],[\"为每个延迟等级的\",{\"1\":{\"356\":1}}],[\"为每个延迟等级都创建一个处理线程\",{\"1\":{\"354\":1}}],[\"为下面的失败处理逻辑使用\",{\"1\":{\"715\":1}}],[\"为下面失败处理逻辑使用\",{\"1\":{\"715\":1}}],[\"为广播模式和集群模式分别创建了消费进度存储类\",{\"1\":{\"701\":1}}],[\"为用户提供了主动处理这些消费多次失败的消息的可能\",{\"1\":{\"700\":1}}],[\"为推模式消费者服务\",{\"1\":{\"689\":1}}],[\"为拉取请求设置下次拉取的偏移量\",{\"1\":{\"685\":1}}],[\"为新增的队列新建\",{\"1\":{\"664\":1,\"744\":1}}],[\"为异步拉取方法\",{\"1\":{\"637\":1}}],[\"为消费者分配队列消费的这一个负载过程并不是一劳永逸的\",{\"1\":{\"618\":1}}],[\"为消息添加多队列分发属性\",{\"1\":{\"816\":1}}],[\"为消息分配全局唯一\",{\"1\":{\"573\":1}}],[\"为消息扩展属性类\",{\"1\":{\"555\":1}}],[\"为空\",{\"1\":{\"585\":1}}],[\"为内存中存储的消息总大小\",{\"1\":{\"585\":1}}],[\"为进程\",{\"1\":{\"567\":1}}],[\"为不同的请求类型\",{\"1\":{\"563\":1}}],[\"为客户端需要使用的消息类\",{\"1\":{\"555\":1}}],[\"为所有心跳请求构造统一的请求头\",{\"1\":{\"490\":1}}],[\"为延迟消息创建了一个内部\",{\"1\":{\"445\":1}}],[\"为当前版本使用的序列化协议\",{\"1\":{\"413\":1}}],[\"为true\",{\"1\":{\"390\":1}}],[\"为该消费者负载的队列新建消息拉取请求\",{\"1\":{\"739\":1}}],[\"为该\",{\"1\":{\"317\":1}}],[\"为该写满的索引文件中\",{\"1\":{\"313\":1}}],[\"为该队列应用的镜像策略\",{\"1\":{\"188\":1}}],[\"为16\",{\"1\":{\"261\":1}}],[\"为什么已经保存过的消息还要重新建一个并且保存\",{\"1\":{\"708\":1}}],[\"为什么主流消息队列都抛弃了\",{\"1\":{\"462\":1}}],[\"为什么这里是\",{\"1\":{\"426\":1}}],[\"为什么需要预热该文件\",{\"1\":{\"402\":1}}],[\"为什么不在\",{\"1\":{\"426\":1}}],[\"为什么不实现任意时间的定时消息\",{\"0\":{\"367\":1}}],[\"为什么不直接调用\",{\"1\":{\"347\":1}}],[\"为什么所有的节点都需要缓存一份发布的消息呢\",{\"1\":{\"207\":1}}],[\"为什么要流控\",{\"0\":{\"144\":1}}],[\"为普通队列\",{\"1\":{\"188\":1}}],[\"为镜像队列\",{\"1\":{\"188\":1}}],[\"为上文描述的扩缩代价与加速比效率结果\",{\"1\":{\"135\":1}}],[\"为openchaos中度量分布式系统弹性能力的指标\",{\"1\":{\"135\":1}}],[\"为系统随机的注入故障\",{\"1\":{\"127\":1}}],[\"为了留时间与\",{\"1\":{\"779\":1}}],[\"为了避免频繁检查匹配状态\",{\"1\":{\"773\":1}}],[\"为了避免一些异常情况\",{\"1\":{\"732\":1}}],[\"为了实现多个生产者分别发送消息到多个集群\",{\"1\":{\"755\":1}}],[\"为了跨消费者进行消费队列负载的协调\",{\"1\":{\"729\":1}}],[\"为了能够先后分别处理多个队列的拉取\",{\"1\":{\"675\":1}}],[\"为了减少网络请求次数\",{\"1\":{\"564\":1}}],[\"为了保证消费速度\",{\"1\":{\"771\":1}}],[\"为了保证消费线程池中没有多个线程消费同一个队列\",{\"1\":{\"737\":1}}],[\"为了保证消息消费的高可靠性\",{\"1\":{\"700\":1}}],[\"为了保证普通消息发送的性能\",{\"1\":{\"530\":1}}],[\"为了保证集群的安全性\",{\"1\":{\"498\":1}}],[\"为了保证可靠性\",{\"1\":{\"445\":1}}],[\"为了追求更高的性能\",{\"1\":{\"450\":1}}],[\"为了同时保证低延迟和高吞吐引入了\",{\"1\":{\"436\":1}}],[\"为了降低\",{\"1\":{\"403\":1}}],[\"为了防止频繁进行重平衡\",{\"1\":{\"648\":1}}],[\"为了防止缺页异常\",{\"1\":{\"402\":1}}],[\"为了防止消息存储发生混乱\",{\"1\":{\"397\":1}}],[\"为了提供差异化服务\",{\"1\":{\"367\":1}}],[\"为了提高网络性能\",{\"1\":{\"324\":1}}],[\"为了方便理解\",{\"1\":{\"240\":1}}],[\"为了优化消费性能\",{\"1\":{\"220\":1}}],[\"为了探索kafka分区的最佳使用实践\",{\"1\":{\"135\":1}}],[\"为了持久性\",{\"1\":{\"101\":1}}],[\"为了速度\",{\"1\":{\"101\":1}}],[\"为避免接收语句因为消息不来而一直等待\",{\"1\":{\"82\":1}}],[\"为通常的情形编写代码并且有意忽略异常错误\",{\"1\":{\"43\":1}}],[\"为\",{\"1\":{\"41\":1,\"168\":1,\"228\":1,\"585\":1,\"715\":1,\"717\":1,\"718\":1,\"787\":1,\"798\":1,\"808\":1,\"813\":1,\"817\":1,\"838\":1}}],[\"为真\",{\"1\":{\"36\":2}}],[\"为一个新的进程\",{\"1\":{\"4\":1}}],[\"表\",{\"1\":{\"664\":1,\"744\":1}}],[\"表中\",{\"1\":{\"837\":1}}],[\"表中该\",{\"1\":{\"492\":1}}],[\"表中移除该\",{\"1\":{\"465\":1}}],[\"表中最后一项可能是损坏的会丢失\",{\"1\":{\"97\":1}}],[\"表offsettable\",{\"1\":{\"377\":1}}],[\"表达了镜像队列的镜像策略和异常后的晋升策略\",{\"1\":{\"189\":1}}],[\"表达式去过滤消息属性\",{\"1\":{\"852\":1}}],[\"表达式模式过滤服务\",{\"1\":{\"852\":1}}],[\"表达式类似\",{\"1\":{\"841\":1}}],[\"表达式解析成一个抽象语法树\",{\"1\":{\"841\":1}}],[\"表达式对象\",{\"1\":{\"841\":2}}],[\"表达式计算来精确匹配\",{\"1\":{\"835\":1}}],[\"表达式匹配\",{\"1\":{\"835\":1}}],[\"表达式表示或的意思\",{\"1\":{\"827\":1}}],[\"表达式来灵活地过滤消息的\",{\"1\":{\"823\":1}}],[\"表达式过滤的逻辑在\",{\"1\":{\"833\":1}}],[\"表达式过滤\",{\"0\":{\"833\":1},\"1\":{\"823\":1,\"838\":1,\"847\":1,\"852\":1}}],[\"表达式加上最后的\",{\"1\":{\"44\":1}}],[\"表达式和case表达式之间的相似性\",{\"1\":{\"44\":1}}],[\"表达式里\",{\"1\":{\"43\":1}}],[\"表达式k\",{\"1\":{\"42\":2}}],[\"表达式的消费者\",{\"1\":{\"851\":1}}],[\"表达式的时机与\",{\"1\":{\"841\":1}}],[\"表达式的值\",{\"1\":{\"37\":1}}],[\"表达式的最后一个关卡是原子\",{\"1\":{\"38\":1}}],[\"表达式的最后\",{\"1\":{\"36\":1}}],[\"表达式\",{\"0\":{\"37\":1,\"38\":1},\"1\":{\"37\":1,\"38\":1,\"825\":1}}],[\"表达式为真\",{\"1\":{\"36\":1}}],[\"表达式均为真\",{\"1\":{\"36\":1}}],[\"表达式组成\",{\"1\":{\"36\":1}}],[\"表还可以在不同机器之间进行复制\",{\"1\":{\"101\":1}}],[\"表在内部是用散列表表示的\",{\"1\":{\"99\":1}}],[\"表效率的因素\",{\"0\":{\"99\":1}}],[\"表里所有的键都是唯一的\",{\"1\":{\"98\":1}}],[\"表保存的是元组\",{\"1\":{\"98\":1}}],[\"表的类型\",{\"0\":{\"98\":1}}],[\"表示这个时间要投递的所有定时消息\",{\"1\":{\"880\":1}}],[\"表示这条消息被\",{\"1\":{\"782\":1}}],[\"表示可能需要消费该消息\",{\"1\":{\"852\":1}}],[\"表示可以消费所有队列\",{\"1\":{\"775\":1}}],[\"表示可以同时投递的消息数\",{\"1\":{\"375\":1}}],[\"表示属性的值在某个集合内\",{\"1\":{\"828\":1}}],[\"表示属性值在两个值的区间之外\",{\"1\":{\"828\":1}}],[\"表示属性值在两个数字之间\",{\"1\":{\"828\":1}}],[\"表示无限\",{\"1\":{\"787\":1}}],[\"表示允许消费者进行额外的负载获取队列的次数\",{\"1\":{\"775\":1}}],[\"表示对应到一个\",{\"1\":{\"755\":1}}],[\"表示该队列有消息正被消费\",{\"1\":{\"745\":1}}],[\"表示该队列没有消息正被消费\",{\"1\":{\"745\":1}}],[\"表示该方法运行的时机\",{\"1\":{\"9\":1}}],[\"表示由客户端控制重试次数\",{\"1\":{\"718\":1}}],[\"表示由\",{\"1\":{\"717\":1,\"718\":1}}],[\"表示拉取的一批消息都消费成功\",{\"1\":{\"715\":1}}],[\"表示最多同时消费\",{\"1\":{\"707\":1}}],[\"表示新增队列\",{\"1\":{\"664\":1,\"744\":1}}],[\"表示新消息到达\",{\"1\":{\"335\":1}}],[\"表示\",{\"1\":{\"485\":2,\"767\":1,\"787\":1}}],[\"表示从节点\",{\"1\":{\"472\":1}}],[\"表示主节点\",{\"1\":{\"472\":1}}],[\"表示下一次从下一个\",{\"1\":{\"377\":1}}],[\"表示下一行\",{\"1\":{\"138\":3}}],[\"表示此时出现流控或者阻塞\",{\"1\":{\"377\":1}}],[\"表示每个延迟等级当前投递的消息在\",{\"1\":{\"377\":1}}],[\"表示每次至少刷2个操作系统page\",{\"1\":{\"289\":1}}],[\"表示每次测试都会执行\",{\"1\":{\"9\":1}}],[\"表示需要创建新的索引文件\",{\"1\":{\"317\":1}}],[\"表示消息在该\",{\"1\":{\"285\":1}}],[\"表示消息为广播的第一条消息\",{\"1\":{\"207\":1}}],[\"表示实时刷盘\",{\"1\":{\"255\":1}}],[\"表示同步副本数为\",{\"1\":{\"188\":1}}],[\"表示手动向master同步数据\",{\"1\":{\"185\":1}}],[\"表示自动向master同步数据\",{\"1\":{\"185\":1}}],[\"表示镜像队列中消息的同步方式\",{\"1\":{\"185\":1}}],[\"表示在指定的代理上进行镜像\",{\"1\":{\"185\":1}}],[\"表示在指定个数的代理上进行镜像\",{\"1\":{\"185\":1}}],[\"表示在集群所有的代理上进行镜像\",{\"1\":{\"185\":1}}],[\"表示函数可以被用作参数\",{\"1\":{\"31\":1}}],[\"表示常量值\",{\"1\":{\"25\":1}}],[\"表示误差\",{\"1\":{\"11\":1}}],[\"表示平均耗时\",{\"1\":{\"11\":1}}],[\"表示模式为\",{\"1\":{\"11\":1}}],[\"表示测试模式\",{\"1\":{\"11\":1}}],[\"只订阅消息标签为\",{\"1\":{\"827\":1}}],[\"只对\",{\"1\":{\"798\":1}}],[\"只不过在使用的\",{\"1\":{\"872\":1}}],[\"只不过变成了\",{\"1\":{\"775\":1}}],[\"只不过封装了订阅和监听器这样的对外接口\",{\"1\":{\"639\":1}}],[\"只打印日志\",{\"1\":{\"708\":1}}],[\"只需要在生产消息时带有需要分发的\",{\"1\":{\"813\":1}}],[\"只需要发回偏移量\",{\"1\":{\"708\":1}}],[\"只需要改变下次拉取的偏移量即可\",{\"1\":{\"675\":1}}],[\"只需要订阅一个\",{\"1\":{\"637\":1}}],[\"只需要找到对应的\",{\"1\":{\"267\":1}}],[\"只作为消息轨迹接收的节点\",{\"1\":{\"532\":1}}],[\"只允许存在在一个acl配置文件中\",{\"1\":{\"518\":1}}],[\"只注册了默认\",{\"1\":{\"484\":1}}],[\"只是互为备份\",{\"1\":{\"461\":1}}],[\"只是建立了进程虚拟内存地址与物理内存地址之间的映射关系\",{\"1\":{\"402\":1}}],[\"只要有一个为\",{\"1\":{\"648\":1}}],[\"只要能将\",{\"1\":{\"445\":1}}],[\"只要实现这个接口\",{\"1\":{\"411\":1}}],[\"只要随机的那块区域还在page\",{\"1\":{\"398\":1}}],[\"只要一个为\",{\"1\":{\"36\":1}}],[\"只删除过期的文件\",{\"1\":{\"390\":1}}],[\"只支持指定时间延迟\",{\"1\":{\"356\":1}}],[\"只会消费一个队列的消息\",{\"1\":{\"777\":1}}],[\"只会打印警告日志\",{\"1\":{\"715\":1}}],[\"只会存储一次\",{\"1\":{\"233\":1}}],[\"只会与主副本进行交互\",{\"1\":{\"228\":1}}],[\"只有一种情况会失败\",{\"1\":{\"817\":1}}],[\"只有一个队列的情况下能够实现\",{\"1\":{\"622\":1}}],[\"只有一个队列\",{\"1\":{\"532\":1}}],[\"只有一个线程调用\",{\"1\":{\"313\":1}}],[\"只有一个\",{\"1\":{\"220\":1}}],[\"只有master支持存储offset\",{\"1\":{\"693\":1}}],[\"只有拉取偏移量大于等于最小偏移量\",{\"1\":{\"684\":1}}],[\"只有指定队列进行拉取的接口\",{\"1\":{\"656\":1}}],[\"只有第一次启动才执行\",{\"1\":{\"642\":1}}],[\"只有拥有某种权限才能进行某些操作\",{\"1\":{\"496\":1}}],[\"只有\",{\"1\":{\"233\":1}}],[\"只有死信队列\",{\"1\":{\"231\":1}}],[\"只有delta状态的消息\",{\"1\":{\"223\":1}}],[\"只有将消息和队列都设置为持久化之后\",{\"1\":{\"218\":1}}],[\"只有当前事务在全部镜像中执行之后\",{\"1\":{\"196\":1}}],[\"只有主节点运行该匹配线程\",{\"1\":{\"782\":1}}],[\"只有主节点才保存\",{\"1\":{\"691\":1}}],[\"只有主节点向外提供服务\",{\"1\":{\"202\":1}}],[\"只有主节点\",{\"1\":{\"190\":1,\"491\":1}}],[\"只有在执行完gen\",{\"1\":{\"157\":1}}],[\"只有父进程知道子进程的\",{\"1\":{\"84\":1}}],[\"只在必要时才对参数求值\",{\"1\":{\"69\":1}}],[\"只能同时被一个消费者消费\",{\"1\":{\"646\":1}}],[\"只能往自己申请的\",{\"1\":{\"498\":1}}],[\"只能单线程操作\",{\"1\":{\"253\":1,\"256\":1}}],[\"只能被强制删除\",{\"1\":{\"236\":1}}],[\"只能被赋值一次\",{\"1\":{\"23\":1}}],[\"只能更新值\",{\"1\":{\"42\":1}}],[\"只遍历列表一次\",{\"1\":{\"39\":1}}],[\"关于这两个\",{\"1\":{\"419\":1}}],[\"关于消息消费的\",{\"1\":{\"266\":1}}],[\"关闭与\",{\"1\":{\"492\":1}}],[\"关闭定时任务线程\",{\"1\":{\"467\":1,\"480\":1}}],[\"关闭\",{\"1\":{\"403\":1,\"467\":1,\"480\":2,\"561\":1}}],[\"关闭文件过后多久才能强制删除\",{\"1\":{\"390\":1}}],[\"关闭端口\",{\"1\":{\"91\":1}}],[\"关机恢复从倒数第3个commitlog文件开始重新转发消息生成consumequeue\",{\"1\":{\"285\":1}}],[\"关键时候方能\",{\"1\":{\"136\":1}}],[\"关键注解\",{\"1\":{\"12\":1}}],[\"关联的所有注册信息\",{\"1\":{\"84\":1}}],[\"关卡防止在某个\",{\"1\":{\"36\":1}}],[\"关卡序列\",{\"1\":{\"36\":1}}],[\"关卡由一系列关卡表达式组成\",{\"1\":{\"36\":1}}],[\"关卡\",{\"0\":{\"36\":1},\"1\":{\"36\":1}}],[\"例如发送日志\",{\"1\":{\"547\":1}}],[\"例如每一天需要投递的消息保存为一个文件队列\",{\"1\":{\"448\":1}}],[\"例如电商\",{\"1\":{\"441\":1,\"871\":1}}],[\"例如两台节点a\",{\"1\":{\"192\":1}}],[\"例如\",{\"1\":{\"135\":1,\"155\":1,\"186\":1,\"195\":1,\"207\":1}}],[\"例如一个完整的\",{\"1\":{\"112\":1}}],[\"例如list\",{\"1\":{\"35\":1}}],[\"例如函数定义\",{\"1\":{\"30\":1}}],[\"最好的方式是以业务唯一标识作为幂等处理的关键依据\",{\"1\":{\"757\":1}}],[\"最佳实践\",{\"0\":{\"751\":1},\"1\":{\"884\":1}}],[\"最新的\",{\"1\":{\"595\":1,\"814\":1}}],[\"最基础的操作之一\",{\"1\":{\"544\":1}}],[\"最长延迟可达\",{\"1\":{\"457\":1}}],[\"最长保存3天\",{\"1\":{\"353\":1}}],[\"最多等待\",{\"1\":{\"745\":1}}],[\"最多可以有\",{\"1\":{\"723\":1}}],[\"最多可以保存\",{\"1\":{\"307\":1}}],[\"最多遍历\",{\"1\":{\"684\":1}}],[\"最多重试消费\",{\"1\":{\"620\":1}}],[\"最多只能被\",{\"1\":{\"615\":1}}],[\"最多只能被一个消费者订阅\",{\"1\":{\"614\":1}}],[\"最多删除\",{\"1\":{\"390\":1}}],[\"最初\",{\"1\":{\"360\":1}}],[\"最大重试次数\",{\"1\":{\"817\":1}}],[\"最大挂起时间\",{\"1\":{\"693\":1}}],[\"最大拉取的消息数量\",{\"1\":{\"669\":1}}],[\"最大拉取消息条数\",{\"1\":{\"637\":1}}],[\"最大不超过\",{\"1\":{\"447\":1}}],[\"最大\",{\"1\":{\"442\":1}}],[\"最大返回结果数量\",{\"1\":{\"317\":1}}],[\"最大查找消息数量\",{\"1\":{\"314\":1}}],[\"最大可存储的\",{\"1\":{\"307\":1}}],[\"最晚的消息存储时间\",{\"1\":{\"307\":1}}],[\"最早的消息存储时间\",{\"1\":{\"307\":1}}],[\"最早之前\",{\"1\":{\"253\":1}}],[\"最重要的是设计它的逻辑结构和文件存储结构\",{\"1\":{\"305\":1}}],[\"最后释放锁容器的锁\",{\"1\":{\"734\":1}}],[\"最后判断一次队列是否被丢弃\",{\"1\":{\"708\":1}}],[\"最后\",{\"1\":{\"510\":1,\"820\":1}}],[\"最后进行源码的解析\",{\"1\":{\"496\":1}}],[\"最后进行进行刷盘\",{\"1\":{\"403\":1}}],[\"最后启动\",{\"1\":{\"480\":1}}],[\"最后添加\",{\"1\":{\"467\":1,\"481\":1}}],[\"最后注册关闭钩子函数\",{\"1\":{\"467\":1,\"480\":1}}],[\"最后创建\",{\"1\":{\"467\":1}}],[\"最后讲解了定时消息取消的设计和实现\",{\"1\":{\"456\":1}}],[\"最后是取消的触发方式\",{\"1\":{\"455\":1}}],[\"最后配合\",{\"1\":{\"402\":1}}],[\"最后才能删除该文件\",{\"1\":{\"390\":1}}],[\"最后将消息保存到磁盘\",{\"1\":{\"354\":1}}],[\"最后一次延迟\",{\"1\":{\"700\":1}}],[\"最后一次写入后\",{\"1\":{\"386\":1}}],[\"最后一个\",{\"1\":{\"798\":1}}],[\"最后一个是指针\",{\"1\":{\"317\":1}}],[\"最后一个文件需要加锁\",{\"1\":{\"314\":1}}],[\"最后一部分展望未来\",{\"1\":{\"125\":1}}],[\"最后更新整个队列的可用偏移量\",{\"1\":{\"279\":1,\"291\":1}}],[\"最老的从节点会被提升为新的主节点\",{\"1\":{\"192\":1}}],[\"最简单的\",{\"1\":{\"175\":1}}],[\"最终的\",{\"1\":{\"837\":1}}],[\"最终的存储方案就很明确了\",{\"1\":{\"449\":1}}],[\"最终投递到\",{\"1\":{\"783\":1}}],[\"最终处理加锁逻辑\",{\"1\":{\"734\":1}}],[\"最终调用\",{\"1\":{\"576\":1}}],[\"最终可能导致集群不可用\",{\"1\":{\"235\":1}}],[\"最终集群中的磁盘上存储了\",{\"1\":{\"234\":1}}],[\"最终会调用\",{\"1\":{\"334\":1,\"490\":1}}],[\"最终会收到自己发送的操作命令\",{\"1\":{\"206\":1}}],[\"最终会导致它的上游\",{\"1\":{\"155\":1}}],[\"最终\",{\"1\":{\"154\":1,\"233\":1}}],[\"最终内存溢出并崩溃\",{\"1\":{\"144\":1}}],[\"最终使用客户端对分布式系统执行操作\",{\"1\":{\"130\":1}}],[\"最下层为被测组件\",{\"1\":{\"130\":1}}],[\"最上层为管理层\",{\"1\":{\"130\":1}}],[\"最常用的内置函数\",{\"1\":{\"35\":1}}],[\"最强\",{\"0\":{\"16\":1}}],[\"有概率消费到\",{\"1\":{\"781\":1}}],[\"有个线程消费这个\",{\"1\":{\"781\":1}}],[\"有个后台线程消费这个\",{\"1\":{\"773\":1}}],[\"有可能是过滤匹配的\",{\"1\":{\"834\":1}}],[\"有可能出现冲突\",{\"1\":{\"757\":1}}],[\"有可能有节点失效\",{\"1\":{\"207\":1}}],[\"有必要根据业务上的唯一key对消息做幂等处理\",{\"1\":{\"757\":1}}],[\"有多个队列\",{\"1\":{\"622\":1}}],[\"有的消费者将无法分配到队列\",{\"1\":{\"769\":1}}],[\"有的队列无法消费的情况\",{\"1\":{\"760\":1}}],[\"有的\",{\"1\":{\"594\":1}}],[\"有众多配置项和部署方式可以选择\",{\"1\":{\"589\":1}}],[\"有全局和用户\",{\"1\":{\"498\":1}}],[\"有一个线程默默主动拉取消息\",{\"1\":{\"639\":1}}],[\"有一个定时任务每隔\",{\"1\":{\"623\":1}}],[\"有一个表记录每个队列当前的投递位移\",{\"1\":{\"452\":1}}],[\"有一大堆元组\",{\"1\":{\"40\":1}}],[\"有没有其他可取的方案\",{\"1\":{\"451\":1}}],[\"有没有办法来优化一下\",{\"1\":{\"431\":1}}],[\"有了时间轮\",{\"1\":{\"451\":1}}],[\"有新的消息\",{\"1\":{\"708\":1}}],[\"有新的消息落盘\",{\"1\":{\"282\":1,\"347\":1}}],[\"有新消息来了可以消费了\",{\"1\":{\"434\":1}}],[\"有许多\",{\"1\":{\"428\":1}}],[\"有直接\",{\"1\":{\"414\":1}}],[\"有两个实现类\",{\"1\":{\"710\":1}}],[\"有两个提交\",{\"1\":{\"409\":1}}],[\"有两种消费方式\",{\"1\":{\"707\":1}}],[\"有两种订阅消息的方式\",{\"1\":{\"622\":1}}],[\"有两种轮询方式\",{\"1\":{\"324\":1}}],[\"有两种捕获异常的方法\",{\"1\":{\"43\":1,\"44\":1}}],[\"有两种方法可以代替它使用\",{\"1\":{\"43\":1}}],[\"有文件需要被删除\",{\"1\":{\"392\":1}}],[\"有交集的索引文件\",{\"1\":{\"309\":1}}],[\"有\",{\"1\":{\"244\":2,\"595\":1}}],[\"有效取值范围为\",{\"1\":{\"185\":1}}],[\"有效取值范围为all\",{\"1\":{\"185\":1}}],[\"有时甚至会导致同步卡住\",{\"1\":{\"211\":1}}],[\"有时是本地的\",{\"1\":{\"154\":1}}],[\"有时上网查询可以找到答案\",{\"1\":{\"2\":1}}],[\"有序异键\",{\"1\":{\"98\":1}}],[\"有些内置函数是用erlang实现的\",{\"1\":{\"35\":1}}],[\"毕达哥拉斯三元数组\",{\"1\":{\"34\":1}}],[\"递归\",{\"1\":{\"34\":1}}],[\"即上图中标记为\",{\"1\":{\"820\":1}}],[\"即进入不可见时间\",{\"1\":{\"771\":1}}],[\"即一个队列同一时间只能被一个消费者的一个线程消费\",{\"1\":{\"724\":1}}],[\"即并发消费和顺序消费\",{\"1\":{\"723\":1}}],[\"即过滤数据\",{\"1\":{\"693\":1}}],[\"即不流控\",{\"1\":{\"665\":1}}],[\"即实现\",{\"1\":{\"639\":1}}],[\"即消息到达消息队列服务端后不会马上投递\",{\"1\":{\"871\":1}}],[\"即消息的\",{\"1\":{\"526\":1}}],[\"即消费线程池同时消费多个队列的消息\",{\"1\":{\"724\":1}}],[\"即消费者端\",{\"1\":{\"651\":1}}],[\"即消费者接口\",{\"1\":{\"636\":1}}],[\"即图中的红黑树\",{\"1\":{\"624\":1}}],[\"即生产发送的消息\",{\"1\":{\"537\":1}}],[\"即访问控制列表\",{\"1\":{\"496\":1}}],[\"即定时消息投递线程\",{\"1\":{\"450\":1}}],[\"即该时间段内要投递的所有消息位置信息\",{\"1\":{\"447\":1}}],[\"即投递的时间段\",{\"1\":{\"447\":1}}],[\"即在消费一个队列时\",{\"1\":{\"622\":1}}],[\"即在\",{\"1\":{\"430\":1}}],[\"即需要足够多的从节点存储了该消息后\",{\"1\":{\"373\":1}}],[\"即为重新调了一次pullmessageprocessor业务处理器的processrequest\",{\"1\":{\"340\":1}}],[\"即索引文件记录的强制刷盘时间来恢复\",{\"1\":{\"309\":1}}],[\"即使找不到订阅关系\",{\"1\":{\"690\":1}}],[\"即使消息端一直从mq读取消息\",{\"1\":{\"399\":1}}],[\"即使写入的数量不足flushconsumequeueleastpages\",{\"1\":{\"289\":1}}],[\"即使是保存到磁盘的消息\",{\"1\":{\"214\":1}}],[\"即每个文件大小相同的内存映射文件队列\",{\"1\":{\"266\":1}}],[\"即便消费组中有多个消费者都订阅同一\",{\"1\":{\"610\":1}}],[\"即便有小部分的副本仍然可用\",{\"1\":{\"236\":1}}],[\"即便主节点已经成功转移\",{\"1\":{\"134\":1}}],[\"即只可能处于alpha\",{\"1\":{\"223\":1}}],[\"即重启之后该队列还会存在\",{\"1\":{\"217\":1}}],[\"即保证组中活着的节点要么都收到消息要么都收不到\",{\"1\":{\"206\":1}}],[\"即接收生产者发布的消息\",{\"1\":{\"204\":1}}],[\"即\",{\"1\":{\"155\":1,\"386\":1,\"600\":1}}],[\"即可在收到消息时自动消费\",{\"1\":{\"637\":1}}],[\"即可解码出多条消息\",{\"1\":{\"564\":1}}],[\"即可\",{\"1\":{\"123\":1}}],[\"即返回true或false的函数\",{\"1\":{\"34\":1}}],[\"即ssh\",{\"1\":{\"21\":1}}],[\"必须向它发送一个消息\",{\"1\":{\"77\":1}}],[\"必须是一个字面数据类型\",{\"1\":{\"54\":1}}],[\"必须是一个原子\",{\"1\":{\"54\":1}}],[\"必须是一个能够得出位串的表达式\",{\"1\":{\"34\":1}}],[\"必须是一个能够得出列表的表达式\",{\"1\":{\"34\":1}}],[\"必须使用特殊的语法才能输入某些字符\",{\"1\":{\"28\":1}}],[\"其会生成如下七个\",{\"1\":{\"841\":1}}],[\"其支持多种消息过滤方式\",{\"1\":{\"823\":1}}],[\"其内用\",{\"1\":{\"675\":1}}],[\"其次这样还是又违反了cap中的a的设计\",{\"1\":{\"462\":1}}],[\"其必须有如下的特点\",{\"1\":{\"443\":1}}],[\"其对\",{\"1\":{\"406\":1}}],[\"其每次最多预分配\",{\"1\":{\"401\":1}}],[\"其\",{\"1\":{\"276\":1}}],[\"其格式和大小是固定的\",{\"1\":{\"275\":1}}],[\"其默认长度\",{\"1\":{\"261\":1}}],[\"其作用是通知\",{\"1\":{\"207\":1}}],[\"其可设置的值为\",{\"1\":{\"192\":1}}],[\"其他消费者会获取\",{\"1\":{\"735\":1}}],[\"其他消费者收到消费者数量变化请求时进行重平衡\",{\"1\":{\"656\":1}}],[\"其他线程都在等待锁释放\",{\"1\":{\"727\":1}}],[\"其他的版本已经跟不上时代了\",{\"1\":{\"593\":1}}],[\"其他请求类型由\",{\"1\":{\"464\":1}}],[\"其他逻辑有所省略\",{\"1\":{\"332\":1}}],[\"其他队列只会保存这条消息的引用\",{\"1\":{\"233\":1}}],[\"其他4个队列则是由erlang\",{\"1\":{\"223\":1}}],[\"其他故障期间花费7秒会恢复集群为可用状态\",{\"1\":{\"134\":1}}],[\"其他环境配置\",{\"1\":{\"122\":1}}],[\"其实在最初还实现了另一种方案\",{\"1\":{\"450\":1}}],[\"其实作用不同\",{\"1\":{\"409\":1}}],[\"其实就是文件预分配的请求\",{\"1\":{\"401\":1}}],[\"其实现了一个新的定时消息\",{\"1\":{\"368\":1}}],[\"其实是\",{\"1\":{\"300\":1}}],[\"其实是指\",{\"1\":{\"122\":1}}],[\"其实这个值在消息被保存到\",{\"1\":{\"285\":1}}],[\"其实同步保存和异步保存消息的逻辑差不多\",{\"1\":{\"251\":1}}],[\"其实\",{\"1\":{\"225\":1,\"261\":1}}],[\"其实只是一个列表的简写\",{\"1\":{\"28\":1}}],[\"其中重平衡是消费者开始消费的起点\",{\"1\":{\"645\":1}}],[\"其中启动参数设置脚本如下\",{\"1\":{\"600\":1}}],[\"其中生产者负责发送消息\",{\"1\":{\"550\":1}}],[\"其中包含有消费者名称经过\",{\"1\":{\"843\":1}}],[\"其中包含每个\",{\"1\":{\"549\":1}}],[\"其中包含该\",{\"1\":{\"470\":1}}],[\"其中key表示accesskey\",{\"1\":{\"517\":1}}],[\"其中key表示acl配置文件的绝对路径\",{\"1\":{\"517\":2}}],[\"其中key是string类型表示accesskey\",{\"1\":{\"517\":1}}],[\"其中红色线为初始化的方法调用链\",{\"1\":{\"510\":1,\"517\":1}}],[\"其中数据内容如下\",{\"1\":{\"464\":1}}],[\"其中华为云\",{\"1\":{\"442\":1}}],[\"其中主要包含了复杂的\",{\"1\":{\"416\":1}}],[\"其中保存有消息在\",{\"1\":{\"271\":1}}],[\"其中4\",{\"1\":{\"249\":1}}],[\"其中400表示每个进程初始的信用值\",{\"1\":{\"151\":1}}],[\"其中一个broker节点定义为存储消息轨迹数据的服务端\",{\"1\":{\"524\":1}}],[\"其中一个在另外节点的从副本会被选举成为主副本\",{\"1\":{\"228\":1}}],[\"其中一个从队列会晋升成主队列\",{\"1\":{\"226\":1}}],[\"其中一个会重新变为mirror\",{\"1\":{\"192\":1}}],[\"其中只有主节点向外提供服务\",{\"1\":{\"182\":1}}],[\"其中\",{\"1\":{\"177\":1,\"275\":1,\"276\":1,\"335\":1,\"370\":1,\"389\":1,\"390\":2,\"410\":1,\"450\":1,\"464\":1,\"481\":1,\"558\":1,\"575\":1,\"592\":1,\"629\":1,\"636\":1,\"765\":1,\"767\":1,\"820\":1,\"835\":1,\"838\":1,\"841\":1}}],[\"其中self\",{\"1\":{\"159\":1}}],[\"其中mainloop会调用recvloop函数\",{\"1\":{\"158\":1}}],[\"其中changecost\",{\"1\":{\"135\":1}}],[\"其中参数是对象\",{\"1\":{\"116\":1}}],[\"其中参数是普通变量\",{\"1\":{\"116\":1}}],[\"其中每一行都是\",{\"1\":{\"103\":1}}],[\"其中的每个\",{\"1\":{\"646\":1}}],[\"其中的多个\",{\"1\":{\"594\":1}}],[\"其中的\",{\"1\":{\"34\":2,\"537\":1,\"837\":1}}],[\"其一是将调用包裹在`try\",{\"1\":{\"43\":1,\"44\":1}}],[\"从队列中弹出\",{\"1\":{\"876\":1}}],[\"从队列中移除该投递任务\",{\"1\":{\"381\":1}}],[\"从队列头开始扫描\",{\"1\":{\"876\":1}}],[\"从队列偏移量表中查询当前队列偏移量\",{\"1\":{\"816\":1}}],[\"从原始消息属性中获取分发的队列列表\",{\"1\":{\"816\":1}}],[\"从内存中\",{\"1\":{\"797\":1}}],[\"从内存中移除\",{\"1\":{\"797\":1}}],[\"从内存中移除保存到磁盘的\",{\"1\":{\"783\":1}}],[\"从内存中移除该\",{\"1\":{\"664\":1,\"744\":1}}],[\"从请求头解析和构造\",{\"1\":{\"780\":1}}],[\"从重试\",{\"1\":{\"777\":1}}],[\"从图上可以看见\",{\"1\":{\"771\":1}}],[\"从图中可以看出实验持续10分钟\",{\"1\":{\"134\":1}}],[\"从锁容器中获取消息队列消费锁\",{\"1\":{\"750\":1}}],[\"从锁容器中移除\",{\"1\":{\"734\":1}}],[\"从处理队列中取一批\",{\"1\":{\"750\":1}}],[\"从处理队列中取一批消息\",{\"1\":{\"738\":1}}],[\"从处理队列中移除这批已经处理过的消息\",{\"1\":{\"708\":1}}],[\"从属性中获取\",{\"1\":{\"708\":1}}],[\"从属性中恢复它的真实\",{\"1\":{\"377\":1}}],[\"从拉取到的消息保存的处理队列获取消息\",{\"1\":{\"699\":1}}],[\"从拉取请求队列中获取一个拉取请求\",{\"1\":{\"688\":1}}],[\"从拉取请求中获取处理队列\",{\"1\":{\"679\":1}}],[\"从broker拉取消息\",{\"1\":{\"691\":1}}],[\"从broker拉取完成的回调函数\",{\"1\":{\"690\":1}}],[\"从filterserver上拉取消息\",{\"1\":{\"691\":1}}],[\"从那个消费队列拉取消息\",{\"1\":{\"690\":1}}],[\"从服务端拉取\",{\"1\":{\"690\":1}}],[\"从消费队列扩展存储中取出这个消息的布隆过滤器产生的二进制数组\",{\"1\":{\"835\":1}}],[\"从消费队列中读取消息\",{\"1\":{\"287\":1,\"694\":1}}],[\"从消息\",{\"1\":{\"852\":1}}],[\"从消息队列中\",{\"1\":{\"790\":1}}],[\"从消息属性中获取它真正的\",{\"1\":{\"738\":1}}],[\"从消息存储\",{\"1\":{\"708\":1}}],[\"从消息存储中查询需要拉取的一批消息\",{\"1\":{\"684\":1}}],[\"从消息存储查询消息\",{\"1\":{\"683\":1}}],[\"从待消费消息数量\",{\"1\":{\"679\":1}}],[\"从阻塞队列中获取拉取请求之后\",{\"1\":{\"679\":1}}],[\"从客户端缓存表中获取\",{\"1\":{\"663\":1}}],[\"从订阅信息中找到所有的\",{\"1\":{\"662\":1}}],[\"从本地缓存中获取该\",{\"1\":{\"657\":1}}],[\"从本地缓存中获取该消费者订阅的所有\",{\"1\":{\"657\":1}}],[\"从本地缓存中获取\",{\"1\":{\"650\":1}}],[\"从左上角第一个方框开始看\",{\"1\":{\"624\":1}}],[\"从第三个等级开始\",{\"1\":{\"620\":1}}],[\"从追加队列中获取一批待发送的消息轨迹数据\",{\"1\":{\"541\":1}}],[\"从轨迹上下文获取消费前的轨迹数据\",{\"1\":{\"540\":1}}],[\"从集群信息表中移除该\",{\"1\":{\"492\":1}}],[\"从路由表\",{\"1\":{\"477\":1,\"493\":1}}],[\"从nameserver更新\",{\"1\":{\"470\":1}}],[\"从存储中查询要被拉取的消息返回相应给消费者\",{\"1\":{\"669\":1}}],[\"从存储中查询消息\",{\"1\":{\"334\":1}}],[\"从存储和投递两个方面详解了华为云\",{\"1\":{\"456\":1}}],[\"从投递位移之后开始扫描消息\",{\"1\":{\"452\":1}}],[\"从定时消息存储中查出消息\",{\"1\":{\"450\":1}}],[\"从中可以学习和借鉴需多东西\",{\"1\":{\"445\":1}}],[\"从中可以看出队列的主节点\",{\"1\":{\"188\":1}}],[\"从火焰图上可以看出\",{\"1\":{\"431\":1}}],[\"从火焰图上看出\",{\"1\":{\"416\":1,\"428\":1}}],[\"从火焰图中可以看到\",{\"1\":{\"416\":1}}],[\"从耗时较多的方法想办法入手优化\",{\"1\":{\"407\":1}}],[\"从磁盘消息存储中根据逻辑偏移量查询消息\",{\"1\":{\"790\":1}}],[\"从磁盘中根据起始偏移量查询一批消息\",{\"1\":{\"778\":1}}],[\"从磁盘中加载offsettable\",{\"1\":{\"360\":1,\"364\":1}}],[\"从磁盘重新加载数据至内存\",{\"1\":{\"402\":1}}],[\"从store中获取该队列消息的最大offset\",{\"1\":{\"345\":1}}],[\"从store中获取队列的最大偏移量\",{\"1\":{\"343\":1}}],[\"从该索引文件中根据key查找offsets\",{\"1\":{\"317\":1}}],[\"从该索引文件中根据\",{\"1\":{\"310\":1,\"317\":1}}],[\"从该索引文件到消息保存时间的时间差\",{\"1\":{\"307\":1}}],[\"从后往前遍历indexfile\",{\"1\":{\"314\":1}}],[\"从后往前遍历\",{\"1\":{\"309\":1}}],[\"从indexfile中查找消息\",{\"1\":{\"309\":1,\"314\":2}}],[\"从倒数第三个文件开始恢复\",{\"1\":{\"291\":1}}],[\"从倒数第三个文件开始往后遍历\",{\"1\":{\"273\":1,\"279\":1,\"291\":1}}],[\"从上一步拉取消息到消费者后\",{\"1\":{\"699\":1}}],[\"从上一条消息的结束位置开始获取下一条消息\",{\"1\":{\"282\":1}}],[\"从上述结果能够看出\",{\"1\":{\"135\":1}}],[\"从这当中可以学到的是在打印日志时需要谨慎\",{\"1\":{\"242\":1}}],[\"从副本不与客户端进行交互\",{\"1\":{\"228\":1}}],[\"从rabbitmq的backing\",{\"1\":{\"223\":1}}],[\"从q1到q4\",{\"1\":{\"223\":1}}],[\"从镜像队列中消费的客户端可能希望知道他们所消费的队列已经失败转移\",{\"1\":{\"198\":1}}],[\"从节点向\",{\"1\":{\"490\":1}}],[\"从节点上想要同步\",{\"1\":{\"450\":1}}],[\"从节点的\",{\"0\":{\"430\":1}}],[\"从节点与主节点完成数据同步\",{\"1\":{\"192\":1}}],[\"从节点晋升策略\",{\"0\":{\"192\":1}}],[\"从节点和镜像策略\",{\"1\":{\"188\":1}}],[\"从节点会准确地按照主节点执行命令的顺序执行动作\",{\"1\":{\"182\":1}}],[\"从节点会提升为主节点继续向外提供服务\",{\"1\":{\"181\":1}}],[\"从节点仅仅接收主节点发送的消息\",{\"1\":{\"182\":1}}],[\"从web\",{\"1\":{\"146\":1}}],[\"从全链路压测\",{\"1\":{\"126\":1}}],[\"从而进行消息的投递和消费\",{\"1\":{\"461\":1}}],[\"从而绕过了排序这个问题\",{\"1\":{\"445\":1}}],[\"从而在后续实际使用这个文件时提升读写性能\",{\"1\":{\"402\":1}}],[\"从而达到在一个节点宕机时\",{\"1\":{\"225\":1}}],[\"从而实现容错行为\",{\"1\":{\"101\":1}}],[\"从而停止系统\",{\"1\":{\"74\":1}}],[\"从\",{\"1\":{\"91\":1,\"147\":2,\"150\":1,\"154\":1,\"253\":1,\"287\":1,\"332\":1,\"345\":1,\"365\":1,\"377\":1,\"381\":1,\"474\":3,\"477\":1,\"492\":3,\"493\":1,\"595\":1,\"637\":1,\"639\":1,\"640\":2,\"642\":1,\"643\":1,\"663\":1,\"689\":1,\"708\":1,\"715\":1,\"799\":1,\"841\":1,\"844\":1,\"852\":1}}],[\"从列表a中移除列表b\",{\"1\":{\"62\":1}}],[\"从列表\",{\"1\":{\"34\":1}}],[\"从入门到精通\",{\"0\":{\"1\":1},\"1\":{\"17\":1}}],[\"由消费者向\",{\"1\":{\"732\":1}}],[\"由抽象类直接实现\",{\"1\":{\"654\":1}}],[\"由启动脚本调用\",{\"1\":{\"467\":1}}],[\"由前文所说\",{\"1\":{\"448\":1}}],[\"由异步刷盘线程写入\",{\"1\":{\"403\":1}}],[\"由用户配置开启\",{\"1\":{\"403\":1}}],[\"由run\",{\"1\":{\"361\":1}}],[\"由一个单独的线程flushconsumequeueservice周期性检查和刷盘\",{\"1\":{\"278\":1}}],[\"由一个单独的线程进行持久化\",{\"1\":{\"272\":1}}],[\"由于拿不到该队列的锁\",{\"1\":{\"745\":1}}],[\"由于\",{\"1\":{\"707\":1,\"708\":1,\"723\":1,\"760\":1}}],[\"由于并发关系\",{\"1\":{\"690\":1}}],[\"由于拉模式和推模式消费者的启动流程大致相同\",{\"1\":{\"640\":1}}],[\"由于需要支持拉和推两种消费模式\",{\"1\":{\"636\":1}}],[\"由于消息轨迹数据没有普通消息那样强的实时性要求\",{\"1\":{\"530\":1}}],[\"由于消息队列需要高性能\",{\"1\":{\"523\":1}}],[\"由于消费者是单线程\",{\"1\":{\"244\":1}}],[\"由于支持了从多文件加载权限配置\",{\"1\":{\"517\":1}}],[\"由于每个队列每次拉取所需要的元信息几乎没什么变化\",{\"1\":{\"675\":1}}],[\"由于每个\",{\"1\":{\"445\":1}}],[\"由于每个索引项的大小是固定的\",{\"1\":{\"271\":1}}],[\"由于大部分情况下都用不到\",{\"1\":{\"423\":1}}],[\"由于各种指令对应的\",{\"1\":{\"410\":1}}],[\"由于它里面保存的每个\",{\"1\":{\"398\":1}}],[\"由于当前代码的复杂性\",{\"1\":{\"256\":1}}],[\"由于要保证消息保存到\",{\"1\":{\"253\":1}}],[\"由于使用了一种低效的消息复制方法\",{\"1\":{\"226\":1}}],[\"由于所有节点组成了一个循环链表\",{\"1\":{\"206\":1}}],[\"由于某些数据可能天生是短暂的或对时间非常敏感\",{\"1\":{\"195\":1}}],[\"由于分布式系统的复杂性\",{\"1\":{\"133\":1}}],[\"由于可能需要在\",{\"1\":{\"7\":1}}],[\"由此可以引出\",{\"1\":{\"498\":1}}],[\"由此可知\",{\"1\":{\"106\":1}}],[\"由此拉开了混沌工程学的序幕\",{\"1\":{\"126\":1}}],[\"由\",{\"1\":{\"34\":1,\"36\":1,\"306\":1,\"386\":1,\"397\":1,\"472\":1,\"487\":1,\"535\":1,\"556\":1,\"708\":1,\"732\":1,\"770\":1,\"810\":1,\"841\":1,\"851\":1}}],[\"循环执行发送\",{\"1\":{\"570\":1}}],[\"循环扫描这个\",{\"1\":{\"445\":1}}],[\"循环等待\",{\"1\":{\"435\":1}}],[\"循环获取队列中第一个投递任务\",{\"1\":{\"381\":1}}],[\"循环或者是周期性定时任务来周期执行\",{\"1\":{\"361\":1}}],[\"循环\",{\"1\":{\"32\":1}}],[\"没有更新slave的消费队列时间戳到checkpoint中的逻辑\",{\"1\":{\"817\":1}}],[\"没有消费到新的消息\",{\"1\":{\"798\":1}}],[\"没有消费到新消息\",{\"1\":{\"798\":1}}],[\"没有查询到消息的次数\",{\"1\":{\"798\":1}}],[\"没有拉取到消息\",{\"1\":{\"789\":1,\"790\":1}}],[\"没有满\",{\"1\":{\"789\":1}}],[\"没有主动解锁\",{\"1\":{\"732\":1}}],[\"没有匹配的消息\",{\"1\":{\"695\":1}}],[\"没有新消息\",{\"1\":{\"695\":1}}],[\"没有上报心跳\",{\"1\":{\"474\":1}}],[\"没有收到心跳\",{\"1\":{\"465\":1}}],[\"没有加锁而是采用\",{\"1\":{\"435\":1}}],[\"没有拷贝和新对象的创建\",{\"1\":{\"414\":1}}],[\"没有决定性优势\",{\"1\":{\"413\":1}}],[\"没有别的线程跟它竞争\",{\"1\":{\"244\":1}}],[\"没有了同步问题\",{\"1\":{\"229\":1}}],[\"没有垃圾收集机制\",{\"1\":{\"97\":1}}],[\"没有\",{\"1\":{\"32\":1}}],[\"括号内的东西就是返回值\",{\"1\":{\"31\":1}}],[\"返回过滤数据的\",{\"1\":{\"847\":1}}],[\"返回全部队列\",{\"1\":{\"787\":1}}],[\"返回该队列中待\",{\"1\":{\"790\":1}}],[\"返回该\",{\"1\":{\"786\":1}}],[\"返回锁定成功的队列集合\",{\"1\":{\"746\":1}}],[\"返回成功并丢弃消息\",{\"1\":{\"718\":1}}],[\"返回错误\",{\"1\":{\"718\":1}}],[\"返回移除这批消息的最小的偏移量\",{\"1\":{\"708\":1}}],[\"返回查询结果\",{\"1\":{\"684\":1}}],[\"返回发送结果\",{\"1\":{\"547\":3,\"570\":1}}],[\"返回包含\",{\"1\":{\"493\":1}}],[\"返回包含系统里所有注册进程的列表\",{\"1\":{\"84\":1}}],[\"返回路由信息\",{\"0\":{\"477\":1}}],[\"返回给消费者\",{\"1\":{\"839\":1}}],[\"返回给客户端\",{\"1\":{\"470\":1}}],[\"返回给consumer\",{\"1\":{\"340\":1}}],[\"返回响应给\",{\"1\":{\"334\":1}}],[\"返回字典里面所有值为\",{\"1\":{\"67\":1}}],[\"返回整个进程字典\",{\"1\":{\"67\":1}}],[\"返回两个列表\",{\"1\":{\"39\":1}}],[\"返回由列表`l`中所有满足`p\",{\"1\":{\"37\":1}}],[\"返回\",{\"1\":{\"31\":1,\"477\":1,\"493\":1,\"572\":1,\"690\":1,\"778\":1,\"847\":2}}],[\"标记该\",{\"1\":{\"796\":1}}],[\"标志位\",{\"1\":{\"691\":1}}],[\"标准的erlang分发套装包含otp库\",{\"1\":{\"112\":1}}],[\"标准库高阶函数\",{\"1\":{\"31\":1}}],[\"标注了\",{\"1\":{\"9\":1}}],[\"操作的开销\",{\"1\":{\"245\":1}}],[\"操作的一些最佳实践\",{\"1\":{\"16\":1}}],[\"操作命令从\",{\"1\":{\"206\":1}}],[\"操作\",{\"1\":{\"154\":1,\"276\":1,\"419\":1,\"420\":1}}],[\"操作系统不会实际分配物理内存\",{\"1\":{\"402\":1}}],[\"操作系统才会清理掉一部分\",{\"1\":{\"399\":1}}],[\"操作系统并不会立刻就清除这个\",{\"1\":{\"399\":1}}],[\"操作系统把数据从文件中复制到\",{\"1\":{\"399\":1}}],[\"操作系统会先把数据写入到内存中的\",{\"1\":{\"399\":1}}],[\"操作系统\",{\"1\":{\"127\":1}}],[\"操作符发送消息\",{\"1\":{\"80\":1}}],[\"操作符优先级\",{\"0\":{\"66\":1}}],[\"操作其他函数的函数被称为高阶函数\",{\"1\":{\"31\":1}}],[\"情况分析函数\",{\"1\":{\"30\":1}}],[\"中终于开源了支持任意时间的定时消息\",{\"1\":{\"872\":1}}],[\"中只支持通过设定延迟等级来支持\",{\"1\":{\"872\":1}}],[\"中解码消息属性\",{\"1\":{\"852\":1}}],[\"中解析原\",{\"1\":{\"799\":1}}],[\"中解析数据并分发请求\",{\"1\":{\"336\":1}}],[\"中取出消息\",{\"1\":{\"852\":1}}],[\"中拿到的\",{\"1\":{\"841\":1}}],[\"中先后被调用\",{\"1\":{\"838\":1}}],[\"中各个处理器处理\",{\"1\":{\"820\":1}}],[\"中断消费\",{\"1\":{\"798\":2}}],[\"中断而再次读取磁盘\",{\"1\":{\"399\":1}}],[\"中消息\",{\"1\":{\"797\":1}}],[\"中消息顺序一致\",{\"1\":{\"450\":1}}],[\"中被\",{\"1\":{\"796\":1}}],[\"中找\",{\"1\":{\"782\":1}}],[\"中找到消息并消费\",{\"1\":{\"356\":1}}],[\"中引入了的轻量化客户端就用到了\",{\"1\":{\"769\":1}}],[\"中引入了一种新的消费模式\",{\"1\":{\"765\":1}}],[\"中队列数量的限制\",{\"1\":{\"769\":1}}],[\"中可以注册多个生产者和消费者\",{\"1\":{\"755\":1}}],[\"中准备锁定请求\",{\"1\":{\"734\":1}}],[\"中就需要有相应的操作以锁定消费队列\",{\"1\":{\"723\":1}}],[\"中移除\",{\"1\":{\"797\":1}}],[\"中移除这批已经处理过的消息\",{\"1\":{\"715\":1}}],[\"中移除该\",{\"1\":{\"474\":1,\"492\":1}}],[\"中加载整个消息体\",{\"1\":{\"694\":1}}],[\"中拉取到的消息会先存入\",{\"1\":{\"689\":1}}],[\"中拉取官方镜像\",{\"1\":{\"592\":1}}],[\"中不断获取消费请求\",{\"1\":{\"708\":1}}],[\"中不包含\",{\"1\":{\"664\":1,\"744\":1}}],[\"中不会有消息被消费\",{\"1\":{\"664\":1,\"744\":1}}],[\"中不是连续存储的\",{\"1\":{\"267\":1}}],[\"中重平衡策略\",{\"1\":{\"658\":1}}],[\"中保存的消息内容进行过滤\",{\"1\":{\"852\":1}}],[\"中保存的消息在\",{\"1\":{\"398\":1}}],[\"中保存和指定\",{\"1\":{\"689\":1}}],[\"中保存了消费者负载的消息队列\",{\"1\":{\"649\":1}}],[\"中弹出拉取请求\",{\"1\":{\"624\":1}}],[\"中官方上传的镜像\",{\"1\":{\"599\":1}}],[\"中选择\",{\"1\":{\"592\":1}}],[\"中选择一个可用的\",{\"1\":{\"572\":1}}],[\"中删除一条消息\",{\"1\":{\"585\":1}}],[\"中创建\",{\"1\":{\"581\":1}}],[\"中创建一个进程\",{\"1\":{\"80\":1}}],[\"中执行\",{\"1\":{\"559\":1}}],[\"中执行的\",{\"1\":{\"541\":1}}],[\"中默认的生产者实现\",{\"1\":{\"556\":1}}],[\"中进行存储\",{\"1\":{\"541\":1}}],[\"中启用消息轨迹功能\",{\"1\":{\"525\":1}}],[\"中启动\",{\"1\":{\"503\":1}}],[\"中字段的含义\",{\"1\":{\"517\":1}}],[\"中设置该\",{\"1\":{\"499\":1}}],[\"中角色\",{\"1\":{\"498\":1}}],[\"中定义了\",{\"1\":{\"498\":1}}],[\"中支持的\",{\"1\":{\"498\":1}}],[\"中统计\",{\"1\":{\"487\":1}}],[\"中路由信息的结构\",{\"1\":{\"483\":1}}],[\"中也有定时器\",{\"1\":{\"465\":1}}],[\"中也有若干个\",{\"1\":{\"155\":2}}],[\"中主要有\",{\"1\":{\"656\":1}}],[\"中主要指对\",{\"1\":{\"498\":1}}],[\"中主要存储的数据\",{\"1\":{\"464\":1}}],[\"中主从复制和同步刷盘的原理\",{\"1\":{\"243\":1}}],[\"中存储的数据\",{\"1\":{\"811\":1}}],[\"中存储的逻辑下标含义相同\",{\"1\":{\"307\":1}}],[\"中存储\",{\"1\":{\"464\":1}}],[\"中据说也是使用\",{\"1\":{\"462\":1}}],[\"中文件存储为内存映射文件\",{\"1\":{\"447\":1}}],[\"中将消息全部信息查出来\",{\"1\":{\"447\":1}}],[\"中将采用这种\",{\"1\":{\"293\":1}}],[\"中所说的消费速度所做的另一个改动\",{\"1\":{\"433\":1}}],[\"中所有的\",{\"1\":{\"465\":1}}],[\"中所有定时任务都是由一个工作线程单线程处理的\",{\"1\":{\"372\":1}}],[\"中所有消息的索引项\",{\"1\":{\"275\":1}}],[\"中所有\",{\"1\":{\"267\":1}}],[\"中直接操作\",{\"1\":{\"414\":1}}],[\"中转一下\",{\"1\":{\"414\":1}}],[\"中用的很少\",{\"1\":{\"422\":1}}],[\"中用\",{\"1\":{\"414\":1}}],[\"中多余的拷贝和对象创建\",{\"1\":{\"414\":1}}],[\"中集中记录\",{\"1\":{\"406\":1}}],[\"中继续把数据读出来\",{\"1\":{\"399\":1}}],[\"中没有\",{\"1\":{\"799\":1,\"800\":1}}],[\"中没有数据\",{\"1\":{\"399\":1}}],[\"中没有一个\",{\"1\":{\"155\":1}}],[\"中来读取数据\",{\"1\":{\"399\":1}}],[\"中获取过滤数据\",{\"1\":{\"844\":1}}],[\"中获取过滤信息\",{\"1\":{\"838\":1}}],[\"中获取编译好的\",{\"1\":{\"841\":1}}],[\"中获取顺序消息相关配置\",{\"1\":{\"493\":1}}],[\"中获取顺序消息相关的配置\",{\"1\":{\"477\":1,\"493\":1}}],[\"中获取信息\",{\"1\":{\"477\":1,\"493\":1}}],[\"中获取远端的地址\",{\"1\":{\"416\":1}}],[\"中获取的延迟等级对应的\",{\"1\":{\"365\":1}}],[\"中获取该队列消息的最大offset\",{\"1\":{\"345\":1}}],[\"中替换成了\",{\"1\":{\"360\":1}}],[\"中检查消息属性中delaylevel\",{\"1\":{\"359\":1,\"363\":1}}],[\"中是否有到期消息\",{\"1\":{\"361\":1}}],[\"中是否有到期的消息\",{\"1\":{\"354\":1}}],[\"中是顺序的\",{\"1\":{\"253\":1}}],[\"中为了支持\",{\"1\":{\"293\":1}}],[\"中调用\",{\"1\":{\"288\":1,\"843\":1}}],[\"中查找\",{\"1\":{\"773\":1,\"783\":1}}],[\"中查出该消息的完整信息\",{\"1\":{\"377\":1}}],[\"中查出索引项\",{\"1\":{\"287\":2,\"694\":1}}],[\"中查询出发回的消息\",{\"1\":{\"708\":1}}],[\"中查询出消息\",{\"1\":{\"271\":1,\"302\":1}}],[\"中查询消息完整信息\",{\"1\":{\"381\":1}}],[\"中查询消息\",{\"1\":{\"298\":1,\"306\":1,\"307\":1,\"332\":1,\"388\":1,\"398\":1,\"684\":1}}],[\"中了\",{\"1\":{\"285\":1}}],[\"中扫描新的消息\",{\"1\":{\"281\":1}}],[\"中有\",{\"1\":{\"541\":1,\"798\":1}}],[\"中有一个码表\",{\"1\":{\"782\":1}}],[\"中有一个客户端实例的引用\",{\"1\":{\"638\":1}}],[\"中有一个\",{\"1\":{\"508\":1,\"514\":1}}],[\"中有一个定时任务线程\",{\"1\":{\"474\":1}}],[\"中有一个或者多个\",{\"1\":{\"155\":1}}],[\"中有数据\",{\"1\":{\"399\":1}}],[\"中有如下这些保存消息的方法\",{\"1\":{\"251\":1}}],[\"中包含\",{\"1\":{\"876\":1}}],[\"中包含了编译好的过滤表达式\",{\"1\":{\"837\":1}}],[\"中包含了普通的\",{\"1\":{\"205\":1}}],[\"中包含两个消息\",{\"1\":{\"419\":1}}],[\"中包含重复代码的\",{\"0\":{\"251\":1}}],[\"中做了交换操作\",{\"1\":{\"245\":1}}],[\"中发布了新的\",{\"1\":{\"208\":1}}],[\"中由工作线程消费\",{\"1\":{\"534\":1}}],[\"中由\",{\"1\":{\"205\":1}}],[\"中添加\",{\"1\":{\"177\":1}}],[\"中使用多种进程来处理消息\",{\"1\":{\"147\":1}}],[\"中\",{\"1\":{\"146\":1,\"155\":1,\"156\":1,\"206\":1,\"247\":1,\"256\":1,\"258\":2,\"261\":1,\"267\":1,\"275\":1,\"276\":2,\"332\":1,\"335\":1,\"336\":1,\"356\":1,\"396\":1,\"399\":1,\"400\":1,\"403\":1,\"417\":1,\"435\":1,\"445\":3,\"450\":3,\"469\":1,\"470\":1,\"472\":1,\"476\":1,\"530\":1,\"532\":1,\"541\":1,\"547\":1,\"614\":1,\"620\":1,\"624\":1,\"638\":1,\"640\":1,\"675\":1,\"708\":2,\"717\":1,\"773\":3,\"777\":1,\"798\":1,\"810\":1,\"814\":2,\"820\":1,\"838\":1,\"839\":2,\"841\":1,\"843\":2,\"851\":2,\"876\":1}}],[\"中间层是执行层\",{\"1\":{\"130\":1}}],[\"中导入\",{\"1\":{\"41\":1}}],[\"中提取\",{\"1\":{\"34\":1}}],[\"中编译\",{\"1\":{\"30\":1}}],[\"中的类名为\",{\"1\":{\"820\":1}}],[\"中的拉取方法实现\",{\"1\":{\"675\":1}}],[\"中的队列\",{\"1\":{\"708\":1}}],[\"中的队列负载机制将一个\",{\"1\":{\"617\":1}}],[\"中的队列如何分配给消费者的问题\",{\"1\":{\"616\":1}}],[\"中的所有消息\",{\"1\":{\"616\":1,\"800\":1}}],[\"中的一个\",{\"1\":{\"615\":1}}],[\"中的镜像地址\",{\"1\":{\"599\":1}}],[\"中的镜像地址改为了官方镜像地址\",{\"1\":{\"595\":1}}],[\"中的镜像\",{\"1\":{\"599\":1}}],[\"中的概念\",{\"1\":{\"498\":1}}],[\"中的路由表\",{\"1\":{\"491\":1}}],[\"中的路由信息主要指的是前面说到的\",{\"1\":{\"469\":1}}],[\"中的几个路由信息表\",{\"1\":{\"473\":1}}],[\"中的任务拿出来放到下一\",{\"1\":{\"451\":1}}],[\"中的消息类主要有\",{\"1\":{\"555\":1}}],[\"中的消息也遵循先生产先消费\",{\"1\":{\"548\":1}}],[\"中的消息\",{\"1\":{\"450\":1,\"773\":1,\"798\":2}}],[\"中的消息都是按照消息产生的时间顺序发送的\",{\"1\":{\"356\":1}}],[\"中的对应\",{\"1\":{\"445\":1}}],[\"中的反向\",{\"0\":{\"408\":1}}],[\"中的逻辑\",{\"1\":{\"377\":1}}],[\"中的逻辑偏移量\",{\"1\":{\"271\":1,\"285\":1}}],[\"中的绝对物理偏移量\",{\"1\":{\"300\":1}}],[\"中的最新刷盘时间\",{\"1\":{\"289\":1}}],[\"中的偏移量\",{\"1\":{\"302\":1,\"307\":1,\"356\":1,\"397\":1}}],[\"中的偏移量和消息大小\",{\"1\":{\"271\":1}}],[\"中的偏移量即可找到消息保存的位置\",{\"1\":{\"267\":1}}],[\"中的索引项\",{\"1\":{\"271\":1}}],[\"中的位置去\",{\"1\":{\"398\":1}}],[\"中的位置以便消费\",{\"1\":{\"387\":1}}],[\"中的位置\",{\"1\":{\"271\":1}}],[\"中的物理偏移量\",{\"1\":{\"269\":1,\"298\":1,\"306\":1,\"307\":1,\"388\":1}}],[\"中的每个消息数据都会在磁盘上存储\",{\"1\":{\"810\":1}}],[\"中的每个\",{\"1\":{\"269\":1,\"611\":1}}],[\"中的起始物理偏移量offset\",{\"1\":{\"267\":1}}],[\"中的属性哈希码进行过滤\",{\"1\":{\"847\":1,\"852\":1}}],[\"中的属性\",{\"1\":{\"262\":1}}],[\"中的过程\",{\"1\":{\"261\":1}}],[\"中的数据写入\",{\"1\":{\"285\":1}}],[\"中的数据\",{\"1\":{\"250\":1}}],[\"中的\",{\"1\":{\"23\":1,\"257\":1,\"285\":1,\"400\":1,\"461\":1,\"469\":1,\"498\":1,\"599\":1,\"614\":1,\"640\":1,\"651\":1,\"755\":1,\"782\":1,\"796\":1}}],[\"子句以分号隔开\",{\"1\":{\"30\":1}}],[\"函数中先解析命令行参数\",{\"1\":{\"467\":1,\"480\":1}}],[\"函数触发启动流程\",{\"1\":{\"467\":1}}],[\"函数返回一个pid\",{\"1\":{\"80\":1}}],[\"函数引用\",{\"0\":{\"60\":1}}],[\"函数多半应该返回\",{\"1\":{\"46\":1}}],[\"函数`rr`\",{\"1\":{\"41\":1}}],[\"函数\",{\"1\":{\"33\":1,\"74\":2,\"80\":1}}],[\"函数有两个子句\",{\"1\":{\"30\":1}}],[\"函数定义\",{\"1\":{\"30\":1}}],[\"函数固然也可以\",{\"1\":{\"2\":1}}],[\"个固定延迟时间\",{\"1\":{\"872\":1}}],[\"个固定延迟时间的延迟等级\",{\"1\":{\"445\":1}}],[\"个配置项注册到配置类中\",{\"1\":{\"854\":1}}],[\"个字节的存储位置用于存储消息的\",{\"1\":{\"839\":1}}],[\"个消费者共享\",{\"1\":{\"775\":1}}],[\"个消费者同时消费\",{\"1\":{\"767\":1}}],[\"个消费者同时进行消费\",{\"1\":{\"723\":1}}],[\"个消费线程\",{\"1\":{\"624\":1}}],[\"个触发点\",{\"1\":{\"656\":1}}],[\"个步骤\",{\"1\":{\"606\":1,\"676\":1,\"772\":1}}],[\"个主节点\",{\"1\":{\"595\":1}}],[\"个主副本\",{\"1\":{\"228\":1}}],[\"个主副本和\",{\"1\":{\"228\":1}}],[\"个工作线程\",{\"1\":{\"541\":1}}],[\"个定时任务\",{\"1\":{\"467\":1,\"481\":1}}],[\"个模块\",{\"1\":{\"464\":1}}],[\"个索引项加载进内存\",{\"1\":{\"451\":1}}],[\"个等级改为定时任意时间\",{\"1\":{\"445\":1}}],[\"个等级之外的延迟时间\",{\"1\":{\"445\":1}}],[\"个条件之一就会触发删除\",{\"1\":{\"390\":1}}],[\"个文件\",{\"1\":{\"386\":1,\"390\":2,\"401\":1}}],[\"个延迟等级的定时消息\",{\"1\":{\"875\":1}}],[\"个延迟等级的定时消息扫描和投递任务都是由一个\",{\"1\":{\"372\":1}}],[\"个延迟等级\",{\"1\":{\"445\":1}}],[\"个延迟等级发送延迟消息\",{\"1\":{\"372\":1}}],[\"个操作系统页\",{\"1\":{\"278\":1,\"289\":1}}],[\"个对象和\",{\"1\":{\"261\":1}}],[\"个线程同时进行消费\",{\"1\":{\"723\":1}}],[\"个线程池\",{\"1\":{\"541\":1}}],[\"个线程\",{\"1\":{\"253\":1,\"575\":1,\"675\":1,\"685\":1,\"699\":1,\"707\":1,\"737\":1}}],[\"个线程是比较合理的数值\",{\"1\":{\"253\":1}}],[\"个队列最多可以被\",{\"1\":{\"767\":1}}],[\"个队列每个都设置成\",{\"1\":{\"233\":1}}],[\"个队列\",{\"1\":{\"233\":1,\"426\":1,\"707\":1,\"723\":1,\"787\":1,\"876\":1}}],[\"个从副本\",{\"1\":{\"228\":1}}],[\"个节点或\",{\"1\":{\"195\":1}}],[\"个节点集群中的\",{\"1\":{\"195\":2}}],[\"个节点\",{\"1\":{\"195\":2}}],[\"个\",{\"1\":{\"188\":1,\"354\":1,\"356\":1,\"386\":2,\"430\":4,\"435\":1,\"445\":1,\"464\":1,\"469\":1,\"555\":1,\"615\":1,\"620\":1,\"684\":1,\"873\":1}}],[\"个参数的函数\",{\"1\":{\"30\":1}}],[\"个测试陷阱\",{\"1\":{\"15\":1}}],[\"句号\",{\"1\":{\"30\":1}}],[\"以订阅一组路径的\",{\"1\":{\"810\":1}}],[\"以保证重分配的结果一致\",{\"1\":{\"653\":1}}],[\"以保证消费的顺序性\",{\"1\":{\"622\":1}}],[\"以加快消费速度\",{\"1\":{\"609\":1}}],[\"以其他部署形式启动\",{\"0\":{\"602\":1}}],[\"以上\",{\"1\":{\"599\":1}}],[\"以集群模式启动\",{\"0\":{\"595\":1}}],[\"以供用户选择发往某个\",{\"1\":{\"549\":1}}],[\"以提高消费速度\",{\"1\":{\"548\":1}}],[\"以提升消息的吞吐量\",{\"1\":{\"181\":1}}],[\"以同样的方法签名\",{\"1\":{\"509\":1}}],[\"以下简称定时消息\",{\"1\":{\"872\":1}}],[\"以下简称\",{\"1\":{\"804\":1}}],[\"以下为参数含义\",{\"1\":{\"767\":1}}],[\"以下为推模式下消息消费者端拉取相关类设计\",{\"1\":{\"675\":1}}],[\"以下三种情况会将响应码设置为responsecode\",{\"1\":{\"339\":1}}],[\"以下是准备工作\",{\"1\":{\"122\":1}}],[\"以此来达到周期性执行该任务的效果\",{\"1\":{\"361\":1}}],[\"以此循环\",{\"1\":{\"326\":1}}],[\"以此类推\",{\"1\":{\"38\":1,\"106\":1}}],[\"以主从复制为例\",{\"1\":{\"244\":1}}],[\"以键值对的形式存储消息\",{\"1\":{\"220\":1}}],[\"以防止异常关机\",{\"1\":{\"216\":1}}],[\"以便构建\",{\"1\":{\"814\":1}}],[\"以便能先消费到\",{\"1\":{\"773\":1}}],[\"以便与\",{\"1\":{\"773\":1}}],[\"以便有足够的重试次数来应对发送失败的场景\",{\"1\":{\"753\":1}}],[\"以便让其他队列有机会消费\",{\"1\":{\"750\":1}}],[\"以便\",{\"1\":{\"507\":1}}],[\"以便将消息更快地发给消费者\",{\"1\":{\"214\":1}}],[\"以便验证在大规模数据请求以及各种故障冲击下的韧性表现\",{\"1\":{\"128\":1}}],[\"以队列维度提供高可用的解决方案\",{\"1\":{\"182\":1}}],[\"以前的版本\",{\"1\":{\"181\":1}}],[\"以了解分区数量对消息吞吐量的影响和达到最大吞吐量的最优分区数数量\",{\"1\":{\"135\":1}}],[\"以消息系统的稳定性评估为例\",{\"1\":{\"133\":1}}],[\"以统一的标准化计算输出结果与图表\",{\"1\":{\"133\":1}}],[\"以观察他们在这种情况下的表现\",{\"1\":{\"132\":1}}],[\"以往支撑在线\",{\"1\":{\"126\":1}}],[\"以\",{\"1\":{\"122\":1,\"300\":1,\"815\":1}}],[\"以`when`关键字开头\",{\"1\":{\"36\":1}}],[\"以句号结尾\",{\"1\":{\"30\":1}}],[\"以及破除一个队列只能保存同一个延迟等级的消息的限制\",{\"1\":{\"880\":1}}],[\"以及消息生产\",{\"1\":{\"530\":1}}],[\"以及每个acl配置文件最近一次修改的时间\",{\"1\":{\"519\":1}}],[\"以及上一步返回的\",{\"1\":{\"515\":1}}],[\"以及请求合并成一个\",{\"1\":{\"515\":1}}],[\"以及请求中\",{\"1\":{\"515\":1}}],[\"以及内部处理中都使用了重量级锁synchronized保证线程安全\",{\"1\":{\"245\":1}}],[\"以及在参数中配置镜像队列的具体参数\",{\"1\":{\"185\":1}}],[\"以及多云多活架构等策略的整体导入\",{\"1\":{\"126\":1}}],[\"以及可选的关卡guard1\",{\"1\":{\"44\":1}}],[\"以及shell里的表达式\",{\"1\":{\"30\":1}}],[\"以及case\",{\"1\":{\"30\":1}}],[\"以大写字母开头或包含字母数字以外字符的原子\",{\"1\":{\"25\":1}}],[\"分开\",{\"1\":{\"811\":1}}],[\"分为多个队列\",{\"1\":{\"548\":1}}],[\"分批将消息发送到\",{\"1\":{\"541\":1}}],[\"分布的\",{\"1\":{\"470\":1,\"488\":1}}],[\"分布在不同的\",{\"1\":{\"461\":1}}],[\"分布式消息中间件\",{\"1\":{\"577\":1}}],[\"分布式消息队列稳定性评估标准\",{\"1\":{\"136\":1}}],[\"分布式系统的弹性能力不能通过编排固定频率的事件以触发检测\",{\"1\":{\"135\":1}}],[\"分布式系统共识组件的一致性等\",{\"1\":{\"128\":1}}],[\"分布式系统韧性架构压舱石openchaos\",{\"0\":{\"125\":1},\"1\":{\"141\":1}}],[\"分布式领域资深技术专家\",{\"1\":{\"127\":1}}],[\"分布式应用程序编写顺序\",{\"1\":{\"88\":1}}],[\"分布式\",{\"1\":{\"87\":1}}],[\"分布式编程\",{\"0\":{\"86\":1}}],[\"分别处理\",{\"1\":{\"780\":1}}],[\"分别在\",{\"1\":{\"649\":1}}],[\"分别消费重试\",{\"1\":{\"615\":1}}],[\"分别用于重新加载全部文件\",{\"1\":{\"518\":1}}],[\"分别为命令行方式切换和客户端代码方式切换\",{\"1\":{\"766\":1}}],[\"分别为全局唯一\",{\"1\":{\"419\":1}}],[\"分别为长轮询\",{\"1\":{\"324\":1}}],[\"分别替换成延迟消息对应的\",{\"1\":{\"354\":1}}],[\"分别创建索引\",{\"1\":{\"314\":1}}],[\"分别是根据消费队列过滤和根据消息详情过滤\",{\"1\":{\"833\":1}}],[\"分别是并发消费和顺序消费的实现\",{\"1\":{\"639\":1}}],[\"分别是并发消费和顺序消费\",{\"1\":{\"622\":1}}],[\"分别是启动和关闭\",{\"1\":{\"481\":1}}],[\"分别是定时消息数据和定时消息索引\",{\"1\":{\"449\":1}}],[\"分别是\",{\"1\":{\"165\":1,\"622\":1}}],[\"分发请求\",{\"1\":{\"817\":1}}],[\"分发\",{\"0\":{\"817\":1},\"1\":{\"814\":1}}],[\"分发到多个队列\",{\"1\":{\"817\":1}}],[\"分发到\",{\"0\":{\"814\":1}}],[\"分发到另一个\",{\"1\":{\"163\":1}}],[\"分发消息到消费索引\",{\"1\":{\"817\":1}}],[\"分发消息到多个\",{\"1\":{\"807\":1}}],[\"分发消息到\",{\"1\":{\"806\":1}}],[\"分发拉取请求到消息拉取服务\",{\"1\":{\"654\":1}}],[\"分发给各个处理器\",{\"1\":{\"282\":1}}],[\"分配策略\",{\"1\":{\"663\":1}}],[\"分配给消费者进行消费的动作即重平衡\",{\"1\":{\"646\":1}}],[\"分配完队列后\",{\"1\":{\"624\":1}}],[\"分配新的morecreditafter\",{\"1\":{\"154\":1}}],[\"分配初始信用值initialcredit\",{\"1\":{\"154\":1}}],[\"分配的值为initialcredit\",{\"1\":{\"152\":1}}],[\"分析反馈较弱\",{\"1\":{\"127\":1}}],[\"分割\",{\"1\":{\"36\":2}}],[\"分隔函数整体\",{\"1\":{\"30\":1}}],[\"分隔函数调用\",{\"1\":{\"30\":1}}],[\"分隔子句\",{\"1\":{\"30\":1}}],[\"分号\",{\"1\":{\"30\":1}}],[\"分钟不会接收消息\",{\"1\":{\"754\":1}}],[\"分钟不更新则过期\",{\"1\":{\"729\":1}}],[\"分钟的超时时间是为了防止某个队列消息过多或消费过慢\",{\"1\":{\"726\":1}}],[\"分钟的消息\",{\"1\":{\"445\":1}}],[\"分钟内\",{\"1\":{\"442\":1}}],[\"分钟后进行一次回调\",{\"1\":{\"441\":1,\"871\":1}}],[\"分钟才会强制删除\",{\"1\":{\"386\":1}}],[\"分钟\",{\"1\":{\"11\":1,\"386\":1,\"732\":1,\"737\":1}}],[\"逗号\",{\"1\":{\"30\":1}}],[\"编码工作\",{\"1\":{\"256\":1}}],[\"编程库与框架\",{\"0\":{\"89\":1}}],[\"编译\",{\"0\":{\"841\":1},\"1\":{\"841\":1}}],[\"编译这个模块\",{\"1\":{\"80\":1}}],[\"编译和运行程序\",{\"0\":{\"72\":1}}],[\"编译之后产生\",{\"1\":{\"30\":1}}],[\"编译后的模块以\",{\"1\":{\"30\":1}}],[\"编写自定义的过滤规则\",{\"1\":{\"823\":1}}],[\"编写一个分布式程序\",{\"0\":{\"88\":1}}],[\"编写并发程序的三要素\",{\"1\":{\"80\":1}}],[\"编写并发程序只需要三个基本函数\",{\"1\":{\"78\":1}}],[\"编写测试代码\",{\"0\":{\"9\":1}}],[\"编写的测试代码可能有缺陷\",{\"1\":{\"3\":1}}],[\"~32767\",{\"1\":{\"414\":2}}],[\"~~info~~\",{\"1\":{\"242\":1}}],[\"~n\",{\"1\":{\"109\":1}}],[\"~p\",{\"1\":{\"109\":1}}],[\"~p~n\",{\"1\":{\"85\":1,\"98\":1}}],[\"~s~n\",{\"1\":{\"109\":1}}],[\"~\",{\"1\":{\"98\":1,\"175\":1,\"236\":1,\"386\":1,\"390\":1,\"599\":3}}],[\"~ts~n\",{\"1\":{\"28\":1}}],[\"~w~n\",{\"1\":{\"28\":1}}],[\"$java\",{\"1\":{\"597\":1}}],[\"$a\",{\"1\":{\"65\":1}}],[\"$a实际上就是代表字符a的整数\",{\"1\":{\"28\":1}}],[\"$\",{\"1\":{\"65\":1,\"74\":2,\"102\":4,\"139\":1,\"592\":1,\"593\":2,\"594\":3,\"595\":9,\"597\":5,\"598\":2,\"599\":4,\"600\":10,\"603\":2,\"604\":2}}],[\"$s\",{\"1\":{\"28\":2}}],[\"那要继续进行任务的转移\",{\"1\":{\"451\":1}}],[\"那它真的完美吗\",{\"1\":{\"451\":1}}],[\"那这个文件的删除时间需要在延迟最大的消息投递之后\",{\"1\":{\"448\":1}}],[\"那就直接读取\",{\"1\":{\"399\":1}}],[\"那就是镜像队列\",{\"1\":{\"225\":1}}],[\"那就必须使用格式化的写语句\",{\"1\":{\"28\":1}}],[\"那样强大\",{\"1\":{\"87\":1}}],[\"那么轻量级队列的实现也就呼之欲出\",{\"1\":{\"811\":1}}],[\"那么本次无法将该队列解锁\",{\"1\":{\"745\":1}}],[\"那么需要将\",{\"1\":{\"723\":1}}],[\"那么进行分页\",{\"1\":{\"714\":1}}],[\"那么进程会解除阻塞\",{\"1\":{\"159\":1}}],[\"那么进程阻塞之后\",{\"1\":{\"158\":1}}],[\"那么挂起当前拉取请求\",{\"1\":{\"693\":1}}],[\"那么可以用消费队列来表示一个\",{\"1\":{\"811\":1}}],[\"那么可以用如下命令打镜像\",{\"1\":{\"592\":1}}],[\"那么可以表示不同的\",{\"1\":{\"422\":1}}],[\"那么该\",{\"1\":{\"548\":1}}],[\"那么该拉取请求会重新放回\",{\"1\":{\"345\":1}}],[\"那么如何在发送普通消息的同时发送消息轨迹消息\",{\"1\":{\"530\":1}}],[\"那么下任务会在上个任务\",{\"1\":{\"452\":1}}],[\"那么下次\",{\"1\":{\"309\":1}}],[\"那么只能把定时消息单独存储\",{\"1\":{\"448\":1}}],[\"那么只要发送一条定时消息取消的命令就可以取消之前发送的定时消息投递\",{\"1\":{\"441\":1,\"871\":1}}],[\"那么最大延迟时间还是会受到普通消息文件过期时间的限制\",{\"1\":{\"446\":1}}],[\"那么他们的投递就是按顺序的\",{\"1\":{\"445\":1}}],[\"那么服务端在收到消息后需要对消息进行排序再投递\",{\"1\":{\"445\":1}}],[\"那么消息的\",{\"1\":{\"444\":1}}],[\"那么消息索引都还没有被存入\",{\"1\":{\"285\":1}}],[\"那么既然已经直到\",{\"1\":{\"426\":1}}],[\"那么想要优化这个方法最直接的方式就是\",{\"1\":{\"416\":1}}],[\"那么这里就还需要一个投递任务状态更新线程\",{\"1\":{\"453\":1}}],[\"那么这个订单不再需要被取消\",{\"1\":{\"441\":1,\"871\":1}}],[\"那么这个方法做了什么\",{\"1\":{\"416\":1}}],[\"那么这是一个很好的选择\",{\"1\":{\"191\":1}}],[\"那么等下次到达\",{\"1\":{\"386\":1}}],[\"那么等待一会后再次执行扫描\",{\"1\":{\"375\":1}}],[\"那么等待0\",{\"1\":{\"365\":1}}],[\"那么会删除这些文件\",{\"1\":{\"384\":1}}],[\"那么会将该拉取请求挂起\",{\"1\":{\"326\":1}}],[\"那么无法重新投递\",{\"1\":{\"367\":1}}],[\"那么无需额外引入依赖\",{\"1\":{\"8\":1}}],[\"那么创建一个定时任务\",{\"1\":{\"365\":1,\"380\":1}}],[\"那么创建一个新的文件\",{\"1\":{\"309\":1}}],[\"那么延迟时间最长为3天\",{\"1\":{\"353\":1}}],[\"那么按照上述流程\",{\"1\":{\"326\":1}}],[\"那么根据\",{\"1\":{\"326\":1}}],[\"那么将新建处理轨迹的钩子\",{\"1\":{\"534\":1}}],[\"那么将唤醒对应的拉取请求\",{\"1\":{\"332\":1}}],[\"那么将拉取到的消息直接返回\",{\"1\":{\"326\":1}}],[\"那么将在另一个节点上创建一个新镜像\",{\"1\":{\"190\":1}}],[\"那么你有没有想过\",{\"1\":{\"322\":1}}],[\"那么索引文件的存储格式也是\",{\"1\":{\"300\":1}}],[\"那么队列数据就永久丢失了\",{\"1\":{\"236\":1}}],[\"那么队列应该是没有消息堆积或者堆积非常少的\",{\"1\":{\"226\":1}}],[\"那么同步的影响就比较小\",{\"1\":{\"226\":1}}],[\"那么就可以把这个正则表达式匹配给优化掉\",{\"1\":{\"424\":1}}],[\"那么就意味着要将当前所有的消息从主队列同步到从队列\",{\"1\":{\"226\":1}}],[\"那么就会出现数据的丢失\",{\"1\":{\"192\":1}}],[\"那么b节点需要再将消息发送给新增的e节点\",{\"1\":{\"207\":1}}],[\"那么节点b感知后节点c失效后需要重新将消息发送给d\",{\"1\":{\"207\":1}}],[\"那么相邻的节点可能需要重新发送给新的节点\",{\"1\":{\"207\":1}}],[\"那么由于ha\",{\"1\":{\"192\":1}}],[\"那么a只会移除前k个x\",{\"1\":{\"62\":1}}],[\"那么expattern1等捕捉模式就会与它进行匹配\",{\"1\":{\"44\":1}}],[\"那么整个\",{\"1\":{\"44\":1}}],[\"那么函数的返回值就会与pattern1\",{\"1\":{\"44\":1}}],[\"那么if的值就是执行表达式序列\",{\"1\":{\"38\":1}}],[\"那么\",{\"1\":{\"27\":1,\"324\":1,\"394\":1}}],[\"而定时消息指定确切的投递时间\",{\"1\":{\"872\":1}}],[\"而每个队列最多只能被一个消费者消费\",{\"1\":{\"769\":1}}],[\"而之前的\",{\"1\":{\"765\":1}}],[\"而业务的唯一标识可以通过消息key设置\",{\"1\":{\"757\":1}}],[\"而本片主要介绍\",{\"1\":{\"723\":1}}],[\"而非挂起请求触发的话\",{\"1\":{\"693\":1}}],[\"而被动触发一般是其他消费者每\",{\"1\":{\"656\":1}}],[\"而用户真正编写的只有最终的消费逻辑\",{\"1\":{\"639\":1}}],[\"而真正的发送逻辑则在\",{\"1\":{\"541\":1}}],[\"而尽可能不影响正常消息发送的性能\",{\"1\":{\"530\":1}}],[\"而在\",{\"1\":{\"523\":1}}],[\"而rocketmq的设计理念也正是基于此\",{\"1\":{\"462\":1}}],[\"而对于一个简单的服务发现的场景来说\",{\"1\":{\"462\":1}}],[\"而zookeeper\",{\"1\":{\"462\":1}}],[\"而这对于一个注册中心来说肯定是不能接受的\",{\"1\":{\"462\":1}}],[\"而堆内存的释放由垃圾回收器负责完成\",{\"1\":{\"424\":1}}],[\"而不必在客户端实现重平衡逻辑\",{\"1\":{\"769\":1}}],[\"而不会主动向其他模块发起请求\",{\"1\":{\"463\":1}}],[\"而不是\",{\"0\":{\"430\":1}}],[\"而不是直接计算\",{\"1\":{\"258\":1}}],[\"而不是直接存储在磁盘中\",{\"1\":{\"214\":1}}],[\"而不发生线程切换\",{\"1\":{\"245\":1}}],[\"而不保存到消息存储中\",{\"1\":{\"220\":1}}],[\"而\",{\"1\":{\"201\":1,\"347\":1,\"401\":1,\"462\":3,\"544\":1,\"804\":1,\"820\":1,\"838\":1}}],[\"而实际应用中\",{\"1\":{\"192\":1}}],[\"而信用证流控的逻辑都位于credit\",{\"1\":{\"156\":1}}],[\"而该进程进入flow状态的原因是因为它的下游进程成为了性能瓶颈\",{\"1\":{\"155\":1}}],[\"而是无状态的\",{\"1\":{\"843\":1}}],[\"而是用专门的\",{\"1\":{\"783\":1}}],[\"而是换一个\",{\"1\":{\"754\":1}}],[\"而是不断重用在重平衡中创建的同一个\",{\"1\":{\"675\":1}}],[\"而是等待一段指定的时间之后才能消费到该消息\",{\"1\":{\"548\":1}}],[\"而是等到处理完morecreditafter条消息\",{\"1\":{\"152\":1}}],[\"而是只需要从上一次投递的时间和偏移量开始一个新的投递任务即可\",{\"1\":{\"452\":1}}],[\"而是投递到延迟消息\",{\"1\":{\"445\":1}}],[\"而是到达某个时间才投递给消费者\",{\"1\":{\"440\":1,\"871\":1}}],[\"而是延迟一定时间后投递\",{\"1\":{\"440\":1}}],[\"而是在消费者端处理消息拉取结果时进行判断\",{\"1\":{\"834\":1}}],[\"而是在当前时间之后的某个时间投递\",{\"1\":{\"440\":1}}],[\"而是在一个任务的末尾执行下一个任务\",{\"1\":{\"377\":1}}],[\"而是挂起一段时间再重试查询\",{\"1\":{\"434\":1}}],[\"而是对于\",{\"1\":{\"414\":1}}],[\"而是尽可能地利用空闲的物理内存保存这些\",{\"1\":{\"399\":1}}],[\"而是先把\",{\"1\":{\"386\":1}}],[\"而是先标记该消息为垃圾数据\",{\"1\":{\"221\":1}}],[\"而是一个任务末尾启动一个新的任务\",{\"1\":{\"378\":1}}],[\"而是提供了18个延迟等级\",{\"1\":{\"353\":1}}],[\"而是需要在指定时间进行消费\",{\"1\":{\"352\":1}}],[\"而是需要自己编写控制结构\",{\"1\":{\"32\":1}}],[\"而是会将该查询请求挂起一段时间\",{\"1\":{\"324\":1}}],[\"而是每次\",{\"1\":{\"361\":1}}],[\"而是每写满一个索引文件时就新建一个文件\",{\"1\":{\"303\":1}}],[\"而是每个方法都单独实现\",{\"1\":{\"251\":1}}],[\"而是简单粗暴的直接一个一个去\",{\"1\":{\"262\":1}}],[\"而是转化为对映射地址映射的pagecache的操作\",{\"1\":{\"248\":1}}],[\"而flaglist规定了跟踪条件满足时要\",{\"1\":{\"111\":1}}],[\"而此函数将会返回到\",{\"1\":{\"106\":1}}],[\"而列表用于保存可变数量的元素\",{\"1\":{\"40\":1}}],[\"而表达式序列执行的结果就是\",{\"1\":{\"37\":1}}],[\"而且最大的定时时间也只有\",{\"1\":{\"872\":1}}],[\"而且\",{\"1\":{\"839\":1}}],[\"而且本身存储的数据应该是高度定制化的\",{\"1\":{\"462\":1}}],[\"而且可以通过增加机器的方式水平扩展\",{\"1\":{\"462\":1}}],[\"而且只需要一个线程就可以驱动时间轮进行工作\",{\"1\":{\"451\":1}}],[\"而且这个解码方法应用广泛\",{\"1\":{\"410\":1}}],[\"而且也避免了重复数据的产生\",{\"1\":{\"400\":1}}],[\"而且在同一张表里可以存在多个相同的元组\",{\"1\":{\"98\":1}}],[\"而且必须先编译才能运行模块里的代码\",{\"1\":{\"30\":1}}],[\"而且不需要宏定义或包含文件就能实现\",{\"1\":{\"25\":1}}],[\"而你其实想让它打印成一列整数\",{\"1\":{\"28\":1}}],[\"打包完成后可以用如下命令查看\",{\"1\":{\"592\":1}}],[\"打包之后也自带可以运行基准测试代码的\",{\"1\":{\"7\":1}}],[\"打开时会进行一致性检查\",{\"1\":{\"97\":1}}],[\"打印错误日志\",{\"1\":{\"738\":1}}],[\"打印\",{\"1\":{\"480\":1}}],[\"打印当前加载配置属性\",{\"1\":{\"480\":1}}],[\"打印一次\",{\"1\":{\"467\":1,\"481\":2}}],[\"打印时总是使用各键排序后的顺序\",{\"1\":{\"42\":1}}],[\"打印成列表记法\",{\"1\":{\"28\":1}}],[\"否则会出现先扫描的消息要后投递的情况\",{\"1\":{\"876\":1}}],[\"否则仅进行第二层过滤\",{\"1\":{\"842\":1}}],[\"否则从\",{\"1\":{\"841\":1}}],[\"否则不消费\",{\"1\":{\"834\":1,\"848\":1}}],[\"否则消费者客户端启动会报错\",{\"1\":{\"828\":1}}],[\"否则消费者客户端启动时会报错\",{\"1\":{\"828\":2}}],[\"否则使用消息存储的地\",{\"1\":{\"717\":1}}],[\"否则返回错误\",{\"1\":{\"684\":1}}],[\"否则返回异常信息\",{\"1\":{\"501\":1}}],[\"否则继续重新投递\",{\"1\":{\"378\":1}}],[\"否则继续循环进行轮询操作\",{\"1\":{\"326\":1}}],[\"否则查找失败\",{\"1\":{\"317\":1}}],[\"否则直接退出循环\",{\"1\":{\"291\":1}}],[\"否则直接退出\",{\"1\":{\"279\":1}}],[\"否则直接写\",{\"1\":{\"122\":1}}],[\"否则就会发生异常错误\",{\"1\":{\"38\":1}}],[\"否则\",{\"1\":{\"28\":1}}],[\"严格来说\",{\"1\":{\"28\":1}}],[\"提交拉取请求前会先判断处理队列的锁定状态\",{\"1\":{\"748\":1}}],[\"提交消费进度\",{\"1\":{\"738\":1}}],[\"提交消费请求到消费线程池\",{\"1\":{\"707\":1}}],[\"提交到消费线程池进行处理\",{\"1\":{\"707\":1}}],[\"提交到消费线程池进行并发消费\",{\"1\":{\"699\":1}}],[\"提交到线程池中执行\",{\"1\":{\"541\":1}}],[\"提交偏移量\",{\"1\":{\"691\":1}}],[\"提交的拉取请求\",{\"1\":{\"675\":1}}],[\"提交给消费线程池\",{\"1\":{\"737\":1}}],[\"提交给消费线程池消费\",{\"1\":{\"714\":1}}],[\"提交给消费线程池进行消费\",{\"1\":{\"699\":1}}],[\"提交给异步发送线程池执行\",{\"1\":{\"541\":1}}],[\"提交给发送线程池执行\",{\"1\":{\"541\":1}}],[\"提交说明上的\",{\"1\":{\"414\":1}}],[\"提前进行计算或者用函数式接口懒加载\",{\"1\":{\"437\":1}}],[\"提前做好\",{\"1\":{\"256\":1}}],[\"提高下面循环中访问该位图的速度\",{\"1\":{\"424\":1}}],[\"提高下面循环的变量访问速度\",{\"1\":{\"424\":1}}],[\"提高编解码性能\",{\"0\":{\"412\":1}}],[\"提高消息消费的性能\",{\"1\":{\"267\":1}}],[\"提醒长轮询请求管理容器\",{\"1\":{\"348\":1}}],[\"提醒\",{\"1\":{\"345\":1}}],[\"提升性能\",{\"1\":{\"833\":1,\"838\":1}}],[\"提升传输效率\",{\"1\":{\"548\":1}}],[\"提升到\",{\"1\":{\"430\":2,\"433\":1}}],[\"提升消息消费\",{\"0\":{\"430\":1}}],[\"提升了消息发送的\",{\"1\":{\"406\":1}}],[\"提升了约\",{\"1\":{\"240\":1}}],[\"提升\",{\"0\":{\"373\":1,\"418\":1}}],[\"提升效率\",{\"1\":{\"262\":1,\"403\":1}}],[\"提示缺少\",{\"1\":{\"178\":1}}],[\"提出了openchaos后续的发展方向\",{\"1\":{\"125\":1}}],[\"提供分布式事务功能\",{\"1\":{\"548\":1}}],[\"提供仲裁队列的原因\",{\"1\":{\"225\":1}}],[\"提供amqqueue调用的接口\",{\"1\":{\"222\":1}}],[\"提供了消费者实现的一些公用方法\",{\"1\":{\"638\":1}}],[\"提供了消息生产和消费的钩子\",{\"1\":{\"530\":1}}],[\"提供了发送消息的\",{\"1\":{\"556\":1}}],[\"提供了参数\",{\"1\":{\"549\":1}}],[\"提供了管理一个配置文件的功能\",{\"1\":{\"360\":1}}],[\"提供了\",{\"1\":{\"192\":1,\"400\":1,\"417\":1,\"637\":1,\"658\":1,\"766\":1}}],[\"提供了详细的栈跟踪信息\",{\"1\":{\"45\":1}}],[\"提供了概括信息\",{\"1\":{\"44\":1}}],[\"提供的安装包\",{\"1\":{\"175\":1}}],[\"提供的\",{\"1\":{\"2\":1,\"177\":1}}],[\"提取\",{\"1\":{\"41\":1}}],[\"提取1到n的所有a值\",{\"1\":{\"34\":1}}],[\"提取列表元素\",{\"1\":{\"27\":1}}],[\"|=\",{\"1\":{\"573\":2}}],[\"|a\",{\"1\":{\"424\":1}}],[\"||\",{\"0\":{\"34\":1},\"1\":{\"34\":5,\"44\":1,\"45\":1,\"69\":1,\"103\":4,\"160\":1,\"262\":4,\"317\":6,\"363\":1,\"390\":3,\"491\":2,\"516\":1,\"518\":2,\"520\":1,\"540\":5,\"571\":2,\"573\":1,\"693\":2,\"695\":2,\"718\":1,\"720\":1,\"749\":1,\"750\":4,\"787\":1,\"790\":5,\"797\":2,\"798\":2,\"800\":2,\"808\":1,\"817\":3,\"827\":2,\"850\":3,\"851\":1,\"852\":9}}],[\"|things\",{\"1\":{\"27\":1}}],[\"|\",{\"1\":{\"27\":1,\"30\":1,\"32\":1,\"33\":3,\"34\":1,\"84\":1,\"158\":1,\"159\":1,\"176\":5,\"718\":2,\"868\":1}}],[\"竖线\",{\"1\":{\"27\":1}}],[\"它与\",{\"1\":{\"872\":1}}],[\"它与系统内部生成的错误差不多\",{\"1\":{\"43\":1}}],[\"它无法支持任意时间的定时\",{\"1\":{\"872\":1}}],[\"它表示通过过滤条件的所有\",{\"1\":{\"852\":1}}],[\"它存在\",{\"1\":{\"837\":1}}],[\"它消费\",{\"1\":{\"783\":1}}],[\"它每秒都会调用\",{\"1\":{\"783\":1}}],[\"它每\",{\"1\":{\"782\":1}}],[\"它允许一个队列被多个消费者\",{\"1\":{\"775\":1}}],[\"它先被放入内存中匹配\",{\"1\":{\"773\":1}}],[\"它将会从内存中被删除\",{\"1\":{\"773\":1}}],[\"它将处理它的\",{\"1\":{\"160\":1}}],[\"它里面包含一批消息的句柄信息\",{\"1\":{\"771\":1}}],[\"它其实是把精确过滤的逻辑提前到消息生产时来做\",{\"1\":{\"835\":1}}],[\"它其实与上面命令行的逻辑一样\",{\"1\":{\"768\":1}}],[\"它其实本质上就是一个\",{\"1\":{\"463\":1}}],[\"它有新的消息\",{\"1\":{\"718\":1}}],[\"它有两个\",{\"1\":{\"518\":1}}],[\"它定义了两个方法\",{\"1\":{\"833\":1}}],[\"它定义了持久化和加载的接口\",{\"1\":{\"710\":1}}],[\"它定义了对分布式系统进行操作的基本形式\",{\"1\":{\"130\":1}}],[\"它没有把二进制位数组\",{\"1\":{\"843\":1}}],[\"它没有订阅\",{\"1\":{\"656\":1}}],[\"它没有包含队列的所有功能\",{\"1\":{\"227\":1}}],[\"它就是\",{\"1\":{\"639\":1}}],[\"它就会将其打印成字符串字面量\",{\"1\":{\"28\":1}}],[\"它由\",{\"1\":{\"561\":1}}],[\"它由瑞典电信公司爱立信开发\",{\"1\":{\"112\":1}}],[\"它调用\",{\"1\":{\"556\":1,\"560\":1}}],[\"它实现了\",{\"1\":{\"556\":1}}],[\"它扩展了\",{\"1\":{\"555\":1,\"710\":1}}],[\"它默认关闭\",{\"1\":{\"549\":1}}],[\"它默认有\",{\"1\":{\"356\":1}}],[\"它不会作为元数据上报到\",{\"1\":{\"811\":1}}],[\"它不会接收消息也不会发送消息\",{\"1\":{\"154\":1}}],[\"它不关心发送结果\",{\"1\":{\"547\":1}}],[\"它也仅保存在内存中\",{\"1\":{\"476\":1}}],[\"它最大的优势就是\",{\"1\":{\"451\":1}}],[\"它\",{\"1\":{\"399\":1}}],[\"它保留\",{\"1\":{\"399\":1}}],[\"它保存的所有从队列的镜像数据都会丢失\",{\"1\":{\"226\":1}}],[\"它所有的消息数据都存放在一个无限增长的文件队列\",{\"1\":{\"396\":1}}],[\"它用类似\",{\"1\":{\"447\":1}}],[\"它用来在关机恢复时标明扫描开始位置\",{\"1\":{\"377\":1}}],[\"它用于设置一个跟踪模式\",{\"1\":{\"111\":1}}],[\"它主要提供了两个方法\",{\"1\":{\"842\":1}}],[\"它主要有\",{\"1\":{\"464\":1}}],[\"它主要负责在保存消息时将原消息的\",{\"1\":{\"356\":1}}],[\"它主要关注系统面对故障所展现出的容错能力\",{\"1\":{\"127\":1}}],[\"它在在当前的互联网环境中有非常大的需求\",{\"1\":{\"871\":1}}],[\"它在高性能和大量定时消息的情况下可能引发灾难\",{\"1\":{\"451\":1}}],[\"它在\",{\"1\":{\"285\":1,\"347\":1,\"422\":1}}],[\"它在镜像中的任何数据都将被丢弃\",{\"1\":{\"210\":1}}],[\"它包括了以下改动\",{\"1\":{\"256\":1}}],[\"它包含一个内存中的消费进度缓存表\",{\"1\":{\"702\":1}}],[\"它包含一个主和多个从副本\",{\"1\":{\"228\":1}}],[\"它包含了多个同一类的消费者实例\",{\"1\":{\"609\":1}}],[\"它包含了用户界面和控制器\",{\"1\":{\"130\":1}}],[\"它包含用户\",{\"1\":{\"496\":1}}],[\"它包含可靠性\",{\"1\":{\"132\":1}}],[\"它比镜像队列更安全\",{\"1\":{\"227\":1}}],[\"它提供了按照消息\",{\"1\":{\"447\":1}}],[\"它提供了相关的接口供\",{\"1\":{\"204\":1}}],[\"它提供队列复制的能力\",{\"1\":{\"225\":1}}],[\"它只被其他模块调用\",{\"1\":{\"465\":1}}],[\"它只需要寻址一次就可以连续读写下去\",{\"1\":{\"396\":1}}],[\"它只接收新消息\",{\"1\":{\"191\":1}}],[\"它只会将消息发往有空闲消费者的下游集群\",{\"1\":{\"167\":1}}],[\"它需要将消息传入并调用credit\",{\"1\":{\"159\":1}}],[\"它会开启一个\",{\"1\":{\"510\":1,\"516\":1}}],[\"它会将请求的参数\",{\"1\":{\"509\":1,\"515\":1}}],[\"它会在处理请求的前后分别执行\",{\"1\":{\"508\":1,\"514\":1}}],[\"它会调用\",{\"1\":{\"480\":1,\"511\":1}}],[\"它会从\",{\"1\":{\"281\":1}}],[\"它会让整个队列不可用\",{\"1\":{\"226\":1}}],[\"它会先将自己的信用值\",{\"1\":{\"154\":1}}],[\"它会启动跟踪\",{\"1\":{\"111\":1}}],[\"它自己的信用值会减一\",{\"1\":{\"152\":1}}],[\"它以发生错误的函数名开头\",{\"1\":{\"106\":1}}],[\"它是真正查询消息的方法\",{\"1\":{\"778\":1}}],[\"它是该消息的句柄\",{\"1\":{\"771\":1}}],[\"它是生产者的具体实现类\",{\"1\":{\"556\":1}}],[\"它是一个\",{\"1\":{\"335\":1}}],[\"它是一个应用程序操作系统\",{\"1\":{\"112\":1}}],[\"它是一个轻量级的性能分析器\",{\"1\":{\"105\":1}}],[\"它是\",{\"1\":{\"105\":1}}],[\"它适用于实验室或模拟系统里的大型系统性能分析\",{\"1\":{\"105\":1}}],[\"它还是高度可定制的\",{\"1\":{\"101\":1}}],[\"它们都调用同一个方法\",{\"1\":{\"778\":1}}],[\"它们都提供大型的键\",{\"1\":{\"97\":1}}],[\"它们会被投递到\",{\"1\":{\"773\":1}}],[\"它们内部都定义了一个消费线程池\",{\"1\":{\"639\":1}}],[\"它们分别实现了消费者接口\",{\"1\":{\"629\":1}}],[\"它们只会保存在内存中\",{\"1\":{\"469\":1}}],[\"它们仅存在于内存中\",{\"1\":{\"464\":1}}],[\"它们仅仅作为一个冗余备份\",{\"1\":{\"228\":1}}],[\"它们的重平衡触发也不太相同\",{\"1\":{\"656\":1}}],[\"它们的\",{\"1\":{\"262\":1}}],[\"它们的写入速率时多少\",{\"1\":{\"235\":1}}],[\"它们的消费将在故障转移时被取消\",{\"1\":{\"198\":1}}],[\"它们的形式通常是\",{\"1\":{\"190\":1}}],[\"它们的普遍实现是通过黑盒的故障注入来模拟一些常见的通用故障\",{\"1\":{\"132\":1}}],[\"它们由内置函数\",{\"1\":{\"68\":1}}],[\"它们被用来定义文件的某些属性\",{\"1\":{\"52\":1}}],[\"它的性能也达不到普通消息\",{\"1\":{\"872\":1}}],[\"它的性能处于消息队列的第一梯队\",{\"1\":{\"394\":1}}],[\"它的方法\",{\"1\":{\"843\":1}}],[\"它的两个方法先后在从\",{\"1\":{\"838\":1}}],[\"它的背后其实是消费者在不断地\",{\"1\":{\"765\":1}}],[\"它的存储位置是\",{\"1\":{\"837\":1}}],[\"它的存储大小不会随着投递到的队列变多而线性增长\",{\"1\":{\"233\":1}}],[\"它的存在是为了解决重平衡后可能的不同消费者并行消费问题\",{\"1\":{\"732\":1}}],[\"它的用处很多\",{\"1\":{\"629\":1,\"638\":1}}],[\"它的目的是在主题没有被创建时\",{\"1\":{\"559\":1}}],[\"它的初始化方法\",{\"1\":{\"467\":1}}],[\"它的作用是引入\",{\"1\":{\"422\":1}}],[\"它的\",{\"1\":{\"335\":1,\"708\":1}}],[\"它的结构类似于类似\",{\"1\":{\"297\":1}}],[\"它的底层结构实际是\",{\"1\":{\"261\":1}}],[\"它的实现大致为\",{\"1\":{\"206\":1}}],[\"它的值就为\",{\"1\":{\"36\":1}}],[\"它的头是h\",{\"1\":{\"27\":1}}],[\"它通过阅读一个自定义的语法标准文件\",{\"1\":{\"841\":1}}],[\"它通过\",{\"1\":{\"36\":1}}],[\"它让程序变得更短\",{\"1\":{\"34\":1}}],[\"它可以使用sql92语法作为过滤规则表达式\",{\"1\":{\"828\":1}}],[\"它可以用来记录消息发送\",{\"1\":{\"523\":1}}],[\"它可以包含多个文件\",{\"1\":{\"300\":1}}],[\"它可以实现消息在\",{\"1\":{\"166\":1}}],[\"它可以是自部署的分布式系统集群\",{\"1\":{\"130\":1}}],[\"它可以绑定x到someexpression这个值上\",{\"1\":{\"23\":1}}],[\"它可以帮助解析\",{\"1\":{\"6\":1}}],[\">6379\",{\"1\":{\"599\":2}}],[\">30931\",{\"1\":{\"599\":2}}],[\">30929\",{\"1\":{\"599\":2}}],[\">8080\",{\"1\":{\"597\":2}}],[\">9876\",{\"1\":{\"595\":2,\"599\":4}}],[\">10912\",{\"1\":{\"595\":2}}],[\">10911\",{\"1\":{\"595\":4}}],[\">10909\",{\"1\":{\"595\":4}}],[\">>\",{\"1\":{\"469\":1,\"486\":1,\"732\":1,\"880\":1}}],[\">q4的顺序流动\",{\"1\":{\"223\":1}}],[\">q3\",{\"1\":{\"223\":1}}],[\">q2\",{\"1\":{\"223\":1}}],[\">ram这样的过程\",{\"1\":{\"223\":1}}],[\">a形成的循环链表\",{\"1\":{\"207\":1}}],[\">delta\",{\"1\":{\"223\":1}}],[\">disk\",{\"1\":{\"223\":1}}],[\">d\",{\"1\":{\"207\":1}}],[\">c\",{\"1\":{\"207\":1}}],[\">b\",{\"1\":{\"207\":1}}],[\">try\",{\"1\":{\"44\":1}}],[\">=\",{\"1\":{\"34\":1,\"103\":1,\"289\":1,\"291\":2,\"314\":1,\"317\":2,\"345\":1,\"390\":2,\"402\":1,\"664\":1,\"693\":2,\"715\":3,\"718\":2,\"744\":1,\"750\":1,\"787\":2,\"790\":1,\"797\":1,\"828\":1,\"851\":1}}],[\">i\",{\"1\":{\"32\":2}}],[\">\",{\"1\":{\"26\":1,\"30\":7,\"31\":9,\"32\":2,\"33\":6,\"34\":3,\"36\":9,\"37\":7,\"38\":7,\"39\":5,\"41\":4,\"42\":1,\"43\":11,\"44\":6,\"45\":3,\"46\":7,\"50\":1,\"63\":2,\"67\":6,\"74\":1,\"79\":2,\"80\":5,\"81\":1,\"82\":3,\"84\":2,\"85\":5,\"91\":1,\"98\":2,\"103\":23,\"106\":2,\"109\":1,\"111\":5,\"123\":2,\"146\":2,\"147\":3,\"152\":3,\"157\":15,\"158\":10,\"159\":10,\"160\":5,\"223\":1,\"242\":1,\"257\":8,\"258\":1,\"262\":2,\"282\":1,\"289\":1,\"291\":1,\"313\":1,\"314\":3,\"316\":1,\"317\":4,\"335\":1,\"344\":1,\"345\":1,\"359\":1,\"360\":1,\"363\":3,\"380\":3,\"390\":3,\"391\":3,\"392\":1,\"414\":1,\"469\":1,\"470\":1,\"488\":1,\"490\":1,\"492\":1,\"514\":2,\"517\":1,\"518\":2,\"519\":1,\"540\":1,\"541\":2,\"570\":1,\"572\":1,\"690\":4,\"694\":2,\"695\":1,\"718\":2,\"749\":1,\"750\":1,\"768\":1,\"789\":1,\"790\":2,\"795\":1,\"796\":2,\"797\":2,\"798\":6,\"799\":1,\"828\":5}}],[\"或连接断开时触发\",{\"1\":{\"850\":1}}],[\"或立即重新拉取\",{\"1\":{\"695\":1,\"749\":1}}],[\"或它的变种算法\",{\"1\":{\"399\":1}}],[\"或开启强制删除\",{\"1\":{\"390\":1}}],[\"或刷盘间隔时间超过\",{\"1\":{\"272\":1}}],[\"或配置文件中定义\",{\"1\":{\"193\":1}}],[\"或从一个\",{\"1\":{\"163\":1}}],[\"或者全部消息都匹配成功\",{\"1\":{\"797\":1}}],[\"或者抛异常\",{\"1\":{\"771\":1}}],[\"或者集群模式下处理队列被锁定且锁未超时\",{\"1\":{\"750\":1}}],[\"或者处理队列中消息消费完\",{\"1\":{\"737\":1}}],[\"或者更新现有锁\",{\"1\":{\"734\":1}}],[\"或者小于\",{\"1\":{\"718\":1}}],[\"或者频繁上下线时\",{\"1\":{\"648\":1}}],[\"或者传入队列选择方法\",{\"1\":{\"549\":1}}],[\"或者\",{\"1\":{\"492\":1,\"498\":1}}],[\"或者自研存储\",{\"1\":{\"448\":1}}],[\"或者时区不一致\",{\"1\":{\"386\":1}}],[\"或者磁盘空间告急\",{\"1\":{\"384\":1}}],[\"或者重试\",{\"1\":{\"375\":1}}],[\"或者延迟时间\",{\"1\":{\"352\":1}}],[\"或者是存储在内存中以达到更高的生产和消费效率\",{\"1\":{\"214\":1}}],[\"或者是将队列中的消息存入磁盘的过程中引起服务器\",{\"1\":{\"155\":1}}],[\"或者有的镜像从集群中断开\",{\"1\":{\"197\":1}}],[\"或者您在rabbitmq节点和ha\",{\"1\":{\"191\":1}}],[\"或者原有的的队列\",{\"1\":{\"188\":1}}],[\"或者可以根据\",{\"1\":{\"177\":1}}],[\"或者其他可以使用表达式的地方\",{\"1\":{\"36\":1}}],[\"或系统响应的预期时间为100ms\",{\"1\":{\"135\":1}}],[\"或进行分布式跟踪\",{\"1\":{\"126\":1}}],[\"或\",{\"1\":{\"46\":1,\"133\":1,\"169\":1,\"798\":1,\"827\":1}}],[\"或at\",{\"1\":{\"25\":1}}],[\"或底层硬件可能对这部分测试代码进行许多优化\",{\"1\":{\"3\":1}}],[\"数组生成一个签名\",{\"1\":{\"515\":1}}],[\"数组\",{\"1\":{\"515\":1}}],[\"数量可能会非常多\",{\"1\":{\"810\":1}}],[\"数量为自身分配负载的队列\",{\"1\":{\"624\":1}}],[\"数量特别多时\",{\"1\":{\"430\":1}}],[\"数量固定的项目归组成单一的实体\",{\"1\":{\"26\":1}}],[\"数字\",{\"0\":{\"65\":1},\"1\":{\"25\":1}}],[\"数据都放到消息体中\",{\"1\":{\"779\":1}}],[\"数据是否为空\",{\"1\":{\"518\":1}}],[\"数据是序列化后的json\",{\"1\":{\"410\":1}}],[\"数据存储模块\",{\"1\":{\"464\":1}}],[\"数据直接从page\",{\"1\":{\"399\":1}}],[\"数据表既可以保存在内存里\",{\"1\":{\"101\":1}}],[\"数据库如\",{\"1\":{\"448\":1}}],[\"数据库与中间件\",{\"1\":{\"127\":1}}],[\"数据库查询\",{\"0\":{\"103\":1}}],[\"数据库\",{\"0\":{\"101\":1},\"1\":{\"102\":1}}],[\"数据构造和模式中的参数\",{\"1\":{\"30\":1}}],[\"数据\",{\"1\":{\"9\":1,\"97\":1}}],[\"也叫\",{\"1\":{\"820\":1}}],[\"也无法消费到其\",{\"1\":{\"813\":1}}],[\"也无法开始消费\",{\"1\":{\"745\":1}}],[\"也减少元数据的内存占用\",{\"1\":{\"811\":1}}],[\"也不会存在频繁的重平衡导致消息积压\",{\"1\":{\"770\":1}}],[\"也不会主动重平衡来解决这个问题\",{\"1\":{\"769\":1}}],[\"也不注册回调函数\",{\"1\":{\"547\":1}}],[\"也依然需要创建一个新的消息保存到\",{\"1\":{\"708\":1}}],[\"也没有这个必要\",{\"1\":{\"708\":1}}],[\"也没有预先设定长度\",{\"1\":{\"429\":1}}],[\"也要重试下\",{\"1\":{\"690\":1}}],[\"也会放入磁盘\",{\"1\":{\"773\":1}}],[\"也会把消息放到重试队列\",{\"1\":{\"771\":1}}],[\"也会启动重平衡线程每\",{\"1\":{\"656\":1}}],[\"也会概括性地讲一下消费流程\",{\"1\":{\"606\":1}}],[\"也会在本地查询\",{\"1\":{\"550\":1}}],[\"也仅保存在内存\",{\"1\":{\"470\":1}}],[\"也有两层过滤机制\",{\"1\":{\"835\":1}}],[\"也有定时任务将内存中的消费偏移量持久化到磁盘\",{\"1\":{\"623\":1}}],[\"也有几个选择\",{\"1\":{\"448\":1}}],[\"也有许多不同于\",{\"1\":{\"394\":1}}],[\"也意味着需要单独对定时消息进行存储\",{\"1\":{\"444\":1}}],[\"也能在其之上构建其他服务\",{\"1\":{\"443\":1}}],[\"也几乎看不到rmq进程从磁盘read数据\",{\"1\":{\"399\":1}}],[\"也触发响应\",{\"1\":{\"345\":1}}],[\"也进行flush\",{\"1\":{\"289\":1}}],[\"也避免了\",{\"1\":{\"261\":1}}],[\"也可能是因为消费端或者下游服务非常慢或者挂掉\",{\"1\":{\"226\":1}}],[\"也可以通过\",{\"1\":{\"826\":1}}],[\"也可以在\",{\"1\":{\"615\":1}}],[\"也可以用\",{\"1\":{\"596\":1}}],[\"也可以用队列参数\",{\"1\":{\"193\":1}}],[\"也可以从\",{\"1\":{\"592\":1}}],[\"也可以每\",{\"1\":{\"452\":1}}],[\"也可以构建这样一个索引文件\",{\"1\":{\"447\":1}}],[\"也可以是容器或者云厂商承载的分布式系统\",{\"1\":{\"130\":1}}],[\"也可以是布尔表达式\",{\"1\":{\"34\":1}}],[\"也可以保存在磁盘上\",{\"1\":{\"101\":1}}],[\"也可以放在后缀为`\",{\"1\":{\"41\":1}}],[\"也可以放在单引号内\",{\"1\":{\"25\":1}}],[\"也可以返回函数\",{\"1\":{\"31\":1}}],[\"也可以视作枚举类型\",{\"1\":{\"25\":1}}],[\"也支持通过配置队列和消息都持久化的方式\",{\"1\":{\"214\":1}}],[\"也是发送请求给集群中的所有\",{\"1\":{\"768\":1}}],[\"也是主流场景中普遍采用的消费形式\",{\"1\":{\"614\":1}}],[\"也是有两种方法\",{\"1\":{\"599\":1}}],[\"也是真正的路由信息\",{\"1\":{\"464\":1}}],[\"也是从\",{\"1\":{\"399\":1}}],[\"也是顺序写\",{\"1\":{\"397\":1}}],[\"也是openchaos强大能力的秘密所在\",{\"1\":{\"130\":1}}],[\"也是一个列表\",{\"1\":{\"27\":1}}],[\"也较难针对表现分析系统缺陷\",{\"1\":{\"127\":1}}],[\"也需要有类似\",{\"1\":{\"120\":1}}],[\"也就是文件在内存中缓存的副本\",{\"1\":{\"399\":1}}],[\"也就是msgid的索引\",{\"1\":{\"314\":1}}],[\"也就是\",{\"1\":{\"314\":1}}],[\"也就是定时刷盘\",{\"1\":{\"255\":1}}],[\"也就是说默认只会进行\",{\"1\":{\"835\":1}}],[\"也就是说重平衡是消息拉取唯一的起点\",{\"1\":{\"657\":1}}],[\"也就是说在第一次拉取消息之后的\",{\"1\":{\"656\":1}}],[\"也就是说在初始化状态下\",{\"1\":{\"402\":1}}],[\"也就是说定时消息延迟时间最大也不能超过这个清除时间\",{\"1\":{\"444\":1}}],[\"也就是说每\",{\"1\":{\"386\":1,\"390\":1}}],[\"也就是说如果\",{\"1\":{\"353\":1}}],[\"也就是说\",{\"1\":{\"155\":1,\"167\":1,\"233\":1,\"323\":1,\"440\":1,\"451\":1,\"462\":1,\"611\":1}}],[\"也就是附加\",{\"1\":{\"62\":1}}],[\"也就是调用者没有准备好处理的非常严重的问题\",{\"1\":{\"43\":1}}],[\"也就是事实陈述\",{\"1\":{\"23\":1}}],[\"原理和\",{\"1\":{\"858\":1}}],[\"原理详解\",{\"0\":{\"763\":1,\"802\":1,\"821\":1,\"869\":1},\"1\":{\"884\":3}}],[\"原先每个消息都会通知一次\",{\"1\":{\"436\":1}}],[\"原先的负载就变得不再均衡\",{\"1\":{\"618\":1}}],[\"原先的\",{\"1\":{\"420\":1}}],[\"原先的方法实现中\",{\"1\":{\"420\":1}}],[\"原先在主从复制逻辑中的数组拷贝步骤其实是可以省略的\",{\"1\":{\"250\":1}}],[\"原来的默认值分别为\",{\"1\":{\"819\":1}}],[\"原来的代码会新建一个字节数组\",{\"1\":{\"249\":1}}],[\"原来有两种消费模式\",{\"1\":{\"765\":1}}],[\"原来锁内用来查位点哈希表的\",{\"1\":{\"256\":1}}],[\"原本的\",{\"1\":{\"810\":1}}],[\"原本的定时消息投递为单线程同步投递\",{\"1\":{\"373\":1}}],[\"原本生成全局\",{\"1\":{\"419\":1}}],[\"原本\",{\"1\":{\"251\":1}}],[\"原子的值就是它本身\",{\"1\":{\"25\":1}}],[\"原子以小写字母开头\",{\"1\":{\"25\":1}}],[\"原子是全局性的\",{\"1\":{\"25\":1}}],[\"原子\",{\"0\":{\"25\":1},\"1\":{\"36\":1}}],[\"原文地址\",{\"1\":{\"1\":1,\"16\":1,\"18\":1,\"113\":1,\"125\":1,\"137\":1,\"142\":1,\"162\":1,\"174\":1,\"180\":1,\"213\":1,\"225\":1,\"239\":1,\"264\":1,\"295\":1,\"319\":1,\"350\":1,\"369\":1,\"382\":1,\"393\":1,\"405\":1,\"438\":1,\"459\":1,\"495\":1,\"522\":1,\"543\":1,\"578\":1,\"588\":1,\"605\":1,\"626\":1,\"644\":1,\"666\":1,\"696\":1,\"722\":1,\"751\":1,\"763\":1,\"802\":1,\"819\":1,\"821\":1,\"854\":1,\"855\":1,\"859\":1,\"869\":1}}],[\"后投递\",{\"1\":{\"873\":2}}],[\"后分发构建索引时\",{\"1\":{\"811\":1}}],[\"后继续执行\",{\"1\":{\"750\":1}}],[\"后再次判断\",{\"1\":{\"748\":1}}],[\"后再次执行拉取请求\",{\"1\":{\"748\":1}}],[\"后再提交\",{\"1\":{\"714\":1}}],[\"后将\",{\"1\":{\"748\":1}}],[\"后将消费失败的消息发回\",{\"1\":{\"708\":1}}],[\"后将拉取请求重新放入队列\",{\"1\":{\"679\":1}}],[\"后台有线程拉取消息进行缓存\",{\"1\":{\"656\":1}}],[\"后就执行拉取消息拉取方法\",{\"1\":{\"639\":1}}],[\"后执行\",{\"1\":{\"452\":1}}],[\"后会启动一个新的定时任务进行下一次扫描\",{\"1\":{\"452\":1}}],[\"后来\",{\"1\":{\"872\":1}}],[\"后来后投递\",{\"1\":{\"445\":1}}],[\"后来看了一些\",{\"1\":{\"121\":1}}],[\"后才会被删除\",{\"1\":{\"386\":1}}],[\"后续不会新建而是重复使用这个拉取请求\",{\"1\":{\"672\":1}}],[\"后续有新的任务进来\",{\"1\":{\"372\":1}}],[\"后续的流控就是关联的解决方法\",{\"1\":{\"223\":1}}],[\"后改成\",{\"1\":{\"361\":1}}],[\"后的\",{\"1\":{\"326\":1}}],[\"后者看做数据消费者\",{\"1\":{\"244\":1}}],[\"后者表示系统伸缩的速率\",{\"1\":{\"135\":1}}],[\"后\",{\"1\":{\"154\":1,\"176\":1,\"188\":1,\"201\":1,\"399\":1,\"403\":1,\"814\":1}}],[\"后面的消息才能投递\",{\"1\":{\"876\":1}}],[\"后面的消息\",{\"1\":{\"715\":1}}],[\"后面的\",{\"1\":{\"715\":1,\"781\":1}}],[\"后面的限定符可以是生成器\",{\"1\":{\"34\":1}}],[\"后面讲解\",{\"1\":{\"708\":1}}],[\"后面按照最大的时间间隔来重试\",{\"1\":{\"620\":1}}],[\"后面是当前函数完成后将会返回的各个函数清单\",{\"1\":{\"106\":1}}],[\"后接空白\",{\"1\":{\"30\":1}}],[\"后接一串字母\",{\"1\":{\"25\":1}}],[\"后剩下的余数\",{\"1\":{\"24\":1}}],[\"后创建\",{\"1\":{\"7\":1}}],[\"整除\",{\"1\":{\"777\":1}}],[\"整除结果仍是浮点数\",{\"1\":{\"24\":1}}],[\"整个流程分\",{\"1\":{\"676\":1}}],[\"整个流程如下图所示\",{\"1\":{\"450\":1}}],[\"整个逻辑比较简单\",{\"1\":{\"667\":1}}],[\"整个集群不可用\",{\"1\":{\"462\":1}}],[\"整个选举的时间太长\",{\"1\":{\"462\":1}}],[\"整个开发过程中\",{\"1\":{\"123\":1}}],[\"整体类图\",{\"0\":{\"635\":1}}],[\"整体流程顺序图\",{\"0\":{\"583\":1}}],[\"整体流程\",{\"0\":{\"581\":1,\"676\":1}}],[\"整体集群恢复为可用\",{\"1\":{\"134\":1}}],[\"整体架构\",{\"0\":{\"130\":1}}],[\"整\",{\"1\":{\"123\":1}}],[\"整数的运算时精确的\",{\"1\":{\"65\":1}}],[\"整数运算是精确的\",{\"1\":{\"22\":1}}],[\"整数运算\",{\"0\":{\"22\":1}}],[\"浮点数的程序会存在和c等语言一样的浮点数取整与精度问题\",{\"1\":{\"24\":1}}],[\"浮点数\",{\"0\":{\"24\":1},\"1\":{\"65\":1}}],[\"因而读写效率比从堆内存中读写高很多\",{\"1\":{\"424\":1}}],[\"因为通常情况下消息消费之后都能很快\",{\"1\":{\"781\":1}}],[\"因为通过\",{\"1\":{\"402\":1}}],[\"因为不同的message\",{\"1\":{\"757\":1}}],[\"因为某个\",{\"1\":{\"754\":1}}],[\"因为如果释放\",{\"1\":{\"735\":1}}],[\"因为只要有多个队列让多个消费者同时消费\",{\"1\":{\"723\":1}}],[\"因为延迟重试消息依赖延迟消息能力\",{\"1\":{\"708\":1}}],[\"因为根据tag过滤时在服务端只验证了tag的哈希码\",{\"1\":{\"695\":1,\"749\":1}}],[\"因为子节点不保存消费者的offset值\",{\"1\":{\"691\":1}}],[\"因为每个消费者都需要消费全量消息消息\",{\"1\":{\"623\":1}}],[\"因为每次从磁盘读数据时需要先寻址\",{\"1\":{\"396\":1}}],[\"因为无法控制哪个队列的消息被先消费\",{\"1\":{\"622\":1}}],[\"因为消费者每次会消费多条消息\",{\"1\":{\"537\":1}}],[\"因为消息是先写入堆外内存\",{\"1\":{\"403\":1}}],[\"因为定时消息定时的时间不固定\",{\"1\":{\"448\":1}}],[\"因为高可靠和高性能都可以依赖\",{\"1\":{\"445\":1}}],[\"因为一个\",{\"1\":{\"623\":1}}],[\"因为一条消息会比一个分布式定时任务轻量得多\",{\"1\":{\"441\":1,\"871\":1}}],[\"因为一般\",{\"1\":{\"426\":1}}],[\"因为一般来说消息队列会更关心新的消息\",{\"1\":{\"307\":1}}],[\"因为订单会占用商品\",{\"1\":{\"441\":1,\"871\":1}}],[\"因为局部变量都位于栈\",{\"1\":{\"424\":1}}],[\"因为正则表达式匹配的字符编码都在\",{\"1\":{\"424\":1}}],[\"因为堆外内存中的数据未提交\",{\"1\":{\"403\":1}}],[\"因为操作系统会将一部分物理内存用作\",{\"1\":{\"399\":1}}],[\"因为在当前的设计中\",{\"1\":{\"817\":1}}],[\"因为在每个指标上要达到完美\",{\"1\":{\"444\":1}}],[\"因为在\",{\"1\":{\"373\":1}}],[\"因为在滚动升级时\",{\"1\":{\"226\":1}}],[\"因为比较方便\",{\"1\":{\"322\":1}}],[\"因为索引文件的\",{\"1\":{\"307\":1}}],[\"因为各种原因\",{\"1\":{\"256\":1}}],[\"因为拿不到锁的线程会让\",{\"1\":{\"253\":1}}],[\"因为写入必须被超过半数的副本接受\",{\"1\":{\"229\":1}}],[\"因为重新启动的\",{\"1\":{\"211\":1}}],[\"因为队列可以跨集群迁移\",{\"1\":{\"190\":1}}],[\"因为rabbit\",{\"1\":{\"158\":1}}],[\"因为\",{\"1\":{\"38\":1,\"347\":1,\"708\":1,\"718\":1,\"813\":1}}],[\"因为x还没有值\",{\"1\":{\"23\":1}}],[\"因此推荐尽可能使用集群模式\",{\"1\":{\"610\":1}}],[\"因此业务方需要关注消费失败的情况\",{\"1\":{\"610\":1}}],[\"因此数据还需要从内核空间拷贝到用户空间才可以被应用程序访问\",{\"1\":{\"400\":1}}],[\"因此这个参数默认值改为\",{\"1\":{\"253\":1}}],[\"因此这里就多了一次集群间的网络交互\",{\"1\":{\"201\":1}}],[\"因此触发消息流动的主要因素是\",{\"1\":{\"223\":1}}],[\"因此所有未被确认的消息都会被重新发送\",{\"1\":{\"198\":1}}],[\"因此对某些队列使用较少的镜像\",{\"1\":{\"195\":1}}],[\"因此credit\",{\"1\":{\"158\":1}}],[\"因此\",{\"1\":{\"157\":1,\"234\":1,\"235\":1,\"340\":1}}],[\"因此基本上所有的列表处理函数都从提取列表头开始\",{\"1\":{\"27\":1}}],[\"因此无需担心运算溢出或无法用特定字长\",{\"1\":{\"22\":1}}],[\"我把重平衡的触发分为主动触发和被动触发\",{\"1\":{\"656\":1}}],[\"我把\",{\"1\":{\"645\":1,\"667\":1,\"697\":1,\"723\":1}}],[\"我将\",{\"1\":{\"606\":1}}],[\"我全都要\",{\"1\":{\"444\":1}}],[\"我想说的是\",{\"1\":{\"444\":1}}],[\"我的设计目标是\",{\"1\":{\"443\":1}}],[\"我希望能随时调用看到的每一个方法\",{\"1\":{\"121\":1}}],[\"我发现仍然很难调用看到的方法\",{\"1\":{\"121\":1}}],[\"我使用了久负盛名的\",{\"1\":{\"121\":1}}],[\"我要做些什么才能让这条语句为真\",{\"1\":{\"23\":1}}],[\"我们在一开始提到的水位线\",{\"1\":{\"820\":1}}],[\"我们对一个\",{\"1\":{\"820\":1}}],[\"我们只在\",{\"1\":{\"773\":1}}],[\"我们姑且把这个锁叫做\",{\"1\":{\"729\":1}}],[\"我们选择\",{\"1\":{\"593\":1}}],[\"我们首先看一下客户端如何注册\",{\"1\":{\"508\":1}}],[\"我们设想这样一个场景\",{\"1\":{\"498\":1}}],[\"我们设计了实验以探索单个topic分区的扩容能力\",{\"1\":{\"135\":1}}],[\"我们完成了任意时间定时消息的设计旅程\",{\"1\":{\"454\":1}}],[\"我们可以通过\",{\"1\":{\"496\":1}}],[\"我们可以人为地为阻塞队列设置一个长度上限\",{\"1\":{\"453\":1}}],[\"我们可以使用\",{\"1\":{\"41\":1}}],[\"我们就可以把每个定时消息的投递作为一个任务\",{\"1\":{\"451\":1}}],[\"我们要达到的定时精度为\",{\"1\":{\"451\":1}}],[\"我们把定时消息存储文件也按投递时间段拆分\",{\"1\":{\"448\":1}}],[\"我们希望实现一个定时消息的底座\",{\"1\":{\"448\":1}}],[\"我们知道\",{\"1\":{\"432\":1,\"765\":1,\"877\":1}}],[\"我们先来看一下开源版本\",{\"1\":{\"445\":1}}],[\"我们先来看一下定时消息涉及到的类分别实现了什么功能\",{\"1\":{\"356\":1}}],[\"我们先来看一下ack函数的实现\",{\"1\":{\"159\":1}}],[\"我们一般使用\",{\"1\":{\"322\":1}}],[\"我们用一个\",{\"1\":{\"233\":1}}],[\"我们访问rabbit\",{\"1\":{\"159\":1}}],[\"我们来看看这个方法具体做了什么\",{\"1\":{\"345\":1}}],[\"我们来看看这个方法中做了什么\",{\"1\":{\"158\":1}}],[\"我们来分析一下rabbit\",{\"1\":{\"158\":1}}],[\"我们会继续打磨该项目\",{\"1\":{\"136\":1}}],[\"我们与混沌工程师实验室紧密合作\",{\"1\":{\"136\":1}}],[\"我们开放了更多分布式系统接入的工作\",{\"1\":{\"136\":1}}],[\"我们开始认真审视并思考\",{\"1\":{\"126\":1}}],[\"我们使用openchaos对etcd集群进行可靠性测试\",{\"1\":{\"134\":1}}],[\"我们有不同的方式来获取信息\",{\"1\":{\"126\":1}}],[\"我们构建\",{\"1\":{\"126\":1}}],[\"我们注明了\",{\"1\":{\"43\":1}}],[\"我们需要在进程内接收消息\",{\"1\":{\"80\":1}}],[\"我们需要在\",{\"1\":{\"41\":1}}],[\"我们能在很多地方看到子句\",{\"1\":{\"30\":1}}],[\"我们第一次说\",{\"1\":{\"23\":1}}],[\"我们编写代码来测试一下\",{\"1\":{\"9\":1}}],[\"我们的神器\",{\"1\":{\"2\":1}}],[\"不在对应\",{\"1\":{\"813\":1}}],[\"不在乎消息是否成功存储在\",{\"1\":{\"547\":1}}],[\"不建议以message\",{\"1\":{\"757\":1}}],[\"不建议开启\",{\"1\":{\"754\":1}}],[\"不再会发送到失败的\",{\"1\":{\"754\":1}}],[\"不再赘述\",{\"1\":{\"363\":1}}],[\"不能用于比较大小\",{\"1\":{\"828\":1}}],[\"不能用于比较字符串\",{\"1\":{\"828\":3}}],[\"不能释放\",{\"1\":{\"729\":1}}],[\"不能立即被消费者消费\",{\"1\":{\"352\":1}}],[\"不匹配则直接跳过该条消息\",{\"1\":{\"694\":1}}],[\"不表示消费成功\",{\"1\":{\"693\":1}}],[\"不本地构建了\",{\"1\":{\"596\":1}}],[\"不启用\",{\"1\":{\"572\":1}}],[\"不保证普通消息消费的顺序\",{\"1\":{\"548\":1}}],[\"不等待\",{\"1\":{\"547\":1}}],[\"不停地尝试从消息轨迹队列中获取一批数据\",{\"1\":{\"541\":1}}],[\"不相等则表示该文件发生过修改\",{\"1\":{\"519\":1}}],[\"不相等则更新\",{\"1\":{\"519\":1}}],[\"不一致则返回异常\",{\"1\":{\"511\":1,\"520\":1}}],[\"不进行后续的其他权限校验\",{\"1\":{\"498\":1}}],[\"不存在则创建集群\",{\"1\":{\"491\":1}}],[\"不存在全局变量或私有变量的说法\",{\"1\":{\"23\":1}}],[\"不希望将其他第三方组件引入开源\",{\"1\":{\"448\":1}}],[\"不支持对重试主题的属性进行过滤\",{\"1\":{\"693\":1}}],[\"不支持\",{\"1\":{\"445\":1}}],[\"不支持任意时间的定时消息\",{\"1\":{\"353\":1}}],[\"不换进行\",{\"1\":{\"402\":1}}],[\"不做操作\",{\"1\":{\"381\":1}}],[\"不断执行\",{\"1\":{\"688\":1}}],[\"不断重试重投\",{\"1\":{\"454\":1}}],[\"不断的消费\",{\"1\":{\"401\":1}}],[\"不断启动任务去扫描该等级对应的消费队列中是否有到期的消息\",{\"1\":{\"375\":1}}],[\"不断接收消息\",{\"1\":{\"244\":1}}],[\"不愿意开源\",{\"1\":{\"367\":1}}],[\"不为\",{\"1\":{\"360\":1}}],[\"不需要提前创建\",{\"1\":{\"813\":1}}],[\"不需要用\",{\"1\":{\"414\":1}}],[\"不需要手动拉取消息和更新消费进度\",{\"1\":{\"322\":1}}],[\"不需要创建索引\",{\"1\":{\"314\":1}}],[\"不出意外的话\",{\"1\":{\"293\":1}}],[\"不过\",{\"1\":{\"820\":1}}],[\"不过消费者需要在消费时指定拉取这个消费队列才可以消费\",{\"1\":{\"811\":1}}],[\"不过这个地方单线程处理\",{\"1\":{\"253\":1}}],[\"不过原子true和false具有特殊的含义\",{\"1\":{\"56\":1}}],[\"不可写\",{\"1\":{\"718\":1}}],[\"不可用\",{\"1\":{\"231\":1,\"561\":1}}],[\"不可变基础设施等特性\",{\"1\":{\"128\":1}}],[\"不仅能让业务使用\",{\"1\":{\"443\":1}}],[\"不仅让仲裁队列比镜像队列更可靠\",{\"1\":{\"229\":1}}],[\"不仅如此\",{\"1\":{\"211\":1,\"226\":1}}],[\"不仅需要模型的全面覆盖\",{\"1\":{\"127\":1}}],[\"不同模式下消费进度保存方式的不同\",{\"1\":{\"623\":1}}],[\"不同\",{\"1\":{\"410\":1,\"422\":1}}],[\"不同的消费队列可以复用\",{\"1\":{\"811\":1}}],[\"不同的消息可能得到相同的\",{\"1\":{\"306\":1}}],[\"不同的通讯请求字段不一样\",{\"1\":{\"410\":1}}],[\"不同的镜像队列形成不同的组\",{\"1\":{\"206\":1}}],[\"不同组件之间通过消息传递\",{\"1\":{\"154\":1}}],[\"不设置\",{\"1\":{\"190\":1}}],[\"不会存在一个客户端\",{\"1\":{\"770\":1}}],[\"不会主动将路由信息推送给客户端\",{\"1\":{\"475\":1}}],[\"不会主动调用其他模块\",{\"1\":{\"465\":1}}],[\"不会持久化\",{\"1\":{\"470\":1}}],[\"不会被持久化\",{\"1\":{\"469\":1}}],[\"不会立即投递到它本该去的\",{\"1\":{\"445\":1}}],[\"不会超过\",{\"1\":{\"426\":1}}],[\"不会产生大量缺页\",{\"1\":{\"399\":1}}],[\"不会阻塞\",{\"1\":{\"340\":1}}],[\"不会马上返回\",{\"1\":{\"324\":1}}],[\"不会丢数据\",{\"1\":{\"229\":1}}],[\"不会接受消息也不会处理消息\",{\"1\":{\"155\":1}}],[\"不会进行重试连接其他节点\",{\"1\":{\"134\":1}}],[\"不会有垃圾收集的负担\",{\"1\":{\"97\":1}}],[\"不用模拟客户端或者泛化调用之类的\",{\"1\":{\"123\":1}}],[\"不如分布式\",{\"1\":{\"87\":1}}],[\"不带交互式\",{\"1\":{\"74\":1}}],[\"不是一回事\",{\"1\":{\"45\":1}}],[\"不是一个变量\",{\"1\":{\"23\":1}}],[\"不成功\",{\"1\":{\"38\":1}}],[\"zip\",{\"1\":{\"562\":1,\"573\":1}}],[\"zookeeper\",{\"0\":{\"462\":1},\"1\":{\"461\":1,\"462\":11}}],[\"z0\",{\"1\":{\"424\":1}}],[\"zab\",{\"1\":{\"462\":1}}],[\"za\",{\"1\":{\"424\":1}}],[\"zero\",{\"1\":{\"406\":1,\"412\":1,\"414\":1,\"855\":1,\"858\":1}}],[\"z>\",{\"1\":{\"21\":1}}],[\"z\",{\"1\":{\"21\":3}}],[\"yes的练级攻略\",{\"1\":{\"858\":1}}],[\"yecc\",{\"1\":{\"21\":1}}],[\"yaml\",{\"1\":{\"516\":1}}],[\"yang\",{\"1\":{\"370\":1}}],[\"yml\",{\"1\":{\"499\":1,\"503\":1,\"510\":1,\"516\":1,\"595\":5,\"598\":2}}],[\"yourself\",{\"1\":{\"852\":1}}],[\"your\",{\"1\":{\"480\":1,\"693\":1}}],[\"you\",{\"1\":{\"139\":1,\"176\":1}}],[\"yunque\",{\"1\":{\"114\":1}}],[\"yuque\",{\"1\":{\"114\":1}}],[\"y\",{\"1\":{\"21\":5,\"26\":1,\"36\":4,\"38\":4,\"63\":2,\"67\":5,\"103\":3,\"176\":3}}],[\"xrunjdwp\",{\"1\":{\"600\":1}}],[\"xdebug\",{\"1\":{\"600\":1}}],[\"xor\",{\"1\":{\"56\":1}}],[\"xx1\",{\"1\":{\"526\":1}}],[\"xxx\",{\"1\":{\"365\":2,\"528\":4,\"693\":2,\"817\":2,\"828\":10}}],[\"xxxx\",{\"1\":{\"356\":1,\"484\":1}}],[\"xxl\",{\"1\":{\"123\":2}}],[\"xx\",{\"1\":{\"42\":1,\"526\":3,\"600\":5}}],[\"x2\",{\"1\":{\"41\":3}}],[\"x1\",{\"1\":{\"41\":3}}],[\"x||x<\",{\"1\":{\"34\":1}}],[\"x|y\",{\"1\":{\"27\":1}}],[\"x=\",{\"1\":{\"28\":1}}],[\"x和y都是未绑定变量\",{\"1\":{\"27\":1}}],[\"xmn128m\",{\"1\":{\"600\":4}}],[\"xmx128m\",{\"1\":{\"600\":4}}],[\"xmx8g\",{\"1\":{\"600\":1}}],[\"xms128m\",{\"1\":{\"600\":4}}],[\"xms8g\",{\"1\":{\"600\":1}}],[\"xml\",{\"1\":{\"480\":1}}],[\"xm\",{\"1\":{\"21\":1}}],[\"x\",{\"0\":{\"34\":2,\"174\":1,\"175\":1,\"293\":1},\"1\":{\"21\":5,\"23\":4,\"26\":1,\"28\":5,\"31\":10,\"34\":12,\"36\":4,\"37\":3,\"38\":4,\"41\":1,\"43\":6,\"44\":6,\"46\":9,\"63\":2,\"67\":4,\"85\":2,\"103\":12,\"175\":1,\"193\":1,\"198\":2,\"238\":1,\"253\":2,\"440\":3,\"594\":13,\"814\":3,\"815\":1,\"827\":3,\"830\":2,\"872\":5,\"873\":1,\"875\":1,\"876\":2}}],[\"命令以后\",{\"1\":{\"841\":1}}],[\"命令设置\",{\"1\":{\"648\":1}}],[\"命令行\",{\"0\":{\"186\":1}}],[\"命令行界面直接编译和运行\",{\"1\":{\"74\":1}}],[\"命令不方便设置复杂的入参\",{\"1\":{\"123\":1}}],[\"命令获取帮助\",{\"1\":{\"21\":1}}],[\"命令让shell忘记现有的任何绑定\",{\"1\":{\"21\":1}}],[\"甚至可以和\",{\"1\":{\"615\":1}}],[\"甚至可能造成节点需要重启\",{\"1\":{\"226\":1}}],[\"甚至作为\",{\"1\":{\"443\":1}}],[\"甚至节点内存会被打爆\",{\"1\":{\"374\":1}}],[\"甚至不得不放弃使用仲裁队列\",{\"1\":{\"234\":1}}],[\"甚至不使用任何镜像\",{\"1\":{\"195\":1}}],[\"甚至智能预测\",{\"1\":{\"127\":1}}],[\"甚至还可以生成一个安全shell\",{\"1\":{\"21\":1}}],[\"甚至每次调用方法前后都可以用\",{\"1\":{\"4\":1}}],[\"qps\",{\"1\":{\"433\":2}}],[\"qid\",{\"1\":{\"285\":2,\"365\":1}}],[\"qos\",{\"1\":{\"231\":1}}],[\"q4\",{\"1\":{\"223\":2}}],[\"q4五个子队列构成\",{\"1\":{\"223\":1}}],[\"q1和q4队列中只有alpha状态的消息\",{\"1\":{\"223\":1}}],[\"q1\",{\"1\":{\"223\":2}}],[\"q3\",{\"1\":{\"223\":5}}],[\"q2和q3包含beta和gamma状态的消息\",{\"1\":{\"223\":1}}],[\"q2\",{\"1\":{\"223\":5}}],[\"qlc\",{\"1\":{\"103\":7}}],[\"qsort\",{\"1\":{\"34\":4}}],[\"quorum\",{\"0\":{\"225\":1},\"1\":{\"161\":1,\"181\":1,\"208\":1,\"225\":3,\"238\":1}}],[\"questions\",{\"1\":{\"179\":1}}],[\"queuename\",{\"1\":{\"817\":7}}],[\"queuekey\",{\"1\":{\"816\":1}}],[\"queuelockmanager\",{\"1\":{\"790\":2}}],[\"queuemaxspanflowcontroltimes\",{\"1\":{\"690\":1}}],[\"queuemaxspanflowcontroltimes++\",{\"1\":{\"690\":1}}],[\"queueflowcontroltimes\",{\"1\":{\"690\":2}}],[\"queueflowcontroltimes++\",{\"1\":{\"690\":2}}],[\"queuedatalist\",{\"1\":{\"492\":3}}],[\"queuedata\",{\"1\":{\"484\":1,\"492\":4}}],[\"queuedata>>\",{\"1\":{\"484\":1}}],[\"queuedatas\",{\"1\":{\"470\":1,\"488\":3}}],[\"queue<putresultprocess>\",{\"1\":{\"380\":1}}],[\"queueoffsets\",{\"1\":{\"816\":3,\"817\":3}}],[\"queueoffsetassigner\",{\"1\":{\"816\":5}}],[\"queueoffset\",{\"1\":{\"257\":3,\"258\":1,\"816\":2,\"817\":5}}],[\"queueidint\",{\"1\":{\"576\":5,\"718\":3}}],[\"queueid=\",{\"1\":{\"343\":1,\"365\":1,\"380\":2,\"721\":1,\"851\":1}}],[\"queueid\",{\"1\":{\"257\":2,\"262\":1,\"271\":1,\"277\":1,\"284\":1,\"285\":2,\"287\":4,\"335\":2,\"339\":2,\"342\":3,\"343\":5,\"345\":5,\"348\":2,\"354\":4,\"356\":3,\"359\":3,\"363\":8,\"377\":1,\"426\":2,\"693\":5,\"694\":6,\"721\":8,\"789\":8,\"790\":21,\"791\":2,\"798\":6,\"799\":4,\"800\":6,\"808\":1,\"817\":12}}],[\"queue=\",{\"1\":{\"242\":1}}],[\"queue结构来看\",{\"1\":{\"223\":1}}],[\"queue模块实现\",{\"1\":{\"223\":1}}],[\"queue的匹配模式\",{\"1\":{\"185\":1}}],[\"queuesize\",{\"1\":{\"541\":1}}],[\"queues\",{\"0\":{\"225\":1},\"1\":{\"154\":2,\"161\":1,\"181\":1,\"186\":1,\"208\":1,\"212\":1,\"225\":4,\"238\":1,\"816\":4,\"817\":5}}],[\"queue\",{\"0\":{\"167\":1,\"293\":1,\"425\":1,\"802\":1},\"1\":{\"147\":3,\"152\":1,\"154\":2,\"155\":6,\"163\":2,\"165\":1,\"167\":1,\"169\":1,\"170\":4,\"180\":1,\"181\":1,\"186\":2,\"188\":2,\"193\":4,\"198\":1,\"201\":1,\"204\":1,\"205\":7,\"212\":1,\"220\":2,\"223\":1,\"266\":1,\"267\":1,\"269\":1,\"271\":1,\"275\":4,\"276\":1,\"285\":3,\"287\":1,\"291\":6,\"339\":1,\"354\":3,\"356\":6,\"361\":2,\"363\":1,\"365\":1,\"380\":1,\"387\":1,\"397\":1,\"398\":1,\"406\":2,\"425\":1,\"430\":7,\"445\":5,\"469\":1,\"492\":1,\"541\":1,\"572\":1,\"611\":1,\"614\":2,\"615\":1,\"646\":3,\"650\":1,\"690\":1,\"693\":3,\"694\":6,\"695\":2,\"715\":1,\"746\":1,\"750\":9,\"767\":1,\"773\":1,\"777\":1,\"786\":1,\"789\":5,\"790\":4,\"793\":1,\"798\":1,\"802\":1,\"804\":1,\"808\":1,\"810\":2,\"816\":4,\"817\":9,\"818\":1,\"820\":2,\"847\":1,\"852\":1,\"884\":1}}],[\"queryload\",{\"1\":{\"786\":5}}],[\"queryassignmentprocessor\",{\"0\":{\"786\":1,\"787\":1},\"1\":{\"775\":1}}],[\"querymsgtracebyid\",{\"1\":{\"528\":1}}],[\"querymsg\",{\"1\":{\"314\":1}}],[\"queryoffsetresult\",{\"1\":{\"314\":2}}],[\"queryoffset\",{\"1\":{\"309\":1,\"314\":2,\"798\":1}}],[\"query\",{\"1\":{\"21\":2,\"287\":4,\"694\":4}}],[\"quantity=n1\",{\"1\":{\"103\":1}}],[\"quantity=quantity\",{\"1\":{\"103\":1}}],[\"quantity\",{\"1\":{\"103\":11,\"159\":3}}],[\"qualifier2\",{\"1\":{\"34\":1}}],[\"qualifier1\",{\"1\":{\"34\":1}}],[\"quit\",{\"1\":{\"21\":1}}],[\"q\",{\"1\":{\"21\":2,\"103\":7,\"767\":2}}],[\"停止消费\",{\"1\":{\"715\":1}}],[\"停止接收信息\",{\"0\":{\"158\":1}}],[\"停止\",{\"1\":{\"21\":1}}],[\"基础信息表中的该\",{\"1\":{\"492\":1}}],[\"基础信息表\",{\"1\":{\"469\":1}}],[\"基础上实现高性能的\",{\"1\":{\"439\":1}}],[\"基于性能的考虑\",{\"1\":{\"462\":1}}],[\"基于定时消息实现如消息重投等功能\",{\"1\":{\"443\":1}}],[\"基于反射来解析和设置消息\",{\"1\":{\"262\":1,\"410\":1}}],[\"基于信用证的流控\",{\"0\":{\"152\":1}}],[\"基于套接字的分布式模型\",{\"1\":{\"87\":1}}],[\"基本流程\",{\"0\":{\"499\":1}}],[\"基本的问题是\",{\"1\":{\"210\":1}}],[\"基本函数从进程邮箱中提取消息\",{\"1\":{\"83\":1}}],[\"基本并发函数\",{\"0\":{\"79\":1}}],[\"基本上是\",{\"1\":{\"44\":1}}],[\"基本概念\",{\"0\":{\"20\":1,\"498\":1}}],[\"基准测试jmh\",{\"1\":{\"15\":1}}],[\"基准测试神器jmh\",{\"1\":{\"13\":1,\"15\":1}}],[\"基准测试工具\",{\"1\":{\"2\":1}}],[\"学习笔记\",{\"0\":{\"18\":1},\"1\":{\"141\":1}}],[\"论最强io\",{\"1\":{\"16\":1}}],[\"孰强孰弱\",{\"1\":{\"16\":1}}],[\"性能之道\",{\"1\":{\"858\":1}}],[\"性能可以达到十万级别\",{\"1\":{\"548\":1}}],[\"性能可以提升多个数量级\",{\"1\":{\"547\":1}}],[\"性能也更好\",{\"1\":{\"450\":1}}],[\"性能高\",{\"1\":{\"448\":2}}],[\"性能和可靠性\",{\"1\":{\"444\":1}}],[\"性能等方面无法都达到完美\",{\"1\":{\"442\":1}}],[\"性能更高\",{\"1\":{\"414\":1}}],[\"性能更好\",{\"1\":{\"227\":1}}],[\"性能对比\",{\"1\":{\"413\":1}}],[\"性能\",{\"0\":{\"257\":1},\"1\":{\"442\":1}}],[\"性能最关键的一个锁\",{\"1\":{\"253\":1,\"256\":1}}],[\"性能优化\",{\"0\":{\"239\":1,\"405\":1,\"407\":1},\"1\":{\"884\":2}}],[\"性能优化神器\",{\"0\":{\"1\":1},\"1\":{\"17\":1}}],[\"性能测试\",{\"1\":{\"136\":1}}],[\"性能明显下降\",{\"1\":{\"135\":1}}],[\"性能分析\",{\"0\":{\"104\":1}}],[\"性能调优必备利器之\",{\"1\":{\"15\":1}}],[\"自研了任意时间定时消息\",{\"1\":{\"872\":1}}],[\"自研的存储的目的是为了能够长期保存定时消息\",{\"1\":{\"448\":1}}],[\"自研存储\",{\"1\":{\"448\":1}}],[\"自助性能测试\",{\"1\":{\"15\":1}}],[\"自己实现基准测试代码时\",{\"1\":{\"3\":1}}],[\"自己写一个测试方法或者\",{\"1\":{\"2\":1}}],[\"与page\",{\"1\":{\"868\":1}}],[\"与内存中的\",{\"1\":{\"796\":1}}],[\"与服务端交互拉取消息\",{\"1\":{\"679\":1}}],[\"与消息队列一一对应\",{\"1\":{\"657\":1}}],[\"与消息的\",{\"1\":{\"201\":1}}],[\"与触发点\",{\"1\":{\"656\":1}}],[\"与集群一起用\",{\"0\":{\"598\":1}}],[\"与普通消息公用存储\",{\"1\":{\"530\":1}}],[\"与普通消息共用存储\",{\"1\":{\"448\":1}}],[\"与当前时间对比\",{\"1\":{\"474\":1}}],[\"与其他组件交互的示意图\",{\"1\":{\"465\":1}}],[\"与镜像队列类似\",{\"1\":{\"228\":1}}],[\"与存储相关的持久化包括队列的持久化和消息的持久化\",{\"1\":{\"216\":1}}],[\"与全局流控不是一个概念\",{\"1\":{\"147\":1}}],[\"与此同时\",{\"1\":{\"136\":1}}],[\"与可靠性不同\",{\"1\":{\"135\":1}}],[\"与越来越多的容器化架构应用的出现\",{\"1\":{\"126\":1}}],[\"与进程同步创建\",{\"1\":{\"79\":1}}],[\"与映射组\",{\"0\":{\"40\":1}}],[\"与\",{\"0\":{\"462\":1,\"601\":1,\"781\":1,\"794\":1,\"855\":1},\"1\":{\"15\":1,\"135\":1,\"280\":1,\"309\":1,\"556\":1,\"615\":1,\"769\":1,\"773\":1,\"778\":1,\"798\":1,\"810\":1,\"811\":1}}],[\"拾遗\",{\"1\":{\"15\":1}}],[\"详解\",{\"0\":{\"385\":1,\"459\":1,\"495\":1,\"866\":1},\"1\":{\"884\":2}}],[\"详解36个官方例子\",{\"1\":{\"13\":1,\"15\":1}}],[\"详情请参阅未同步的镜像部分\",{\"1\":{\"191\":1}}],[\"详细记录消息各个处理环节的日志\",{\"1\":{\"523\":1}}],[\"详细的逻辑结构\",{\"1\":{\"305\":1}}],[\"详细设计\",{\"0\":{\"274\":1,\"304\":1,\"466\":1,\"533\":1,\"554\":1,\"582\":1,\"633\":1,\"651\":1,\"674\":1,\"705\":1,\"730\":1,\"774\":1,\"812\":1,\"836\":1}}],[\"详细流程\",{\"0\":{\"153\":1,\"327\":1,\"355\":1}}],[\"详细讲解了它的可靠性模型和弹性模型的工作原理\",{\"1\":{\"125\":1}}],[\"详见该项目\",{\"1\":{\"769\":1}}],[\"详见\",{\"1\":{\"13\":1,\"872\":1}}],[\"高水位线通过\",{\"1\":{\"820\":1}}],[\"高水位为\",{\"1\":{\"819\":1}}],[\"高可用设计\",{\"0\":{\"551\":1}}],[\"高可靠的原理\",{\"1\":{\"544\":1}}],[\"高可靠\",{\"1\":{\"443\":1}}],[\"高精度\",{\"1\":{\"443\":1}}],[\"高性能\",{\"1\":{\"443\":1}}],[\"高性能优化之路\",{\"1\":{\"263\":1}}],[\"高性能程序时有没有这样的场景\",{\"1\":{\"2\":1}}],[\"高阶函数\",{\"0\":{\"31\":1}}],[\"高级用法\",{\"0\":{\"13\":1}}],[\"注销\",{\"1\":{\"850\":1}}],[\"注册过滤信息\",{\"0\":{\"850\":1}}],[\"注册消费者时会预先编译好\",{\"1\":{\"841\":1}}],[\"注册消费者时就会把过滤信息\",{\"1\":{\"839\":1}}],[\"注册消费者到客户端实例\",{\"1\":{\"642\":1}}],[\"注册消息过滤钩子函数列表\",{\"1\":{\"640\":1,\"642\":1}}],[\"注册消息轨迹采集钩子\",{\"0\":{\"539\":1},\"1\":{\"539\":1}}],[\"注册发送消息处理器\",{\"0\":{\"575\":1}}],[\"注册服务\",{\"1\":{\"567\":1}}],[\"注册不同的业务处理器和线程池去处理\",{\"1\":{\"563\":1}}],[\"注册了\",{\"1\":{\"556\":1}}],[\"注册到\",{\"1\":{\"557\":1}}],[\"注册到生产者或消费者实例中去\",{\"1\":{\"534\":1}}],[\"注册到客户端\",{\"1\":{\"504\":1,\"505\":1}}],[\"注册钩子函数\",{\"1\":{\"500\":1}}],[\"注册后更新\",{\"1\":{\"490\":1}}],[\"注册\",{\"0\":{\"508\":1,\"514\":1},\"1\":{\"473\":1,\"480\":1,\"491\":1,\"508\":1,\"514\":1,\"850\":1}}],[\"注册进程\",{\"0\":{\"84\":1}}],[\"注意需要重启\",{\"1\":{\"525\":1}}],[\"注意这个\",{\"1\":{\"778\":1}}],[\"注意这个值是从\",{\"1\":{\"307\":1}}],[\"注意这里还未强制刷盘\",{\"1\":{\"817\":1}}],[\"注意这里有一句\",{\"1\":{\"424\":1}}],[\"注意这里会创建\",{\"1\":{\"309\":1,\"314\":1}}],[\"注意该函数的入参中有一个cqoffset\",{\"1\":{\"285\":1}}],[\"注意事项\",{\"0\":{\"194\":1},\"1\":{\"610\":1}}],[\"注意此时需要指定安装\",{\"1\":{\"177\":1}}],[\"注意\",{\"1\":{\"157\":1,\"158\":1,\"285\":1,\"306\":1,\"500\":1,\"559\":1,\"600\":1,\"623\":1,\"842\":1}}],[\"注\",{\"1\":{\"135\":1}}],[\"注释\",{\"1\":{\"21\":1}}],[\"注释详解\",{\"0\":{\"12\":1}}],[\"注解来设置启动和停止的方法\",{\"1\":{\"4\":1}}],[\"注解中可以指定执行的迭代次数和每次迭代的执行时常\",{\"1\":{\"4\":1}}],[\"注解的代码在编译之后会被编译成多个执行类以进行基准测试结果输出\",{\"1\":{\"4\":1}}],[\"uuid\",{\"1\":{\"541\":1}}],[\"url\",{\"1\":{\"493\":1,\"567\":1,\"642\":1,\"693\":1}}],[\"urgent\",{\"1\":{\"41\":2}}],[\"u0001true\",{\"1\":{\"262\":1,\"410\":1}}],[\"u0001taga\",{\"1\":{\"262\":1,\"410\":1}}],[\"u0001value2\",{\"1\":{\"260\":1}}],[\"u0001value1\",{\"1\":{\"260\":1}}],[\"u0002wait\",{\"1\":{\"262\":1,\"410\":1}}],[\"u0002\",{\"1\":{\"260\":2,\"262\":1,\"410\":1}}],[\"u0002key2\",{\"1\":{\"260\":1}}],[\"utf\",{\"1\":{\"873\":1}}],[\"utf8\",{\"1\":{\"257\":4}}],[\"utilall\",{\"1\":{\"258\":1,\"313\":1,\"490\":1,\"537\":2,\"717\":1,\"718\":2,\"755\":1,\"851\":1}}],[\"util\",{\"1\":{\"117\":1,\"528\":1}}],[\"ubuntu\",{\"1\":{\"174\":1,\"176\":4,\"177\":3,\"594\":26,\"595\":3,\"597\":1,\"599\":6}}],[\"ubirth\",{\"1\":{\"116\":1}}],[\"ui\",{\"1\":{\"147\":1,\"155\":1}}],[\"ui可以观察到\",{\"1\":{\"146\":1}}],[\"uewell\",{\"1\":{\"116\":1}}],[\"upgrade\",{\"1\":{\"691\":1}}],[\"upgraded\",{\"1\":{\"176\":2}}],[\"up\",{\"1\":{\"365\":1,\"406\":1,\"433\":2,\"595\":3,\"597\":1,\"599\":4}}],[\"upstream\",{\"0\":{\"170\":1},\"1\":{\"163\":2,\"169\":1,\"171\":2}}],[\"updatepullfromwhichnode\",{\"1\":{\"848\":1}}],[\"updateprocessqueuetableinrebalance\",{\"0\":{\"664\":1},\"1\":{\"654\":1,\"657\":1,\"663\":2,\"664\":1,\"733\":1,\"744\":1}}],[\"updated\",{\"1\":{\"720\":1}}],[\"updateconsumeroffsetoneway\",{\"1\":{\"720\":1}}],[\"updateconsumeroffsetrequestheader\",{\"1\":{\"720\":2}}],[\"updateconsumeroffset\",{\"1\":{\"711\":1,\"720\":1}}],[\"updateconsumeoffsettobroker\",{\"1\":{\"711\":1,\"720\":4}}],[\"updateconsumeoffset\",{\"1\":{\"637\":1}}],[\"updatesubgroup\",{\"1\":{\"648\":1}}],[\"updatetopicsubscribeinfowhensubscriptionchanged\",{\"1\":{\"642\":1}}],[\"updatetopicrouteinfofromnameserver\",{\"1\":{\"476\":1,\"568\":2,\"571\":2,\"691\":1,\"720\":1,\"808\":1}}],[\"updatefaultitem\",{\"1\":{\"570\":1}}],[\"updateoffset\",{\"1\":{\"365\":3,\"381\":1,\"624\":1,\"695\":1,\"711\":1,\"715\":1}}],[\"update的定义\",{\"1\":{\"157\":1}}],[\"update\",{\"1\":{\"42\":2,\"103\":2,\"157\":3,\"158\":1,\"159\":3,\"160\":1,\"177\":1,\"257\":2,\"665\":2,\"720\":2,\"721\":1,\"732\":1,\"786\":1,\"790\":1}}],[\"uptime\",{\"1\":{\"21\":2}}],[\"usr\",{\"1\":{\"74\":1}}],[\"using\",{\"1\":{\"21\":1,\"177\":1,\"573\":2}}],[\"useful\",{\"1\":{\"798\":1}}],[\"usebiasedlocking\",{\"1\":{\"600\":1}}],[\"uselargepages\",{\"1\":{\"600\":1}}],[\"used\",{\"1\":{\"157\":1,\"176\":1,\"287\":1,\"694\":1}}],[\"usereentrantlockwhenputmessage\",{\"1\":{\"240\":1,\"252\":1,\"253\":1}}],[\"user\",{\"1\":{\"121\":1,\"515\":1,\"520\":1}}],[\"use\",{\"1\":{\"11\":1,\"21\":1,\"406\":1,\"430\":1,\"541\":1,\"768\":1,\"807\":1}}],[\"unknown\",{\"1\":{\"850\":1}}],[\"unused\",{\"1\":{\"720\":1}}],[\"unusedmq\",{\"1\":{\"720\":4}}],[\"unmodifiablelist\",{\"1\":{\"715\":1,\"750\":1}}],[\"unsupported\",{\"1\":{\"786\":1}}],[\"unsubscribe\",{\"1\":{\"637\":1}}],[\"unselected\",{\"1\":{\"176\":1}}],[\"unneccessary\",{\"1\":{\"515\":1}}],[\"unnecessary\",{\"1\":{\"406\":1,\"427\":1,\"664\":2}}],[\"unlockdelay\",{\"1\":{\"745\":1}}],[\"unlock\",{\"1\":{\"313\":2,\"314\":1,\"392\":1,\"491\":1,\"492\":2,\"742\":1,\"745\":2,\"750\":1,\"790\":1}}],[\"unconfigured\",{\"1\":{\"176\":1}}],[\"unpacking\",{\"1\":{\"176\":1,\"178\":1}}],[\"unpack\",{\"1\":{\"176\":1,\"178\":1}}],[\"untitled\",{\"1\":{\"157\":1,\"244\":1,\"245\":1,\"246\":1,\"248\":1,\"250\":1,\"251\":2,\"257\":2,\"260\":1,\"261\":3,\"275\":1,\"287\":1,\"293\":1,\"306\":1,\"307\":1,\"309\":1,\"345\":1}}],[\"unblocked\",{\"1\":{\"160\":1}}],[\"unblock\",{\"1\":{\"146\":1,\"159\":1,\"160\":4}}],[\"uniq\",{\"1\":{\"793\":1}}],[\"uniqkey\",{\"1\":{\"314\":3}}],[\"unique\",{\"1\":{\"262\":1,\"410\":1,\"419\":1,\"573\":1,\"807\":1}}],[\"unitname\",{\"1\":{\"556\":1,\"755\":4}}],[\"unit\",{\"1\":{\"285\":2,\"287\":1,\"291\":2,\"365\":3,\"380\":3,\"694\":3,\"847\":1,\"852\":1}}],[\"unitmode\",{\"1\":{\"262\":1}}],[\"units\",{\"1\":{\"11\":1,\"261\":1}}],[\"unix\",{\"1\":{\"138\":1}}],[\"unregisterbroker\",{\"1\":{\"474\":1}}],[\"unregister\",{\"1\":{\"84\":1,\"850\":2}}],[\"undef\",{\"1\":{\"64\":1}}],[\"undefined\",{\"1\":{\"41\":1,\"67\":3,\"84\":1,\"105\":1,\"157\":2,\"160\":1}}],[\"understanding\",{\"1\":{\"15\":1}}],[\"耗时进行采样形成火焰图\",{\"1\":{\"437\":1}}],[\"耗时开销很大\",{\"1\":{\"420\":1}}],[\"耗时百分比的原因\",{\"1\":{\"416\":1}}],[\"耗时都较小\",{\"1\":{\"245\":1}}],[\"耗时\",{\"1\":{\"11\":1,\"537\":1}}],[\"所使用的大小的一个值\",{\"1\":{\"820\":1}}],[\"所在的\",{\"1\":{\"559\":1,\"561\":1,\"572\":2}}],[\"所在区域\",{\"1\":{\"537\":1}}],[\"所属集群是否存在\",{\"1\":{\"491\":1}}],[\"所属集群名称\",{\"1\":{\"469\":1}}],[\"所属\",{\"1\":{\"484\":1}}],[\"所处的类所在的包是\",{\"1\":{\"347\":1}}],[\"所以第一条消息会阻塞后续消息的投递\",{\"1\":{\"876\":1}}],[\"所以先根据消费队列进行一次过滤\",{\"1\":{\"833\":1}}],[\"所以先创建一个位图\",{\"1\":{\"424\":1}}],[\"所以一个\",{\"1\":{\"778\":1}}],[\"所以重平衡时对每个消费者执行\",{\"1\":{\"775\":1}}],[\"所以是向\",{\"1\":{\"772\":1}}],[\"所以真正安全的幂等处理\",{\"1\":{\"757\":1}}],[\"所以每个消费组都有一组锁\",{\"1\":{\"732\":1}}],[\"所以每个索引文件不应超过\",{\"1\":{\"447\":1}}],[\"所以也有可能并发消费一个队列中的多个消息\",{\"1\":{\"723\":1}}],[\"所以即便是已经保存在\",{\"1\":{\"708\":1}}],[\"所以定义了一个消费消息服务接口\",{\"1\":{\"707\":1}}],[\"所以消费进度可以存在本地\",{\"1\":{\"701\":1}}],[\"所以消息的消费进度需要统一保存\",{\"1\":{\"623\":1}}],[\"所以消息队列\",{\"1\":{\"610\":1}}],[\"所以如果业务对消费重复非常敏感\",{\"1\":{\"757\":1}}],[\"所以如果是从子节点拉消息\",{\"1\":{\"691\":1}}],[\"所以如果客户端创建时开启了消息轨迹功能\",{\"1\":{\"534\":1}}],[\"所以并没有选择每次都创建新的\",{\"1\":{\"675\":1}}],[\"所以整个客户端实例只需要一个共用线程就足够了\",{\"1\":{\"675\":1}}],[\"所以整个队列不会因为新的副本加入而收到影响\",{\"1\":{\"229\":1}}],[\"所以拉取流程并不复杂\",{\"1\":{\"671\":1}}],[\"所以按通常的想法\",{\"1\":{\"636\":1}}],[\"所以对于消息是否成功发送到\",{\"1\":{\"523\":1}}],[\"所以保存在磁盘中为妙\",{\"1\":{\"455\":1}}],[\"所以异常消息的重投就十分重要\",{\"1\":{\"454\":1}}],[\"所以频率就是\",{\"1\":{\"451\":1}}],[\"所以时间跨度定为\",{\"1\":{\"447\":1}}],[\"所以本文中所实现的定时消息效果也可以用作延迟消息使用\",{\"1\":{\"440\":1}}],[\"所以改成\",{\"1\":{\"429\":1}}],[\"所以改用可重入锁\",{\"1\":{\"253\":1}}],[\"所以可以通过批量发送的方式减少性能损耗\",{\"1\":{\"530\":1}}],[\"所以可以通过逻辑下标计算出索引项在索引文件中的绝对偏移量\",{\"1\":{\"307\":1}}],[\"所以可以增加一个判断\",{\"1\":{\"423\":1}}],[\"所以耗时较高\",{\"1\":{\"419\":1}}],[\"所以很有优化的必要\",{\"1\":{\"410\":1}}],[\"所以该特性增大数据丢失的风险\",{\"1\":{\"403\":1}}],[\"所以只介绍推模式消费者的启动流程\",{\"1\":{\"640\":1}}],[\"所以只会存在一个\",{\"1\":{\"532\":1}}],[\"所以只会从\",{\"1\":{\"403\":1}}],[\"所以只要知道消息在\",{\"1\":{\"271\":1}}],[\"所以性能比随机读写好很多\",{\"1\":{\"396\":1}}],[\"所以需要一个地方保存真正的\",{\"1\":{\"708\":1}}],[\"所以需要一个桥梁\",{\"1\":{\"347\":1}}],[\"所以需要共享消费进度\",{\"1\":{\"701\":1}}],[\"所以需要提交消费进度\",{\"1\":{\"623\":1}}],[\"所以需要提前手动修改\",{\"1\":{\"595\":1}}],[\"所以需要主动从\",{\"1\":{\"559\":1}}],[\"所以需要在消息生产和消费时采集一些数据\",{\"1\":{\"530\":1}}],[\"所以需要消费者线程从队列中消费并判断这些异步投递任务的状态\",{\"1\":{\"375\":1}}],[\"所以暂时先直接跳过该条消息\",{\"1\":{\"365\":1}}],[\"所以这里不会加入到内存\",{\"1\":{\"779\":1}}],[\"所以这里只讨论\",{\"1\":{\"355\":1}}],[\"所以这些配置大多为\",{\"1\":{\"517\":1}}],[\"所以这个表会定期持久化到磁盘中\",{\"1\":{\"377\":1}}],[\"所以这个\",{\"1\":{\"7\":1}}],[\"所以不存在写竟争问题\",{\"1\":{\"313\":1}}],[\"所以不需要加锁\",{\"1\":{\"285\":1}}],[\"所以不会因为脑裂而丢数据\",{\"1\":{\"229\":1}}],[\"所以引入了\",{\"1\":{\"267\":1}}],[\"所以同一\",{\"1\":{\"267\":1}}],[\"所以优化方案就是先算好需要的长度\",{\"1\":{\"261\":1}}],[\"所以建议手动设置\",{\"1\":{\"760\":1}}],[\"所以建议\",{\"1\":{\"254\":1}}],[\"所以它的队列\",{\"1\":{\"813\":1}}],[\"所以它不能用普通消息的消费组维度的重试\",{\"1\":{\"783\":1}}],[\"所以它可以批量处理这\",{\"1\":{\"244\":1}}],[\"所以它也可能被多个进程阻塞\",{\"1\":{\"158\":1}}],[\"所以\",{\"1\":{\"236\":1,\"723\":1,\"758\":1,\"875\":1,\"876\":1}}],[\"所以当使用仲裁队列时\",{\"1\":{\"235\":1}}],[\"所以当有大量消息持续发往某个进程时\",{\"1\":{\"144\":1}}],[\"所以发布\",{\"1\":{\"234\":1}}],[\"所以在slave中在doreput\",{\"1\":{\"817\":1}}],[\"所以在内存中就能够与\",{\"1\":{\"773\":1}}],[\"所以在重试时会尽量避开刚刚发送失败的\",{\"1\":{\"552\":1}}],[\"所以在重要业务中使用同步刷盘确保数据不丢失\",{\"1\":{\"285\":1}}],[\"所以在被重新投递之前\",{\"1\":{\"356\":1}}],[\"所以在这个情况下的写入放大是\",{\"1\":{\"233\":1}}],[\"所以在仲裁队列和镜像队列之间的选择不是一个容易的事情\",{\"1\":{\"227\":1}}],[\"所以说仲裁队列相对于可用性更看重一致性\",{\"1\":{\"228\":1}}],[\"所以说虽然理论上消息会按照q1\",{\"1\":{\"223\":1}}],[\"所以我管它叫做仲裁队列\",{\"1\":{\"228\":1}}],[\"所以我在寻找一种可以不停机的开发方法\",{\"1\":{\"120\":1}}],[\"所以运维有时就不会选择进行消息同步\",{\"1\":{\"226\":1}}],[\"所以delta队列并不在内存中\",{\"1\":{\"223\":1}}],[\"所以镜像队列的消费需要由\",{\"1\":{\"202\":1}}],[\"所以从节点的状态与主节点应是一致的\",{\"1\":{\"182\":1}}],[\"所得到的值\",{\"1\":{\"38\":1}}],[\"所下的是一种断言\",{\"1\":{\"23\":1}}],[\"所有消费者收到后唤醒重平衡线程进行重平衡\",{\"1\":{\"656\":1}}],[\"所有消息都会保存到每个副本的磁盘中\",{\"1\":{\"237\":1}}],[\"所有消息都是持久化的\",{\"1\":{\"237\":1}}],[\"所有消息一直保存在内存中\",{\"0\":{\"235\":1}}],[\"所有acl配置文件绝对路径\",{\"1\":{\"519\":1}}],[\"所有指令当前共用了一个通用的解析方法\",{\"1\":{\"410\":1}}],[\"所有\",{\"1\":{\"372\":1,\"810\":1}}],[\"所有问题的源头来自于节点的宕机\",{\"1\":{\"226\":1}}],[\"所有文件数据大小\",{\"1\":{\"221\":1}}],[\"所有队列的消息\",{\"1\":{\"777\":2}}],[\"所有队列共同使用\",{\"1\":{\"220\":1}}],[\"所有队列操作首先经过主队列\",{\"1\":{\"193\":1}}],[\"所有新消息都将被复制\",{\"1\":{\"211\":1}}],[\"所有镜像队列都会自动同步\",{\"1\":{\"211\":1}}],[\"所有的\",{\"1\":{\"207\":1}}],[\"所有变更都能随时生效\",{\"1\":{\"120\":1}}],[\"所有变量名都必须以大写字母开头\",{\"1\":{\"23\":1}}],[\"所有键都是原子\",{\"1\":{\"41\":1}}],[\"所有测试执行完毕\",{\"1\":{\"11\":1}}],[\"≈\",{\"1\":{\"11\":1}}],[\"8g\",{\"1\":{\"599\":1}}],[\"85\",{\"1\":{\"384\":1,\"386\":1}}],[\"8563\",{\"1\":{\"123\":1}}],[\"8m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"8万\",{\"1\":{\"135\":1}}],[\"8次故障期间\",{\"1\":{\"134\":1}}],[\"8080\",{\"1\":{\"597\":1,\"598\":1,\"601\":1}}],[\"80\",{\"1\":{\"126\":1}}],[\"81\",{\"1\":{\"32\":1}}],[\"8734\",{\"1\":{\"28\":1}}],[\"871\",{\"1\":{\"11\":1}}],[\"83\",{\"1\":{\"28\":3}}],[\"831\",{\"1\":{\"11\":2}}],[\"8>\",{\"1\":{\"27\":1,\"31\":1,\"67\":1,\"105\":1}}],[\"82\",{\"1\":{\"26\":1}}],[\"8\",{\"0\":{\"225\":1,\"256\":1,\"695\":1},\"1\":{\"15\":1,\"27\":1,\"31\":5,\"32\":1,\"34\":1,\"103\":1,\"176\":4,\"181\":2,\"208\":1,\"225\":2,\"238\":1,\"257\":2,\"258\":3,\"317\":4,\"414\":1,\"484\":2,\"488\":2,\"599\":1,\"767\":1,\"768\":2,\"834\":1,\"839\":1,\"873\":1,\"878\":1}}],[\"8994\",{\"1\":{\"11\":2}}],[\"8815\",{\"1\":{\"11\":1}}],[\"ng\",{\"1\":{\"593\":2}}],[\"nums\",{\"1\":{\"718\":2}}],[\"num\",{\"1\":{\"317\":1,\"694\":2,\"767\":1}}],[\"number\",{\"1\":{\"103\":3,\"541\":1,\"816\":1}}],[\"null\",{\"1\":{\"257\":11,\"258\":2,\"262\":21,\"282\":2,\"285\":1,\"287\":6,\"313\":5,\"314\":5,\"316\":1,\"317\":6,\"339\":2,\"340\":1,\"342\":2,\"345\":5,\"347\":1,\"364\":2,\"365\":6,\"380\":4,\"381\":3,\"390\":2,\"392\":2,\"411\":4,\"414\":6,\"480\":7,\"481\":2,\"490\":2,\"491\":10,\"492\":7,\"493\":3,\"514\":1,\"515\":6,\"516\":1,\"518\":6,\"520\":6,\"540\":10,\"541\":4,\"567\":2,\"568\":3,\"570\":11,\"571\":1,\"572\":3,\"573\":11,\"576\":3,\"642\":3,\"643\":2,\"662\":1,\"663\":7,\"664\":1,\"690\":4,\"691\":4,\"692\":3,\"693\":13,\"694\":15,\"695\":3,\"715\":6,\"717\":1,\"718\":13,\"720\":5,\"721\":2,\"742\":2,\"744\":1,\"746\":2,\"749\":2,\"750\":5,\"786\":15,\"789\":4,\"790\":5,\"793\":1,\"796\":1,\"798\":4,\"799\":2,\"800\":5,\"808\":1,\"817\":1,\"828\":12,\"830\":3,\"847\":2,\"848\":2,\"850\":7,\"851\":5,\"852\":18}}],[\"n表示\",{\"1\":{\"138\":1}}],[\"n1\",{\"1\":{\"103\":1}}],[\"native\",{\"1\":{\"599\":1}}],[\"nativelong\",{\"1\":{\"402\":2}}],[\"napples\",{\"1\":{\"103\":2}}],[\"names\",{\"1\":{\"595\":1,\"597\":1,\"599\":2}}],[\"namesrvutil\",{\"1\":{\"493\":1}}],[\"namesrvaddr\",{\"1\":{\"490\":4}}],[\"namesrv\",{\"1\":{\"480\":3,\"491\":1,\"494\":1,\"595\":2,\"598\":3,\"600\":6,\"601\":2,\"640\":2,\"642\":1,\"643\":1}}],[\"namesrvconfig\",{\"1\":{\"480\":11}}],[\"namesrvcontroller\",{\"0\":{\"481\":1},\"1\":{\"467\":4,\"480\":12,\"481\":2,\"493\":3}}],[\"namesrvstartup\",{\"1\":{\"467\":3,\"480\":3}}],[\"nameserveraddresslist\",{\"1\":{\"490\":5}}],[\"nameserver\",{\"0\":{\"459\":1,\"461\":1,\"462\":1,\"467\":1,\"469\":1,\"473\":1,\"477\":1,\"479\":1,\"483\":1,\"491\":1},\"1\":{\"459\":1,\"461\":9,\"462\":4,\"463\":1,\"464\":3,\"465\":10,\"467\":3,\"469\":2,\"470\":2,\"471\":1,\"472\":3,\"473\":1,\"474\":3,\"475\":3,\"477\":1,\"480\":3,\"483\":1,\"491\":1,\"493\":2,\"494\":1,\"550\":5,\"556\":1,\"557\":1,\"559\":3,\"562\":1,\"567\":1,\"573\":1,\"595\":1,\"597\":1,\"601\":1,\"691\":1,\"810\":1,\"811\":1,\"884\":1}}],[\"namespaceutil\",{\"1\":{\"540\":3,\"573\":2,\"717\":1,\"718\":1}}],[\"namespace\",{\"0\":{\"421\":1},\"1\":{\"406\":1,\"421\":1,\"422\":3,\"423\":4,\"493\":1,\"539\":3,\"570\":1,\"717\":1,\"718\":2}}],[\"name2loadstrategy\",{\"1\":{\"786\":1}}],[\"name2\",{\"1\":{\"53\":1}}],[\"name=\",{\"1\":{\"28\":1}}],[\"name\",{\"1\":{\"26\":2,\"30\":2,\"53\":1,\"103\":4,\"185\":1,\"186\":1,\"262\":1,\"406\":1,\"410\":1,\"414\":1,\"424\":1,\"480\":7,\"490\":4,\"493\":1,\"567\":2,\"568\":1,\"593\":1,\"595\":1,\"597\":1,\"598\":1,\"600\":3,\"601\":1,\"640\":1,\"642\":2,\"643\":1,\"680\":1,\"693\":1,\"715\":1,\"718\":1,\"750\":1,\"767\":2,\"786\":1,\"789\":1,\"807\":3,\"808\":3}}],[\"nwant\",{\"1\":{\"103\":5}}],[\"nregs\",{\"1\":{\"21\":1}}],[\"nl\",{\"1\":{\"21\":1}}],[\"nc\",{\"1\":{\"21\":1}}],[\"nearby\",{\"1\":{\"494\":1}}],[\"nemesrvstartup\",{\"0\":{\"480\":1}}],[\"needretry\",{\"1\":{\"789\":3}}],[\"neededperm\",{\"1\":{\"520\":3}}],[\"needcheckedentry\",{\"1\":{\"520\":3}}],[\"needcheckedpermmap\",{\"1\":{\"520\":4}}],[\"needcheckedaccess\",{\"1\":{\"520\":6}}],[\"needadminperm\",{\"1\":{\"520\":1}}],[\"need2skip\",{\"1\":{\"381\":1}}],[\"need2blocked\",{\"1\":{\"380\":1}}],[\"need\",{\"1\":{\"176\":1,\"257\":2,\"345\":1,\"520\":1,\"576\":1,\"720\":1,\"807\":1}}],[\"network\",{\"1\":{\"595\":1}}],[\"networked\",{\"1\":{\"21\":1}}],[\"net\",{\"1\":{\"158\":1,\"197\":1,\"600\":3,\"601\":1}}],[\"netflix最初为了搬迁基础设施上云创建了\",{\"1\":{\"126\":1}}],[\"nettyclientconfig\",{\"1\":{\"854\":1}}],[\"nettyclientpublicexecutorthreadpool\",{\"1\":{\"624\":1}}],[\"nettysystemconfig\",{\"1\":{\"819\":1}}],[\"nettyserverconfig\",{\"0\":{\"819\":1},\"1\":{\"480\":8,\"481\":2,\"854\":1,\"884\":1}}],[\"nettyserver\",{\"1\":{\"463\":1}}],[\"nettyrequestprocessor\",{\"1\":{\"575\":1}}],[\"nettyremotingabstract\",{\"1\":{\"508\":1,\"514\":2}}],[\"nettyremotingclient\",{\"1\":{\"508\":1,\"514\":3,\"562\":1,\"675\":1,\"685\":1,\"734\":1}}],[\"nettyremotingserver\",{\"1\":{\"481\":2,\"508\":1,\"514\":1}}],[\"nettyencoder\",{\"1\":{\"414\":1}}],[\"netty\",{\"0\":{\"819\":1},\"1\":{\"117\":2,\"414\":3,\"416\":1,\"417\":1,\"437\":1,\"467\":4,\"480\":6,\"481\":2,\"487\":1,\"528\":1,\"563\":1,\"790\":1,\"819\":4,\"820\":13,\"884\":1}}],[\"nextint\",{\"1\":{\"718\":2,\"789\":1}}],[\"nextindextoread\",{\"1\":{\"317\":4}}],[\"nextbeginoffset\",{\"1\":{\"694\":10,\"695\":1,\"795\":3}}],[\"nextlong\",{\"1\":{\"570\":1}}],[\"nextoffsetcorrection\",{\"1\":{\"694\":7}}],[\"nextoffset=\",{\"1\":{\"365\":1}}],[\"nextoffset\",{\"1\":{\"365\":10,\"380\":7,\"664\":4,\"689\":1,\"744\":4}}],[\"nextphyfilestartoffset\",{\"1\":{\"287\":1,\"694\":5}}],[\"next\",{\"1\":{\"103\":1,\"291\":1,\"307\":1,\"491\":1,\"492\":6,\"664\":4,\"744\":4,\"797\":1,\"851\":1}}],[\"newmq\",{\"1\":{\"787\":2}}],[\"newmsg\",{\"1\":{\"717\":10}}],[\"newtopic\",{\"1\":{\"718\":8}}],[\"newoffset=\",{\"1\":{\"693\":1}}],[\"newoffset\",{\"1\":{\"690\":2,\"748\":2,\"799\":8}}],[\"newval\",{\"1\":{\"665\":6}}],[\"newversion\",{\"1\":{\"665\":3}}],[\"newfixedthreadpool\",{\"1\":{\"481\":1}}],[\"newestoffset\",{\"1\":{\"345\":4}}],[\"newinstance\",{\"1\":{\"262\":1}}],[\"newlastmodifiedtime\",{\"1\":{\"519\":3}}],[\"newly\",{\"1\":{\"176\":1}}],[\"newline\",{\"1\":{\"139\":1}}],[\"newastate\",{\"1\":{\"157\":6}}],[\"newspaper\",{\"1\":{\"27\":6}}],[\"new\",{\"1\":{\"9\":2,\"98\":1,\"161\":1,\"176\":1,\"198\":1,\"257\":4,\"258\":1,\"262\":4,\"313\":5,\"314\":2,\"335\":1,\"339\":1,\"340\":3,\"342\":1,\"345\":2,\"355\":1,\"364\":3,\"365\":5,\"380\":1,\"381\":1,\"389\":1,\"390\":1,\"392\":1,\"400\":1,\"402\":3,\"424\":1,\"470\":1,\"480\":12,\"481\":7,\"488\":1,\"490\":5,\"491\":6,\"504\":4,\"505\":6,\"514\":1,\"515\":2,\"516\":1,\"517\":6,\"518\":10,\"519\":6,\"520\":6,\"526\":2,\"527\":3,\"539\":3,\"540\":4,\"541\":6,\"567\":3,\"568\":6,\"570\":2,\"571\":1,\"573\":6,\"575\":1,\"576\":1,\"642\":7,\"643\":1,\"663\":2,\"664\":6,\"688\":1,\"690\":1,\"691\":3,\"693\":8,\"694\":3,\"695\":2,\"714\":3,\"715\":4,\"717\":1,\"718\":1,\"720\":3,\"721\":2,\"742\":6,\"744\":6,\"746\":1,\"750\":3,\"755\":3,\"767\":5,\"768\":3,\"786\":2,\"787\":3,\"789\":1,\"791\":1,\"793\":2,\"795\":1,\"798\":4,\"800\":3,\"807\":2,\"808\":4,\"816\":1,\"817\":1,\"819\":1,\"820\":1,\"826\":2,\"827\":1,\"829\":2,\"830\":1,\"848\":1,\"850\":2,\"851\":1,\"852\":1,\"854\":1,\"873\":1}}],[\"nio\",{\"1\":{\"285\":1,\"400\":1}}],[\"nil\",{\"1\":{\"38\":1}}],[\"ni\",{\"1\":{\"21\":1}}],[\"n\",{\"1\":{\"21\":4,\"24\":2,\"30\":4,\"33\":2,\"34\":5,\"43\":8,\"44\":6,\"45\":2,\"111\":3,\"176\":1,\"195\":1,\"480\":2,\"504\":1,\"505\":2,\"526\":1,\"527\":2,\"528\":1,\"723\":2,\"767\":1,\"768\":3,\"787\":3,\"829\":1}}],[\"nomsgcount++\",{\"1\":{\"798\":1}}],[\"nomsgcount\",{\"1\":{\"798\":3}}],[\"none\",{\"1\":{\"693\":1}}],[\"nonode\",{\"1\":{\"102\":1}}],[\"no\",{\"1\":{\"287\":1,\"339\":1,\"406\":1,\"421\":1,\"492\":1,\"493\":1,\"520\":4,\"528\":1,\"570\":2,\"576\":2,\"599\":1,\"693\":9,\"694\":7,\"695\":4,\"718\":2,\"728\":1,\"786\":4,\"789\":1,\"790\":3,\"796\":1,\"851\":2,\"852\":3}}],[\"nofityall\",{\"1\":{\"246\":1}}],[\"now\",{\"1\":{\"240\":1,\"256\":1,\"258\":1,\"339\":1,\"344\":2,\"365\":3,\"380\":3,\"693\":3,\"694\":2,\"795\":3,\"796\":5,\"797\":4}}],[\"noranges\",{\"1\":{\"103\":3}}],[\"normaltopic\",{\"1\":{\"799\":2}}],[\"normal\",{\"1\":{\"11\":2,\"43\":1,\"44\":3,\"188\":1,\"799\":3}}],[\"nohost\",{\"1\":{\"102\":1}}],[\"noshell\",{\"1\":{\"74\":2}}],[\"notlockedmqs\",{\"1\":{\"742\":4}}],[\"notbestbroker\",{\"1\":{\"572\":5}}],[\"notifyconsumeridschanged\",{\"1\":{\"850\":1}}],[\"notifyconsumeridschangedenable\",{\"1\":{\"648\":2}}],[\"notifyme\",{\"1\":{\"344\":1,\"690\":1,\"721\":1,\"748\":1}}],[\"notifymessagearrivinglistener\",{\"0\":{\"348\":1},\"1\":{\"347\":2,\"348\":1}}],[\"notifymessagearriving\",{\"0\":{\"345\":1,\"433\":1},\"1\":{\"332\":3,\"335\":1,\"343\":1,\"345\":1,\"347\":2,\"348\":1,\"406\":1,\"433\":1,\"434\":2,\"435\":1,\"789\":1,\"800\":1}}],[\"notify\",{\"1\":{\"332\":1,\"365\":2,\"435\":2,\"436\":1,\"665\":2,\"693\":2,\"789\":1,\"817\":2}}],[\"not\",{\"1\":{\"42\":1,\"56\":1,\"103\":1,\"176\":11,\"178\":1,\"262\":1,\"284\":1,\"314\":1,\"334\":1,\"339\":3,\"345\":1,\"363\":1,\"381\":1,\"493\":1,\"516\":3,\"518\":2,\"520\":1,\"567\":2,\"568\":1,\"570\":1,\"573\":1,\"642\":2,\"643\":1,\"663\":2,\"690\":2,\"691\":2,\"693\":27,\"694\":2,\"715\":1,\"718\":5,\"720\":1,\"745\":1,\"748\":1,\"750\":6,\"786\":2,\"789\":2,\"790\":3,\"793\":1,\"797\":1,\"798\":1,\"799\":3,\"800\":1,\"817\":1,\"828\":11,\"830\":3,\"852\":2}}],[\"note\",{\"1\":{\"18\":1,\"113\":1}}],[\"node2\",{\"1\":{\"202\":1}}],[\"node2节点是2进1出的流量\",{\"1\":{\"201\":1}}],[\"node1节点是2进3出的流量\",{\"1\":{\"201\":1}}],[\"nodelist\",{\"1\":{\"102\":1}}],[\"node\",{\"1\":{\"21\":1,\"87\":1,\"102\":1,\"103\":1}}],[\"nodes\",{\"1\":{\"21\":2,\"185\":2,\"190\":1}}],[\"6765\",{\"1\":{\"597\":4}}],[\"67289768>\",{\"1\":{\"80\":1}}],[\"672\",{\"1\":{\"11\":1}}],[\"657\",{\"1\":{\"372\":1}}],[\"65746770>\",{\"1\":{\"31\":7}}],[\"6m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"600\",{\"1\":{\"430\":2,\"433\":1}}],[\"60\",{\"1\":{\"381\":1,\"389\":1,\"390\":2,\"568\":1,\"715\":1,\"750\":1,\"826\":1}}],[\"60s\",{\"1\":{\"272\":1,\"278\":1,\"289\":1,\"389\":1,\"750\":2}}],[\"605\",{\"1\":{\"261\":1}}],[\"63b0\",{\"1\":{\"269\":1}}],[\"635\",{\"1\":{\"11\":1}}],[\"627\",{\"1\":{\"45\":1}}],[\"6844904013859651597\",{\"1\":{\"116\":1,\"124\":1}}],[\"686\",{\"1\":{\"45\":1}}],[\"689\",{\"1\":{\"45\":1}}],[\"64k\",{\"1\":{\"819\":1}}],[\"642\",{\"1\":{\"45\":1}}],[\"64\",{\"1\":{\"32\":1,\"414\":1,\"819\":1}}],[\"66\",{\"1\":{\"573\":1}}],[\"6666666666666667\",{\"1\":{\"24\":1}}],[\"663\",{\"1\":{\"11\":1}}],[\"6>\",{\"1\":{\"21\":1,\"30\":1,\"31\":1,\"67\":1,\"105\":1}}],[\"6\",{\"0\":{\"251\":1,\"403\":1,\"564\":1,\"623\":1,\"693\":1,\"722\":1,\"800\":1},\"1\":{\"16\":1,\"27\":7,\"31\":4,\"32\":1,\"34\":1,\"45\":1,\"103\":2,\"134\":1,\"257\":2,\"381\":1,\"484\":6,\"488\":1,\"573\":1,\"594\":2,\"599\":3,\"658\":1,\"722\":1,\"884\":1}}],[\"693\",{\"1\":{\"11\":2}}],[\"71da5cd67513\",{\"1\":{\"599\":2}}],[\"77\",{\"1\":{\"593\":1}}],[\"771\",{\"1\":{\"11\":1}}],[\"700m\",{\"1\":{\"447\":1}}],[\"7w\",{\"1\":{\"430\":3}}],[\"7m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"79\",{\"1\":{\"262\":1,\"410\":1}}],[\"722c5c14d3d0\",{\"1\":{\"595\":1}}],[\"72h\",{\"1\":{\"390\":2}}],[\"72\",{\"1\":{\"386\":2,\"390\":1,\"430\":2}}],[\"72654g4\",{\"1\":{\"105\":5}}],[\"728\",{\"1\":{\"11\":1}}],[\"7\",{\"0\":{\"174\":1,\"252\":1,\"694\":1},\"1\":{\"31\":3,\"32\":1,\"45\":2,\"174\":2,\"175\":1,\"178\":7,\"238\":1,\"257\":2,\"484\":3,\"488\":1,\"599\":1,\"763\":1}}],[\"7>\",{\"1\":{\"27\":1,\"31\":1,\"67\":1,\"105\":1}}],[\"765\",{\"1\":{\"11\":1}}],[\"766\",{\"1\":{\"11\":1}}],[\"75\",{\"1\":{\"384\":1,\"386\":3,\"390\":1,\"585\":1}}],[\"753\",{\"1\":{\"11\":1}}],[\"755\",{\"1\":{\"11\":2}}],[\"754\",{\"1\":{\"11\":1}}],[\"±\",{\"1\":{\"11\":4}}],[\"rqid=\",{\"1\":{\"796\":4}}],[\"rqid\",{\"1\":{\"793\":4}}],[\"rcv\",{\"1\":{\"693\":3}}],[\"rwxrwxr\",{\"1\":{\"594\":7}}],[\"rw\",{\"1\":{\"400\":1}}],[\"rmqnamesrv\",{\"1\":{\"595\":2,\"599\":2,\"600\":3,\"601\":1}}],[\"rmqbroker1\",{\"1\":{\"599\":1,\"600\":1}}],[\"rmqbroker2\",{\"1\":{\"599\":2,\"600\":1}}],[\"rmqbroker\",{\"1\":{\"595\":5,\"599\":2,\"600\":1}}],[\"rmq\",{\"1\":{\"363\":1,\"365\":2,\"380\":2,\"484\":1,\"532\":1,\"592\":2,\"598\":1,\"601\":1,\"718\":1,\"808\":2}}],[\"rip28\",{\"1\":{\"818\":1}}],[\"rip\",{\"0\":{\"802\":1,\"869\":1},\"1\":{\"293\":1,\"801\":1,\"883\":2,\"884\":1}}],[\"rabalanceimpl\",{\"1\":{\"653\":1}}],[\"rabbit\",{\"1\":{\"151\":1,\"154\":4,\"157\":8,\"158\":3,\"159\":5,\"160\":1,\"190\":1,\"220\":2}}],[\"rabbitmq数据读写过程\",{\"1\":{\"224\":1}}],[\"rabbitmq学习记录\",{\"1\":{\"224\":1}}],[\"rabbitmq先将消息的内容和索引保存在磁盘中\",{\"1\":{\"223\":1}}],[\"rabbitmq才会把消息写到磁盘上\",{\"1\":{\"223\":1}}],[\"rabbitmq会根据消息的传输速度来计算当前内存中允许保存的最大消息数量\",{\"1\":{\"223\":1}}],[\"rabbitmq中队列的存储状态\",{\"0\":{\"223\":1}}],[\"rabbitmq中的每个队列都有一个主队列\",{\"1\":{\"193\":1}}],[\"rabbitmq中有四种进程\",{\"1\":{\"152\":1}}],[\"rabbitmq流量控制机制分析\",{\"1\":{\"161\":1}}],[\"rabbitmq实战指南\",{\"1\":{\"161\":1}}],[\"rabbitmqctl\",{\"1\":{\"151\":1,\"178\":2,\"186\":2}}],[\"rabbitmq\",{\"0\":{\"142\":1,\"145\":1,\"162\":1,\"174\":1,\"178\":1,\"179\":1,\"180\":1,\"213\":1,\"225\":1,\"238\":1},\"1\":{\"142\":2,\"146\":2,\"147\":2,\"150\":1,\"161\":3,\"162\":2,\"163\":1,\"168\":3,\"173\":2,\"174\":3,\"175\":2,\"178\":12,\"179\":3,\"180\":2,\"181\":6,\"182\":1,\"187\":1,\"192\":1,\"197\":1,\"201\":3,\"208\":1,\"212\":5,\"213\":2,\"214\":5,\"220\":3,\"225\":8,\"228\":1,\"238\":6,\"442\":1}}],[\"randomq\",{\"1\":{\"789\":5}}],[\"randomqueueid\",{\"1\":{\"576\":1}}],[\"random\",{\"1\":{\"570\":1,\"789\":1}}],[\"randomuuid\",{\"1\":{\"541\":1}}],[\"randomaccessfile\",{\"1\":{\"400\":1}}],[\"raw\",{\"1\":{\"276\":1,\"326\":1,\"332\":1,\"798\":8}}],[\"raft\",{\"0\":{\"228\":1},\"1\":{\"227\":2,\"228\":1,\"229\":1,\"237\":1}}],[\"ram\",{\"1\":{\"223\":6}}],[\"r表示\",{\"1\":{\"138\":1}}],[\"rto\",{\"1\":{\"133\":1}}],[\"ruradh\",{\"1\":{\"114\":1}}],[\"runbroker\",{\"1\":{\"600\":2}}],[\"runtimeexception\",{\"1\":{\"515\":1,\"850\":1}}],[\"runtime\",{\"1\":{\"480\":1}}],[\"runningflags\",{\"1\":{\"694\":2}}],[\"running\",{\"1\":{\"381\":1,\"557\":1,\"567\":3,\"568\":1,\"595\":1,\"642\":2,\"643\":1}}],[\"runnable\",{\"1\":{\"313\":1,\"340\":2,\"361\":1,\"389\":1,\"481\":2,\"490\":1,\"541\":1,\"568\":5,\"695\":1,\"721\":1}}],[\"run\",{\"0\":{\"344\":1},\"1\":{\"11\":3,\"249\":1,\"313\":1,\"332\":1,\"335\":1,\"340\":4,\"344\":1,\"361\":2,\"364\":1,\"381\":1,\"389\":4,\"481\":2,\"490\":1,\"519\":1,\"541\":2,\"568\":5,\"597\":1,\"600\":3,\"601\":1,\"660\":1,\"678\":1,\"688\":3,\"695\":1,\"708\":1,\"715\":1,\"721\":1,\"750\":2,\"783\":1}}],[\"rk4eks\",{\"1\":{\"114\":1}}],[\"route\",{\"1\":{\"493\":1,\"494\":1,\"570\":2}}],[\"routeinfomanager\",{\"1\":{\"464\":2,\"469\":1,\"473\":3,\"474\":2,\"477\":1,\"481\":1,\"491\":3,\"492\":1,\"493\":1}}],[\"routing\",{\"1\":{\"201\":1}}],[\"rockemq集群中至少有两个broker节点\",{\"1\":{\"524\":1}}],[\"rocketmq与kafka高性能设计对比\",{\"1\":{\"858\":1}}],[\"rocketmq无法避免消息重复\",{\"1\":{\"757\":1}}],[\"rocketmq消息消费源码分析\",{\"1\":{\"625\":1}}],[\"rocketmq消息消费\",{\"1\":{\"625\":1}}],[\"rocketmq消息轨迹\",{\"1\":{\"542\":1}}],[\"rocketmq消费消息原理\",{\"1\":{\"625\":1}}],[\"rocketmq消费消息\",{\"1\":{\"625\":1}}],[\"rocketmqinc\",{\"1\":{\"593\":1}}],[\"rocketmq按照业务逻辑区分请求处理器\",{\"1\":{\"575\":1}}],[\"rocketmqlog\",{\"1\":{\"528\":2}}],[\"rocketmq安装目录\",{\"1\":{\"518\":1,\"519\":1}}],[\"rocketmq2\",{\"1\":{\"503\":1}}],[\"rocketmqprotocolencode\",{\"1\":{\"413\":1,\"414\":3}}],[\"rocketmqserializable\",{\"1\":{\"406\":1,\"412\":1,\"413\":2,\"414\":3}}],[\"rocketmq存储实现分析\",{\"1\":{\"404\":1,\"868\":1}}],[\"rocketmq存储篇\",{\"1\":{\"318\":1}}],[\"rocketmq中的定时消息支持\",{\"0\":{\"353\":1}}],[\"rocketmq的存储文件都遵循一种通用的数据存储格式定义实践\",{\"1\":{\"307\":1}}],[\"rocketmq高性能之底层存储设计\",{\"1\":{\"294\":1,\"404\":1,\"868\":1}}],[\"rocketmq源码分析\",{\"1\":{\"294\":1}}],[\"rocketmq这样做\",{\"1\":{\"263\":1}}],[\"rocketmq4\",{\"1\":{\"253\":1}}],[\"rocketmq在保存消息时\",{\"1\":{\"253\":1}}],[\"rocketmq\",{\"0\":{\"239\":1,\"264\":1,\"293\":1,\"295\":1,\"319\":1,\"350\":1,\"369\":1,\"382\":1,\"393\":1,\"405\":1,\"409\":1,\"438\":1,\"457\":1,\"459\":1,\"495\":1,\"522\":1,\"529\":1,\"543\":1,\"578\":1,\"588\":1,\"592\":1,\"594\":1,\"595\":1,\"596\":1,\"597\":1,\"599\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"626\":1,\"644\":1,\"666\":1,\"696\":1,\"722\":1,\"751\":1,\"763\":1,\"802\":1,\"819\":1,\"821\":1,\"823\":1,\"854\":1,\"855\":1,\"859\":1,\"869\":1,\"884\":1},\"1\":{\"127\":1,\"136\":1,\"214\":1,\"239\":2,\"240\":2,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"247\":1,\"248\":1,\"249\":1,\"253\":1,\"255\":1,\"256\":2,\"260\":1,\"262\":1,\"263\":2,\"264\":2,\"266\":1,\"276\":2,\"293\":1,\"294\":1,\"295\":2,\"297\":2,\"307\":1,\"318\":1,\"319\":2,\"320\":1,\"321\":1,\"322\":1,\"324\":2,\"325\":1,\"326\":3,\"332\":1,\"349\":1,\"350\":2,\"353\":2,\"356\":3,\"360\":1,\"369\":2,\"370\":2,\"372\":1,\"382\":2,\"383\":2,\"393\":2,\"394\":5,\"396\":1,\"397\":1,\"399\":1,\"400\":1,\"401\":1,\"402\":3,\"403\":1,\"404\":4,\"405\":2,\"406\":2,\"407\":1,\"410\":2,\"413\":3,\"414\":5,\"419\":2,\"422\":1,\"432\":1,\"435\":1,\"437\":1,\"438\":2,\"439\":2,\"442\":9,\"443\":1,\"445\":9,\"447\":2,\"448\":1,\"450\":2,\"452\":1,\"454\":1,\"456\":2,\"457\":1,\"459\":2,\"461\":3,\"462\":2,\"480\":2,\"494\":1,\"495\":2,\"496\":3,\"498\":6,\"499\":2,\"503\":2,\"504\":1,\"505\":1,\"506\":1,\"510\":1,\"516\":2,\"518\":1,\"519\":1,\"521\":4,\"522\":2,\"523\":1,\"524\":1,\"529\":1,\"530\":1,\"543\":2,\"544\":2,\"545\":3,\"547\":1,\"548\":1,\"549\":1,\"550\":1,\"555\":2,\"556\":1,\"558\":1,\"563\":2,\"564\":1,\"573\":1,\"577\":3,\"578\":2,\"588\":2,\"589\":5,\"590\":3,\"591\":1,\"592\":4,\"593\":12,\"594\":1,\"595\":20,\"596\":3,\"597\":10,\"598\":2,\"599\":15,\"600\":16,\"601\":1,\"605\":2,\"606\":5,\"608\":1,\"610\":2,\"611\":1,\"614\":1,\"615\":2,\"617\":2,\"618\":1,\"620\":2,\"625\":5,\"626\":2,\"627\":1,\"629\":1,\"636\":1,\"637\":2,\"639\":1,\"644\":2,\"645\":2,\"646\":1,\"647\":1,\"648\":1,\"650\":1,\"651\":2,\"656\":1,\"658\":1,\"666\":2,\"667\":3,\"675\":1,\"688\":1,\"696\":2,\"697\":3,\"699\":1,\"700\":1,\"701\":1,\"707\":1,\"708\":1,\"722\":2,\"723\":6,\"727\":1,\"729\":1,\"735\":1,\"751\":2,\"754\":1,\"755\":2,\"758\":1,\"759\":1,\"763\":2,\"765\":2,\"766\":1,\"769\":3,\"773\":2,\"801\":1,\"802\":2,\"804\":5,\"807\":1,\"810\":2,\"817\":1,\"818\":1,\"819\":5,\"821\":2,\"823\":1,\"827\":1,\"829\":1,\"833\":1,\"838\":1,\"839\":1,\"841\":2,\"843\":1,\"853\":1,\"854\":2,\"855\":2,\"859\":2,\"860\":1,\"868\":3,\"869\":2,\"872\":4,\"873\":1,\"876\":2,\"877\":1,\"878\":1,\"880\":1,\"884\":27}}],[\"rocksdb\",{\"1\":{\"448\":2}}],[\"rollnextfile\",{\"1\":{\"287\":1,\"694\":2}}],[\"rollback\",{\"1\":{\"284\":1,\"314\":1,\"750\":1}}],[\"rolled\",{\"1\":{\"240\":1,\"242\":2}}],[\"rooms\",{\"1\":{\"103\":2}}],[\"row\",{\"1\":{\"103\":2}}],[\"rhs\",{\"1\":{\"23\":2}}],[\"rr\",{\"1\":{\"21\":3,\"41\":1}}],[\"rpo\",{\"1\":{\"126\":1,\"133\":1}}],[\"rpchooks\",{\"1\":{\"508\":2,\"514\":9}}],[\"rpchook\",{\"1\":{\"499\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":3,\"510\":1,\"514\":15,\"516\":1,\"539\":4,\"567\":1,\"642\":1}}],[\"rpc\",{\"1\":{\"85\":1}}],[\"rp\",{\"1\":{\"21\":1}}],[\"rl\",{\"1\":{\"21\":2}}],[\"rf\",{\"1\":{\"21\":2,\"41\":1}}],[\"r\",{\"1\":{\"21\":7,\"80\":3,\"140\":1,\"262\":15,\"693\":2,\"718\":6}}],[\"rd\",{\"1\":{\"21\":1}}],[\"revivedelay=\",{\"1\":{\"800\":1}}],[\"reviveretry\",{\"1\":{\"800\":2}}],[\"revivemsgfromck\",{\"1\":{\"799\":1,\"800\":1}}],[\"reviveoffset\",{\"1\":{\"798\":1}}],[\"revivequeueoffset\",{\"1\":{\"795\":3}}],[\"revivequeueid=\",{\"1\":{\"798\":6,\"799\":3,\"800\":5}}],[\"revivequeueid\",{\"1\":{\"795\":3}}],[\"reviveqid=\",{\"1\":{\"796\":1}}],[\"reviveqid\",{\"1\":{\"789\":8,\"790\":4,\"791\":4,\"796\":7}}],[\"revivetopic\",{\"1\":{\"779\":1,\"780\":1,\"781\":2,\"783\":4,\"793\":1,\"798\":3,\"799\":3,\"800\":1}}],[\"revivetime\",{\"1\":{\"773\":3,\"779\":1,\"781\":1,\"797\":1}}],[\"revive\",{\"1\":{\"771\":1,\"773\":2,\"789\":2,\"791\":2,\"793\":1,\"796\":1,\"798\":6,\"799\":3,\"800\":2}}],[\"reverse\",{\"1\":{\"106\":1,\"406\":1,\"408\":1}}],[\"reentrantlock\",{\"1\":{\"742\":1}}],[\"rejectedexecutionexception\",{\"1\":{\"714\":2}}],[\"rebalancelockmanager\",{\"1\":{\"732\":1,\"734\":1,\"742\":1}}],[\"rebalancepushimpl\",{\"1\":{\"665\":1,\"745\":1}}],[\"rebalanceresultset=\",{\"1\":{\"663\":1}}],[\"rebalanceresultsize=\",{\"1\":{\"663\":1}}],[\"rebalanced\",{\"1\":{\"663\":1}}],[\"rebalanceimmediately\",{\"1\":{\"642\":1,\"656\":1}}],[\"rebalanceimpl\",{\"0\":{\"652\":1,\"661\":1},\"1\":{\"640\":2,\"642\":6,\"649\":3,\"652\":1,\"657\":2,\"690\":3,\"695\":1,\"744\":1,\"746\":1,\"748\":1}}],[\"rebalancebytopic\",{\"0\":{\"663\":1},\"1\":{\"624\":1,\"654\":1,\"657\":1,\"662\":2,\"663\":1}}],[\"rebalance\",{\"0\":{\"618\":1},\"1\":{\"568\":1,\"644\":1,\"665\":2,\"801\":1}}],[\"rebalanceservice\",{\"0\":{\"660\":1},\"1\":{\"557\":1,\"568\":1,\"624\":1,\"631\":1,\"640\":2,\"643\":1,\"649\":1,\"656\":1,\"660\":1}}],[\"re\",{\"1\":{\"365\":1,\"380\":1}}],[\"ret=\",{\"1\":{\"851\":1}}],[\"ret\",{\"1\":{\"402\":2,\"851\":6,\"852\":9}}],[\"retrytopicconfig\",{\"1\":{\"789\":8}}],[\"retrytopic\",{\"1\":{\"718\":2}}],[\"retrytimeswhensendasyncfailed\",{\"1\":{\"560\":1}}],[\"retrytimeswhensendfailed\",{\"1\":{\"560\":1}}],[\"retrytimes\",{\"1\":{\"289\":3,\"537\":1}}],[\"retrygetandcreateindexfile\",{\"1\":{\"309\":1,\"314\":1}}],[\"retry\",{\"1\":{\"289\":1,\"488\":1,\"503\":1,\"573\":1,\"620\":1,\"662\":1,\"663\":1,\"693\":6,\"695\":1,\"708\":1,\"717\":1,\"718\":4,\"783\":1,\"786\":1,\"789\":1,\"800\":4,\"817\":2}}],[\"returns\",{\"1\":{\"786\":1}}],[\"returnnull\",{\"1\":{\"715\":1,\"750\":1}}],[\"returntype\",{\"1\":{\"715\":7,\"750\":7}}],[\"return\",{\"1\":{\"111\":1,\"257\":5,\"258\":3,\"262\":4,\"285\":5,\"287\":1,\"313\":3,\"314\":6,\"316\":1,\"317\":2,\"339\":1,\"365\":4,\"380\":7,\"381\":2,\"390\":3,\"392\":1,\"413\":2,\"414\":1,\"435\":1,\"480\":4,\"481\":1,\"490\":2,\"491\":1,\"493\":2,\"504\":1,\"505\":2,\"515\":1,\"516\":2,\"518\":1,\"520\":6,\"527\":1,\"540\":3,\"570\":5,\"571\":2,\"572\":9,\"573\":2,\"576\":5,\"663\":1,\"664\":2,\"690\":9,\"691\":2,\"692\":4,\"693\":17,\"694\":7,\"715\":3,\"717\":3,\"718\":12,\"720\":1,\"742\":2,\"744\":2,\"745\":4,\"746\":3,\"748\":2,\"750\":3,\"755\":1,\"768\":1,\"786\":7,\"787\":2,\"789\":3,\"790\":6,\"791\":1,\"793\":3,\"795\":7,\"796\":10,\"799\":1,\"800\":1,\"808\":1,\"816\":2,\"817\":8,\"847\":7,\"848\":2,\"850\":7,\"851\":2,\"852\":15}}],[\"req\",{\"1\":{\"283\":2,\"309\":1,\"314\":10}}],[\"requestoffset=\",{\"1\":{\"693\":3,\"721\":1}}],[\"requestfutureholder\",{\"1\":{\"567\":1}}],[\"requestid\",{\"1\":{\"537\":1}}],[\"requestbody\",{\"1\":{\"490\":4,\"746\":5}}],[\"requestcode\",{\"1\":{\"472\":1,\"575\":4,\"692\":1}}],[\"requestprocessor\",{\"1\":{\"464\":1}}],[\"requestlist\",{\"1\":{\"345\":3}}],[\"requesttask\",{\"1\":{\"340\":1}}],[\"requestheader\",{\"1\":{\"339\":3,\"490\":9,\"493\":4,\"573\":18,\"576\":12,\"691\":13,\"692\":2,\"693\":83,\"718\":14,\"720\":7,\"789\":20,\"790\":25,\"791\":2,\"793\":8}}],[\"request\",{\"1\":{\"85\":2,\"262\":2,\"284\":3,\"334\":2,\"339\":3,\"340\":8,\"343\":1,\"344\":1,\"345\":14,\"493\":2,\"514\":7,\"515\":8,\"516\":3,\"520\":1,\"541\":2,\"568\":1,\"576\":6,\"690\":3,\"692\":3,\"693\":11,\"694\":1,\"695\":3,\"718\":5,\"748\":1,\"789\":3,\"793\":4,\"817\":26,\"851\":11}}],[\"rename\",{\"1\":{\"262\":1,\"410\":1,\"807\":1}}],[\"redirect\",{\"1\":{\"693\":1}}],[\"redis\",{\"1\":{\"136\":1,\"599\":3}}],[\"redelivered\",{\"1\":{\"198\":1}}],[\"reinstall\",{\"1\":{\"179\":1}}],[\"release\",{\"1\":{\"317\":6,\"365\":1,\"380\":1,\"693\":2,\"694\":3}}],[\"releases\",{\"1\":{\"178\":1}}],[\"reloadserversslcontext\",{\"1\":{\"481\":3}}],[\"reload\",{\"1\":{\"21\":1,\"481\":3}}],[\"reorder\",{\"1\":{\"103\":1}}],[\"restnum\",{\"1\":{\"789\":11,\"790\":13}}],[\"resource\",{\"1\":{\"520\":7}}],[\"resources\",{\"1\":{\"503\":1}}],[\"resizing\",{\"1\":{\"406\":1,\"427\":1}}],[\"resize\",{\"1\":{\"406\":1,\"426\":1}}],[\"resilienceefficienty\",{\"1\":{\"135\":1}}],[\"resendcount++\",{\"1\":{\"381\":1}}],[\"resend\",{\"1\":{\"381\":6,\"570\":1}}],[\"resetretryandnamespace\",{\"1\":{\"715\":1,\"750\":1}}],[\"resetoffset\",{\"1\":{\"380\":7}}],[\"resetbytebuffer\",{\"1\":{\"257\":4}}],[\"reset\",{\"1\":{\"103\":1,\"435\":1,\"480\":1,\"570\":1,\"573\":1}}],[\"responseheader\",{\"1\":{\"576\":2,\"693\":13,\"789\":7}}],[\"responsecode\",{\"1\":{\"334\":1,\"339\":2,\"493\":2,\"576\":1,\"693\":34,\"718\":10,\"789\":3,\"793\":1}}],[\"response\",{\"1\":{\"85\":2,\"339\":2,\"340\":9,\"493\":8,\"514\":3,\"516\":1,\"568\":1,\"576\":10,\"693\":66,\"718\":31,\"789\":5,\"793\":4}}],[\"resultprocess\",{\"1\":{\"380\":2}}],[\"results\",{\"1\":{\"21\":2}}],[\"result\",{\"1\":{\"11\":2,\"258\":2,\"282\":5,\"289\":3,\"381\":4,\"406\":1,\"415\":1,\"490\":3,\"491\":4,\"663\":1,\"665\":1,\"695\":1,\"715\":3,\"786\":1,\"800\":1,\"816\":1,\"817\":4,\"851\":1,\"852\":1,\"873\":1}}],[\"ref\",{\"1\":{\"68\":1}}],[\"reference\",{\"1\":{\"21\":1,\"68\":1}}],[\"reput\",{\"1\":{\"365\":1,\"431\":1,\"576\":1,\"797\":1,\"843\":1,\"852\":1}}],[\"reputfromoffset\",{\"1\":{\"282\":2}}],[\"reputmessageservice\",{\"0\":{\"282\":1,\"331\":1,\"336\":1,\"346\":1,\"433\":1},\"1\":{\"276\":1,\"332\":1,\"335\":1,\"406\":1,\"433\":1,\"814\":1}}],[\"reply\",{\"1\":{\"484\":1}}],[\"replace\",{\"1\":{\"576\":1}}],[\"replacement\",{\"1\":{\"63\":2}}],[\"replay\",{\"1\":{\"450\":2}}],[\"replaylist\",{\"1\":{\"345\":4}}],[\"replication\",{\"1\":{\"228\":1}}],[\"repository\",{\"1\":{\"177\":1,\"592\":1,\"593\":1}}],[\"repeated\",{\"1\":{\"518\":1}}],[\"repeatedly\",{\"1\":{\"285\":2}}],[\"repeat\",{\"1\":{\"21\":1}}],[\"realfilterdata\",{\"1\":{\"852\":7}}],[\"realaclfilesnum\",{\"1\":{\"519\":9}}],[\"real\",{\"1\":{\"363\":3,\"365\":2,\"380\":1}}],[\"reach\",{\"1\":{\"242\":1}}],[\"reason\",{\"1\":{\"46\":1,\"146\":1,\"157\":2,\"158\":2}}],[\"readable\",{\"1\":{\"694\":1}}],[\"readgetmessageresult\",{\"1\":{\"693\":1}}],[\"readoffsettype\",{\"1\":{\"690\":1}}],[\"readoffset\",{\"1\":{\"690\":1}}],[\"readqueuenums\",{\"1\":{\"484\":10,\"488\":2,\"693\":1}}],[\"readcustomheader\",{\"1\":{\"414\":2,\"515\":1,\"576\":1,\"693\":1}}],[\"readlock\",{\"1\":{\"313\":2,\"314\":2,\"392\":2,\"492\":2}}],[\"readwritelock\",{\"1\":{\"313\":4,\"314\":2,\"392\":2}}],[\"readsize\",{\"1\":{\"282\":2}}],[\"reading\",{\"1\":{\"176\":3,\"178\":1}}],[\"reader的进程字典\",{\"1\":{\"159\":1}}],[\"reader的进程字典中\",{\"1\":{\"157\":1}}],[\"reader来授予信用\",{\"1\":{\"159\":1}}],[\"reader更多的信用值\",{\"1\":{\"159\":1}}],[\"reader新的morecreditafter点信用值\",{\"1\":{\"159\":1}}],[\"reader进程收到bump\",{\"1\":{\"159\":1}}],[\"reader进程中被追踪\",{\"1\":{\"157\":1}}],[\"reader进程中\",{\"1\":{\"157\":1}}],[\"reader进行一次确认\",{\"1\":{\"159\":1}}],[\"reader每接收一个包\",{\"1\":{\"158\":1}}],[\"reader接收消息的入口\",{\"1\":{\"158\":1}}],[\"reader可能会将消息发送给多个进程\",{\"1\":{\"158\":1}}],[\"reader通过credit\",{\"1\":{\"157\":1}}],[\"reader处理一个有内容的命令\",{\"1\":{\"157\":1}}],[\"reader\",{\"1\":{\"147\":1,\"152\":1,\"154\":6,\"155\":2,\"156\":1,\"157\":3,\"158\":1,\"159\":2}}],[\"read\",{\"1\":{\"21\":3,\"41\":1,\"103\":3,\"400\":1,\"690\":1,\"718\":2,\"789\":1}}],[\"recalculatepullfromwhichnode\",{\"1\":{\"691\":2}}],[\"recvlen\",{\"1\":{\"158\":2}}],[\"recvloop\",{\"1\":{\"158\":4}}],[\"recvloop方法\",{\"1\":{\"158\":1}}],[\"recv\",{\"1\":{\"158\":3}}],[\"reconsumelater\",{\"1\":{\"771\":1}}],[\"reconsume\",{\"1\":{\"573\":2,\"715\":3}}],[\"reconsumetimes\",{\"1\":{\"257\":2,\"262\":1,\"573\":3}}],[\"recover\",{\"0\":{\"291\":1},\"1\":{\"291\":6,\"573\":1}}],[\"recovery\",{\"1\":{\"133\":2}}],[\"recorddiskfallbehindsize\",{\"1\":{\"694\":1}}],[\"records\",{\"1\":{\"41\":2}}],[\"record\",{\"0\":{\"40\":1,\"41\":1},\"1\":{\"21\":9,\"40\":1,\"41\":7,\"103\":6,\"491\":1}}],[\"received\",{\"1\":{\"85\":1}}],[\"receive\",{\"1\":{\"79\":2,\"80\":1,\"82\":1,\"83\":1,\"85\":2,\"505\":1,\"527\":1,\"693\":1,\"768\":1}}],[\"rectangles\",{\"1\":{\"80\":1}}],[\"rectangle\",{\"1\":{\"30\":4,\"80\":1,\"103\":1}}],[\"remember\",{\"1\":{\"480\":1}}],[\"remark\",{\"1\":{\"414\":5}}],[\"removing\",{\"1\":{\"287\":1,\"693\":1,\"694\":1,\"790\":1}}],[\"removewaitstorepropertystring\",{\"1\":{\"816\":1}}],[\"removeck\",{\"1\":{\"797\":4}}],[\"removeoffset\",{\"1\":{\"745\":1}}],[\"removemessage\",{\"1\":{\"715\":1}}],[\"removemap\",{\"1\":{\"242\":2}}],[\"removeall\",{\"1\":{\"715\":1}}],[\"removeprocessqueue\",{\"1\":{\"695\":1}}],[\"removeunnecessarymessagequeue\",{\"1\":{\"654\":1,\"664\":2,\"744\":2,\"745\":2}}],[\"removebrokername\",{\"1\":{\"492\":4}}],[\"removedirtyoffset\",{\"1\":{\"664\":1,\"744\":1}}],[\"removedopoffset\",{\"1\":{\"242\":2}}],[\"removed\",{\"1\":{\"176\":1,\"492\":2}}],[\"remove\",{\"1\":{\"21\":2,\"103\":1,\"176\":1,\"179\":4,\"240\":4,\"242\":1,\"243\":2,\"251\":1,\"381\":2,\"491\":3,\"492\":14,\"572\":1,\"576\":2,\"664\":4,\"720\":2,\"744\":2,\"797\":2}}],[\"remotingtoomuchrequestexception\",{\"1\":{\"573\":2}}],[\"remotingexception\",{\"1\":{\"570\":2,\"573\":1,\"691\":2,\"692\":1,\"717\":2,\"720\":1}}],[\"remotingexecutorthread\",{\"1\":{\"481\":1}}],[\"remotingexecutor\",{\"1\":{\"481\":2}}],[\"remotinghelper\",{\"1\":{\"504\":1,\"514\":1,\"526\":1,\"693\":2,\"715\":1,\"717\":1,\"750\":1,\"786\":1,\"807\":1,\"826\":1,\"829\":1}}],[\"remotingclient\",{\"1\":{\"490\":1,\"556\":1}}],[\"remotingcommand\",{\"1\":{\"262\":1,\"334\":3,\"339\":2,\"340\":2,\"410\":1,\"413\":1,\"414\":2,\"480\":1,\"493\":4,\"514\":5,\"515\":2,\"516\":3,\"576\":2,\"692\":2,\"693\":4,\"718\":3,\"789\":2,\"793\":4}}],[\"remotingcommandexception\",{\"1\":{\"262\":5,\"339\":2,\"340\":3,\"411\":1,\"493\":1,\"693\":2,\"718\":2,\"789\":2,\"793\":2}}],[\"remotingserver\",{\"1\":{\"481\":4,\"575\":4}}],[\"remotingserializable\",{\"1\":{\"413\":2,\"414\":1,\"470\":1,\"488\":1}}],[\"remoting\",{\"1\":{\"467\":3,\"480\":5,\"481\":2,\"819\":2}}],[\"remotebrokeroffset\",{\"1\":{\"710\":1}}],[\"remotebrokeroffsetstore\",{\"1\":{\"623\":1,\"640\":1,\"642\":1,\"711\":2,\"720\":2}}],[\"remoteaddr\",{\"1\":{\"417\":1,\"492\":2,\"515\":1,\"516\":3}}],[\"remoteaddressstrategy\",{\"1\":{\"520\":3}}],[\"remoteaddressstrategyfactory\",{\"1\":{\"517\":3,\"518\":1}}],[\"remoteaddress\",{\"1\":{\"340\":1,\"576\":1,\"693\":4,\"790\":3}}],[\"remote\",{\"1\":{\"417\":1,\"467\":1,\"480\":1,\"520\":1}}],[\"remotefunc\",{\"1\":{\"60\":1}}],[\"reminder\",{\"1\":{\"41\":2}}],[\"rem\",{\"1\":{\"24\":1,\"31\":1,\"37\":1,\"39\":1}}],[\"region\",{\"1\":{\"540\":1}}],[\"regionname\",{\"1\":{\"537\":1}}],[\"regionid\",{\"1\":{\"537\":2,\"540\":2,\"541\":7}}],[\"registerfiltermessagehook\",{\"1\":{\"642\":1}}],[\"registerfirst\",{\"1\":{\"491\":5}}],[\"registermessagequeuelistener\",{\"1\":{\"637\":1}}],[\"registermessagelistener\",{\"1\":{\"505\":1,\"527\":1,\"637\":1,\"768\":1}}],[\"registersendmessagehook\",{\"1\":{\"575\":1}}],[\"registerserverrpchook\",{\"1\":{\"516\":1}}],[\"registerproducer\",{\"1\":{\"567\":1}}],[\"registerprocessor\",{\"1\":{\"481\":1,\"575\":5}}],[\"registerok\",{\"1\":{\"567\":2,\"642\":2}}],[\"registerconsumer\",{\"1\":{\"642\":1,\"837\":1}}],[\"registerconsumemessagehook\",{\"1\":{\"539\":1,\"575\":1}}],[\"registerconfig\",{\"1\":{\"480\":1}}],[\"registerrpchook\",{\"1\":{\"514\":1}}],[\"registerbrokerbody\",{\"1\":{\"490\":2}}],[\"registerbrokerresult\",{\"1\":{\"490\":1,\"491\":3}}],[\"registerbrokerresultlist\",{\"1\":{\"490\":3}}],[\"registerbrokerrequestheader\",{\"1\":{\"490\":2}}],[\"registerbroker\",{\"1\":{\"473\":1,\"490\":2,\"491\":3}}],[\"registerbrokerall\",{\"1\":{\"472\":1,\"490\":2}}],[\"register\",{\"1\":{\"84\":1,\"472\":2,\"473\":1,\"481\":1,\"490\":1,\"850\":4}}],[\"registered\",{\"1\":{\"21\":2,\"84\":1,\"487\":1,\"491\":1}}],[\"regex\",{\"1\":{\"406\":1,\"424\":1}}],[\"regs\",{\"1\":{\"21\":1}}],[\"919ce578e6db\",{\"1\":{\"599\":1}}],[\"9101\",{\"1\":{\"11\":1}}],[\"947\",{\"1\":{\"594\":1}}],[\"940\",{\"1\":{\"11\":3}}],[\"901\",{\"1\":{\"594\":1}}],[\"902\",{\"1\":{\"594\":1}}],[\"90\",{\"1\":{\"386\":1}}],[\"9000\",{\"1\":{\"135\":1}}],[\"9m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"9e01a24a24d4\",{\"1\":{\"269\":1}}],[\"9c52\",{\"1\":{\"269\":1}}],[\"93\",{\"1\":{\"135\":1,\"599\":1}}],[\"938\",{\"1\":{\"11\":1}}],[\"9876\",{\"1\":{\"480\":2,\"504\":1,\"505\":1,\"528\":1,\"595\":5,\"598\":1,\"599\":5,\"600\":3,\"601\":1,\"755\":2,\"807\":2,\"808\":2}}],[\"98\",{\"1\":{\"28\":3}}],[\"988\",{\"1\":{\"11\":2}}],[\"9795\",{\"1\":{\"105\":2}}],[\"97的简写\",{\"1\":{\"65\":1}}],[\"97\",{\"1\":{\"28\":3,\"135\":1}}],[\"9767\",{\"1\":{\"11\":1}}],[\"9>\",{\"1\":{\"27\":1,\"31\":1,\"32\":1,\"67\":1,\"105\":1}}],[\"9643\",{\"1\":{\"11\":1}}],[\"9656\",{\"1\":{\"11\":1}}],[\"950\",{\"1\":{\"11\":1}}],[\"9\",{\"0\":{\"239\":1,\"369\":1,\"405\":1},\"1\":{\"11\":4,\"30\":1,\"31\":2,\"32\":2,\"176\":4,\"177\":1,\"239\":1,\"240\":3,\"257\":2,\"263\":1,\"369\":1,\"370\":1,\"405\":1,\"406\":6,\"409\":2,\"412\":2,\"424\":1,\"433\":1,\"437\":1,\"445\":1,\"452\":1,\"576\":1,\"592\":3,\"593\":2,\"594\":5,\"595\":11,\"598\":1,\"599\":13,\"600\":9,\"603\":1,\"604\":1,\"718\":1,\"804\":1,\"814\":1,\"819\":1,\"827\":1,\"830\":1,\"872\":1,\"884\":3}}],[\"99999999\",{\"1\":{\"718\":2}}],[\"9999\",{\"1\":{\"426\":1}}],[\"99991231\",{\"1\":{\"16\":1,\"854\":1,\"855\":1,\"859\":1,\"869\":1}}],[\"99\",{\"1\":{\"11\":4,\"28\":2,\"777\":1}}],[\"43\",{\"0\":{\"869\":1},\"1\":{\"883\":2}}],[\"433021cbeb23\",{\"1\":{\"597\":1}}],[\"4s\",{\"1\":{\"798\":2}}],[\"46379\",{\"1\":{\"599\":2}}],[\"48080\",{\"1\":{\"598\":2,\"601\":2}}],[\"48\",{\"1\":{\"595\":2}}],[\"489\",{\"1\":{\"11\":2}}],[\"4kb\",{\"1\":{\"562\":1,\"573\":1}}],[\"4k\",{\"1\":{\"437\":1}}],[\"4点\",{\"1\":{\"390\":2}}],[\"4m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1,\"819\":2}}],[\"4194304\",{\"1\":{\"819\":1}}],[\"41\",{\"1\":{\"45\":2,\"80\":1}}],[\"499\",{\"1\":{\"261\":1}}],[\"49\",{\"1\":{\"32\":1}}],[\"44\",{\"1\":{\"31\":7,\"80\":1}}],[\"449\",{\"1\":{\"11\":1}}],[\"456\",{\"1\":{\"807\":1}}],[\"45\",{\"1\":{\"26\":1,\"597\":2}}],[\"42b7\",{\"1\":{\"269\":1}}],[\"420\",{\"1\":{\"103\":1}}],[\"42\",{\"1\":{\"26\":2}}],[\"4>\",{\"1\":{\"24\":1,\"31\":1,\"35\":1,\"67\":1}}],[\"40+ms\",{\"1\":{\"435\":1}}],[\"4096\",{\"1\":{\"220\":1,\"594\":6}}],[\"400\",{\"1\":{\"151\":1,\"152\":3,\"154\":1}}],[\"40\",{\"1\":{\"11\":1,\"67\":4,\"135\":1,\"442\":1,\"528\":1}}],[\"47451\",{\"1\":{\"11\":1}}],[\"4\",{\"0\":{\"149\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":2,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"206\":1,\"207\":2,\"239\":1,\"243\":1,\"272\":1,\"278\":1,\"280\":1,\"281\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":2,\"286\":1,\"287\":1,\"288\":1,\"289\":1,\"290\":2,\"291\":2,\"303\":1,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":2,\"317\":1,\"325\":1,\"337\":1,\"338\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":2,\"346\":1,\"347\":1,\"348\":1,\"362\":1,\"363\":1,\"364\":1,\"365\":1,\"369\":1,\"379\":1,\"380\":1,\"381\":1,\"389\":1,\"390\":1,\"391\":1,\"392\":1,\"401\":1,\"405\":1,\"474\":1,\"478\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"488\":1,\"489\":1,\"490\":1,\"491\":1,\"492\":2,\"493\":1,\"512\":1,\"513\":1,\"514\":1,\"515\":1,\"516\":1,\"517\":1,\"518\":1,\"519\":1,\"520\":1,\"528\":1,\"533\":1,\"534\":1,\"535\":1,\"551\":1,\"552\":1,\"553\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"562\":2,\"565\":1,\"566\":1,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"573\":2,\"574\":1,\"575\":1,\"576\":1,\"619\":1,\"620\":1,\"621\":1,\"638\":1,\"641\":1,\"642\":1,\"643\":1,\"659\":1,\"660\":1,\"661\":1,\"662\":1,\"663\":1,\"664\":1,\"665\":2,\"666\":1,\"681\":1,\"686\":1,\"687\":1,\"688\":1,\"689\":1,\"690\":1,\"691\":2,\"692\":1,\"693\":1,\"694\":1,\"695\":1,\"712\":1,\"713\":1,\"714\":1,\"715\":1,\"716\":1,\"717\":1,\"718\":1,\"719\":1,\"720\":1,\"721\":1,\"735\":1,\"740\":1,\"741\":1,\"742\":1,\"743\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"748\":1,\"749\":1,\"750\":1,\"781\":1,\"782\":1,\"783\":1,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"788\":1,\"789\":1,\"790\":1,\"791\":1,\"792\":1,\"793\":1,\"794\":2,\"795\":2,\"796\":2,\"797\":2,\"798\":3,\"799\":2,\"800\":2,\"815\":1,\"816\":1,\"817\":1,\"840\":1,\"841\":1,\"842\":1,\"843\":1,\"844\":2,\"845\":1,\"846\":1,\"847\":1,\"848\":1,\"849\":1,\"850\":1,\"851\":1,\"852\":1,\"865\":1,\"867\":1},\"1\":{\"11\":4,\"22\":1,\"24\":2,\"27\":4,\"30\":1,\"31\":7,\"32\":2,\"34\":3,\"37\":2,\"43\":1,\"44\":2,\"45\":2,\"103\":3,\"111\":1,\"176\":4,\"177\":1,\"228\":1,\"239\":1,\"240\":1,\"253\":3,\"254\":1,\"257\":2,\"258\":3,\"262\":2,\"263\":1,\"317\":8,\"369\":1,\"370\":1,\"372\":1,\"384\":1,\"386\":4,\"390\":2,\"405\":1,\"406\":6,\"409\":3,\"410\":1,\"412\":3,\"414\":3,\"422\":1,\"426\":1,\"433\":1,\"437\":1,\"442\":1,\"445\":1,\"452\":1,\"464\":2,\"469\":2,\"496\":2,\"498\":2,\"523\":2,\"573\":1,\"575\":1,\"592\":6,\"593\":4,\"594\":11,\"595\":24,\"598\":2,\"599\":26,\"600\":18,\"603\":2,\"604\":2,\"606\":1,\"625\":1,\"656\":2,\"666\":1,\"675\":1,\"685\":1,\"697\":1,\"718\":1,\"723\":1,\"778\":1,\"795\":1,\"798\":1,\"804\":1,\"814\":1,\"819\":1,\"827\":1,\"830\":1,\"854\":1,\"872\":5,\"875\":1,\"876\":2,\"884\":4}}],[\"3s\",{\"1\":{\"748\":3,\"753\":1,\"773\":1}}],[\"3+\",{\"1\":{\"370\":1}}],[\"3m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"310\",{\"1\":{\"262\":1,\"410\":1}}],[\"3458\",{\"1\":{\"370\":1}}],[\"342\",{\"1\":{\"261\":1}}],[\"34222\",{\"1\":{\"11\":1}}],[\"34\",{\"1\":{\"122\":1}}],[\"39664283\",{\"1\":{\"179\":1}}],[\"39\",{\"1\":{\"122\":1}}],[\"3997\",{\"1\":{\"11\":1}}],[\"3000\",{\"1\":{\"808\":1}}],[\"30000\",{\"1\":{\"690\":1,\"808\":1}}],[\"30919\",{\"1\":{\"600\":2}}],[\"30911\",{\"1\":{\"600\":2}}],[\"30921\",{\"1\":{\"600\":2}}],[\"30929\",{\"1\":{\"599\":2,\"600\":2}}],[\"30909\",{\"1\":{\"600\":2}}],[\"30931\",{\"1\":{\"599\":2,\"600\":2}}],[\"30m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"30s\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"465\":3,\"472\":1,\"475\":1,\"476\":1,\"559\":1,\"700\":1,\"761\":1}}],[\"30\",{\"1\":{\"115\":1,\"550\":2,\"771\":1,\"817\":2}}],[\"3确定的\",{\"1\":{\"111\":1}}],[\"3e+6\",{\"1\":{\"65\":1}}],[\"3825\",{\"1\":{\"819\":1}}],[\"38\",{\"1\":{\"45\":1,\"593\":1}}],[\"389\",{\"1\":{\"11\":3}}],[\"3694\",{\"1\":{\"804\":1}}],[\"3600w\",{\"1\":{\"447\":2}}],[\"3651\",{\"1\":{\"819\":1}}],[\"3659\",{\"1\":{\"433\":1}}],[\"3657\",{\"1\":{\"430\":1}}],[\"3619\",{\"1\":{\"427\":1}}],[\"3612\",{\"1\":{\"426\":1}}],[\"3613\",{\"1\":{\"306\":1}}],[\"36\",{\"1\":{\"32\":1}}],[\"32k\",{\"1\":{\"819\":1}}],[\"32条\",{\"1\":{\"798\":1}}],[\"3201\",{\"1\":{\"594\":1}}],[\"3286\",{\"1\":{\"372\":1}}],[\"3287\",{\"1\":{\"360\":1,\"370\":1}}],[\"32\",{\"1\":{\"31\":2,\"414\":1,\"690\":1,\"721\":1,\"742\":1,\"808\":1,\"819\":1}}],[\"3>\",{\"1\":{\"24\":1,\"28\":1,\"30\":1,\"31\":1,\"67\":1}}],[\"37132\",{\"1\":{\"11\":2}}],[\"378\",{\"1\":{\"11\":1}}],[\"372\",{\"1\":{\"11\":1}}],[\"3\",{\"0\":{\"148\":1,\"153\":1,\"154\":1,\"155\":1,\"159\":1,\"174\":1,\"179\":1,\"183\":1,\"184\":1,\"185\":1,\"186\":1,\"187\":2,\"188\":1,\"189\":2,\"190\":2,\"191\":2,\"192\":3,\"193\":2,\"194\":1,\"195\":1,\"196\":1,\"197\":2,\"198\":1,\"206\":1,\"222\":1,\"225\":1,\"271\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":2,\"278\":1,\"279\":1,\"284\":1,\"288\":1,\"289\":1,\"302\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"315\":1,\"324\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"331\":2,\"332\":1,\"333\":2,\"334\":2,\"335\":2,\"336\":3,\"344\":1,\"346\":1,\"347\":1,\"348\":1,\"355\":1,\"356\":1,\"357\":1,\"358\":2,\"359\":2,\"360\":2,\"361\":3,\"369\":1,\"376\":1,\"377\":1,\"378\":1,\"385\":1,\"386\":1,\"387\":1,\"388\":2,\"392\":1,\"400\":1,\"405\":1,\"466\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":2,\"472\":2,\"473\":2,\"474\":1,\"475\":1,\"476\":1,\"477\":1,\"489\":1,\"490\":1,\"491\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":2,\"506\":1,\"507\":1,\"508\":1,\"509\":1,\"510\":1,\"511\":2,\"519\":1,\"520\":1,\"527\":1,\"530\":1,\"531\":1,\"532\":1,\"541\":1,\"550\":1,\"554\":1,\"555\":1,\"556\":1,\"557\":2,\"558\":1,\"559\":1,\"560\":1,\"561\":2,\"562\":1,\"563\":1,\"564\":1,\"572\":1,\"574\":1,\"575\":1,\"576\":1,\"611\":1,\"615\":1,\"616\":1,\"617\":1,\"618\":1,\"624\":1,\"633\":1,\"634\":1,\"635\":1,\"636\":1,\"637\":2,\"638\":1,\"639\":1,\"640\":1,\"644\":1,\"650\":1,\"651\":1,\"652\":1,\"653\":1,\"654\":1,\"655\":1,\"656\":1,\"657\":1,\"658\":2,\"664\":1,\"673\":1,\"674\":1,\"675\":1,\"676\":1,\"677\":1,\"678\":1,\"679\":1,\"680\":2,\"681\":1,\"682\":1,\"683\":1,\"684\":1,\"685\":2,\"690\":1,\"701\":1,\"702\":1,\"703\":1,\"704\":2,\"705\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":1,\"710\":1,\"711\":1,\"719\":1,\"720\":1,\"721\":1,\"730\":1,\"731\":1,\"732\":1,\"733\":1,\"734\":2,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"739\":2,\"746\":1,\"750\":1,\"769\":1,\"773\":1,\"774\":1,\"775\":1,\"776\":1,\"777\":1,\"778\":1,\"779\":2,\"780\":2,\"781\":1,\"782\":1,\"783\":1,\"791\":1,\"792\":1,\"793\":1,\"797\":1,\"808\":1,\"812\":1,\"813\":1,\"814\":1,\"836\":1,\"837\":1,\"838\":1,\"839\":2,\"840\":1,\"841\":1,\"842\":1,\"843\":2,\"844\":1,\"852\":1,\"864\":1,\"866\":1,\"878\":1,\"882\":1},\"1\":{\"11\":4,\"22\":1,\"24\":3,\"27\":8,\"28\":2,\"30\":2,\"31\":5,\"32\":1,\"34\":2,\"37\":1,\"42\":7,\"43\":1,\"44\":2,\"45\":3,\"65\":1,\"80\":1,\"98\":6,\"103\":4,\"111\":1,\"134\":1,\"135\":1,\"147\":1,\"150\":1,\"157\":1,\"161\":3,\"170\":1,\"171\":1,\"174\":2,\"175\":2,\"176\":4,\"177\":1,\"178\":6,\"181\":2,\"185\":1,\"186\":1,\"187\":1,\"195\":2,\"208\":1,\"225\":2,\"228\":1,\"236\":1,\"238\":2,\"244\":2,\"253\":1,\"257\":2,\"291\":1,\"369\":1,\"370\":2,\"373\":1,\"374\":1,\"380\":1,\"390\":2,\"405\":1,\"406\":3,\"409\":1,\"412\":1,\"433\":1,\"437\":1,\"444\":1,\"445\":3,\"452\":1,\"462\":1,\"464\":1,\"480\":1,\"545\":1,\"547\":1,\"555\":1,\"573\":1,\"576\":1,\"594\":1,\"599\":3,\"644\":1,\"656\":1,\"667\":1,\"669\":1,\"676\":1,\"717\":2,\"718\":2,\"760\":1,\"768\":1,\"778\":1,\"793\":1,\"798\":1,\"804\":1,\"819\":1,\"830\":1,\"872\":1,\"873\":1,\"877\":2,\"884\":3}}],[\"3594\",{\"1\":{\"424\":1}}],[\"3591\",{\"1\":{\"421\":1}}],[\"3590\",{\"1\":{\"418\":1}}],[\"3589\",{\"1\":{\"415\":1}}],[\"3588\",{\"1\":{\"409\":1,\"412\":1}}],[\"3586\",{\"1\":{\"408\":1}}],[\"3585\",{\"1\":{\"406\":1}}],[\"35<\",{\"1\":{\"8\":2}}],[\"35\",{\"1\":{\"8\":1,\"11\":1}}],[\"2l\",{\"1\":{\"797\":1}}],[\"2s\",{\"1\":{\"783\":1,\"798\":2}}],[\"2g\",{\"1\":{\"447\":2,\"600\":1}}],[\"2h\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"2m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"2+1\",{\"1\":{\"195\":1}}],[\"2f\",{\"1\":{\"187\":1}}],[\"2方法获取并更新进程字典的值\",{\"1\":{\"157\":1}}],[\"2方法后才会进入到rabbit\",{\"1\":{\"157\":1}}],[\"2和credit\",{\"1\":{\"157\":1}}],[\"24\",{\"1\":{\"594\":13}}],[\"2453\",{\"1\":{\"372\":1}}],[\"2456\",{\"1\":{\"103\":1}}],[\"24>\",{\"1\":{\"28\":1,\"31\":1}}],[\"26\",{\"1\":{\"135\":1,\"293\":1,\"594\":1}}],[\"262144\",{\"1\":{\"81\":1}}],[\"263334\",{\"1\":{\"11\":1}}],[\"27t15\",{\"1\":{\"599\":7}}],[\"276\",{\"1\":{\"261\":1}}],[\"27\",{\"1\":{\"65\":1,\"178\":7}}],[\"278\",{\"1\":{\"11\":1}}],[\"2354\",{\"1\":{\"594\":1}}],[\"23\",{\"1\":{\"45\":1,\"65\":1,\"103\":1,\"594\":11}}],[\"23>\",{\"1\":{\"28\":1,\"31\":1}}],[\"255\",{\"1\":{\"599\":3}}],[\"250\",{\"1\":{\"103\":4}}],[\"256\",{\"1\":{\"42\":1}}],[\"25\",{\"1\":{\"32\":1,\"35\":1,\"593\":1,\"594\":1}}],[\"218965349z\",{\"1\":{\"599\":1}}],[\"218960481z\",{\"1\":{\"599\":1}}],[\"218953791z\",{\"1\":{\"599\":1}}],[\"218891884z\",{\"1\":{\"599\":1}}],[\"218887204z\",{\"1\":{\"599\":1}}],[\"218878131z\",{\"1\":{\"599\":1}}],[\"218761998z\",{\"1\":{\"599\":1}}],[\"21\",{\"1\":{\"175\":1}}],[\"212\",{\"1\":{\"31\":2}}],[\"21131\",{\"1\":{\"11\":1}}],[\"2271\",{\"1\":{\"594\":1}}],[\"2290\",{\"1\":{\"368\":1}}],[\"2257\",{\"1\":{\"261\":1}}],[\"221bf0008↩︎\",{\"1\":{\"136\":1}}],[\"221e\",{\"1\":{\"28\":2}}],[\"22\",{\"0\":{\"175\":1},\"1\":{\"35\":1,\"175\":1,\"176\":5,\"177\":1,\"593\":1}}],[\"22>\",{\"1\":{\"28\":1,\"31\":1}}],[\"2>\",{\"1\":{\"23\":1,\"24\":1,\"30\":1,\"31\":1,\"34\":1,\"67\":1,\"74\":1,\"98\":1,\"102\":1}}],[\"2883\",{\"1\":{\"240\":1}}],[\"28\",{\"0\":{\"802\":1},\"1\":{\"225\":1,\"240\":1,\"884\":1}}],[\"28290\",{\"1\":{\"11\":2}}],[\"28116\",{\"1\":{\"11\":1}}],[\"29749\",{\"1\":{\"11\":1}}],[\"2\",{\"0\":{\"145\":1,\"146\":1,\"147\":2,\"148\":1,\"149\":1,\"150\":1,\"151\":1,\"152\":2,\"155\":1,\"158\":1,\"177\":1,\"178\":1,\"182\":1,\"186\":1,\"188\":1,\"191\":1,\"196\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"206\":1,\"207\":1,\"211\":2,\"215\":1,\"216\":1,\"217\":1,\"218\":2,\"219\":2,\"220\":2,\"221\":3,\"222\":1,\"243\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":2,\"271\":1,\"272\":1,\"273\":1,\"276\":1,\"283\":1,\"286\":1,\"287\":1,\"298\":1,\"299\":1,\"300\":1,\"301\":2,\"302\":1,\"303\":1,\"307\":1,\"308\":1,\"314\":1,\"317\":1,\"322\":1,\"323\":1,\"326\":1,\"330\":1,\"332\":1,\"335\":1,\"340\":1,\"341\":1,\"342\":1,\"343\":2,\"344\":1,\"345\":1,\"348\":1,\"353\":1,\"354\":1,\"357\":1,\"360\":1,\"364\":1,\"365\":1,\"368\":1,\"371\":1,\"372\":1,\"373\":2,\"374\":2,\"375\":3,\"378\":1,\"381\":1,\"384\":1,\"387\":1,\"391\":1,\"398\":1,\"399\":1,\"412\":1,\"436\":1,\"462\":1,\"463\":1,\"464\":1,\"465\":2,\"468\":1,\"469\":1,\"470\":2,\"473\":1,\"477\":1,\"481\":1,\"482\":1,\"483\":1,\"488\":2,\"491\":1,\"497\":1,\"498\":1,\"499\":2,\"500\":2,\"501\":3,\"502\":1,\"503\":1,\"504\":2,\"505\":1,\"509\":1,\"510\":1,\"515\":1,\"516\":1,\"517\":1,\"518\":2,\"519\":1,\"524\":1,\"525\":1,\"526\":2,\"527\":1,\"528\":1,\"529\":1,\"532\":1,\"535\":1,\"538\":1,\"539\":1,\"540\":2,\"545\":1,\"546\":1,\"547\":1,\"548\":2,\"549\":2,\"550\":1,\"551\":1,\"552\":1,\"553\":2,\"556\":1,\"560\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":2,\"572\":1,\"573\":1,\"576\":1,\"607\":1,\"608\":1,\"609\":1,\"610\":2,\"611\":1,\"612\":2,\"613\":2,\"614\":3,\"615\":2,\"616\":1,\"617\":1,\"618\":2,\"619\":1,\"620\":1,\"621\":2,\"622\":1,\"623\":1,\"626\":1,\"628\":1,\"629\":1,\"630\":2,\"631\":2,\"632\":3,\"636\":1,\"640\":1,\"643\":1,\"647\":1,\"648\":1,\"649\":2,\"650\":1,\"654\":1,\"655\":1,\"656\":1,\"657\":2,\"661\":1,\"662\":1,\"663\":2,\"664\":1,\"665\":1,\"668\":1,\"669\":1,\"670\":2,\"671\":2,\"672\":3,\"673\":1,\"676\":1,\"677\":1,\"678\":1,\"679\":2,\"680\":1,\"681\":1,\"682\":2,\"683\":2,\"684\":3,\"685\":1,\"689\":1,\"698\":1,\"699\":1,\"700\":2,\"701\":1,\"702\":1,\"703\":2,\"704\":1,\"708\":1,\"709\":1,\"710\":1,\"711\":2,\"715\":1,\"716\":1,\"717\":1,\"718\":2,\"721\":1,\"724\":1,\"725\":1,\"726\":1,\"727\":2,\"728\":2,\"729\":2,\"733\":1,\"736\":1,\"737\":1,\"738\":2,\"743\":1,\"744\":1,\"745\":2,\"746\":1,\"747\":1,\"748\":1,\"749\":2,\"766\":1,\"767\":1,\"768\":2,\"770\":1,\"771\":1,\"772\":2,\"773\":1,\"776\":1,\"777\":1,\"778\":2,\"779\":1,\"783\":1,\"787\":1,\"788\":1,\"789\":1,\"790\":2,\"791\":1,\"796\":1,\"805\":1,\"806\":1,\"807\":2,\"808\":1,\"809\":1,\"810\":1,\"811\":1,\"814\":1,\"817\":1,\"824\":1,\"825\":1,\"828\":2,\"831\":1,\"832\":1,\"833\":2,\"834\":2,\"835\":3,\"838\":1,\"842\":1,\"848\":1,\"849\":1,\"850\":1,\"851\":2,\"852\":1,\"861\":1,\"862\":1,\"863\":2,\"864\":1,\"865\":1,\"872\":1,\"873\":1,\"874\":1,\"875\":1,\"876\":1,\"877\":2,\"878\":1,\"879\":2,\"880\":2,\"881\":3},\"1\":{\"11\":4,\"22\":1,\"24\":5,\"28\":2,\"31\":10,\"32\":2,\"34\":4,\"37\":3,\"39\":1,\"42\":6,\"43\":1,\"44\":2,\"45\":2,\"65\":2,\"80\":3,\"98\":6,\"103\":11,\"106\":1,\"111\":1,\"170\":1,\"171\":1,\"176\":1,\"188\":1,\"190\":1,\"195\":1,\"220\":1,\"226\":1,\"228\":1,\"244\":2,\"245\":1,\"253\":1,\"257\":2,\"261\":7,\"289\":1,\"343\":1,\"386\":2,\"390\":1,\"401\":1,\"406\":2,\"426\":1,\"442\":1,\"467\":1,\"480\":1,\"481\":1,\"487\":1,\"498\":2,\"552\":1,\"560\":1,\"568\":2,\"573\":1,\"576\":1,\"594\":2,\"595\":1,\"599\":2,\"626\":1,\"656\":1,\"667\":1,\"700\":1,\"723\":2,\"753\":1,\"755\":4,\"766\":1,\"775\":2,\"872\":1,\"884\":1}}],[\"2048\",{\"1\":{\"541\":1}}],[\"20181109221800\",{\"1\":{\"527\":1}}],[\"2019\",{\"1\":{\"225\":1}}],[\"2019年随着该兴趣组并入app\",{\"1\":{\"126\":1}}],[\"20w\",{\"1\":{\"430\":2,\"433\":2,\"435\":1}}],[\"20m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"20s\",{\"1\":{\"332\":1,\"618\":1,\"624\":1,\"648\":1,\"656\":5,\"660\":2,\"729\":1,\"735\":1}}],[\"206\",{\"1\":{\"262\":1,\"410\":1}}],[\"20230703004414898\",{\"1\":{\"841\":1}}],[\"20230702220114234\",{\"1\":{\"838\":1}}],[\"20230716\",{\"1\":{\"821\":1}}],[\"20230324\",{\"1\":{\"819\":1}}],[\"20230304\",{\"1\":{\"802\":1}}],[\"20230306\",{\"1\":{\"113\":1,\"125\":1}}],[\"20230316\",{\"1\":{\"137\":1}}],[\"2021\",{\"1\":{\"528\":1}}],[\"20211209174133951\",{\"1\":{\"307\":1}}],[\"20221212\",{\"1\":{\"763\":1}}],[\"20221104\",{\"1\":{\"751\":1}}],[\"2022\",{\"1\":{\"115\":1,\"406\":1,\"599\":7}}],[\"20220929\",{\"1\":{\"722\":1}}],[\"20220912\",{\"1\":{\"696\":1}}],[\"20220904\",{\"1\":{\"666\":1}}],[\"20220830\",{\"1\":{\"644\":1}}],[\"20220827\",{\"1\":{\"626\":1}}],[\"20220820\",{\"1\":{\"605\":1}}],[\"20220724\",{\"1\":{\"588\":1}}],[\"20220714\",{\"1\":{\"225\":1}}],[\"20220606\",{\"1\":{\"543\":1}}],[\"20220618\",{\"1\":{\"578\":1}}],[\"20220610\",{\"1\":{\"213\":1}}],[\"20220614\",{\"1\":{\"18\":1}}],[\"20220521\",{\"1\":{\"522\":1}}],[\"20220515\",{\"1\":{\"495\":1}}],[\"20220502\",{\"1\":{\"459\":1}}],[\"20220328\",{\"1\":{\"382\":1}}],[\"20220320\",{\"1\":{\"369\":1}}],[\"20220301\",{\"1\":{\"264\":1,\"295\":1,\"319\":1}}],[\"20220313\",{\"1\":{\"162\":1,\"350\":1}}],[\"20220411235923338\",{\"1\":{\"432\":1}}],[\"20220411235323472\",{\"1\":{\"432\":1}}],[\"20220411235301250\",{\"1\":{\"432\":1}}],[\"20220411235759752\",{\"1\":{\"432\":1}}],[\"20220411234502755\",{\"1\":{\"429\":1}}],[\"20220411232605135\",{\"1\":{\"426\":1}}],[\"20220411231805018\",{\"1\":{\"424\":1}}],[\"20220411224424160\",{\"1\":{\"423\":1}}],[\"20220411223612434\",{\"1\":{\"422\":1}}],[\"20220411222509675\",{\"1\":{\"420\":1}}],[\"20220411222306938\",{\"1\":{\"420\":1}}],[\"20220411222721408\",{\"1\":{\"419\":1}}],[\"20220411221546009\",{\"1\":{\"420\":1}}],[\"20220411215152793\",{\"1\":{\"417\":1}}],[\"20220411213226971\",{\"1\":{\"416\":1}}],[\"20220411212011338\",{\"1\":{\"408\":1}}],[\"20220412\",{\"1\":{\"405\":1,\"438\":1}}],[\"20220410\",{\"1\":{\"393\":1}}],[\"20220409\",{\"1\":{\"180\":1}}],[\"20220408\",{\"1\":{\"174\":1}}],[\"20220427\",{\"1\":{\"1\":1}}],[\"20220131\",{\"1\":{\"142\":1,\"239\":1}}],[\"20>\",{\"1\":{\"28\":1}}],[\"2000\",{\"1\":{\"808\":1}}],[\"2000万个\",{\"1\":{\"307\":1}}],[\"2000万个索引项\",{\"1\":{\"307\":1}}],[\"20000\",{\"1\":{\"103\":1,\"820\":1}}],[\"200表示下游进程处理200个消息后会一次性给上游进程加200信用值\",{\"1\":{\"151\":1}}],[\"200\",{\"1\":{\"11\":2,\"103\":1,\"151\":2,\"154\":2,\"433\":1}}],[\"20\",{\"1\":{\"11\":1,\"67\":4,\"80\":1,\"103\":1,\"177\":1,\"624\":1,\"699\":1,\"707\":3,\"723\":1,\"737\":1}}],[\"empty\",{\"1\":{\"786\":1}}],[\"embed\",{\"1\":{\"220\":1}}],[\"e1\",{\"1\":{\"340\":2}}],[\"equals\",{\"1\":{\"262\":9,\"365\":1,\"380\":1,\"481\":3,\"491\":1,\"492\":2,\"519\":1,\"520\":1,\"540\":1,\"567\":1,\"572\":1,\"573\":1,\"664\":1,\"718\":1,\"744\":1,\"745\":1,\"750\":3,\"790\":7,\"798\":2,\"847\":1}}],[\"equivalent\",{\"1\":{\"103\":4}}],[\"eol\",{\"1\":{\"175\":1}}],[\"elapsedtime\",{\"1\":{\"694\":2,\"851\":3}}],[\"element\",{\"1\":{\"541\":1}}],[\"eliminate\",{\"1\":{\"240\":1,\"247\":1,\"406\":5,\"408\":1,\"421\":1,\"424\":1,\"426\":1}}],[\"eliminates\",{\"1\":{\"157\":1}}],[\"else\",{\"1\":{\"38\":1,\"64\":1,\"262\":5,\"287\":1,\"291\":3,\"313\":1,\"314\":1,\"317\":4,\"344\":1,\"365\":4,\"380\":4,\"390\":3,\"392\":1,\"413\":1,\"414\":2,\"491\":1,\"492\":1,\"518\":1,\"519\":1,\"541\":2,\"570\":1,\"571\":1,\"572\":2,\"576\":2,\"642\":2,\"663\":1,\"664\":3,\"690\":2,\"693\":9,\"694\":9,\"695\":2,\"714\":2,\"715\":5,\"718\":1,\"720\":3,\"721\":1,\"742\":1,\"744\":3,\"745\":1,\"748\":2,\"749\":2,\"750\":6,\"786\":1,\"787\":2,\"789\":5,\"790\":2,\"796\":1,\"797\":2,\"798\":4,\"800\":2,\"817\":3,\"847\":1,\"852\":1}}],[\"epoch\",{\"1\":{\"800\":2}}],[\"epolls\",{\"1\":{\"693\":2}}],[\"eprof\",{\"1\":{\"105\":1}}],[\"epp\",{\"1\":{\"63\":1}}],[\"esl\",{\"1\":{\"176\":12}}],[\"escape\",{\"1\":{\"157\":2}}],[\"escript\",{\"1\":{\"74\":1}}],[\"eshell\",{\"1\":{\"98\":1}}],[\"etc\",{\"1\":{\"177\":1}}],[\"etcd等\",{\"1\":{\"136\":1}}],[\"etcd\",{\"1\":{\"134\":2}}],[\"etcd客户端视角下\",{\"1\":{\"134\":1}}],[\"ets\",{\"0\":{\"97\":1,\"99\":1},\"1\":{\"97\":4,\"98\":14,\"99\":1}}],[\"eta\",{\"1\":{\"11\":2}}],[\"entity\",{\"1\":{\"541\":2}}],[\"entrypoint\",{\"1\":{\"599\":1}}],[\"entry<messagequeue\",{\"1\":{\"664\":1,\"720\":1,\"744\":1}}],[\"entry<string\",{\"1\":{\"491\":1,\"492\":3,\"520\":1,\"541\":1,\"662\":1,\"797\":2}}],[\"entry<long\",{\"1\":{\"491\":1,\"492\":1}}],[\"entry<integer\",{\"1\":{\"364\":1}}],[\"entryset\",{\"1\":{\"364\":1,\"491\":2,\"492\":5,\"520\":1,\"541\":1,\"662\":1,\"664\":1,\"720\":1,\"744\":1,\"797\":1}}],[\"entry\",{\"1\":{\"364\":3,\"435\":1,\"491\":2,\"492\":12,\"541\":4,\"662\":2,\"720\":3,\"797\":2}}],[\"enablecalcfilterbitmap\",{\"1\":{\"851\":1}}],[\"enablecalcfilterbitmap=true\",{\"1\":{\"828\":1,\"835\":1}}],[\"enableconsumequeueext=true\",{\"1\":{\"828\":1,\"835\":1}}],[\"enablepropertyfilter=true\",{\"1\":{\"828\":2}}],[\"enablemultidispatch\",{\"1\":{\"694\":1,\"806\":1}}],[\"enablemsgtrace\",{\"1\":{\"539\":2}}],[\"enablelmq\",{\"1\":{\"694\":1,\"806\":1}}],[\"enable\",{\"1\":{\"516\":1}}],[\"enableasyncdeliver\",{\"1\":{\"380\":1}}],[\"enablescheduleasyncdeliver\",{\"1\":{\"370\":1}}],[\"enabled\",{\"1\":{\"122\":1}}],[\"encoderfromcontextbean\",{\"1\":{\"541\":1}}],[\"encoderbuffer\",{\"1\":{\"257\":22}}],[\"encodeheader\",{\"1\":{\"414\":1,\"693\":1}}],[\"encodedbuff\",{\"1\":{\"257\":1}}],[\"encode\",{\"1\":{\"257\":3,\"406\":1,\"409\":1,\"413\":1,\"414\":2,\"490\":1,\"493\":1}}],[\"encountered\",{\"1\":{\"176\":1}}],[\"enough\",{\"1\":{\"103\":1}}],[\"environment\",{\"1\":{\"480\":1,\"595\":1,\"598\":1}}],[\"env\",{\"1\":{\"74\":1,\"151\":1,\"480\":1}}],[\"endphyoffset\",{\"1\":{\"307\":1,\"314\":2,\"392\":2}}],[\"endtime\",{\"1\":{\"798\":14,\"799\":1}}],[\"endtimestamp\",{\"1\":{\"307\":1,\"309\":1,\"313\":1,\"570\":3}}],[\"endtransactionthreadpoolnums\",{\"1\":{\"240\":1,\"252\":1,\"254\":2}}],[\"endif\",{\"1\":{\"64\":1}}],[\"end\",{\"1\":{\"31\":8,\"32\":2,\"33\":1,\"37\":3,\"38\":2,\"39\":1,\"43\":1,\"44\":1,\"46\":2,\"55\":1,\"79\":2,\"80\":2,\"82\":1,\"85\":2,\"103\":8,\"111\":1,\"157\":6,\"158\":2,\"159\":3,\"160\":2,\"309\":3,\"310\":1,\"314\":5,\"317\":4,\"344\":1,\"365\":3,\"519\":1,\"660\":1,\"688\":1,\"690\":1}}],[\"event\",{\"1\":{\"484\":1,\"693\":8,\"850\":5}}],[\"eventgrid等\",{\"1\":{\"126\":1}}],[\"eventmesh\",{\"1\":{\"126\":1}}],[\"evens\",{\"1\":{\"39\":9}}],[\"even\",{\"1\":{\"31\":5,\"39\":1}}],[\"evaluate\",{\"1\":{\"851\":1,\"852\":1}}],[\"eval\",{\"1\":{\"31\":7,\"42\":2,\"45\":4,\"80\":1,\"151\":1,\"345\":1,\"851\":1,\"852\":1}}],[\"eyecolour\",{\"1\":{\"26\":1}}],[\"ex\",{\"1\":{\"786\":1}}],[\"exists\",{\"1\":{\"518\":1,\"519\":1,\"664\":1,\"744\":1}}],[\"exist\",{\"1\":{\"493\":1,\"573\":1,\"663\":2,\"691\":1,\"693\":14,\"718\":5,\"720\":1,\"786\":2,\"799\":1}}],[\"exit和error其中之一\",{\"1\":{\"44\":1}}],[\"exited\",{\"1\":{\"43\":1,\"44\":2,\"599\":3}}],[\"exit\",{\"1\":{\"43\":5,\"44\":2,\"45\":4,\"480\":4}}],[\"executors\",{\"1\":{\"481\":1}}],[\"execution\",{\"1\":{\"406\":1,\"433\":1}}],[\"executeconsumemessagehookafter\",{\"1\":{\"718\":1}}],[\"executeconsumemessagehookbefore\",{\"1\":{\"693\":1}}],[\"executehookafter\",{\"1\":{\"715\":1,\"750\":1}}],[\"executehookbefore\",{\"1\":{\"715\":1,\"750\":1}}],[\"executetasklater\",{\"1\":{\"695\":2}}],[\"executepullrequestlater\",{\"1\":{\"690\":9,\"695\":2,\"748\":2,\"749\":1}}],[\"executepullrequestimmediately\",{\"1\":{\"639\":3,\"675\":1,\"688\":2,\"695\":3,\"749\":2}}],[\"executesendmessagehookafter\",{\"1\":{\"573\":1}}],[\"executesendmessagehookbefore\",{\"1\":{\"562\":1,\"573\":1}}],[\"executedeletefilesmanually方法被调用\",{\"1\":{\"390\":1}}],[\"executeontimeup\",{\"1\":{\"361\":1,\"365\":2,\"377\":1,\"380\":1}}],[\"execute\",{\"1\":{\"345\":2,\"365\":1,\"380\":1,\"490\":1,\"690\":1,\"695\":1}}],[\"executerequestwhenwakeup\",{\"0\":{\"340\":1},\"1\":{\"332\":2,\"334\":2,\"340\":1,\"345\":2}}],[\"extaddr\",{\"1\":{\"817\":3}}],[\"ext=\",{\"1\":{\"600\":4}}],[\"externals\",{\"1\":{\"573\":1}}],[\"extend\",{\"1\":{\"291\":1,\"365\":1,\"380\":1,\"694\":1,\"817\":1,\"847\":1,\"852\":1}}],[\"extends\",{\"1\":{\"262\":1,\"470\":1,\"488\":1,\"660\":1}}],[\"extfield\",{\"1\":{\"410\":2}}],[\"extfields\",{\"1\":{\"262\":3,\"410\":1}}],[\"extrainfo\",{\"1\":{\"793\":8}}],[\"extrainfoutil\",{\"1\":{\"790\":3,\"793\":7}}],[\"extract\",{\"1\":{\"240\":5,\"256\":5}}],[\"extret\",{\"1\":{\"287\":1,\"694\":4}}],[\"ext\",{\"1\":{\"262\":1,\"365\":1,\"380\":1,\"600\":2,\"694\":1}}],[\"excuterequestwhenwakeup\",{\"1\":{\"340\":1}}],[\"exceed\",{\"1\":{\"694\":1}}],[\"exceeds\",{\"1\":{\"257\":2,\"690\":2}}],[\"exceeded\",{\"1\":{\"257\":5}}],[\"exceptiontype是一个原子\",{\"1\":{\"44\":1}}],[\"exceptionsimpledesc\",{\"1\":{\"715\":1,\"750\":1}}],[\"exceptions\",{\"1\":{\"21\":1}}],[\"exception\",{\"1\":{\"21\":1,\"37\":1,\"42\":1,\"43\":10,\"44\":1,\"45\":2,\"105\":1,\"157\":2,\"313\":2,\"314\":2,\"317\":4,\"340\":1,\"344\":1,\"364\":1,\"365\":1,\"380\":1,\"381\":6,\"392\":2,\"480\":2,\"481\":2,\"490\":2,\"491\":2,\"492\":4,\"504\":1,\"515\":2,\"516\":1,\"519\":3,\"526\":1,\"568\":10,\"570\":3,\"572\":1,\"662\":1,\"663\":1,\"664\":1,\"688\":2,\"690\":4,\"693\":3,\"695\":2,\"715\":2,\"717\":4,\"720\":2,\"742\":1,\"744\":1,\"745\":2,\"746\":2,\"748\":1,\"750\":2,\"768\":2,\"786\":1,\"790\":2,\"800\":3}}],[\"exchange\",{\"0\":{\"166\":1,\"169\":1},\"1\":{\"163\":2,\"165\":1,\"166\":4,\"169\":1,\"170\":4,\"172\":2,\"173\":1,\"201\":1,\"233\":1,\"810\":2}}],[\"exhaustion\",{\"1\":{\"155\":2}}],[\"examinebrokerclusterinfo\",{\"1\":{\"768\":1}}],[\"examples\",{\"1\":{\"187\":1}}],[\"example\",{\"1\":{\"11\":4,\"54\":1,\"103\":2,\"545\":1}}],[\"exactly\",{\"1\":{\"133\":1,\"185\":2,\"186\":1,\"187\":1,\"190\":2,\"757\":1}}],[\"expiredtime\",{\"1\":{\"390\":3}}],[\"expired\",{\"1\":{\"382\":1,\"750\":1}}],[\"expectlogicoffset\",{\"1\":{\"285\":15}}],[\"expressmessagefilter\",{\"1\":{\"847\":1}}],[\"express\",{\"1\":{\"116\":3}}],[\"expressionmessagefilter\",{\"1\":{\"693\":1,\"790\":1,\"838\":2,\"839\":2,\"844\":2,\"852\":1}}],[\"expressionforretrymessagefilter\",{\"1\":{\"693\":1,\"838\":1}}],[\"expressiontype\",{\"1\":{\"691\":6,\"693\":3,\"847\":1,\"850\":1,\"852\":2}}],[\"expressions\",{\"1\":{\"82\":1}}],[\"expressions2\",{\"1\":{\"79\":1,\"82\":1}}],[\"expressions1\",{\"1\":{\"79\":1,\"82\":1}}],[\"expression\",{\"1\":{\"21\":1,\"37\":2,\"693\":1,\"841\":6,\"844\":1,\"850\":5,\"851\":1,\"852\":2}}],[\"expr2\",{\"1\":{\"69\":4}}],[\"exprn\",{\"1\":{\"55\":1}}],[\"expr1\",{\"1\":{\"55\":1,\"69\":4}}],[\"exprs\",{\"1\":{\"45\":2}}],[\"expr\",{\"1\":{\"38\":3,\"42\":1,\"157\":3}}],[\"export\",{\"1\":{\"30\":2,\"80\":1,\"85\":1,\"98\":1,\"103\":1}}],[\"e\",{\"0\":{\"421\":1},\"1\":{\"21\":1,\"103\":1,\"139\":2,\"146\":2,\"262\":6,\"313\":2,\"314\":2,\"317\":8,\"340\":2,\"343\":2,\"344\":2,\"345\":4,\"364\":2,\"365\":2,\"380\":2,\"381\":6,\"390\":1,\"392\":2,\"406\":1,\"410\":1,\"435\":2,\"481\":1,\"490\":3,\"491\":2,\"492\":4,\"504\":2,\"515\":2,\"519\":4,\"526\":2,\"539\":1,\"541\":1,\"568\":10,\"572\":2,\"600\":7,\"601\":1,\"662\":2,\"663\":2,\"664\":1,\"688\":4,\"690\":6,\"693\":3,\"695\":4,\"714\":2,\"715\":3,\"717\":4,\"720\":2,\"721\":2,\"742\":2,\"744\":1,\"745\":2,\"746\":2,\"748\":2,\"750\":3,\"786\":2,\"790\":2,\"796\":2,\"808\":1,\"817\":4,\"851\":4,\"852\":4}}],[\"erase\",{\"1\":{\"67\":4,\"160\":1}}],[\"errata\",{\"1\":{\"41\":5}}],[\"errorinfo\",{\"1\":{\"693\":3}}],[\"errors\",{\"1\":{\"176\":1}}],[\"error\",{\"1\":{\"11\":2,\"42\":1,\"43\":5,\"44\":3,\"46\":9,\"105\":1,\"106\":2,\"157\":4,\"158\":1,\"176\":1,\"261\":1,\"285\":1,\"313\":1,\"314\":7,\"317\":4,\"340\":7,\"343\":1,\"345\":2,\"364\":1,\"365\":6,\"380\":6,\"381\":4,\"392\":1,\"435\":1,\"481\":1,\"491\":1,\"492\":2,\"519\":1,\"539\":1,\"568\":5,\"572\":2,\"663\":1,\"664\":1,\"688\":2,\"690\":2,\"693\":6,\"694\":1,\"695\":1,\"717\":2,\"718\":5,\"720\":1,\"721\":2,\"742\":1,\"745\":1,\"746\":1,\"748\":1,\"786\":1,\"790\":1,\"793\":2,\"796\":3,\"798\":1,\"800\":1,\"817\":2,\"851\":6,\"852\":4}}],[\"erl文件中\",{\"1\":{\"156\":1}}],[\"erl文件\",{\"1\":{\"156\":1}}],[\"erlc\",{\"1\":{\"58\":1,\"74\":1}}],[\"erl\",{\"1\":{\"21\":1,\"30\":2,\"42\":4,\"45\":10,\"58\":1,\"74\":3,\"98\":1,\"102\":3,\"157\":4,\"158\":2,\"159\":3,\"160\":1}}],[\"erlang=1\",{\"1\":{\"177\":1}}],[\"erlang没有对进程邮箱的大小进行限制\",{\"1\":{\"144\":1}}],[\"erlang没有单独的布尔值类型\",{\"1\":{\"56\":1}}],[\"erlang进程之间不共享内存\",{\"1\":{\"144\":1}}],[\"erlang进程没有共享内存\",{\"1\":{\"77\":1}}],[\"erlang里的数字不是整数就是浮点数\",{\"1\":{\"65\":1}}],[\"erlang预处理器\",{\"1\":{\"63\":1}}],[\"erlang模块在编译前会自动由erlang的预处理器进行处理\",{\"1\":{\"58\":1}}],[\"erlang允许一个模块的两个版本同时运行\",{\"1\":{\"57\":1}}],[\"erlang对自己说\",{\"1\":{\"23\":1}}],[\"erlang可以用任意长度的整数执行整数运算\",{\"1\":{\"22\":1}}],[\"erlang\",{\"0\":{\"18\":1,\"21\":1,\"47\":1,\"91\":1,\"93\":1,\"96\":1,\"101\":1,\"105\":1,\"110\":1,\"175\":1},\"1\":{\"18\":1,\"21\":2,\"23\":2,\"28\":1,\"30\":1,\"31\":1,\"32\":1,\"38\":1,\"41\":2,\"43\":2,\"44\":1,\"50\":1,\"68\":1,\"74\":2,\"78\":1,\"80\":2,\"81\":1,\"87\":4,\"88\":2,\"91\":2,\"97\":2,\"102\":3,\"103\":1,\"105\":1,\"111\":4,\"141\":1,\"147\":1,\"152\":1,\"154\":1,\"156\":2,\"158\":1,\"161\":1,\"175\":6,\"176\":15,\"177\":4,\"197\":1}}],[\"each\",{\"1\":{\"11\":2,\"240\":3,\"261\":1,\"406\":1,\"426\":1,\"520\":1,\"576\":1,\"787\":2}}],[\"吞吐量降到\",{\"1\":{\"135\":1}}],[\"吞吐量\",{\"1\":{\"11\":1}}],[\"wuchanming\",{\"1\":{\"294\":1}}],[\"wrter\",{\"1\":{\"820\":1}}],[\"wrapmultidispatch\",{\"1\":{\"814\":1}}],[\"wrap\",{\"1\":{\"717\":1,\"848\":1}}],[\"writabilitychanged\",{\"1\":{\"820\":1}}],[\"writable\",{\"1\":{\"487\":1}}],[\"writing\",{\"1\":{\"406\":1}}],[\"writebufferwatermark\",{\"1\":{\"819\":4,\"820\":1}}],[\"writebufferlowwatermark\",{\"1\":{\"819\":1}}],[\"writebufferhighwatermark\",{\"0\":{\"819\":1},\"1\":{\"819\":1,\"884\":1}}],[\"writebytes\",{\"1\":{\"414\":1}}],[\"writebyte\",{\"1\":{\"414\":2}}],[\"writequeuenums\",{\"1\":{\"484\":10,\"488\":2,\"572\":3}}],[\"writestr\",{\"1\":{\"414\":3}}],[\"writeshort\",{\"1\":{\"414\":2,\"420\":1}}],[\"writeint\",{\"1\":{\"414\":4,\"420\":1}}],[\"writelong\",{\"1\":{\"414\":1}}],[\"writelock\",{\"1\":{\"313\":2,\"491\":2,\"492\":2}}],[\"writerindex\",{\"1\":{\"414\":5}}],[\"writecharsequence\",{\"1\":{\"414\":1}}],[\"writemessagestore\",{\"1\":{\"365\":1,\"381\":1}}],[\"writeandflush\",{\"1\":{\"340\":1,\"693\":1}}],[\"write\",{\"0\":{\"820\":1},\"1\":{\"103\":7,\"109\":1,\"400\":1,\"430\":1,\"718\":2,\"817\":1,\"819\":3,\"820\":9}}],[\"wrong\",{\"1\":{\"285\":1,\"693\":1,\"695\":1,\"745\":1}}],[\"wroteoffset\",{\"1\":{\"258\":3}}],[\"would\",{\"1\":{\"157\":2}}],[\"world~n\",{\"1\":{\"74\":1}}],[\"world\",{\"1\":{\"74\":2,\"504\":1,\"526\":1,\"826\":1}}],[\"workspace\",{\"1\":{\"595\":3,\"597\":1,\"599\":3}}],[\"works\",{\"1\":{\"576\":1}}],[\"worker\",{\"1\":{\"541\":3}}],[\"worked\",{\"1\":{\"30\":2}}],[\"work\",{\"1\":{\"406\":1}}],[\"working\",{\"1\":{\"21\":2,\"787\":1}}],[\"word\",{\"1\":{\"22\":1}}],[\"www\",{\"1\":{\"114\":1,\"175\":2,\"187\":1,\"225\":1,\"819\":1}}],[\"water\",{\"0\":{\"820\":1},\"1\":{\"819\":6,\"820\":4}}],[\"watermark\",{\"1\":{\"819\":1}}],[\"watch\",{\"0\":{\"519\":1},\"1\":{\"516\":1,\"519\":4}}],[\"way\",{\"1\":{\"547\":1,\"693\":1}}],[\"wakeup\",{\"1\":{\"345\":2,\"435\":2,\"660\":1}}],[\"wakeupall\",{\"1\":{\"246\":1}}],[\"was\",{\"1\":{\"287\":1,\"573\":1,\"690\":1,\"693\":1,\"694\":1,\"790\":1}}],[\"warmmappedfile\",{\"1\":{\"402\":3}}],[\"warmup\",{\"1\":{\"4\":2,\"9\":1,\"11\":11}}],[\"warn\",{\"1\":{\"257\":4,\"285\":3,\"317\":1,\"344\":1,\"365\":2,\"380\":2,\"381\":4,\"390\":1,\"481\":1,\"490\":1,\"518\":1,\"519\":1,\"528\":2,\"662\":1,\"663\":3,\"664\":2,\"690\":6,\"693\":10,\"694\":4,\"695\":4,\"715\":4,\"721\":1,\"744\":2,\"745\":1,\"750\":8,\"786\":4,\"790\":1,\"795\":2,\"796\":3,\"797\":1,\"799\":2,\"800\":2,\"817\":7,\"851\":1}}],[\"wangji92\",{\"1\":{\"122\":2}}],[\"wangji\",{\"1\":{\"114\":1}}],[\"wants\",{\"1\":{\"103\":1}}],[\"want\",{\"1\":{\"103\":1,\"139\":1,\"176\":1}}],[\"waitinterval\",{\"1\":{\"660\":1}}],[\"waitingthreadtable\",{\"1\":{\"246\":2}}],[\"waitstoremsgokvalue\",{\"1\":{\"576\":2}}],[\"waitpoint\",{\"1\":{\"435\":3}}],[\"waitforrunning\",{\"1\":{\"344\":2,\"435\":2,\"519\":1,\"660\":1}}],[\"wait=true\",{\"1\":{\"240\":1,\"576\":1}}],[\"waitnotifyobject\",{\"0\":{\"246\":1},\"1\":{\"240\":1,\"243\":1,\"246\":3}}],[\"wait\",{\"1\":{\"103\":1,\"246\":1,\"435\":1,\"576\":3,\"816\":1}}],[\"were\",{\"1\":{\"176\":1}}],[\"web\",{\"1\":{\"112\":1,\"147\":1}}],[\"websocket\",{\"0\":{\"96\":1}}],[\"we\",{\"1\":{\"80\":1,\"103\":1,\"157\":4,\"160\":1,\"406\":1}}],[\"w\",{\"1\":{\"41\":1,\"80\":2}}],[\"white\",{\"1\":{\"520\":2}}],[\"whiteremoteaddress\",{\"1\":{\"503\":3}}],[\"while\",{\"1\":{\"176\":1,\"242\":1,\"291\":1,\"344\":1,\"361\":1,\"365\":2,\"380\":5,\"381\":1,\"491\":1,\"492\":6,\"519\":1,\"541\":1,\"660\":1,\"664\":1,\"688\":1,\"744\":1,\"745\":1,\"797\":1,\"798\":1,\"851\":1}}],[\"which\",{\"1\":{\"21\":1,\"175\":1,\"240\":1,\"251\":1,\"406\":1,\"767\":2}}],[\"whether\",{\"1\":{\"257\":1}}],[\"where\",{\"1\":{\"103\":2,\"406\":1,\"421\":1}}],[\"whereis\",{\"1\":{\"84\":1}}],[\"when\",{\"0\":{\"36\":1},\"1\":{\"36\":5,\"37\":2,\"46\":1,\"79\":2,\"82\":2,\"158\":1,\"192\":2,\"345\":3,\"402\":2,\"406\":3,\"421\":1,\"426\":1,\"572\":1,\"665\":1,\"690\":5,\"694\":1}}],[\"why\",{\"1\":{\"43\":4,\"46\":1,\"798\":1}}],[\"what\",{\"1\":{\"30\":2,\"33\":2,\"173\":1}}],[\"who=w\",{\"1\":{\"41\":1}}],[\"who\",{\"1\":{\"26\":2,\"41\":4}}],[\"windows\",{\"1\":{\"103\":2,\"138\":1}}],[\"width\",{\"1\":{\"30\":4}}],[\"wildcards\",{\"1\":{\"21\":1}}],[\"willneed\",{\"1\":{\"402\":1}}],[\"will\",{\"1\":{\"11\":1,\"176\":3,\"390\":1,\"525\":1,\"576\":1,\"694\":1,\"790\":1,\"797\":1}}],[\"without\",{\"1\":{\"715\":1}}],[\"withoutnamespace\",{\"1\":{\"540\":3,\"573\":2,\"717\":1}}],[\"withnamespace\",{\"1\":{\"570\":1,\"717\":1}}],[\"with\",{\"1\":{\"21\":4,\"46\":2,\"98\":1,\"154\":2,\"161\":1,\"406\":2,\"412\":1,\"425\":1,\"570\":1,\"717\":1,\"883\":3}}],[\"+alwayspretouch\",{\"1\":{\"600\":1}}],[\"+1\",{\"1\":{\"465\":1,\"472\":1,\"487\":1,\"717\":1,\"718\":1}}],[\"+$\",{\"1\":{\"424\":1}}],[\"+=\",{\"1\":{\"287\":1,\"291\":2,\"365\":1,\"380\":1,\"402\":1,\"694\":1,\"800\":1}}],[\"+2\",{\"1\":{\"188\":1}}],[\"++ff=unix\",{\"1\":{\"139\":2}}],[\"++\",{\"0\":{\"62\":1},\"1\":{\"34\":3,\"62\":2,\"109\":1}}],[\"+\",{\"1\":{\"11\":1,\"22\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":7,\"80\":1,\"103\":1,\"111\":1,\"159\":3,\"190\":1,\"223\":1,\"257\":11,\"258\":7,\"262\":4,\"282\":1,\"285\":10,\"289\":1,\"291\":15,\"306\":2,\"307\":1,\"313\":2,\"317\":25,\"344\":1,\"345\":1,\"347\":1,\"365\":14,\"377\":1,\"380\":3,\"390\":3,\"414\":3,\"426\":1,\"480\":1,\"493\":2,\"519\":9,\"541\":2,\"567\":5,\"568\":2,\"570\":3,\"573\":2,\"576\":2,\"595\":1,\"642\":5,\"643\":2,\"660\":2,\"688\":2,\"691\":7,\"693\":8,\"694\":10,\"700\":1,\"710\":1,\"715\":4,\"717\":7,\"718\":13,\"720\":3,\"721\":2,\"746\":1,\"760\":1,\"775\":1,\"789\":3,\"790\":9,\"793\":2,\"795\":5,\"796\":9,\"798\":15,\"799\":1,\"800\":4,\"807\":1,\"816\":2,\"817\":16,\"829\":1,\"830\":1,\"843\":2,\"850\":3,\"852\":8,\"873\":3}}],[\"b959cf8b6542\",{\"1\":{\"599\":1}}],[\"br\",{\"1\":{\"600\":3,\"601\":1}}],[\"break\",{\"1\":{\"242\":1,\"284\":2,\"291\":3,\"314\":3,\"317\":3,\"339\":1,\"381\":4,\"390\":3,\"392\":1,\"492\":3,\"541\":1,\"567\":2,\"568\":2,\"570\":3,\"573\":3,\"642\":5,\"643\":2,\"663\":3,\"664\":3,\"692\":1,\"693\":19,\"694\":1,\"695\":4,\"714\":1,\"715\":6,\"718\":1,\"744\":3,\"750\":5,\"786\":3,\"798\":4,\"799\":1,\"817\":1,\"850\":3}}],[\"broadcast\",{\"1\":{\"693\":1}}],[\"broadcasting\",{\"0\":{\"610\":1},\"1\":{\"608\":1,\"642\":1,\"663\":1,\"693\":1,\"715\":2,\"750\":1,\"786\":1}}],[\"brokerpathconfighelper\",{\"1\":{\"854\":1}}],[\"broker锁并开始消费\",{\"1\":{\"735\":1}}],[\"broker锁\",{\"0\":{\"731\":1,\"741\":1,\"742\":1},\"1\":{\"729\":6,\"732\":2,\"733\":2,\"735\":4,\"738\":1,\"739\":2,\"744\":1}}],[\"brokerminoffset=\",{\"1\":{\"693\":1}}],[\"broker是否可读\",{\"1\":{\"693\":1}}],[\"broker地址找到注册在broker上的filterserver地址\",{\"1\":{\"691\":1}}],[\"brokerbusy\",{\"1\":{\"690\":4,\"748\":4}}],[\"broker0\",{\"1\":{\"600\":3}}],[\"broker2\",{\"1\":{\"595\":1,\"600\":3}}],[\"broker1\",{\"1\":{\"595\":2,\"600\":3}}],[\"brokerclustername\",{\"1\":{\"595\":2}}],[\"brokercontroller\",{\"0\":{\"587\":1},\"1\":{\"339\":4,\"340\":1,\"343\":1,\"344\":2,\"345\":3,\"472\":1,\"490\":1,\"510\":1,\"516\":1,\"576\":6,\"693\":31,\"711\":1,\"718\":12,\"721\":2,\"786\":3,\"789\":4,\"790\":16,\"793\":6,\"795\":5,\"796\":6,\"797\":4,\"798\":6,\"799\":3,\"800\":6,\"850\":4,\"854\":1}}],[\"brokerconfig\",{\"1\":{\"282\":1,\"347\":1,\"370\":1,\"516\":1,\"537\":1,\"721\":1,\"851\":1,\"854\":1}}],[\"brokerip1=\",{\"1\":{\"595\":2}}],[\"brokerip\",{\"1\":{\"595\":1}}],[\"brokerid从mqclientinstance中获取broker地址\",{\"1\":{\"691\":1}}],[\"brokerid\",{\"1\":{\"472\":1,\"485\":1,\"490\":3,\"491\":5,\"492\":2,\"595\":2}}],[\"brokervipchannel\",{\"1\":{\"573\":1}}],[\"brokerstatsmanager\",{\"1\":{\"693\":4,\"694\":1}}],[\"brokerstartup\",{\"1\":{\"599\":4}}],[\"brokers\",{\"1\":{\"601\":1,\"807\":1}}],[\"brokerssent\",{\"1\":{\"570\":2}}],[\"brokersuspendmaxtimemillis\",{\"1\":{\"325\":1,\"332\":1,\"691\":3}}],[\"brokerouterexecutor\",{\"1\":{\"490\":1}}],[\"brokerouterapi\",{\"1\":{\"490\":2}}],[\"brokerhousekeepingservice\",{\"1\":{\"481\":1}}],[\"brokerdata\",{\"1\":{\"491\":9,\"492\":6,\"768\":1}}],[\"brokerdatas\",{\"1\":{\"470\":1,\"488\":3}}],[\"brokerdata>>\",{\"1\":{\"492\":1}}],[\"brokerdata>\",{\"1\":{\"469\":1,\"485\":1}}],[\"brokerliveinfo\",{\"1\":{\"487\":1,\"491\":6}}],[\"brokerliveinfo>>\",{\"1\":{\"492\":1}}],[\"brokerliveinfo>\",{\"1\":{\"469\":1,\"487\":1,\"492\":1}}],[\"brokerlivetable\",{\"0\":{\"487\":1},\"1\":{\"464\":1,\"469\":1,\"473\":1,\"474\":1,\"487\":1,\"491\":3,\"492\":2}}],[\"brokernamefound\",{\"1\":{\"492\":7}}],[\"brokernames\",{\"1\":{\"491\":5,\"492\":3}}],[\"brokername\",{\"1\":{\"469\":3,\"474\":1,\"484\":11,\"485\":2,\"486\":1,\"488\":4,\"490\":2,\"491\":6,\"492\":3,\"595\":2,\"717\":4,\"791\":2,\"808\":2}}],[\"brokeraddrfound\",{\"1\":{\"492\":10}}],[\"brokeraddrsmap\",{\"1\":{\"491\":2}}],[\"brokeraddrs\",{\"1\":{\"485\":2,\"488\":2,\"768\":2}}],[\"brokeraddr\",{\"1\":{\"469\":2,\"470\":1,\"487\":1,\"488\":1,\"490\":2,\"491\":9,\"492\":4,\"573\":9,\"691\":4,\"717\":2,\"768\":2}}],[\"brokeraddrtable\",{\"0\":{\"485\":1},\"1\":{\"464\":1,\"465\":1,\"469\":1,\"473\":1,\"474\":1,\"477\":1,\"485\":1,\"491\":4,\"492\":4,\"493\":1,\"573\":1}}],[\"brokerallowsuspend\",{\"1\":{\"339\":3,\"693\":5,\"793\":2}}],[\"broker处理再到消息被消费的流程\",{\"1\":{\"354\":1}}],[\"broker端是否允许挂起\",{\"1\":{\"339\":1,\"693\":1}}],[\"broker断电就会存在数据丢失的情况\",{\"1\":{\"285\":1}}],[\"brokerrole\",{\"1\":{\"282\":1,\"347\":1,\"595\":2,\"693\":2,\"817\":1}}],[\"broker启动时\",{\"1\":{\"273\":1,\"279\":1}}],[\"broker在内部都是通过actor模式实现的\",{\"1\":{\"154\":1}}],[\"broker\",{\"0\":{\"210\":1,\"262\":1,\"472\":1,\"490\":1,\"503\":1,\"510\":1,\"511\":1,\"516\":1,\"520\":1,\"525\":1,\"553\":1,\"563\":1,\"574\":1,\"575\":1,\"673\":1,\"682\":1,\"717\":1,\"718\":1,\"721\":1,\"729\":1,\"762\":1,\"775\":1,\"776\":1,\"780\":1,\"781\":1,\"785\":1,\"788\":1,\"792\":1,\"794\":1,\"806\":1,\"847\":1},\"1\":{\"144\":2,\"147\":2,\"210\":1,\"211\":1,\"220\":1,\"240\":1,\"249\":1,\"256\":1,\"267\":1,\"277\":1,\"307\":2,\"309\":1,\"321\":1,\"323\":1,\"324\":1,\"325\":1,\"326\":2,\"329\":2,\"332\":2,\"334\":1,\"336\":1,\"347\":2,\"353\":1,\"354\":4,\"355\":1,\"356\":2,\"359\":1,\"360\":2,\"386\":3,\"403\":1,\"406\":2,\"407\":2,\"419\":1,\"426\":1,\"428\":1,\"431\":1,\"461\":10,\"464\":8,\"465\":9,\"467\":2,\"469\":6,\"470\":3,\"471\":3,\"472\":9,\"473\":4,\"474\":11,\"481\":4,\"483\":1,\"484\":20,\"485\":3,\"486\":1,\"487\":3,\"488\":5,\"490\":2,\"491\":13,\"492\":11,\"498\":1,\"499\":4,\"500\":3,\"503\":2,\"506\":2,\"507\":1,\"510\":4,\"516\":3,\"518\":1,\"520\":1,\"523\":3,\"524\":1,\"525\":2,\"530\":2,\"531\":1,\"532\":4,\"535\":1,\"537\":4,\"541\":2,\"544\":3,\"547\":4,\"548\":2,\"549\":5,\"550\":5,\"552\":4,\"553\":4,\"555\":1,\"556\":1,\"557\":1,\"559\":6,\"561\":5,\"562\":2,\"563\":2,\"572\":12,\"573\":4,\"576\":1,\"581\":1,\"595\":20,\"599\":8,\"600\":5,\"601\":2,\"606\":1,\"613\":1,\"614\":3,\"615\":1,\"617\":5,\"618\":1,\"620\":1,\"621\":1,\"622\":2,\"623\":8,\"624\":4,\"629\":1,\"632\":1,\"637\":2,\"638\":2,\"639\":2,\"640\":4,\"642\":2,\"643\":2,\"645\":1,\"648\":5,\"650\":3,\"656\":8,\"657\":3,\"658\":2,\"663\":1,\"665\":4,\"667\":2,\"669\":2,\"672\":1,\"673\":1,\"675\":2,\"676\":2,\"680\":1,\"683\":1,\"689\":1,\"690\":4,\"691\":4,\"693\":7,\"694\":1,\"697\":1,\"699\":2,\"700\":2,\"701\":1,\"703\":4,\"707\":2,\"708\":9,\"710\":5,\"711\":6,\"715\":3,\"717\":8,\"718\":4,\"720\":8,\"723\":1,\"729\":5,\"732\":3,\"734\":4,\"738\":1,\"739\":1,\"744\":1,\"745\":2,\"746\":3,\"748\":3,\"754\":5,\"765\":3,\"768\":1,\"769\":2,\"770\":3,\"771\":4,\"772\":5,\"773\":2,\"775\":4,\"777\":1,\"786\":1,\"806\":1,\"807\":1,\"808\":2,\"817\":1,\"828\":1,\"832\":2,\"833\":1,\"834\":1,\"837\":1,\"838\":1,\"839\":1,\"841\":1,\"850\":1,\"872\":1}}],[\"brown\",{\"1\":{\"26\":1}}],[\"b再发送给c\",{\"1\":{\"207\":1}}],[\"b节点上的mirror提升为master\",{\"1\":{\"192\":1}}],[\"b组成集群\",{\"1\":{\"192\":1}}],[\"bysql\",{\"1\":{\"830\":1}}],[\"byte>\",{\"1\":{\"520\":3}}],[\"byte2string\",{\"1\":{\"420\":1}}],[\"bytebuf\",{\"1\":{\"414\":7,\"437\":1}}],[\"bytebufferindex\",{\"1\":{\"285\":6}}],[\"bytebuffer\",{\"1\":{\"16\":1,\"249\":2,\"250\":2,\"257\":4,\"258\":5,\"285\":3,\"291\":6,\"402\":3,\"403\":1,\"414\":2,\"419\":1,\"420\":1,\"838\":2,\"848\":4,\"852\":1}}],[\"bytes2string\",{\"1\":{\"258\":1}}],[\"bytes\",{\"1\":{\"240\":1,\"414\":1,\"576\":1,\"851\":1}}],[\"byte\",{\"1\":{\"220\":1,\"240\":1,\"257\":6,\"345\":1,\"348\":1,\"402\":1,\"413\":1,\"414\":3,\"490\":1,\"493\":1,\"515\":3,\"520\":2,\"573\":1,\"576\":1,\"693\":1,\"797\":1,\"800\":1,\"852\":2}}],[\"by\",{\"1\":{\"157\":1,\"291\":1,\"345\":1,\"617\":1,\"691\":1,\"693\":4,\"694\":1,\"718\":1,\"847\":1,\"852\":3}}],[\"blank\",{\"1\":{\"285\":1}}],[\"blackhole\",{\"1\":{\"11\":2}}],[\"bloomdatavalid\",{\"1\":{\"852\":1}}],[\"bloom\",{\"1\":{\"851\":1,\"852\":2}}],[\"bloomfilterdata\",{\"1\":{\"843\":7,\"850\":3}}],[\"bloomfilter\",{\"0\":{\"842\":1},\"1\":{\"843\":1,\"850\":1,\"852\":3}}],[\"blog\",{\"1\":{\"225\":1}}],[\"blocking\",{\"1\":{\"541\":1}}],[\"blockingqueue\",{\"1\":{\"534\":1}}],[\"blocks\",{\"1\":{\"158\":2,\"160\":2}}],[\"blocked的列表中删除\",{\"1\":{\"160\":1}}],[\"blocked的值是一个进程id列表\",{\"1\":{\"158\":1}}],[\"blocked的值\",{\"1\":{\"158\":1}}],[\"blocked列表\",{\"1\":{\"160\":1}}],[\"blocked中\",{\"1\":{\"158\":1}}],[\"blocked\",{\"1\":{\"158\":6,\"159\":1,\"160\":4,\"380\":1}}],[\"blockedlistener\",{\"1\":{\"146\":1}}],[\"block\",{\"1\":{\"157\":2,\"158\":2,\"380\":1}}],[\"blob\",{\"1\":{\"122\":1,\"545\":1}}],[\"b2\",{\"1\":{\"56\":3}}],[\"b1\",{\"1\":{\"56\":4}}],[\"backtopic\",{\"1\":{\"718\":3}}],[\"backtrace\",{\"1\":{\"21\":1}}],[\"backup\",{\"1\":{\"363\":1}}],[\"back\",{\"1\":{\"240\":1,\"242\":2,\"575\":1,\"717\":1}}],[\"backingqueue的设计有点类似于linux的虚拟内存swap区\",{\"1\":{\"223\":1}}],[\"backingqueue由q1\",{\"1\":{\"223\":1}}],[\"backingqueue\",{\"1\":{\"222\":1}}],[\"backing\",{\"1\":{\"204\":1,\"205\":4}}],[\"batchsize\",{\"1\":{\"541\":3}}],[\"batch\",{\"0\":{\"293\":1,\"425\":1,\"564\":1},\"1\":{\"191\":1,\"240\":1,\"256\":1,\"262\":1,\"293\":2,\"390\":1,\"406\":1,\"425\":1,\"575\":1}}],[\"base\",{\"1\":{\"592\":2}}],[\"based\",{\"1\":{\"154\":2,\"406\":1}}],[\"basicproperties\",{\"1\":{\"218\":1}}],[\"basicconsume\",{\"1\":{\"198\":1}}],[\"basicqos\",{\"1\":{\"149\":1}}],[\"banana\",{\"1\":{\"103\":2}}],[\"bag\",{\"1\":{\"98\":6}}],[\"badly\",{\"1\":{\"693\":2,\"694\":1,\"695\":1,\"790\":1}}],[\"bad\",{\"1\":{\"42\":1,\"106\":3,\"406\":1}}],[\"bornhostlength\",{\"1\":{\"257\":1}}],[\"bornhostholder\",{\"1\":{\"257\":2}}],[\"bornhost\",{\"1\":{\"257\":2}}],[\"borntimestamp\",{\"1\":{\"257\":2,\"262\":1}}],[\"bottlenecks\",{\"1\":{\"161\":1}}],[\"both\",{\"1\":{\"139\":1}}],[\"bo\",{\"1\":{\"116\":1}}],[\"booleancanonicalname2\",{\"1\":{\"262\":1}}],[\"booleancanonicalname1\",{\"1\":{\"262\":1}}],[\"boolean\",{\"1\":{\"246\":1,\"262\":5,\"282\":1,\"285\":1,\"289\":1,\"310\":1,\"313\":2,\"314\":1,\"317\":4,\"339\":1,\"345\":1,\"380\":2,\"390\":5,\"424\":3,\"480\":1,\"481\":2,\"490\":2,\"491\":1,\"492\":2,\"517\":1,\"520\":1,\"537\":2,\"539\":1,\"541\":2,\"567\":2,\"570\":1,\"573\":4,\"576\":1,\"586\":1,\"642\":1,\"662\":1,\"663\":3,\"664\":3,\"690\":3,\"693\":5,\"694\":3,\"695\":1,\"714\":1,\"715\":2,\"717\":1,\"720\":1,\"744\":3,\"745\":1,\"746\":2,\"748\":1,\"749\":1,\"750\":2,\"789\":1,\"790\":2,\"791\":1,\"793\":1,\"795\":1,\"796\":1,\"797\":1,\"817\":5,\"838\":2,\"843\":1,\"847\":1,\"850\":1,\"851\":2,\"852\":5}}],[\"boot\",{\"1\":{\"116\":1,\"119\":1,\"122\":2}}],[\"book\",{\"1\":{\"41\":5}}],[\"bodysize\",{\"1\":{\"414\":2}}],[\"bodycrc32\",{\"1\":{\"490\":2}}],[\"bodycrc\",{\"1\":{\"257\":2}}],[\"body\",{\"1\":{\"257\":4,\"307\":2,\"414\":2,\"490\":3,\"573\":2,\"576\":2,\"807\":2}}],[\"bodylength\",{\"1\":{\"257\":10,\"537\":1}}],[\"body2\",{\"1\":{\"37\":1}}],[\"body1\",{\"1\":{\"37\":1}}],[\"but\",{\"1\":{\"340\":1,\"365\":1,\"390\":1,\"520\":1,\"663\":2,\"690\":1,\"694\":1,\"748\":1}}],[\"bug\",{\"1\":{\"285\":1,\"365\":2,\"380\":2,\"573\":1,\"664\":1,\"694\":1,\"695\":1,\"817\":4,\"851\":2}}],[\"buildmsgoffsetinfo\",{\"1\":{\"790\":1}}],[\"buildmqclientid\",{\"1\":{\"755\":1}}],[\"buildstartoffsetinfo\",{\"1\":{\"790\":1}}],[\"buildsysflag\",{\"1\":{\"690\":1,\"718\":1}}],[\"buildordercountinfo\",{\"1\":{\"790\":1}}],[\"buildpopretrytopic\",{\"1\":{\"789\":2,\"790\":1,\"800\":1}}],[\"buildplainaccessresource\",{\"1\":{\"518\":1}}],[\"buildconsumemessagecontext\",{\"1\":{\"718\":1}}],[\"buildcommandlineoptions\",{\"1\":{\"480\":2}}],[\"buildindex\",{\"1\":{\"309\":1,\"314\":2}}],[\"building\",{\"1\":{\"176\":1,\"314\":1}}],[\"buildkey\",{\"1\":{\"306\":1,\"314\":3,\"342\":1,\"345\":1,\"406\":1,\"426\":2}}],[\"build\",{\"1\":{\"276\":1,\"285\":2,\"314\":1,\"592\":3,\"693\":2}}],[\"built\",{\"1\":{\"35\":1}}],[\"bump\",{\"1\":{\"159\":4}}],[\"buflen\",{\"1\":{\"158\":9}}],[\"buf\",{\"1\":{\"158\":8}}],[\"bufferedinputstream\",{\"1\":{\"480\":1}}],[\"buffercq\",{\"1\":{\"365\":8,\"380\":7}}],[\"bufferconsumequeue\",{\"1\":{\"287\":6,\"694\":7}}],[\"buffer\",{\"0\":{\"820\":1},\"1\":{\"117\":2,\"244\":4,\"245\":1,\"256\":1,\"258\":1,\"406\":1,\"420\":2,\"779\":1,\"780\":1,\"782\":5,\"795\":3,\"796\":2,\"797\":7,\"819\":3,\"820\":18,\"852\":3}}],[\"bus\",{\"1\":{\"116\":1}}],[\"buy\",{\"1\":{\"103\":1}}],[\"buy3\",{\"1\":{\"27\":1}}],[\"buy3|things3\",{\"1\":{\"27\":1}}],[\"buy2\",{\"1\":{\"27\":2}}],[\"buy1\",{\"1\":{\"27\":1}}],[\"buy1|things2\",{\"1\":{\"27\":1}}],[\"biz\",{\"1\":{\"800\":1}}],[\"bitnum\",{\"1\":{\"843\":1}}],[\"bitpos\",{\"1\":{\"843\":2}}],[\"bits\",{\"1\":{\"843\":3}}],[\"bitsarray\",{\"1\":{\"843\":5,\"851\":2,\"852\":7}}],[\"bitstringexpr\",{\"1\":{\"34\":2}}],[\"bitstringpattern\",{\"1\":{\"34\":1}}],[\"bitstring\",{\"1\":{\"34\":1}}],[\"bitmap=\",{\"1\":{\"852\":1}}],[\"bitmap\",{\"1\":{\"424\":1,\"782\":2,\"852\":1}}],[\"bit\",{\"1\":{\"345\":1,\"424\":2,\"796\":1,\"797\":1,\"798\":2,\"851\":4,\"852\":1}}],[\"binary\",{\"1\":{\"106\":1}}],[\"bin\",{\"1\":{\"74\":1,\"106\":2}}],[\"binding\",{\"1\":{\"21\":1}}],[\"bindings\",{\"1\":{\"21\":2}}],[\"bt\",{\"1\":{\"21\":1}}],[\"b\",{\"0\":{\"409\":1,\"412\":1},\"1\":{\"21\":2,\"28\":2,\"34\":8,\"42\":5,\"62\":2,\"63\":2,\"98\":5,\"160\":2,\"207\":1,\"262\":3,\"406\":2,\"409\":1,\"410\":1,\"411\":2,\"412\":1,\"414\":1,\"425\":1,\"595\":5,\"828\":1}}],[\"between\",{\"1\":{\"828\":4,\"830\":1}}],[\"beta\",{\"1\":{\"223\":2}}],[\"before\",{\"1\":{\"390\":1,\"501\":1,\"508\":1,\"509\":1,\"514\":1,\"515\":1,\"534\":1,\"567\":1,\"568\":1,\"573\":1,\"642\":1,\"643\":1,\"717\":1,\"786\":1,\"852\":1}}],[\"because\",{\"1\":{\"258\":1,\"492\":6,\"664\":2,\"690\":1,\"715\":1,\"744\":1,\"748\":1,\"750\":4,\"790\":3,\"852\":1}}],[\"become\",{\"1\":{\"158\":2}}],[\"been\",{\"1\":{\"240\":1,\"242\":2,\"567\":1,\"568\":1,\"573\":1,\"642\":1,\"643\":1}}],[\"below\",{\"1\":{\"220\":1}}],[\"be\",{\"1\":{\"103\":1,\"157\":1,\"176\":3,\"390\":1,\"518\":1,\"525\":1,\"528\":1,\"573\":1,\"576\":1,\"693\":1,\"715\":1,\"720\":1,\"750\":4,\"797\":2,\"852\":1}}],[\"beginning\",{\"1\":{\"642\":1}}],[\"beginstarttime\",{\"1\":{\"573\":3}}],[\"beginindex\",{\"1\":{\"414\":5}}],[\"beginlocktimestamp\",{\"1\":{\"344\":2}}],[\"beginphyoffset\",{\"1\":{\"307\":1}}],[\"begintime\",{\"1\":{\"402\":1,\"694\":2,\"750\":2}}],[\"begintimestampprev\",{\"1\":{\"570\":4}}],[\"begintimestampfirst\",{\"1\":{\"570\":4}}],[\"begintimestamp\",{\"1\":{\"307\":1,\"309\":1,\"690\":1,\"695\":1,\"715\":2,\"749\":1,\"750\":2}}],[\"begintimemills\",{\"1\":{\"258\":1,\"693\":2}}],[\"begin\",{\"1\":{\"55\":1,\"157\":1,\"309\":3,\"310\":1,\"314\":6,\"317\":5,\"390\":1,\"690\":1}}],[\"bean\",{\"1\":{\"540\":1}}],[\"beans\",{\"1\":{\"540\":4}}],[\"bear\",{\"1\":{\"31\":1}}],[\"beam\",{\"1\":{\"30\":2}}],[\"best\",{\"1\":{\"16\":1,\"751\":1}}],[\"benchmarktest\",{\"1\":{\"484\":1}}],[\"benchmarks\",{\"1\":{\"10\":1}}],[\"benchmark\",{\"1\":{\"7\":2,\"9\":4,\"10\":1,\"11\":4,\"15\":1,\"261\":1,\"437\":1,\"488\":1}}],[\"benchmarkmode\",{\"1\":{\"4\":1,\"9\":1}}],[\"来指定延迟时间或定时时间\",{\"1\":{\"873\":1}}],[\"来指导架构提升自身的韧性能力\",{\"1\":{\"127\":1}}],[\"来\",{\"1\":{\"783\":1}}],[\"来匹配\",{\"1\":{\"781\":1,\"782\":1}}],[\"来尝试匹配\",{\"1\":{\"773\":1}}],[\"来修改单条消息的不可见时间\",{\"1\":{\"771\":1}}],[\"来保证没有多个消费者在重平衡后同时消费一个队列\",{\"1\":{\"729\":1}}],[\"来管理和保存该锁\",{\"1\":{\"729\":1}}],[\"来标记哪些消息成功了\",{\"1\":{\"715\":1}}],[\"来真正发送拉取请求\",{\"1\":{\"675\":1}}],[\"来处理消息拉取任务拉取成功后提交的消费任务\",{\"1\":{\"737\":1}}],[\"来处理消息拉取\",{\"1\":{\"675\":1}}],[\"来发送命令\",{\"1\":{\"556\":1}}],[\"来实现\",{\"1\":{\"496\":1}}],[\"来实现pull消息请求的二次处理\",{\"1\":{\"340\":1}}],[\"来自\",{\"1\":{\"470\":1,\"488\":1}}],[\"来算\",{\"1\":{\"447\":1}}],[\"来写入\",{\"1\":{\"432\":1}}],[\"来写\",{\"1\":{\"432\":1}}],[\"来让操作系统分配物理内存空间\",{\"1\":{\"402\":1}}],[\"来让人更方便地发现分布式系统可能存在的缺陷和不足\",{\"1\":{\"133\":1}}],[\"来说依赖太重\",{\"1\":{\"462\":1}}],[\"来说\",{\"1\":{\"398\":2}}],[\"来判断该消息是否要投递\",{\"1\":{\"365\":1}}],[\"来执行最终的消息消费逻辑\",{\"1\":{\"639\":1}}],[\"来执行\",{\"1\":{\"629\":1}}],[\"来执行定时任务\",{\"1\":{\"360\":1}}],[\"来执行与之前相同的跟踪\",{\"1\":{\"111\":1}}],[\"来配置\",{\"1\":{\"307\":2}}],[\"来配置镜像策略\",{\"1\":{\"185\":1}}],[\"来存储\",{\"1\":{\"307\":1}}],[\"来定时持久化的\",{\"1\":{\"288\":1}}],[\"来构建\",{\"1\":{\"276\":1}}],[\"来达到批量处理的目的\",{\"1\":{\"244\":1}}],[\"来控制每个消费者消费的队列和拉取的消息\",{\"1\":{\"615\":1}}],[\"来控制\",{\"1\":{\"197\":1}}],[\"来替代镜像队列\",{\"1\":{\"181\":1}}],[\"来提交消费进度\",{\"1\":{\"790\":1}}],[\"来提升写入速度\",{\"1\":{\"432\":1}}],[\"来提供高可用性\",{\"1\":{\"181\":1}}],[\"来提取该字段\",{\"1\":{\"41\":1}}],[\"来看一下进程字典中关于信用证的信息\",{\"1\":{\"157\":1}}],[\"来触发扩缩容动作\",{\"1\":{\"135\":1}}],[\"来观察\",{\"1\":{\"127\":1}}],[\"来对表里的行进行定义\",{\"1\":{\"103\":1}}],[\"来表示某个整数\",{\"1\":{\"22\":1}}],[\"来运行测试\",{\"1\":{\"10\":1}}],[\"来调用\",{\"1\":{\"4\":1}}],[\"v4\",{\"1\":{\"691\":1}}],[\"vm\",{\"1\":{\"599\":3}}],[\"vmtool\",{\"1\":{\"116\":3}}],[\"v2\",{\"1\":{\"575\":1}}],[\"vice\",{\"1\":{\"789\":1}}],[\"virtual\",{\"1\":{\"400\":1}}],[\"vim\",{\"0\":{\"137\":1},\"1\":{\"137\":1,\"141\":1,\"595\":4,\"597\":1,\"598\":1,\"599\":1}}],[\"v6\",{\"1\":{\"258\":1}}],[\"volumes\",{\"1\":{\"595\":1}}],[\"volatile\",{\"1\":{\"246\":1,\"541\":3,\"688\":1}}],[\"void\",{\"1\":{\"9\":3,\"282\":1,\"283\":1,\"284\":2,\"289\":1,\"291\":1,\"313\":1,\"314\":1,\"316\":1,\"317\":1,\"334\":1,\"340\":3,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"347\":1,\"348\":1,\"364\":2,\"365\":1,\"380\":1,\"381\":2,\"389\":3,\"390\":1,\"391\":1,\"392\":2,\"400\":1,\"402\":2,\"411\":1,\"414\":1,\"420\":1,\"435\":2,\"480\":1,\"481\":6,\"490\":1,\"492\":1,\"504\":1,\"505\":1,\"514\":3,\"515\":1,\"516\":3,\"518\":1,\"519\":4,\"520\":2,\"540\":2,\"541\":2,\"567\":1,\"568\":7,\"575\":1,\"637\":2,\"642\":1,\"643\":1,\"660\":1,\"662\":1,\"663\":1,\"665\":1,\"688\":2,\"690\":1,\"693\":1,\"695\":3,\"714\":1,\"715\":2,\"717\":1,\"720\":2,\"721\":3,\"748\":1,\"749\":1,\"750\":1,\"768\":2,\"791\":1,\"797\":1,\"798\":1,\"799\":1,\"800\":2,\"808\":2,\"816\":1,\"817\":3,\"843\":1,\"850\":1,\"851\":1}}],[\"vhost\",{\"1\":{\"186\":1}}],[\"v3\",{\"1\":{\"178\":1,\"718\":1}}],[\"v1\",{\"1\":{\"158\":5}}],[\"v12\",{\"1\":{\"98\":1}}],[\"v的作用是将现有键k的值更新为新值v\",{\"1\":{\"42\":1}}],[\"v对\",{\"1\":{\"42\":1}}],[\"v有两种用途\",{\"1\":{\"42\":1}}],[\"various\",{\"1\":{\"568\":1}}],[\"variable\",{\"1\":{\"21\":3,\"480\":1}}],[\"var\",{\"1\":{\"63\":1,\"157\":4}}],[\"var2\",{\"1\":{\"63\":1}}],[\"var1\",{\"1\":{\"63\":1}}],[\"validators\",{\"1\":{\"570\":1}}],[\"validator\",{\"1\":{\"516\":6}}],[\"validatenameserversetting\",{\"1\":{\"570\":1}}],[\"validate\",{\"1\":{\"510\":2,\"511\":2,\"516\":1,\"520\":2}}],[\"valid\",{\"1\":{\"424\":3}}],[\"val\",{\"1\":{\"43\":2,\"44\":2,\"46\":2,\"103\":2}}],[\"value为其最近一次修改时间\",{\"1\":{\"519\":1}}],[\"value表示该配置文件对应的dataversion\",{\"1\":{\"517\":1}}],[\"value表示acl配置文件的绝对路径\",{\"1\":{\"517\":1}}],[\"value表示相应配置文件中的权限数据\",{\"1\":{\"517\":1}}],[\"value是plainaccessresource类型\",{\"1\":{\"517\":1}}],[\"valueof\",{\"1\":{\"363\":1,\"417\":1,\"540\":1,\"541\":1,\"573\":2,\"715\":1,\"717\":2,\"793\":1,\"800\":1,\"829\":1}}],[\"value以链表的方式存储\",{\"1\":{\"300\":1}}],[\"values\",{\"1\":{\"289\":2,\"391\":2,\"768\":1}}],[\"valueparsed\",{\"1\":{\"262\":7}}],[\"value\",{\"1\":{\"21\":1,\"37\":2,\"41\":1,\"46\":1,\"54\":2,\"67\":7,\"240\":1,\"252\":1,\"257\":2,\"262\":7,\"300\":4,\"306\":1,\"317\":2,\"335\":1,\"414\":1,\"417\":1,\"420\":2,\"447\":1,\"485\":1,\"515\":4,\"517\":1,\"541\":1,\"585\":1,\"675\":1,\"694\":3,\"695\":1,\"715\":1,\"749\":1,\"761\":1,\"819\":1,\"880\":1}}],[\"v\",{\"1\":{\"21\":1,\"157\":2,\"414\":3,\"448\":1,\"600\":9}}],[\"vsn\",{\"1\":{\"53\":1}}],[\"vs\",{\"1\":{\"16\":3}}],[\"versa\",{\"1\":{\"789\":1}}],[\"version=$1\",{\"1\":{\"597\":1}}],[\"version\",{\"1\":{\"11\":1,\"53\":1,\"262\":1,\"410\":1,\"414\":1,\"480\":2,\"518\":1,\"592\":2,\"597\":1,\"665\":2,\"691\":2,\"718\":1}}],[\"version>\",{\"1\":{\"8\":2}}],[\"verify\",{\"1\":{\"10\":1}}],[\"pq\",{\"1\":{\"664\":9,\"744\":9,\"745\":7}}],[\"ps\",{\"1\":{\"595\":1,\"597\":1,\"599\":2}}],[\"pdflush\",{\"1\":{\"399\":1}}],[\"physicsize\",{\"1\":{\"381\":1}}],[\"physicoffset\",{\"1\":{\"381\":1}}],[\"physical\",{\"1\":{\"300\":1,\"694\":1}}],[\"physicaloffset\",{\"1\":{\"257\":2}}],[\"phyoffsetread\",{\"1\":{\"317\":2}}],[\"phyoffsets\",{\"1\":{\"310\":1,\"314\":4,\"317\":5}}],[\"phyoffset\",{\"1\":{\"310\":1,\"317\":5}}],[\"phyoffset=\",{\"1\":{\"285\":1}}],[\"phy\",{\"1\":{\"258\":1}}],[\"please\",{\"1\":{\"262\":1,\"410\":1,\"480\":1,\"528\":1,\"567\":1,\"642\":1,\"693\":1,\"807\":1}}],[\"plugin\",{\"0\":{\"114\":1},\"1\":{\"122\":3,\"162\":1,\"173\":2}}],[\"play\",{\"1\":{\"594\":7,\"595\":1,\"599\":5,\"600\":1,\"601\":2,\"603\":1,\"604\":1}}],[\"plainaclconfdata\",{\"1\":{\"518\":7}}],[\"plainaccessconfig\",{\"1\":{\"518\":4}}],[\"plainaccessconfiglist\",{\"1\":{\"518\":2}}],[\"plainaccessresource\",{\"1\":{\"518\":7,\"520\":21}}],[\"plainaccessresourcemap\",{\"1\":{\"518\":4}}],[\"plainaccessresource>\",{\"1\":{\"518\":1}}],[\"plainaccessresource>>\",{\"1\":{\"517\":1,\"518\":1}}],[\"plainaccessvalidator\",{\"1\":{\"500\":1,\"510\":3,\"511\":1,\"516\":2}}],[\"plainpermissonmanager\",{\"0\":{\"517\":1,\"518\":1,\"519\":1},\"1\":{\"517\":1}}],[\"plainpermissionmanager\",{\"1\":{\"510\":2,\"511\":1,\"516\":3,\"517\":1,\"519\":1,\"520\":1}}],[\"plain\",{\"1\":{\"499\":1,\"503\":1,\"510\":1,\"516\":1,\"518\":2,\"519\":1}}],[\"platformdependent0\",{\"1\":{\"528\":1}}],[\"platformdependent\",{\"1\":{\"117\":1}}],[\"platform\",{\"1\":{\"112\":1}}],[\"planid\",{\"1\":{\"103\":2}}],[\"plans\",{\"1\":{\"103\":1}}],[\"plan\",{\"1\":{\"103\":5}}],[\"popcheckpoint>\",{\"1\":{\"798\":1}}],[\"popcheckpointwrapper>\",{\"1\":{\"797\":1}}],[\"popcheckpointwrapper>>\",{\"1\":{\"797\":1}}],[\"popcheckpointwrapper\",{\"1\":{\"795\":2,\"796\":1,\"797\":1}}],[\"popcheckpoint\",{\"1\":{\"791\":3,\"795\":1,\"796\":1,\"797\":1,\"798\":3,\"799\":12,\"800\":26}}],[\"popbuffer\",{\"1\":{\"790\":1,\"795\":3,\"796\":5,\"797\":2}}],[\"popbuffermergeservice\",{\"0\":{\"795\":1,\"796\":1,\"797\":1},\"1\":{\"782\":1,\"790\":1,\"791\":2}}],[\"popackconstants\",{\"1\":{\"790\":2,\"793\":1,\"798\":7,\"799\":4}}],[\"poptime\",{\"1\":{\"789\":6,\"790\":4,\"791\":2}}],[\"popworkgroupsize\",{\"1\":{\"787\":1}}],[\"popreviveservice\",{\"0\":{\"798\":1,\"799\":1,\"800\":1},\"1\":{\"783\":2}}],[\"popmessagerequestheader\",{\"1\":{\"790\":1,\"791\":1}}],[\"popmessageprocessor\",{\"0\":{\"789\":1,\"790\":1,\"791\":1},\"1\":{\"777\":1,\"793\":1}}],[\"popmsgfromqueue\",{\"0\":{\"790\":1},\"1\":{\"778\":1,\"789\":4,\"790\":2}}],[\"poppushconsumer\",{\"1\":{\"768\":2}}],[\"popsharequeuenum\",{\"1\":{\"767\":2,\"775\":4,\"787\":6}}],[\"pop\",{\"0\":{\"615\":1,\"763\":1,\"765\":1,\"766\":1,\"769\":1,\"771\":1,\"776\":1,\"778\":1,\"788\":1},\"1\":{\"615\":4,\"625\":1,\"651\":1,\"763\":1,\"765\":5,\"766\":2,\"767\":4,\"768\":3,\"769\":4,\"770\":2,\"771\":7,\"772\":4,\"773\":3,\"775\":4,\"777\":9,\"778\":4,\"779\":1,\"781\":2,\"782\":1,\"783\":4,\"786\":2,\"787\":5,\"789\":4,\"790\":10,\"791\":6,\"793\":2,\"795\":5,\"796\":5,\"797\":2,\"798\":8,\"799\":3,\"800\":7,\"801\":1,\"884\":1}}],[\"poll\",{\"1\":{\"435\":1,\"541\":1}}],[\"pollingresult\",{\"1\":{\"789\":3}}],[\"pollingtimemills\",{\"1\":{\"339\":3,\"693\":3}}],[\"polling\",{\"1\":{\"326\":1,\"332\":1,\"789\":5}}],[\"policies\",{\"1\":{\"187\":1}}],[\"policy的设置命令为\",{\"1\":{\"186\":1}}],[\"policy的优先级\",{\"1\":{\"185\":1}}],[\"policy的名称\",{\"1\":{\"185\":1}}],[\"policy\",{\"1\":{\"169\":1,\"171\":2,\"185\":1,\"186\":2,\"188\":3,\"231\":1}}],[\"posixparser\",{\"1\":{\"480\":1}}],[\"position\",{\"1\":{\"223\":1,\"257\":1,\"258\":1,\"817\":2}}],[\"pos\",{\"1\":{\"420\":2,\"572\":8}}],[\"post\",{\"1\":{\"116\":1,\"124\":1,\"157\":3}}],[\"pooledbytebufallocator\",{\"1\":{\"117\":1}}],[\"potato\",{\"1\":{\"103\":2}}],[\"ports\",{\"1\":{\"595\":2,\"597\":1,\"598\":1,\"599\":2}}],[\"port>\",{\"1\":{\"491\":2}}],[\"portname\",{\"1\":{\"91\":1}}],[\"port\",{\"1\":{\"91\":5,\"491\":1,\"595\":2}}],[\"pointwrapper\",{\"1\":{\"795\":6,\"796\":7,\"797\":22}}],[\"pointer\",{\"1\":{\"402\":5}}],[\"point之后的所有索引文件\",{\"1\":{\"313\":1}}],[\"point\",{\"1\":{\"26\":5,\"133\":1,\"791\":1,\"795\":11,\"796\":5,\"797\":5,\"798\":22}}],[\"pub|sub\",{\"1\":{\"503\":2}}],[\"pub\",{\"1\":{\"498\":2,\"503\":2,\"528\":1,\"537\":1}}],[\"publish\",{\"1\":{\"157\":1}}],[\"publicexecutor\",{\"1\":{\"675\":1}}],[\"public\",{\"1\":{\"9\":4,\"257\":1,\"258\":2,\"262\":2,\"283\":1,\"284\":2,\"287\":1,\"291\":1,\"313\":3,\"314\":2,\"316\":1,\"317\":2,\"340\":3,\"342\":1,\"344\":1,\"345\":1,\"348\":2,\"363\":1,\"364\":2,\"365\":1,\"380\":1,\"381\":1,\"389\":1,\"390\":1,\"392\":1,\"402\":2,\"411\":1,\"414\":2,\"424\":1,\"435\":1,\"470\":1,\"480\":3,\"481\":6,\"488\":1,\"490\":2,\"491\":1,\"492\":1,\"493\":1,\"504\":2,\"505\":3,\"514\":2,\"515\":1,\"516\":3,\"518\":1,\"519\":3,\"520\":1,\"527\":1,\"537\":2,\"539\":1,\"540\":2,\"541\":3,\"567\":1,\"568\":6,\"572\":2,\"575\":1,\"642\":1,\"643\":1,\"660\":2,\"662\":1,\"665\":1,\"688\":2,\"689\":1,\"690\":1,\"691\":1,\"692\":1,\"693\":1,\"694\":2,\"695\":3,\"714\":1,\"715\":2,\"717\":2,\"720\":2,\"721\":2,\"742\":2,\"745\":1,\"746\":1,\"748\":1,\"749\":1,\"750\":1,\"755\":1,\"768\":4,\"787\":1,\"795\":1,\"796\":1,\"808\":2,\"816\":2,\"817\":1,\"819\":3,\"847\":1,\"848\":1,\"850\":2,\"851\":1,\"852\":2}}],[\"pulser\",{\"1\":{\"442\":1}}],[\"pullstatus\",{\"1\":{\"848\":1}}],[\"pullsysflag\",{\"1\":{\"690\":1,\"691\":2,\"693\":3}}],[\"pullblockifnotfound\",{\"1\":{\"808\":1}}],[\"pullrt\",{\"1\":{\"695\":2,\"749\":2}}],[\"pullresultext\",{\"1\":{\"848\":6}}],[\"pullresult\",{\"1\":{\"637\":1,\"690\":1,\"691\":4,\"692\":1,\"695\":18,\"748\":1,\"749\":13,\"808\":3,\"848\":7}}],[\"pullrequest=\",{\"1\":{\"690\":3}}],[\"pullrequestlist\",{\"1\":{\"664\":3,\"744\":3}}],[\"pullrequestqueue\",{\"1\":{\"624\":2,\"657\":1,\"675\":1,\"688\":4}}],[\"pullrequest\",{\"0\":{\"689\":1},\"1\":{\"335\":2,\"339\":4,\"342\":4,\"345\":1,\"624\":1,\"639\":4,\"640\":1,\"657\":4,\"664\":14,\"675\":3,\"688\":8,\"689\":1,\"690\":35,\"693\":4,\"695\":24,\"744\":14,\"748\":18,\"749\":11}}],[\"pullrequesttable\",{\"1\":{\"335\":4,\"336\":1,\"342\":2,\"343\":1,\"345\":2}}],[\"pullrequestholdservice\",{\"0\":{\"319\":1,\"330\":1,\"335\":1,\"341\":1,\"433\":1},\"1\":{\"319\":1,\"332\":2,\"336\":1,\"345\":1,\"347\":3,\"348\":1,\"406\":2,\"426\":2,\"433\":1,\"435\":1,\"884\":1}}],[\"pulling\",{\"1\":{\"693\":2}}],[\"pulltimedelaymillswhenexception\",{\"1\":{\"690\":5,\"695\":1,\"748\":2}}],[\"pullthresholdsizeforqueue\",{\"1\":{\"665\":1}}],[\"pullthresholdsizefortopic\",{\"1\":{\"665\":3}}],[\"pullthresholdforqueue\",{\"1\":{\"665\":1}}],[\"pullthresholdfortopic\",{\"1\":{\"665\":3}}],[\"pullapiwrapper\",{\"0\":{\"680\":1,\"691\":1},\"1\":{\"640\":1,\"642\":3,\"679\":1,\"690\":1,\"695\":1,\"749\":1,\"839\":1,\"848\":1}}],[\"pullcallback\",{\"0\":{\"695\":1},\"1\":{\"637\":1,\"675\":1,\"676\":1,\"690\":4,\"691\":4,\"692\":3,\"739\":1,\"808\":1}}],[\"pullmessageresponseheader\",{\"1\":{\"693\":3}}],[\"pullmessagerequestheader\",{\"1\":{\"691\":2,\"692\":1,\"693\":3}}],[\"pullmessagesync\",{\"1\":{\"692\":1}}],[\"pullmessageservice\",{\"0\":{\"678\":1,\"688\":1},\"1\":{\"557\":1,\"568\":1,\"639\":3,\"640\":2,\"643\":1,\"657\":1,\"664\":1,\"675\":1,\"678\":1,\"689\":1,\"744\":1}}],[\"pullmessageasync\",{\"1\":{\"692\":1}}],[\"pullmessage\",{\"1\":{\"639\":1,\"675\":1,\"679\":1,\"688\":1,\"690\":2,\"691\":1,\"692\":1,\"693\":1,\"739\":1,\"748\":1}}],[\"pullmessageexecutor\",{\"1\":{\"563\":1}}],[\"pullmessageprocess\",{\"1\":{\"332\":1}}],[\"pullmessageprocessor\",{\"0\":{\"329\":1,\"334\":1,\"338\":1,\"683\":1,\"693\":1},\"1\":{\"335\":1,\"340\":1,\"581\":1,\"838\":1}}],[\"pullnotifyqueue\",{\"1\":{\"436\":1}}],[\"pullkernelimpl\",{\"1\":{\"332\":1,\"679\":1,\"690\":2,\"691\":1}}],[\"pull模式固定20s\",{\"1\":{\"325\":1,\"693\":1}}],[\"pull\",{\"0\":{\"613\":1},\"1\":{\"277\":1,\"286\":1,\"321\":2,\"323\":1,\"324\":1,\"334\":1,\"339\":3,\"568\":1,\"593\":1,\"614\":1,\"615\":2,\"637\":2,\"656\":1,\"664\":1,\"666\":1,\"688\":1,\"690\":11,\"692\":1,\"693\":18,\"695\":4,\"748\":5,\"765\":4,\"766\":1,\"767\":1,\"797\":1,\"804\":1,\"817\":1,\"852\":3}}],[\"push模式固定15s\",{\"1\":{\"693\":1}}],[\"pushconsumer为被动消费\",{\"1\":{\"664\":1,\"744\":1}}],[\"pushconsumer\",{\"1\":{\"642\":1,\"827\":1}}],[\"push\",{\"0\":{\"322\":1,\"323\":1,\"614\":1},\"1\":{\"321\":2,\"322\":2,\"323\":2,\"324\":1,\"349\":1,\"434\":1,\"568\":1,\"614\":3,\"615\":4,\"624\":1,\"642\":1,\"765\":4,\"766\":1,\"769\":4,\"771\":1,\"772\":1,\"775\":1}}],[\"purge\",{\"1\":{\"179\":1}}],[\"purpose\",{\"1\":{\"54\":1}}],[\"putuserproperty\",{\"1\":{\"807\":1,\"829\":1}}],[\"putall\",{\"1\":{\"800\":1}}],[\"putacktostore\",{\"1\":{\"797\":1}}],[\"putcktostore\",{\"1\":{\"797\":2}}],[\"putoffsetqueue\",{\"1\":{\"795\":1}}],[\"putresultprocess\",{\"1\":{\"380\":2,\"381\":13}}],[\"putrequest\",{\"1\":{\"245\":2}}],[\"putproperty\",{\"1\":{\"363\":2,\"576\":1,\"717\":1,\"718\":1,\"816\":1}}],[\"putifabsent\",{\"1\":{\"342\":1,\"515\":1,\"571\":1,\"664\":1,\"744\":1,\"850\":1}}],[\"putint\",{\"1\":{\"257\":16,\"285\":1,\"317\":4}}],[\"putkey\",{\"1\":{\"309\":1,\"310\":1,\"314\":5,\"317\":3}}],[\"putshort\",{\"1\":{\"257\":2}}],[\"putlong\",{\"1\":{\"257\":10,\"258\":1,\"285\":2,\"317\":1}}],[\"putmessagetospecificqueue\",{\"1\":{\"793\":1,\"800\":1}}],[\"putmessagethreadlocal\",{\"1\":{\"257\":1}}],[\"putmessageposiitoninfo\",{\"0\":{\"285\":1}}],[\"putmessagepositioninfo只有一个线程调用\",{\"1\":{\"285\":1}}],[\"putmessagepositioninfowrapper\",{\"1\":{\"284\":1,\"817\":1}}],[\"putmessagepositioninfo\",{\"1\":{\"276\":1,\"284\":2,\"285\":1,\"288\":1,\"817\":2}}],[\"putmessagecontext\",{\"1\":{\"258\":2,\"816\":2}}],[\"putmessageresult\",{\"1\":{\"257\":3,\"365\":4,\"381\":1,\"576\":4,\"718\":3,\"793\":7,\"800\":5}}],[\"putmessagestatus\",{\"1\":{\"257\":2,\"365\":1,\"381\":1,\"793\":4}}],[\"putmessages\",{\"0\":{\"251\":1},\"1\":{\"240\":1,\"251\":3}}],[\"putmessage\",{\"0\":{\"251\":1,\"256\":1},\"1\":{\"240\":3,\"251\":3,\"256\":2,\"257\":2,\"357\":1,\"359\":1,\"365\":1,\"381\":1,\"585\":1,\"695\":1,\"742\":1,\"749\":1}}],[\"put\",{\"1\":{\"67\":3,\"157\":4,\"158\":1,\"187\":1,\"198\":1,\"257\":10,\"258\":1,\"365\":1,\"381\":1,\"402\":1,\"414\":2,\"436\":1,\"491\":5,\"515\":3,\"516\":1,\"518\":5,\"519\":2,\"541\":1,\"567\":1,\"576\":1,\"688\":2,\"715\":1,\"718\":1,\"721\":3,\"742\":2,\"750\":1,\"793\":3,\"795\":1,\"797\":1,\"798\":1,\"800\":2,\"817\":3,\"842\":1,\"843\":1}}],[\"p\",{\"1\":{\"37\":5,\"58\":1,\"111\":1,\"186\":1,\"480\":2,\"597\":1,\"600\":6,\"601\":1}}],[\"pythag\",{\"1\":{\"34\":1}}],[\"pipeline\",{\"1\":{\"820\":1}}],[\"pickoneatleast\",{\"1\":{\"572\":1}}],[\"pickuptopicroutedata\",{\"1\":{\"477\":1,\"493\":2}}],[\"pickupstoretimestamp\",{\"1\":{\"365\":1,\"380\":1}}],[\"picc\",{\"1\":{\"91\":3}}],[\"pivot\",{\"1\":{\"34\":6}}],[\"pidspec\",{\"1\":{\"111\":2}}],[\"pid2\",{\"1\":{\"79\":1}}],[\"pid1\",{\"1\":{\"79\":1,\"91\":2}}],[\"pid\",{\"1\":{\"21\":4,\"43\":1,\"79\":4,\"80\":1,\"84\":4,\"85\":3,\"91\":2,\"157\":3,\"158\":1,\"201\":1}}],[\"passively\",{\"1\":{\"664\":1,\"744\":1}}],[\"pagecache\",{\"1\":{\"693\":2}}],[\"pages\",{\"1\":{\"402\":2}}],[\"page\",{\"0\":{\"399\":1},\"1\":{\"399\":19,\"400\":1,\"402\":7,\"403\":10,\"451\":1}}],[\"packageconflictdetect\",{\"1\":{\"480\":1}}],[\"packages\",{\"1\":{\"176\":3,\"177\":1}}],[\"package\",{\"1\":{\"176\":12,\"178\":1}}],[\"paused\",{\"1\":{\"690\":1}}],[\"pause\",{\"1\":{\"105\":1,\"664\":1}}],[\"patch\",{\"1\":{\"251\":1,\"260\":1}}],[\"pathz\",{\"1\":{\"73\":1}}],[\"patha\",{\"1\":{\"73\":1}}],[\"path\",{\"1\":{\"73\":1,\"102\":1,\"481\":4,\"519\":1}}],[\"pattern2等模式进行匹配\",{\"1\":{\"44\":1}}],[\"pattern2\",{\"1\":{\"37\":2,\"79\":1,\"82\":1}}],[\"pattern1\",{\"1\":{\"37\":2,\"79\":1,\"82\":1}}],[\"pattern\",{\"1\":{\"34\":1,\"111\":2,\"185\":1,\"186\":1,\"187\":1,\"424\":1}}],[\"parsenormaltopic\",{\"1\":{\"799\":1,\"800\":1}}],[\"parseobject\",{\"1\":{\"798\":2}}],[\"parsesocketaddressaddr\",{\"1\":{\"717\":1}}],[\"parsecmdline\",{\"1\":{\"480\":1}}],[\"parsechannelremoteaddr\",{\"0\":{\"415\":1},\"1\":{\"406\":1,\"415\":1,\"416\":1,\"514\":1,\"693\":2,\"786\":1}}],[\"parsedouble\",{\"1\":{\"262\":1}}],[\"parseboolean\",{\"1\":{\"262\":3,\"573\":1,\"576\":1}}],[\"parselong\",{\"1\":{\"262\":2,\"817\":1}}],[\"parseint\",{\"1\":{\"262\":7,\"343\":1,\"411\":1,\"819\":2}}],[\"parse\",{\"1\":{\"240\":1,\"262\":1,\"516\":1,\"693\":3,\"841\":1}}],[\"parserequestcontent\",{\"1\":{\"515\":3}}],[\"parser\",{\"1\":{\"21\":1}}],[\"param\",{\"1\":{\"284\":1,\"285\":4,\"287\":6,\"313\":1,\"314\":6,\"316\":1,\"317\":6,\"339\":3,\"340\":2,\"342\":3,\"345\":3,\"390\":4,\"392\":1,\"520\":2,\"540\":2,\"541\":1,\"570\":4,\"572\":3,\"573\":6,\"576\":4,\"663\":1,\"664\":3,\"665\":3,\"688\":1,\"690\":1,\"691\":12,\"693\":3,\"694\":6,\"714\":4,\"715\":3,\"717\":5,\"718\":2,\"720\":1,\"721\":9,\"742\":3,\"744\":3,\"745\":2,\"746\":1,\"748\":1,\"786\":5,\"787\":6,\"789\":2,\"790\":12,\"791\":8,\"793\":3,\"795\":4,\"796\":2,\"798\":1,\"800\":2,\"816\":3,\"817\":8,\"847\":2,\"848\":3,\"850\":5,\"852\":4}}],[\"parameters\",{\"1\":{\"240\":1,\"252\":1}}],[\"params指定\",{\"1\":{\"185\":2}}],[\"params\",{\"1\":{\"185\":2,\"186\":1,\"187\":1,\"190\":1}}],[\"partb\",{\"1\":{\"409\":1}}],[\"partition\",{\"1\":{\"192\":2}}],[\"part\",{\"1\":{\"16\":1,\"406\":12,\"409\":1,\"412\":1,\"425\":1,\"433\":2}}],[\"peek\",{\"1\":{\"380\":1,\"381\":1}}],[\"pendingqueue\",{\"1\":{\"381\":4}}],[\"pending\",{\"1\":{\"158\":2}}],[\"pet\",{\"1\":{\"36\":2}}],[\"pear\",{\"1\":{\"31\":3,\"103\":2}}],[\"pears\",{\"1\":{\"27\":7}}],[\"permname\",{\"1\":{\"693\":2,\"718\":6}}],[\"permission\",{\"1\":{\"520\":6,\"576\":1,\"693\":5,\"718\":2}}],[\"perm\",{\"1\":{\"484\":10,\"488\":2,\"520\":2,\"718\":4}}],[\"period\",{\"1\":{\"365\":1}}],[\"persistall\",{\"1\":{\"711\":1,\"720\":2}}],[\"persistallconsumeroffset\",{\"1\":{\"568\":2}}],[\"persist\",{\"1\":{\"364\":1,\"695\":1,\"711\":1,\"721\":2,\"745\":1}}],[\"persistent\",{\"1\":{\"220\":1}}],[\"person\",{\"1\":{\"26\":4}}],[\"performance\",{\"1\":{\"157\":1,\"239\":1,\"240\":5,\"243\":1,\"256\":3,\"262\":1,\"393\":1,\"405\":1,\"406\":5,\"409\":1,\"412\":1,\"418\":1}}],[\"per\",{\"1\":{\"11\":1,\"147\":1,\"718\":2}}],[\"pwd\",{\"1\":{\"21\":1,\"595\":3,\"597\":1}}],[\"practice\",{\"1\":{\"751\":1}}],[\"pr\",{\"1\":{\"240\":1,\"360\":1,\"368\":1,\"370\":2,\"425\":1,\"883\":1}}],[\"prromote\",{\"1\":{\"192\":1}}],[\"presend\",{\"1\":{\"576\":1}}],[\"prefix\",{\"1\":{\"573\":1,\"662\":1,\"663\":1,\"695\":1,\"786\":1,\"800\":1,\"807\":1}}],[\"prefetchcount\",{\"1\":{\"149\":1}}],[\"preferred\",{\"1\":{\"117\":1}}],[\"pre\",{\"1\":{\"285\":1,\"664\":2,\"744\":2}}],[\"prepare\",{\"1\":{\"402\":1}}],[\"prepared\",{\"1\":{\"257\":2,\"284\":1,\"314\":1,\"573\":4,\"576\":1,\"717\":1}}],[\"preparing\",{\"1\":{\"176\":1,\"178\":1}}],[\"prevrequestoffset\",{\"1\":{\"695\":5,\"749\":1}}],[\"prevbody\",{\"1\":{\"573\":4}}],[\"prevbrokerliveinfo\",{\"1\":{\"491\":2}}],[\"prev\",{\"1\":{\"342\":3,\"850\":3}}],[\"previndexread\",{\"1\":{\"317\":5}}],[\"previndexfile\",{\"1\":{\"313\":3}}],[\"previously\",{\"1\":{\"176\":1}}],[\"previous\",{\"1\":{\"21\":2}}],[\"prevent\",{\"1\":{\"176\":1,\"178\":1,\"240\":1,\"402\":1,\"480\":1}}],[\"priority\",{\"1\":{\"185\":1,\"186\":3}}],[\"price\",{\"1\":{\"103\":3}}],[\"println\",{\"1\":{\"808\":1}}],[\"printstr\",{\"1\":{\"520\":2}}],[\"printstacktrace\",{\"1\":{\"146\":1,\"381\":1,\"504\":1,\"526\":1}}],[\"printallperiodically\",{\"1\":{\"481\":1}}],[\"printobjectproperties\",{\"1\":{\"480\":4}}],[\"printf\",{\"1\":{\"480\":2,\"504\":1,\"505\":2,\"526\":1,\"527\":2,\"768\":2,\"829\":1}}],[\"print\",{\"1\":{\"21\":3}}],[\"private\",{\"1\":{\"9\":2,\"257\":1,\"262\":13,\"282\":1,\"285\":1,\"289\":1,\"309\":1,\"335\":1,\"339\":1,\"343\":1,\"347\":1,\"380\":1,\"381\":1,\"389\":2,\"390\":1,\"391\":1,\"392\":1,\"400\":1,\"413\":2,\"417\":1,\"470\":4,\"481\":2,\"488\":4,\"504\":2,\"505\":2,\"516\":1,\"517\":7,\"519\":1,\"537\":25,\"541\":21,\"568\":1,\"570\":1,\"571\":1,\"573\":1,\"576\":1,\"663\":1,\"664\":1,\"688\":1,\"689\":4,\"693\":1,\"718\":1,\"721\":1,\"742\":2,\"744\":1,\"761\":1,\"768\":1,\"786\":1,\"789\":1,\"790\":1,\"791\":1,\"793\":1,\"797\":1,\"800\":2,\"817\":3,\"819\":2,\"843\":2}}],[\"prop\",{\"1\":{\"817\":8}}],[\"props=\",{\"1\":{\"851\":1}}],[\"props\",{\"1\":{\"540\":3}}],[\"properly\",{\"1\":{\"528\":1}}],[\"propertiesstring\",{\"1\":{\"576\":1}}],[\"properties2object\",{\"1\":{\"480\":3}}],[\"properties属性中\",{\"1\":{\"359\":1,\"363\":1}}],[\"properties\",{\"1\":{\"257\":6,\"262\":1,\"345\":4,\"348\":2,\"354\":1,\"480\":7,\"515\":1,\"576\":1,\"838\":2,\"852\":4}}],[\"propertieslength\",{\"1\":{\"257\":10}}],[\"propertiesdata\",{\"1\":{\"257\":10}}],[\"property\",{\"1\":{\"240\":1,\"363\":2,\"414\":1,\"515\":1,\"540\":2,\"573\":5,\"576\":5,\"717\":2,\"718\":3,\"793\":1,\"800\":2,\"807\":1,\"816\":2,\"817\":4}}],[\"protected\",{\"1\":{\"257\":1,\"435\":1,\"514\":3,\"515\":1,\"798\":1,\"799\":1}}],[\"problem\",{\"1\":{\"240\":1,\"256\":1}}],[\"problems\",{\"1\":{\"176\":2,\"178\":1}}],[\"product\",{\"1\":{\"597\":1}}],[\"producer2\",{\"1\":{\"755\":1}}],[\"producer1\",{\"1\":{\"755\":1}}],[\"producertable\",{\"1\":{\"556\":1,\"567\":1}}],[\"producer\",{\"1\":{\"355\":2,\"406\":1,\"414\":1,\"461\":1,\"464\":1,\"465\":1,\"504\":5,\"514\":1,\"526\":4,\"567\":4,\"594\":1,\"753\":3,\"755\":8,\"807\":4,\"826\":1,\"829\":1,\"873\":1}}],[\"producergroupname\",{\"1\":{\"504\":1,\"526\":1}}],[\"producergroup\",{\"1\":{\"262\":1,\"528\":1,\"567\":1}}],[\"produce\",{\"1\":{\"240\":1,\"243\":1,\"256\":1}}],[\"prodetail\",{\"1\":{\"136\":1}}],[\"promote\",{\"1\":{\"192\":5}}],[\"promot\",{\"1\":{\"190\":1}}],[\"processconsumeresult\",{\"1\":{\"707\":1,\"708\":1,\"715\":2,\"750\":1}}],[\"processpullresult\",{\"1\":{\"695\":1,\"749\":1,\"839\":1,\"848\":1}}],[\"processqueue>\",{\"1\":{\"664\":1,\"744\":1}}],[\"processqueue>>\",{\"1\":{\"664\":1,\"744\":1}}],[\"processqueuetable\",{\"1\":{\"653\":1,\"664\":3,\"665\":1,\"744\":3,\"746\":1}}],[\"processqueue\",{\"1\":{\"624\":1,\"657\":1,\"664\":9,\"675\":1,\"679\":1,\"689\":3,\"690\":14,\"695\":2,\"714\":5,\"715\":5,\"744\":9,\"745\":1,\"746\":5,\"748\":3,\"749\":2,\"750\":15}}],[\"processstatus\",{\"1\":{\"381\":3}}],[\"processrequest方法拉取消息\",{\"1\":{\"345\":1}}],[\"processrequestwrapper\",{\"1\":{\"340\":2}}],[\"processrequest\",{\"0\":{\"339\":1,\"789\":1,\"793\":1},\"1\":{\"329\":1,\"332\":1,\"334\":2,\"335\":1,\"339\":1,\"340\":1,\"575\":1,\"576\":1,\"683\":1,\"693\":1,\"777\":1,\"780\":1,\"789\":1,\"793\":1,\"838\":1}}],[\"processoffset\",{\"1\":{\"291\":7}}],[\"processor\",{\"1\":{\"240\":1,\"256\":1}}],[\"processing\",{\"1\":{\"176\":2,\"540\":1}}],[\"processlimit\",{\"1\":{\"81\":1}}],[\"process3\",{\"1\":{\"46\":1}}],[\"processesqueue\",{\"1\":{\"380\":4}}],[\"processes\",{\"1\":{\"21\":2,\"161\":1}}],[\"process\",{\"1\":{\"21\":1,\"46\":3,\"67\":1,\"80\":1,\"147\":1,\"152\":1,\"154\":1,\"157\":8,\"160\":1,\"204\":2,\"205\":2,\"242\":3,\"340\":1,\"573\":1,\"715\":1,\"797\":1}}],[\"progress\",{\"1\":{\"11\":2,\"406\":1}}],[\"ck=\",{\"1\":{\"800\":1}}],[\"ckmessagenumber\",{\"1\":{\"789\":1}}],[\"ck\",{\"1\":{\"771\":1,\"783\":3,\"791\":4,\"795\":3,\"796\":1,\"797\":4,\"798\":10,\"799\":4,\"800\":6}}],[\"centos\",{\"1\":{\"592\":1}}],[\"certificate\",{\"1\":{\"481\":3}}],[\"certchanged\",{\"1\":{\"481\":4}}],[\"cmq\",{\"1\":{\"442\":1}}],[\"cmd\",{\"1\":{\"93\":1,\"414\":10}}],[\"cqmaxoffset=\",{\"1\":{\"380\":1}}],[\"cqminoffset=\",{\"1\":{\"365\":1,\"380\":1}}],[\"cqminoffset\",{\"1\":{\"365\":4}}],[\"cqextunit\",{\"1\":{\"287\":1,\"345\":1,\"365\":5,\"380\":5,\"694\":6,\"817\":8,\"838\":4,\"847\":3,\"852\":8}}],[\"cqoffset\",{\"1\":{\"285\":5}}],[\"cq\",{\"1\":{\"284\":2,\"285\":2,\"287\":1,\"289\":2,\"291\":2,\"365\":12,\"380\":14,\"694\":3,\"790\":1,\"817\":2}}],[\"customizedtracetopic\",{\"1\":{\"539\":2}}],[\"customheader\",{\"1\":{\"414\":2}}],[\"custom\",{\"1\":{\"262\":10}}],[\"currentqueuecount\",{\"1\":{\"665\":4}}],[\"currentthread\",{\"1\":{\"505\":1,\"527\":1,\"768\":1}}],[\"currenttimemillis\",{\"1\":{\"242\":1,\"289\":4,\"313\":1,\"345\":1,\"365\":1,\"380\":1,\"390\":1,\"402\":1,\"491\":1,\"537\":1,\"540\":2,\"570\":3,\"573\":4,\"665\":1,\"690\":2,\"695\":1,\"715\":3,\"742\":2,\"746\":1,\"749\":1,\"750\":4,\"760\":1,\"789\":1,\"793\":1,\"795\":1,\"796\":1,\"797\":2,\"798\":4,\"800\":1,\"851\":1,\"873\":1}}],[\"currentpendingnum=\",{\"1\":{\"380\":1}}],[\"currentpendingnum\",{\"1\":{\"380\":3}}],[\"currentlogicoffset\",{\"1\":{\"285\":9}}],[\"currently\",{\"1\":{\"176\":1,\"178\":1}}],[\"current\",{\"1\":{\"21\":1,\"291\":2,\"480\":1,\"718\":2,\"750\":3}}],[\"cfnullable\",{\"1\":{\"262\":4}}],[\"cfnotnull\",{\"1\":{\"262\":8}}],[\"c节点中新增了e节点\",{\"1\":{\"207\":1}}],[\"cp\",{\"1\":{\"462\":1,\"600\":1}}],[\"cpu\",{\"1\":{\"155\":2,\"181\":1,\"242\":1,\"253\":2,\"406\":1,\"414\":1,\"416\":1,\"420\":1,\"424\":2,\"434\":1,\"437\":1}}],[\"cpu总体利用率达到\",{\"1\":{\"135\":1}}],[\"cprof\",{\"1\":{\"105\":4}}],[\"ctx\",{\"1\":{\"334\":1,\"493\":1,\"576\":5,\"718\":2,\"786\":2}}],[\"cto甚至包括ceo开始重视并投入到混沌工程实践中\",{\"1\":{\"126\":1}}],[\"ctemplate\",{\"1\":{\"85\":1}}],[\"cncf成立了专门的兴趣小组\",{\"1\":{\"126\":1}}],[\"cn\",{\"1\":{\"116\":1,\"124\":1,\"136\":1,\"545\":1}}],[\"cnt\",{\"1\":{\"11\":1,\"261\":1}}],[\"crc32\",{\"1\":{\"490\":1}}],[\"creation\",{\"1\":{\"157\":1}}],[\"createtopicinsendmessagebackmethod\",{\"1\":{\"718\":2}}],[\"createrequestcommand\",{\"1\":{\"692\":1}}],[\"createresponsecommand\",{\"1\":{\"493\":1,\"693\":1,\"718\":1,\"793\":1}}],[\"createbrokercontroller\",{\"1\":{\"599\":1}}],[\"createandupdatequeuedata\",{\"1\":{\"491\":1}}],[\"created\",{\"1\":{\"481\":1,\"567\":1,\"568\":1,\"592\":1,\"595\":2,\"597\":1,\"599\":2,\"642\":1,\"643\":1}}],[\"createnamesrvcontroller\",{\"1\":{\"467\":1,\"480\":2}}],[\"createuniqid\",{\"0\":{\"418\":1},\"1\":{\"406\":1,\"418\":1,\"419\":1,\"537\":1}}],[\"create\",{\"1\":{\"102\":2,\"103\":4,\"157\":1,\"557\":1,\"559\":1,\"567\":4,\"568\":1,\"642\":2,\"643\":1,\"767\":1,\"787\":1,\"807\":1,\"851\":1,\"852\":1}}],[\"credit消息给列表中的进程\",{\"1\":{\"160\":1}}],[\"credit消息后\",{\"1\":{\"159\":1}}],[\"credits\",{\"1\":{\"160\":2}}],[\"credit\",{\"1\":{\"151\":2,\"154\":2,\"155\":2,\"157\":5,\"158\":4,\"159\":11,\"160\":7,\"161\":2}}],[\"cr用符号\",{\"1\":{\"138\":1}}],[\"cr\",{\"0\":{\"140\":1},\"1\":{\"138\":2,\"139\":1}}],[\"cross\",{\"1\":{\"21\":1}}],[\"c=>xx\",{\"1\":{\"42\":1}}],[\"c小于等于n并且a\",{\"1\":{\"34\":1}}],[\"chl\",{\"1\":{\"850\":2}}],[\"choose\",{\"1\":{\"515\":1,\"600\":1}}],[\"chpid\",{\"1\":{\"157\":9}}],[\"chkey\",{\"1\":{\"157\":5}}],[\"charsequence\",{\"1\":{\"414\":1}}],[\"charset\",{\"1\":{\"257\":4,\"414\":2,\"504\":1,\"526\":1,\"793\":1,\"798\":2,\"807\":1,\"826\":1,\"829\":1}}],[\"char\",{\"1\":{\"261\":1,\"420\":5,\"424\":2}}],[\"chanel\",{\"1\":{\"820\":2}}],[\"channels\",{\"1\":{\"850\":3}}],[\"channeloutboundbuffer\",{\"1\":{\"820\":1}}],[\"channeloption\",{\"1\":{\"820\":1}}],[\"channelfuture\",{\"1\":{\"340\":1,\"693\":1}}],[\"channelfuturelistener\",{\"1\":{\"340\":1,\"693\":1}}],[\"channelhandlercontext\",{\"1\":{\"334\":1,\"493\":1,\"576\":1,\"718\":1,\"786\":1}}],[\"channel将会发送一条\",{\"1\":{\"159\":1}}],[\"channel累计处理的消息数达到morecreditafter值时\",{\"1\":{\"159\":1}}],[\"channel每处理一条消息\",{\"1\":{\"159\":1}}],[\"channel模块中调用credit\",{\"1\":{\"157\":1}}],[\"channel进程的id将从credit\",{\"1\":{\"160\":1}}],[\"channel进程的内存空间\",{\"1\":{\"157\":1}}],[\"channel进程会记录它向特定的发送者\",{\"1\":{\"159\":1}}],[\"channel进程发送的消息数\",{\"1\":{\"157\":1}}],[\"channel进程为例\",{\"1\":{\"156\":1}}],[\"channel中会调用credit\",{\"1\":{\"157\":1}}],[\"channel\",{\"1\":{\"147\":1,\"152\":1,\"154\":7,\"155\":12,\"157\":13,\"158\":1,\"159\":1,\"198\":3,\"201\":5,\"334\":2,\"339\":4,\"340\":7,\"416\":2,\"417\":2,\"487\":3,\"491\":3,\"492\":13,\"514\":1,\"568\":1,\"576\":1,\"693\":11,\"786\":1,\"789\":8,\"790\":7,\"793\":3,\"819\":4,\"820\":4,\"850\":2}}],[\"changeinvisibletime\",{\"1\":{\"771\":3}}],[\"changeinstancenametopid\",{\"1\":{\"567\":1,\"642\":1}}],[\"changed\",{\"1\":{\"481\":2,\"663\":5,\"664\":5,\"665\":4,\"744\":5}}],[\"change\",{\"1\":{\"21\":1,\"240\":2,\"242\":1,\"252\":1,\"787\":1,\"850\":1}}],[\"chaos\",{\"1\":{\"126\":1}}],[\"checkmultidispatchqueue\",{\"1\":{\"817\":2}}],[\"checkmessage\",{\"1\":{\"570\":2}}],[\"checkmessageandreturnsize\",{\"1\":{\"282\":1}}],[\"checkqueueok\",{\"1\":{\"795\":1}}],[\"checkblock\",{\"1\":{\"790\":1}}],[\"checkindiskbycommitoffset\",{\"1\":{\"694\":1}}],[\"checkclientinbroker\",{\"1\":{\"642\":1}}],[\"checkconfig\",{\"1\":{\"567\":1,\"642\":1}}],[\"checkforbiddenhook\",{\"1\":{\"573\":1}}],[\"checkfields\",{\"1\":{\"262\":1}}],[\"checkpermission\",{\"1\":{\"520\":2}}],[\"checkperm\",{\"1\":{\"520\":3}}],[\"checkpoint会先被保存在内存中\",{\"1\":{\"773\":1}}],[\"checkpoint文件刷盘\",{\"1\":{\"309\":1,\"316\":1}}],[\"checkpoint\",{\"0\":{\"779\":1,\"781\":1,\"794\":1},\"1\":{\"309\":2,\"771\":1,\"773\":10,\"778\":5,\"779\":4,\"781\":3,\"782\":10,\"783\":3,\"790\":2,\"791\":1,\"795\":3,\"796\":5,\"797\":10,\"798\":4,\"799\":1,\"800\":1}}],[\"checkholdrequest\",{\"0\":{\"343\":1},\"1\":{\"332\":1,\"335\":3,\"343\":1,\"344\":1}}],[\"checknotnull\",{\"1\":{\"262\":8}}],[\"checker组件会对实验中的业务和非业务数据进行自动化分析\",{\"1\":{\"130\":1}}],[\"check\",{\"1\":{\"21\":1,\"343\":1,\"344\":1,\"406\":1,\"424\":1,\"520\":6,\"691\":1,\"791\":1,\"797\":1,\"799\":1}}],[\"cheatsheet\",{\"1\":{\"15\":1}}],[\"cd\",{\"1\":{\"21\":1,\"590\":1,\"592\":1,\"594\":1,\"598\":1,\"599\":1,\"603\":1,\"604\":1}}],[\"c\",{\"0\":{\"92\":1,\"415\":1},\"1\":{\"21\":2,\"30\":2,\"31\":6,\"34\":7,\"42\":6,\"74\":1,\"80\":1,\"98\":1,\"111\":1,\"116\":3,\"117\":2,\"157\":3,\"159\":8,\"160\":3,\"262\":3,\"406\":1,\"410\":1,\"411\":2,\"480\":3,\"595\":3,\"597\":1,\"599\":8,\"600\":3,\"767\":2,\"768\":1}}],[\"cap\",{\"1\":{\"462\":1}}],[\"capacity\",{\"1\":{\"317\":1}}],[\"capacity属性\",{\"1\":{\"261\":1}}],[\"cache的爱恨情仇\",{\"1\":{\"868\":1}}],[\"cache的热点范围内\",{\"1\":{\"398\":1}}],[\"cache关系及演化历史\",{\"1\":{\"858\":1}}],[\"cache和buffer\",{\"1\":{\"858\":1}}],[\"cached\",{\"1\":{\"690\":2}}],[\"cachedmessagesizeinmib\",{\"1\":{\"690\":4}}],[\"cachedmessagecount\",{\"1\":{\"690\":4}}],[\"cache经由socket发送给了consumer\",{\"1\":{\"399\":1}}],[\"cache\",{\"0\":{\"399\":1},\"1\":{\"398\":1,\"399\":19,\"400\":1,\"402\":3,\"403\":10,\"406\":1,\"415\":1,\"451\":1,\"787\":1}}],[\"caculate\",{\"1\":{\"80\":1}}],[\"caculateaera\",{\"1\":{\"80\":4}}],[\"caculategeometry\",{\"1\":{\"80\":3}}],[\"cause\",{\"1\":{\"340\":1,\"693\":1,\"790\":1}}],[\"caught\",{\"1\":{\"43\":3,\"44\":6}}],[\"calc\",{\"1\":{\"851\":4}}],[\"calculate\",{\"1\":{\"540\":1}}],[\"calsignature\",{\"1\":{\"515\":1,\"520\":1}}],[\"calsignature方法会根据客户端的\",{\"1\":{\"515\":1}}],[\"calmsglength\",{\"1\":{\"257\":2}}],[\"calltimeout\",{\"1\":{\"570\":2}}],[\"callable<void>\",{\"1\":{\"480\":1}}],[\"call\",{\"1\":{\"42\":2,\"103\":1,\"406\":1,\"421\":1,\"480\":1,\"573\":2,\"807\":1}}],[\"called\",{\"1\":{\"42\":1,\"406\":1,\"426\":1}}],[\"callback\",{\"1\":{\"21\":2}}],[\"callbacks\",{\"1\":{\"21\":1}}],[\"cas\",{\"1\":{\"245\":1,\"435\":1}}],[\"cast\",{\"1\":{\"157\":2}}],[\"cases\",{\"1\":{\"576\":1}}],[\"case\",{\"0\":{\"37\":1},\"1\":{\"37\":3,\"39\":1,\"44\":1,\"46\":1,\"121\":1,\"157\":5,\"158\":2,\"159\":1,\"160\":2,\"240\":1,\"284\":4,\"314\":4,\"339\":1,\"381\":4,\"567\":4,\"568\":2,\"570\":3,\"573\":3,\"576\":1,\"642\":6,\"643\":2,\"663\":2,\"664\":2,\"692\":3,\"693\":20,\"695\":4,\"715\":4,\"718\":1,\"744\":2,\"749\":1,\"786\":2,\"787\":1,\"850\":3}}],[\"canwrite\",{\"1\":{\"817\":4}}],[\"cancel\",{\"1\":{\"198\":2}}],[\"can\",{\"1\":{\"80\":1,\"179\":1,\"365\":2,\"380\":2,\"481\":1,\"515\":1,\"518\":1,\"539\":1,\"693\":1,\"694\":2,\"745\":1,\"789\":1,\"798\":1,\"799\":2,\"800\":1,\"817\":1}}],[\"cat\",{\"1\":{\"31\":1,\"35\":2,\"36\":4}}],[\"catcher2\",{\"1\":{\"45\":3}}],[\"catcher\",{\"1\":{\"43\":2,\"44\":2}}],[\"catch`表达式中\",{\"1\":{\"43\":1,\"44\":1}}],[\"catch和receive表达式\",{\"1\":{\"30\":1}}],[\"catch\",{\"0\":{\"44\":1,\"45\":1},\"1\":{\"21\":1,\"43\":3,\"44\":5,\"45\":5,\"46\":1,\"146\":1,\"262\":3,\"313\":2,\"314\":1,\"317\":4,\"340\":2,\"343\":1,\"344\":1,\"345\":2,\"364\":1,\"365\":1,\"380\":1,\"381\":3,\"390\":1,\"391\":1,\"392\":1,\"435\":1,\"481\":1,\"490\":2,\"491\":1,\"492\":2,\"504\":1,\"515\":1,\"516\":1,\"519\":2,\"526\":1,\"539\":1,\"541\":1,\"568\":5,\"570\":1,\"572\":1,\"573\":1,\"662\":1,\"663\":1,\"664\":1,\"688\":3,\"690\":3,\"693\":2,\"695\":1,\"714\":2,\"715\":1,\"717\":2,\"720\":1,\"721\":1,\"742\":1,\"744\":1,\"745\":1,\"746\":1,\"748\":1,\"750\":1,\"786\":1,\"790\":1,\"796\":1,\"798\":1,\"817\":2,\"851\":2,\"852\":2}}],[\"cb\",{\"1\":{\"21\":2}}],[\"cidallsize=\",{\"1\":{\"663\":1}}],[\"cidall\",{\"1\":{\"663\":6,\"786\":6,\"787\":10}}],[\"cid\",{\"1\":{\"527\":1,\"768\":1,\"787\":2,\"799\":1,\"808\":2}}],[\"circles\",{\"1\":{\"80\":1}}],[\"circle\",{\"1\":{\"80\":2,\"103\":1,\"617\":1}}],[\"ci\",{\"1\":{\"11\":2}}],[\"cobbliu\",{\"1\":{\"858\":1}}],[\"coffeemaker\",{\"1\":{\"810\":1}}],[\"collection<consumerfilterdata>\",{\"1\":{\"851\":1}}],[\"collection<subscriptiondata>\",{\"1\":{\"850\":2}}],[\"collections\",{\"1\":{\"663\":2,\"715\":1,\"750\":1,\"786\":2}}],[\"collectors\",{\"1\":{\"768\":1}}],[\"collect\",{\"1\":{\"768\":1}}],[\"could\",{\"1\":{\"503\":1,\"528\":1,\"787\":1}}],[\"countofminute1\",{\"1\":{\"797\":1}}],[\"count++\",{\"1\":{\"797\":1}}],[\"countck++\",{\"1\":{\"797\":2}}],[\"countck\",{\"1\":{\"797\":1}}],[\"count=\",{\"1\":{\"690\":2}}],[\"counter\",{\"1\":{\"487\":1,\"795\":3,\"797\":3}}],[\"count时\",{\"1\":{\"223\":1}}],[\"count值为2表示两个副本\",{\"1\":{\"190\":1}}],[\"count值为1表示一个副本\",{\"1\":{\"190\":1}}],[\"count\",{\"1\":{\"190\":1,\"223\":1,\"287\":1,\"317\":1,\"690\":1,\"694\":1,\"790\":2,\"797\":1}}],[\"countdownlatch\",{\"1\":{\"490\":5}}],[\"countdown秒之后执行\",{\"1\":{\"365\":1,\"380\":1}}],[\"countdown\",{\"1\":{\"146\":1,\"365\":4,\"380\":2,\"435\":1,\"490\":1}}],[\"copysubscription\",{\"1\":{\"642\":1}}],[\"copyonwritearraylist<>\",{\"1\":{\"490\":1}}],[\"copymappedfiles\",{\"1\":{\"390\":1}}],[\"copy\",{\"1\":{\"240\":1,\"247\":1,\"406\":1,\"412\":1,\"414\":1,\"855\":1,\"858\":1}}],[\"coordinator\",{\"1\":{\"205\":1}}],[\"corresponding\",{\"1\":{\"541\":1}}],[\"correct\",{\"1\":{\"790\":3}}],[\"correcttopic\",{\"1\":{\"718\":3}}],[\"correcttagsoffset\",{\"1\":{\"695\":1}}],[\"correction\",{\"1\":{\"693\":2}}],[\"correcting\",{\"1\":{\"176\":1}}],[\"correctdelivertimestamp\",{\"1\":{\"365\":1,\"380\":1}}],[\"corbaorb\",{\"1\":{\"112\":1}}],[\"core<\",{\"1\":{\"8\":1}}],[\"conumser\",{\"1\":{\"461\":1}}],[\"concurrentmap<integer\",{\"1\":{\"289\":2,\"360\":1,\"391\":2,\"721\":1}}],[\"concurrentmap<string\",{\"1\":{\"289\":1,\"335\":1,\"391\":1,\"470\":1,\"488\":1,\"491\":1,\"732\":1,\"742\":1,\"837\":1}}],[\"concurrenthashmap<messagequeue\",{\"1\":{\"732\":1,\"742\":3}}],[\"concurrenthashmap<integer\",{\"1\":{\"721\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"470\":1,\"488\":1,\"742\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"335\":1,\"742\":1}}],[\"concurrenthashmap\",{\"1\":{\"246\":1,\"335\":1}}],[\"concepts\",{\"1\":{\"161\":1}}],[\"constructor\",{\"1\":{\"854\":1}}],[\"constant\",{\"1\":{\"63\":1}}],[\"consuming\",{\"1\":{\"745\":1}}],[\"consumsergroup\",{\"1\":{\"498\":1}}],[\"consumethreadmax\",{\"1\":{\"758\":2}}],[\"consumethreadmin\",{\"1\":{\"758\":1}}],[\"consumetype\",{\"1\":{\"664\":1,\"744\":1}}],[\"consumebatchsize\",{\"1\":{\"714\":4,\"750\":2}}],[\"consumeorderlystatus\",{\"1\":{\"750\":8}}],[\"consumeorderlycontext\",{\"1\":{\"750\":2}}],[\"consumeorderly\",{\"1\":{\"642\":2,\"690\":1,\"748\":1}}],[\"consumeexecutor\",{\"1\":{\"639\":2,\"707\":1,\"714\":2}}],[\"consumeconcurrentlycontext\",{\"1\":{\"505\":1,\"527\":1,\"715\":3,\"717\":1}}],[\"consumeconcurrentlystatus\",{\"1\":{\"505\":2,\"527\":2,\"715\":6,\"768\":1}}],[\"consumemessagedirectly\",{\"1\":{\"707\":1}}],[\"consumemessagethreadpool\",{\"1\":{\"624\":1}}],[\"consumemessagetracehookimpl\",{\"1\":{\"534\":1,\"539\":1,\"540\":1}}],[\"consumemessageservice\",{\"1\":{\"624\":1,\"639\":2,\"642\":4,\"695\":1,\"707\":1,\"749\":1}}],[\"consumemessageorderlyservice\",{\"1\":{\"622\":1,\"639\":1,\"642\":1,\"750\":20}}],[\"consumemessageconcurrentlyservice\",{\"1\":{\"622\":1,\"639\":1,\"642\":1,\"708\":1,\"714\":1,\"715\":14,\"717\":1}}],[\"consumemessagecontext\",{\"1\":{\"540\":2,\"693\":2,\"715\":15,\"718\":1,\"750\":15}}],[\"consumemessagehooklist\",{\"1\":{\"575\":1}}],[\"consumemessageafter\",{\"1\":{\"540\":1}}],[\"consumemessagebefore\",{\"1\":{\"540\":1}}],[\"consumemessage\",{\"1\":{\"505\":1,\"527\":1,\"624\":1,\"639\":2,\"715\":3,\"750\":4}}],[\"consumefromwhere\",{\"1\":{\"505\":1,\"527\":1,\"768\":1}}],[\"consumequque\",{\"1\":{\"377\":1}}],[\"consumequeueinterface\",{\"1\":{\"814\":1,\"817\":1}}],[\"consumequeue里面的tagscode实际是一个时间点\",{\"1\":{\"365\":1,\"380\":1}}],[\"consumequeue>\",{\"1\":{\"289\":1,\"391\":1}}],[\"consumequeue>>\",{\"1\":{\"289\":1,\"391\":1}}],[\"consumequeuetable\",{\"1\":{\"289\":1,\"391\":1}}],[\"consumequeueext\",{\"1\":{\"280\":1,\"291\":2,\"345\":1,\"365\":2,\"380\":2,\"694\":2,\"817\":3,\"838\":1,\"843\":1,\"847\":1,\"851\":1,\"852\":2}}],[\"consumequeue\",{\"0\":{\"264\":1,\"266\":1,\"267\":1,\"285\":1,\"291\":1,\"387\":1,\"391\":1,\"430\":1},\"1\":{\"264\":1,\"266\":3,\"267\":4,\"269\":4,\"270\":1,\"271\":4,\"275\":2,\"276\":5,\"277\":1,\"280\":3,\"281\":2,\"284\":5,\"285\":7,\"287\":8,\"289\":3,\"293\":3,\"301\":1,\"331\":1,\"332\":2,\"336\":1,\"354\":2,\"356\":2,\"359\":2,\"365\":6,\"377\":1,\"380\":4,\"383\":1,\"384\":2,\"387\":3,\"389\":2,\"391\":3,\"392\":1,\"397\":2,\"398\":3,\"399\":1,\"400\":1,\"432\":3,\"450\":3,\"600\":1,\"694\":17,\"811\":2,\"814\":3,\"817\":3,\"839\":2,\"847\":1,\"852\":1,\"884\":1}}],[\"consume\",{\"0\":{\"293\":1},\"1\":{\"275\":2,\"276\":1,\"285\":2,\"291\":5,\"326\":1,\"332\":1,\"365\":1,\"380\":1,\"406\":2,\"430\":1,\"433\":1,\"505\":2,\"527\":2,\"539\":1,\"540\":1,\"664\":2,\"690\":1,\"693\":3,\"694\":1,\"696\":1,\"715\":7,\"722\":1,\"744\":2,\"748\":1,\"750\":9,\"763\":1,\"767\":1,\"768\":2,\"817\":2,\"847\":1,\"852\":1}}],[\"consumernum=\",{\"1\":{\"851\":1}}],[\"consumer=\",{\"1\":{\"851\":1}}],[\"consumermanager\",{\"1\":{\"837\":2,\"838\":1,\"839\":1}}],[\"consumermanagerprocess\",{\"1\":{\"711\":1}}],[\"consumeroffset\",{\"1\":{\"721\":1}}],[\"consumeroffsetmanager\",{\"1\":{\"710\":2,\"711\":2,\"721\":1}}],[\"consumersendmsgbackrequestheader\",{\"1\":{\"718\":3}}],[\"consumersendmessageback\",{\"1\":{\"717\":1}}],[\"consumertable\",{\"1\":{\"837\":1}}],[\"consumert\",{\"1\":{\"715\":3,\"750\":3}}],[\"consumereviveobj\",{\"1\":{\"798\":6,\"799\":7}}],[\"consumerevivemessage\",{\"0\":{\"798\":1},\"1\":{\"783\":2,\"798\":1}}],[\"consumerequest\",{\"1\":{\"708\":1,\"714\":10,\"715\":23,\"750\":1}}],[\"consumerequestqueue\",{\"1\":{\"707\":1,\"708\":1}}],[\"consumereturntype\",{\"1\":{\"540\":1,\"715\":7,\"750\":7}}],[\"consumeretrytimes\",{\"1\":{\"262\":1}}],[\"consumerfiltermanager\",{\"1\":{\"693\":1,\"837\":1,\"841\":2,\"844\":1,\"850\":2,\"851\":3,\"852\":1}}],[\"consumerfilterdata\",{\"1\":{\"693\":11,\"837\":1,\"851\":1,\"852\":12}}],[\"consumergroupevent\",{\"1\":{\"850\":1}}],[\"consumergroupinfo>\",{\"1\":{\"837\":1}}],[\"consumergroupinfo\",{\"1\":{\"693\":5,\"786\":4}}],[\"consumergroup\",{\"1\":{\"498\":1,\"539\":4,\"663\":7,\"664\":8,\"689\":1,\"691\":1,\"715\":7,\"717\":1,\"744\":6,\"746\":2,\"750\":3,\"786\":9,\"787\":5,\"843\":1,\"850\":4}}],[\"consumer拉取请求\",{\"1\":{\"340\":1}}],[\"consumer\",{\"1\":{\"198\":3,\"287\":1,\"326\":1,\"329\":2,\"334\":4,\"335\":1,\"414\":1,\"464\":1,\"465\":1,\"488\":1,\"505\":7,\"527\":7,\"575\":1,\"594\":1,\"605\":1,\"625\":1,\"626\":1,\"642\":3,\"644\":1,\"663\":1,\"665\":1,\"666\":1,\"690\":4,\"693\":17,\"694\":2,\"696\":1,\"720\":2,\"721\":1,\"722\":1,\"760\":1,\"763\":1,\"767\":1,\"768\":11,\"786\":1,\"787\":2,\"801\":1,\"827\":1,\"830\":1,\"851\":2,\"852\":1}}],[\"console\",{\"1\":{\"480\":4,\"593\":2}}],[\"conf\",{\"1\":{\"386\":1,\"480\":1,\"499\":1,\"503\":1,\"518\":2,\"519\":1,\"525\":1,\"595\":14,\"599\":5,\"600\":12,\"648\":1,\"806\":1}}],[\"configured\",{\"1\":{\"520\":1}}],[\"configurator\",{\"1\":{\"480\":3}}],[\"configuration\",{\"1\":{\"176\":1,\"178\":1,\"854\":2}}],[\"config目录下\",{\"1\":{\"503\":1}}],[\"configs\",{\"1\":{\"480\":1}}],[\"configtable\",{\"1\":{\"464\":1}}],[\"config\",{\"1\":{\"464\":1,\"480\":1,\"493\":1,\"518\":2,\"520\":1,\"694\":2,\"854\":1}}],[\"configmanager\",{\"1\":{\"360\":2,\"710\":2}}],[\"confirm消息等\",{\"1\":{\"222\":1}}],[\"confirm\",{\"1\":{\"204\":1}}],[\"conflict\",{\"1\":{\"157\":1}}],[\"continuously\",{\"1\":{\"750\":1}}],[\"continueconsume\",{\"1\":{\"750\":4}}],[\"continue\",{\"1\":{\"176\":1,\"262\":1,\"287\":2,\"313\":1,\"345\":2,\"365\":2,\"380\":2,\"520\":1,\"540\":2,\"541\":1,\"570\":1,\"664\":2,\"694\":4,\"742\":2,\"744\":2,\"797\":5,\"798\":3,\"799\":4,\"800\":4,\"851\":2}}],[\"container\",{\"1\":{\"595\":5,\"597\":2,\"598\":1,\"599\":2}}],[\"contains\",{\"1\":{\"514\":1,\"518\":1,\"519\":1,\"664\":1,\"720\":1,\"744\":1,\"746\":1,\"842\":1,\"843\":1,\"847\":1,\"848\":1}}],[\"containskey\",{\"1\":{\"242\":1,\"518\":1,\"520\":2,\"576\":1,\"664\":1,\"744\":1}}],[\"contrib\",{\"1\":{\"177\":1}}],[\"controller\",{\"1\":{\"480\":10}}],[\"control\",{\"0\":{\"142\":1},\"1\":{\"130\":1,\"142\":1,\"147\":1,\"154\":2,\"157\":1,\"161\":2,\"238\":1,\"380\":2,\"496\":1,\"690\":6}}],[\"content\",{\"1\":{\"157\":4,\"365\":2,\"380\":2,\"493\":2,\"541\":3,\"694\":2}}],[\"contextlist\",{\"1\":{\"541\":3}}],[\"contexts\",{\"1\":{\"541\":4}}],[\"contexttype\",{\"1\":{\"540\":3}}],[\"contextcode\",{\"1\":{\"537\":1}}],[\"context\",{\"1\":{\"116\":3,\"122\":1,\"123\":1,\"481\":2,\"505\":1,\"527\":1,\"537\":1,\"540\":18,\"541\":9,\"573\":17,\"693\":15,\"715\":9,\"717\":4,\"718\":2,\"750\":5,\"768\":1,\"851\":2,\"852\":2}}],[\"connecton\",{\"1\":{\"201\":1}}],[\"connection\",{\"1\":{\"146\":3,\"147\":1,\"154\":1,\"155\":8,\"156\":1,\"158\":2,\"201\":1}}],[\"connect\",{\"1\":{\"91\":1}}],[\"convert\",{\"1\":{\"21\":1,\"503\":1}}],[\"costtimeasync\",{\"1\":{\"573\":3}}],[\"costtimesync\",{\"1\":{\"573\":3}}],[\"costtimes\",{\"1\":{\"528\":1}}],[\"costtime\",{\"1\":{\"344\":3,\"537\":1,\"540\":2,\"570\":3}}],[\"cost=cost\",{\"1\":{\"103\":1}}],[\"cost\",{\"1\":{\"27\":1,\"30\":1,\"33\":1,\"103\":19,\"344\":1,\"540\":1}}],[\"code=\",{\"1\":{\"520\":1}}],[\"code\",{\"1\":{\"21\":1,\"73\":3,\"240\":4,\"251\":1,\"256\":3,\"257\":2,\"262\":1,\"365\":1,\"380\":1,\"410\":1,\"414\":1,\"847\":1,\"852\":1}}],[\"combinerequestcontent\",{\"1\":{\"515\":2}}],[\"commercialsizepermsg\",{\"1\":{\"789\":2}}],[\"commercialbasecount\",{\"1\":{\"693\":2}}],[\"commercial\",{\"1\":{\"693\":1}}],[\"commpressed\",{\"1\":{\"573\":1}}],[\"communicationmode\",{\"1\":{\"570\":7,\"573\":7,\"690\":1,\"691\":4,\"692\":3}}],[\"commitoffset\",{\"1\":{\"690\":1,\"691\":3,\"693\":1,\"711\":1,\"721\":3,\"790\":3,\"799\":1}}],[\"commitoffsetvalue\",{\"1\":{\"690\":4}}],[\"commitoffsetenable\",{\"1\":{\"690\":3}}],[\"commits\",{\"1\":{\"406\":1}}],[\"commitlogoffset=\",{\"1\":{\"851\":1}}],[\"commitlogdelay\",{\"1\":{\"798\":2}}],[\"commitlogdispatchercalcbitmap\",{\"1\":{\"843\":1,\"851\":1}}],[\"commitlogdispatcher\",{\"1\":{\"282\":1,\"283\":1}}],[\"commitlogdispatcherbuildconsumequeue\",{\"0\":{\"284\":1},\"1\":{\"276\":1}}],[\"commitlog偏移量\",{\"1\":{\"392\":1}}],[\"commitlog可用则一直进行循环扫描\",{\"1\":{\"282\":1}}],[\"commitlog\",{\"0\":{\"251\":1,\"359\":1,\"363\":1,\"386\":1,\"390\":1,\"430\":1,\"814\":1},\"1\":{\"240\":3,\"247\":1,\"248\":1,\"249\":2,\"250\":1,\"251\":2,\"253\":4,\"256\":5,\"257\":7,\"258\":2,\"266\":1,\"267\":5,\"269\":1,\"270\":2,\"271\":2,\"275\":1,\"276\":3,\"281\":1,\"282\":3,\"285\":8,\"287\":5,\"298\":2,\"300\":1,\"301\":2,\"302\":2,\"306\":2,\"307\":4,\"314\":2,\"326\":1,\"331\":1,\"334\":1,\"336\":1,\"353\":2,\"356\":4,\"357\":2,\"361\":1,\"367\":4,\"368\":1,\"370\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":3,\"386\":6,\"387\":1,\"388\":3,\"389\":2,\"390\":4,\"391\":2,\"392\":3,\"396\":2,\"397\":5,\"398\":3,\"399\":1,\"400\":1,\"401\":1,\"430\":1,\"432\":2,\"447\":1,\"450\":6,\"600\":1,\"683\":1,\"684\":1,\"694\":5,\"708\":6,\"718\":2,\"811\":3,\"814\":4,\"816\":1,\"838\":1,\"852\":1}}],[\"committed\",{\"1\":{\"240\":1,\"242\":2,\"790\":1}}],[\"commit\",{\"1\":{\"196\":1,\"240\":2,\"256\":1,\"284\":1,\"307\":1,\"314\":1,\"363\":1,\"406\":1,\"433\":1,\"750\":1,\"790\":1,\"799\":1,\"817\":2,\"852\":1}}],[\"common\",{\"1\":{\"122\":1,\"157\":1}}],[\"commandline2properties\",{\"1\":{\"480\":1}}],[\"commandline\",{\"1\":{\"480\":6}}],[\"commandcustomheader>\",{\"1\":{\"262\":1}}],[\"commandcustomheader\",{\"1\":{\"262\":3,\"515\":1}}],[\"command\",{\"1\":{\"21\":1,\"91\":1,\"157\":1,\"595\":2,\"597\":1,\"599\":2,\"693\":1}}],[\"commands\",{\"1\":{\"21\":4}}],[\"com\",{\"1\":{\"114\":1,\"116\":1,\"118\":1,\"122\":4,\"124\":1,\"175\":2,\"177\":1,\"178\":2,\"179\":1,\"187\":1,\"225\":1,\"276\":1,\"294\":1,\"326\":1,\"332\":1,\"372\":1,\"545\":1,\"573\":1,\"590\":1,\"804\":1,\"817\":1,\"819\":3}}],[\"compose\",{\"0\":{\"588\":1,\"595\":1,\"598\":1},\"1\":{\"588\":1,\"589\":1,\"594\":2,\"595\":11,\"598\":3,\"884\":1}}],[\"compressed\",{\"1\":{\"490\":3,\"573\":2}}],[\"comprehension\",{\"1\":{\"34\":1}}],[\"computeelapsedtimemilliseconds\",{\"1\":{\"851\":1}}],[\"computepullfromwhichfilterserver\",{\"1\":{\"691\":1}}],[\"computepullfromwherewithexception\",{\"1\":{\"657\":1,\"664\":1,\"690\":1,\"744\":1,\"748\":1}}],[\"computedelivertimestamp\",{\"1\":{\"365\":1,\"380\":1}}],[\"compute\",{\"1\":{\"365\":1,\"380\":1,\"664\":1,\"690\":1,\"744\":1,\"748\":1}}],[\"comparable<tracecontext>\",{\"1\":{\"537\":1}}],[\"compareandset\",{\"1\":{\"364\":1,\"435\":2}}],[\"company\",{\"1\":{\"102\":1}}],[\"completablefuture\",{\"1\":{\"576\":3,\"718\":7}}],[\"completablefuture<remotingcommand>\",{\"1\":{\"576\":1,\"718\":1}}],[\"completablefuture<putmessageresult>\",{\"1\":{\"363\":1,\"576\":1,\"718\":1,\"816\":1}}],[\"completedfuture\",{\"1\":{\"576\":3,\"718\":7}}],[\"complete\",{\"1\":{\"11\":3}}],[\"compiled\",{\"1\":{\"851\":1}}],[\"compiler\",{\"1\":{\"841\":2}}],[\"compile\",{\"1\":{\"21\":3,\"53\":1,\"80\":1,\"85\":1,\"103\":1,\"841\":1}}],[\"clusterinfo\",{\"1\":{\"768\":3}}],[\"clustering\",{\"0\":{\"611\":1},\"1\":{\"608\":1,\"642\":2,\"663\":1,\"690\":1,\"715\":1,\"745\":1,\"750\":2,\"786\":1}}],[\"cluster2\",{\"1\":{\"755\":1}}],[\"cluster1\",{\"1\":{\"755\":1}}],[\"clustername\",{\"1\":{\"469\":1,\"486\":1,\"490\":2,\"491\":4,\"492\":5,\"576\":2,\"767\":1}}],[\"cluster信息\",{\"1\":{\"464\":1}}],[\"clusteraddrtable\",{\"0\":{\"486\":1},\"1\":{\"464\":1,\"469\":1,\"473\":1,\"474\":1,\"486\":1,\"491\":3,\"492\":4}}],[\"clustertestrequestprocessor\",{\"1\":{\"464\":1}}],[\"cluster\",{\"1\":{\"178\":1,\"190\":1,\"485\":1,\"488\":2,\"492\":1,\"576\":1,\"767\":2,\"768\":1}}],[\"club\",{\"1\":{\"115\":1}}],[\"clients\",{\"1\":{\"769\":1}}],[\"clientversion\",{\"1\":{\"850\":3}}],[\"clientv\",{\"1\":{\"693\":1}}],[\"clienterrorcode\",{\"1\":{\"570\":1}}],[\"clientip=\",{\"1\":{\"693\":1}}],[\"clientip\",{\"1\":{\"556\":1,\"760\":3}}],[\"clientid=\",{\"1\":{\"663\":1}}],[\"clientid\",{\"0\":{\"760\":1},\"1\":{\"556\":3,\"557\":1,\"568\":1,\"643\":1,\"720\":1,\"742\":6,\"755\":4,\"760\":4,\"786\":4,\"787\":5}}],[\"clienthost=\",{\"1\":{\"721\":1}}],[\"clienthost\",{\"1\":{\"528\":1,\"537\":1,\"721\":6}}],[\"clientconfig\",{\"1\":{\"423\":1,\"568\":5,\"643\":1}}],[\"client\",{\"1\":{\"130\":1,\"146\":1,\"147\":1,\"193\":1,\"465\":1,\"567\":2,\"568\":1,\"642\":1,\"643\":1,\"676\":1,\"694\":1,\"732\":1,\"786\":3,\"787\":1,\"793\":1,\"801\":1,\"820\":1}}],[\"clonemessage\",{\"1\":{\"573\":2}}],[\"clone\",{\"1\":{\"573\":1,\"590\":1}}],[\"clonelistandclear\",{\"1\":{\"345\":1}}],[\"closure\",{\"1\":{\"157\":1}}],[\"close\",{\"1\":{\"91\":1,\"109\":1,\"480\":1}}],[\"cloudamqp\",{\"1\":{\"225\":1}}],[\"cloud\",{\"1\":{\"124\":1}}],[\"clearcommitoffsetflag\",{\"1\":{\"691\":1}}],[\"clearproperty\",{\"1\":{\"573\":2,\"717\":1}}],[\"clear\",{\"1\":{\"103\":2,\"258\":1,\"519\":1,\"786\":1}}],[\"cleanofflinebroker\",{\"1\":{\"568\":1}}],[\"cleanimmediately\",{\"1\":{\"390\":4}}],[\"cleanatonce\",{\"1\":{\"390\":4}}],[\"cleanfilesperiodically\",{\"1\":{\"389\":2}}],[\"cleanconsumequeueservice\",{\"1\":{\"389\":2,\"391\":1,\"392\":1}}],[\"cleancommitlogservice\",{\"1\":{\"389\":2}}],[\"clean\",{\"1\":{\"10\":1,\"492\":1}}],[\"classfilter模式详解\",{\"1\":{\"853\":1}}],[\"classfilter\",{\"1\":{\"690\":3}}],[\"classpath\",{\"1\":{\"600\":1}}],[\"classheader\",{\"1\":{\"262\":3}}],[\"class<\",{\"1\":{\"262\":1}}],[\"classic\",{\"1\":{\"154\":2,\"181\":1,\"212\":1}}],[\"classname\",{\"1\":{\"116\":3}}],[\"classloader\",{\"1\":{\"116\":1}}],[\"class\",{\"1\":{\"9\":1,\"262\":1,\"348\":1,\"470\":1,\"488\":1,\"493\":1,\"504\":1,\"505\":1,\"516\":1,\"518\":3,\"537\":2,\"541\":2,\"660\":1,\"689\":1,\"690\":1,\"693\":2,\"718\":1,\"742\":1,\"750\":1,\"768\":1,\"793\":1,\"798\":2,\"843\":1}}],[\"o那些事\",{\"1\":{\"858\":1}}],[\"o线程准备好处理队列中的写请求\",{\"1\":{\"819\":1}}],[\"o线程将立即执行所请求的写操作时返回\",{\"1\":{\"819\":1}}],[\"owner\",{\"1\":{\"693\":5}}],[\"ownedperm\",{\"1\":{\"520\":2}}],[\"ownedpermmap\",{\"1\":{\"520\":6}}],[\"ownedaccess\",{\"1\":{\"520\":13}}],[\"omitstacktraceinfastthrow\",{\"1\":{\"600\":1}}],[\"occurred\",{\"1\":{\"572\":1}}],[\"our\",{\"1\":{\"433\":1}}],[\"outputshutdown\",{\"1\":{\"487\":1}}],[\"outputtimeunit\",{\"1\":{\"9\":1}}],[\"out\",{\"1\":{\"109\":3,\"240\":5,\"256\":5,\"414\":24,\"480\":2,\"504\":1,\"505\":2,\"526\":1,\"527\":2,\"715\":1,\"750\":1,\"768\":2,\"808\":1,\"829\":1}}],[\"oldoffset\",{\"1\":{\"798\":5,\"799\":2}}],[\"oldclientid\",{\"1\":{\"742\":1}}],[\"oldaddr\",{\"1\":{\"491\":2}}],[\"old\",{\"1\":{\"261\":2,\"798\":4}}],[\"oldvalue\",{\"1\":{\"67\":1}}],[\"o和磁盘空间的使用\",{\"1\":{\"190\":1}}],[\"overflow\",{\"1\":{\"339\":1,\"693\":2,\"694\":2,\"695\":2,\"790\":1}}],[\"override\",{\"1\":{\"313\":1,\"340\":2,\"344\":1,\"348\":1,\"364\":1,\"389\":1,\"411\":1,\"480\":1,\"481\":3,\"490\":1,\"505\":1,\"514\":2,\"515\":1,\"516\":2,\"519\":3,\"527\":1,\"540\":2,\"541\":1,\"568\":5,\"660\":1,\"665\":1,\"693\":1,\"695\":3,\"714\":1,\"715\":1,\"720\":2,\"721\":1,\"745\":1,\"808\":2,\"816\":1,\"817\":1,\"847\":1,\"850\":1,\"851\":1,\"852\":2}}],[\"over\",{\"1\":{\"178\":1,\"289\":1,\"291\":3,\"317\":1,\"340\":1,\"693\":1}}],[\"objlock\",{\"1\":{\"750\":2}}],[\"object\",{\"1\":{\"262\":1,\"390\":1,\"392\":1,\"515\":1,\"568\":1,\"643\":1,\"750\":1,\"850\":1,\"851\":1,\"852\":1}}],[\"objectheader\",{\"1\":{\"262\":5}}],[\"object>\",{\"1\":{\"198\":2}}],[\"objective\",{\"1\":{\"133\":2}}],[\"obtuseralivestatus\",{\"1\":{\"116\":1}}],[\"obtglobalstatistics\",{\"1\":{\"116\":1}}],[\"ognl\",{\"0\":{\"124\":1},\"1\":{\"117\":2}}],[\"otp\",{\"0\":{\"112\":1},\"1\":{\"112\":1,\"176\":1}}],[\"other\",{\"0\":{\"141\":1},\"1\":{\"18\":1,\"46\":1,\"113\":1,\"125\":1,\"137\":1,\"157\":2}}],[\"oops\",{\"1\":{\"103\":1}}],[\"oid\",{\"1\":{\"103\":2}}],[\"ospp\",{\"1\":{\"136\":1}}],[\"os\",{\"1\":{\"93\":1,\"138\":1,\"402\":4}}],[\"odds\",{\"1\":{\"39\":10}}],[\"ok\",{\"1\":{\"30\":2,\"46\":2,\"74\":2,\"98\":2,\"102\":2,\"106\":1,\"109\":1,\"157\":5,\"158\":2,\"160\":3,\"196\":1,\"258\":1,\"365\":1,\"381\":1,\"480\":1,\"490\":1,\"567\":3,\"568\":1,\"570\":2,\"571\":2,\"576\":3,\"642\":3,\"643\":1,\"690\":1,\"693\":1,\"715\":3,\"718\":1,\"746\":1,\"750\":1,\"793\":1,\"800\":1}}],[\"onsuccess\",{\"1\":{\"695\":1,\"749\":1,\"808\":1}}],[\"onfilenumchanged\",{\"1\":{\"519\":2}}],[\"onfilechanged\",{\"1\":{\"519\":2}}],[\"onchanged\",{\"1\":{\"481\":1}}],[\"onchanneldestroy\",{\"1\":{\"474\":1,\"492\":3}}],[\"once\",{\"1\":{\"103\":1,\"133\":2,\"158\":3,\"492\":1,\"567\":1,\"642\":1,\"720\":1,\"757\":1}}],[\"onwaitend\",{\"1\":{\"435\":2}}],[\"oneway\",{\"1\":{\"490\":2,\"570\":1,\"573\":2,\"692\":1}}],[\"onexceptionimpl\",{\"1\":{\"560\":1}}],[\"onexception\",{\"1\":{\"381\":3,\"695\":1,\"808\":1}}],[\"one\",{\"1\":{\"339\":1,\"491\":1,\"515\":1,\"547\":1,\"693\":1,\"694\":1,\"695\":1,\"807\":1}}],[\"only\",{\"1\":{\"80\":1,\"240\":1,\"256\":1,\"491\":1}}],[\"on\",{\"1\":{\"21\":2,\"160\":1,\"161\":1,\"176\":4,\"178\":1,\"190\":1,\"192\":6,\"198\":2,\"406\":1,\"598\":1}}],[\"o\",{\"1\":{\"16\":1,\"21\":1,\"155\":2,\"190\":1,\"195\":2,\"399\":1,\"437\":1,\"444\":1,\"451\":1,\"597\":1,\"820\":1,\"858\":2}}],[\"origprops\",{\"1\":{\"576\":6}}],[\"originmsgid\",{\"1\":{\"717\":3,\"718\":3}}],[\"origin\",{\"1\":{\"573\":1}}],[\"original\",{\"1\":{\"541\":2}}],[\"ordinal\",{\"1\":{\"540\":1,\"691\":1,\"718\":1}}],[\"ordercountinfo\",{\"1\":{\"789\":6,\"790\":3}}],[\"orderly\",{\"1\":{\"722\":1,\"750\":1}}],[\"orderid188\",{\"1\":{\"504\":1,\"526\":2}}],[\"ordertopicconf\",{\"1\":{\"470\":1,\"488\":1,\"493\":2}}],[\"order\",{\"1\":{\"285\":1,\"313\":1,\"493\":1,\"789\":1,\"793\":1}}],[\"ordered\",{\"1\":{\"98\":3,\"99\":1}}],[\"orelse\",{\"1\":{\"69\":1}}],[\"orange1\",{\"1\":{\"103\":2}}],[\"orange\",{\"1\":{\"31\":4,\"103\":6}}],[\"oranges\",{\"1\":{\"27\":4,\"103\":4}}],[\"or\",{\"1\":{\"15\":1,\"21\":2,\"36\":1,\"56\":1,\"80\":1,\"176\":1,\"599\":1,\"768\":1,\"797\":1,\"828\":4,\"852\":1}}],[\"org\",{\"1\":{\"11\":4,\"116\":4,\"136\":1,\"402\":2,\"510\":1,\"516\":2,\"599\":2}}],[\"off\",{\"1\":{\"720\":1}}],[\"official\",{\"1\":{\"593\":1}}],[\"offsetbuffersize\",{\"1\":{\"797\":1}}],[\"offsetmovedevent\",{\"1\":{\"693\":2}}],[\"offsetmsgid\",{\"1\":{\"419\":1,\"537\":1}}],[\"offsetstore\",{\"1\":{\"642\":5,\"690\":1,\"695\":2,\"710\":1,\"711\":3}}],[\"offsets结果列表\",{\"1\":{\"317\":1}}],[\"offset=\",{\"1\":{\"365\":1,\"380\":2,\"851\":2}}],[\"offsettable\",{\"1\":{\"360\":1,\"364\":1,\"365\":1,\"624\":1,\"710\":1,\"720\":2,\"721\":2}}],[\"offset未找到任何数据\",{\"1\":{\"339\":1}}],[\"offsetpy=\",{\"1\":{\"365\":2,\"380\":1,\"694\":1}}],[\"offsetpy\",{\"1\":{\"287\":4,\"365\":5,\"380\":8,\"694\":7}}],[\"offset\",{\"1\":{\"240\":1,\"242\":2,\"257\":2,\"258\":2,\"277\":1,\"285\":8,\"287\":5,\"291\":4,\"300\":1,\"307\":2,\"309\":1,\"310\":1,\"315\":1,\"317\":1,\"332\":1,\"339\":4,\"343\":2,\"360\":2,\"364\":4,\"365\":9,\"375\":5,\"377\":5,\"378\":2,\"380\":17,\"388\":2,\"391\":2,\"392\":9,\"484\":1,\"505\":1,\"527\":1,\"615\":2,\"637\":1,\"664\":1,\"690\":10,\"691\":3,\"693\":18,\"694\":26,\"695\":7,\"715\":3,\"718\":1,\"720\":8,\"721\":10,\"744\":1,\"748\":10,\"768\":1,\"790\":26,\"791\":5,\"795\":1,\"796\":1,\"797\":2,\"798\":11,\"800\":2,\"808\":2,\"816\":2,\"817\":3,\"838\":1}}],[\"of\",{\"1\":{\"11\":2,\"21\":4,\"37\":2,\"39\":1,\"43\":1,\"44\":1,\"46\":1,\"54\":1,\"80\":1,\"103\":3,\"147\":2,\"154\":2,\"157\":4,\"158\":2,\"159\":1,\"160\":2,\"176\":3,\"178\":1,\"240\":12,\"252\":1,\"256\":10,\"257\":2,\"287\":1,\"365\":4,\"380\":1,\"406\":3,\"415\":1,\"418\":1,\"430\":1,\"433\":1,\"480\":1,\"520\":1,\"537\":1,\"541\":1,\"570\":1,\"694\":1,\"767\":1,\"787\":1,\"796\":1,\"807\":1,\"847\":1,\"851\":1,\"852\":1}}],[\"opaque\",{\"1\":{\"262\":1,\"410\":1,\"414\":1}}],[\"op\",{\"1\":{\"261\":1}}],[\"operationcomplete\",{\"1\":{\"340\":1,\"693\":1}}],[\"operation\",{\"1\":{\"176\":1}}],[\"operating\",{\"1\":{\"160\":1}}],[\"open0\",{\"1\":{\"599\":1}}],[\"openmessaging最初的创始人冯嘉曾表示\",{\"1\":{\"127\":1}}],[\"openchaos已支持接入大多数分布式系统\",{\"1\":{\"136\":1}}],[\"openchaos可以根据用户设置的操作系统指标或业务指标阈值来触发扩缩容\",{\"1\":{\"135\":1}}],[\"openchaos支持对系统扩缩容能力的度量与评测\",{\"1\":{\"135\":1}}],[\"openchaos执行的一个实验结果示例\",{\"1\":{\"134\":1}}],[\"openchaos不仅支持普遍的黑盒故障注入\",{\"1\":{\"132\":1}}],[\"openchaos中的检测模型关注更高维度的属性\",{\"1\":{\"132\":1}}],[\"openchaos的整体架构可以分为管理层\",{\"1\":{\"130\":1}}],[\"openchaos的工作原理是这样的\",{\"1\":{\"130\":1}}],[\"openchaos借助混沌工程思想\",{\"1\":{\"128\":1}}],[\"openchaos创始团队早期也和这些社区的先行者进行过多轮交流\",{\"1\":{\"126\":1}}],[\"openchaos\",{\"0\":{\"128\":1},\"1\":{\"125\":1,\"128\":1}}],[\"open\",{\"1\":{\"91\":1,\"106\":1,\"109\":1,\"112\":1,\"487\":1,\"525\":1,\"599\":1}}],[\"openjdk\",{\"1\":{\"2\":1,\"7\":1,\"8\":2}}],[\"opt=\",{\"1\":{\"600\":8}}],[\"option\",{\"1\":{\"767\":5,\"820\":1}}],[\"options\",{\"1\":{\"21\":1,\"53\":2,\"116\":1,\"480\":4,\"600\":1}}],[\"optimized\",{\"1\":{\"720\":1}}],[\"optimise\",{\"1\":{\"240\":4,\"243\":1,\"256\":2,\"262\":1}}],[\"opt\",{\"1\":{\"91\":1,\"595\":4,\"599\":1,\"600\":20,\"767\":5}}],[\"ops\",{\"1\":{\"11\":25,\"261\":4}}],[\"用编译好的\",{\"1\":{\"844\":1,\"852\":1}}],[\"用它能够将消费者端指定的\",{\"1\":{\"841\":1}}],[\"用它来判断这个消费者是否可能匹配过滤规则\",{\"1\":{\"835\":1}}],[\"用它来解析权限配置文件\",{\"1\":{\"510\":1,\"516\":1}}],[\"用布隆过滤器计算匹配过滤条件的消费组\",{\"1\":{\"828\":1,\"835\":1}}],[\"用消费队列来表示轻量级队列\",{\"1\":{\"811\":1}}],[\"用消费队列表示的好处还在于\",{\"1\":{\"811\":1}}],[\"用请求头中的信息构造\",{\"1\":{\"793\":1}}],[\"用如下命令\",{\"1\":{\"767\":1}}],[\"用该偏移量更新消费进度\",{\"1\":{\"708\":1}}],[\"用该消息重新消费的次数计算延迟等级\",{\"1\":{\"700\":1}}],[\"用阻塞队列\",{\"1\":{\"675\":1}}],[\"用单独的一个拉取消息线程\",{\"1\":{\"675\":1}}],[\"用物理偏移量从消息存储中查找消息\",{\"1\":{\"673\":1}}],[\"用一个周期性任务去扫描\",{\"1\":{\"876\":1}}],[\"用一个线程从拉取请求队列\",{\"1\":{\"624\":1}}],[\"用一个单独的线程异步调用\",{\"1\":{\"435\":1}}],[\"用同一个网络\",{\"1\":{\"601\":1}}],[\"用本地构建的镜像和\",{\"1\":{\"599\":1}}],[\"用到的是\",{\"1\":{\"555\":1}}],[\"用原\",{\"1\":{\"541\":1}}],[\"用分层时间轮或者哈希时间轮就好了\",{\"1\":{\"451\":1}}],[\"用代码复杂度换性能\",{\"1\":{\"437\":1}}],[\"用作返回值\",{\"1\":{\"778\":1}}],[\"用作请求处理前的权限校验\",{\"1\":{\"500\":1}}],[\"用作保存消息在\",{\"1\":{\"387\":1}}],[\"用作消息过滤\",{\"1\":{\"275\":1}}],[\"用图展示一下消息投递线程和任务更新线程的工作流程\",{\"1\":{\"376\":1}}],[\"用以执行基本的\",{\"1\":{\"841\":1}}],[\"用以解析\",{\"1\":{\"841\":1}}],[\"用以被scheduledexecutorservice定时调用\",{\"1\":{\"361\":1}}],[\"用以被\",{\"1\":{\"361\":1}}],[\"用以提高定时消息重投递的性能\",{\"1\":{\"360\":1}}],[\"用以生成\",{\"1\":{\"331\":1}}],[\"用以在客户端应对可能的阻塞情况\",{\"1\":{\"146\":1}}],[\"用法类似\",{\"1\":{\"246\":1}}],[\"用户态线程和内核态线程有什么区别\",{\"1\":{\"858\":1}}],[\"用户态和内核态\",{\"0\":{\"857\":1},\"1\":{\"858\":1}}],[\"用户业务代码返回\",{\"1\":{\"771\":1}}],[\"用户主动发起拉取\",{\"1\":{\"671\":1}}],[\"用户往往难以快速部署\",{\"1\":{\"589\":1}}],[\"用户也可以自己实现其他验证器\",{\"1\":{\"510\":1,\"516\":1}}],[\"用户ip白名单\",{\"1\":{\"503\":1}}],[\"用户名和密码进行签名\",{\"1\":{\"501\":1}}],[\"用户需手动配置一个\",{\"1\":{\"500\":1}}],[\"用户需在消息属性中设置延迟等级\",{\"1\":{\"354\":1}}],[\"用户手动修改和配置\",{\"1\":{\"500\":1}}],[\"用户权限的集合\",{\"1\":{\"498\":1}}],[\"用户\",{\"1\":{\"498\":2}}],[\"用户组\",{\"1\":{\"496\":1}}],[\"用户的应用程序在使用完某块\",{\"1\":{\"399\":1}}],[\"用户自己进行消息的拉取和消费进度的更新\",{\"1\":{\"321\":1}}],[\"用户自定义\",{\"1\":{\"185\":1}}],[\"用户定义的模块属性\",{\"0\":{\"54\":1}}],[\"用平衡二叉树表示\",{\"1\":{\"99\":1}}],[\"用端口建立外部\",{\"0\":{\"92\":1}}],[\"用于比较数字\",{\"1\":{\"828\":3}}],[\"用于设置写缓冲区的低水位线和高水位线\",{\"1\":{\"819\":1}}],[\"用于\",{\"1\":{\"798\":1}}],[\"用于等待\",{\"1\":{\"790\":1}}],[\"用于获取客户端\",{\"1\":{\"790\":1}}],[\"用于存放\",{\"1\":{\"783\":1}}],[\"用于存放所有的\",{\"1\":{\"508\":1,\"514\":1}}],[\"用于匹配\",{\"0\":{\"779\":1}}],[\"用于快速更新和查询\",{\"1\":{\"711\":1}}],[\"用于注册和执行消息消费的真正逻辑\",{\"1\":{\"707\":1}}],[\"用于响应和请求的匹配\",{\"1\":{\"693\":1}}],[\"用于暂存解析出来的\",{\"1\":{\"518\":1}}],[\"用于解析白名单\",{\"1\":{\"517\":1}}],[\"用于每\",{\"1\":{\"510\":1,\"516\":1}}],[\"用于在发送请求前将该账号的用户名和密码信息放入请求中\",{\"1\":{\"507\":1}}],[\"用于在发送请求前在请求中加入验证信息\",{\"1\":{\"500\":1}}],[\"用于配置全局客户端\",{\"1\":{\"503\":1}}],[\"用于类模式的消息过滤\",{\"1\":{\"469\":1}}],[\"用于类模式消息过滤\",{\"1\":{\"464\":1}}],[\"用于路由发现的场景非常合适\",{\"1\":{\"462\":1}}],[\"用于写入字符串数组\",{\"1\":{\"420\":1}}],[\"用于将消费失败的消息重新生产到\",{\"1\":{\"640\":1,\"643\":1}}],[\"用于将\",{\"1\":{\"417\":1}}],[\"用于加速文件\",{\"1\":{\"399\":1}}],[\"用于周期性扫描延迟等级的消息\",{\"1\":{\"360\":1,\"364\":1}}],[\"用于消费者消费消息\",{\"1\":{\"356\":1}}],[\"用于管理和控制所有索引文件\",{\"1\":{\"309\":1}}],[\"用于根据时间范围查询消息\",{\"1\":{\"307\":1}}],[\"用于搜索时间范围内的消息\",{\"1\":{\"306\":1}}],[\"用于到\",{\"1\":{\"306\":1,\"307\":1}}],[\"用于往consumequeue中写入索引项\",{\"1\":{\"285\":1}}],[\"用于以下情形\",{\"1\":{\"55\":1}}],[\"用于测试\",{\"1\":{\"2\":1}}],[\"用整数组成的列表或一个二进制型表示字符串\",{\"1\":{\"28\":1}}],[\"用来将元素加入到集合中\",{\"1\":{\"842\":1}}],[\"用来为\",{\"1\":{\"839\":1}}],[\"用来标记消费成功失败的位置\",{\"1\":{\"715\":1}}],[\"用来快速更新和查询\",{\"1\":{\"710\":1}}],[\"用来快速查找某一时刻需要投递的消息\",{\"1\":{\"447\":1}}],[\"用来让消费者实时上报消费进度\",{\"1\":{\"703\":1}}],[\"用来实时更新\",{\"1\":{\"702\":1}}],[\"用来临时存放拉取到待消费的消息\",{\"1\":{\"657\":1}}],[\"用来保证在有消息正在被顺序消费时\",{\"1\":{\"729\":1}}],[\"用来保证每个消费者执行同样的重平衡流程得到的结果一致\",{\"1\":{\"657\":1}}],[\"用来保存拉取到的消息\",{\"1\":{\"624\":1}}],[\"用来保存返回结果\",{\"1\":{\"261\":1}}],[\"用来保存信用值信息的\",{\"1\":{\"157\":1}}],[\"用来与\",{\"1\":{\"638\":1}}],[\"用来注册消费监听器\",{\"1\":{\"637\":1}}],[\"用来缓存acl配置文件和全局白名单的映射关系\",{\"1\":{\"517\":1}}],[\"用来缓存accesskey和acl配置文件的映射关系\",{\"1\":{\"517\":1}}],[\"用来缓存所有acl配置文件的dataversion\",{\"1\":{\"517\":1}}],[\"用来缓存所有acl配置文件的权限数据\",{\"1\":{\"517\":2}}],[\"用来缓存所有\",{\"1\":{\"517\":1}}],[\"用来缓存\",{\"1\":{\"517\":1}}],[\"用来配置用户和用户权限\",{\"1\":{\"503\":1}}],[\"用来拼接数据统计字典的\",{\"1\":{\"428\":1}}],[\"用来表示它里面的每个条消息是否被\",{\"1\":{\"782\":1}}],[\"用来表示\",{\"1\":{\"423\":1}}],[\"用来表示元组是什么\",{\"1\":{\"26\":1}}],[\"用来存储状态\",{\"1\":{\"417\":1}}],[\"用来存放任意数量的事物\",{\"1\":{\"27\":1}}],[\"用来根据投递时间查询该时间需要投递的消息\",{\"1\":{\"368\":1}}],[\"用来高效存储海量的\",{\"1\":{\"97\":1}}],[\"用模式匹配的方式提取元组的值\",{\"1\":{\"26\":1}}],[\"用\",{\"0\":{\"44\":1,\"45\":1,\"96\":1,\"97\":1,\"595\":1,\"597\":1},\"1\":{\"24\":1,\"26\":1,\"36\":1,\"84\":1,\"87\":1,\"123\":1,\"452\":1,\"599\":1,\"675\":1,\"778\":1,\"782\":1,\"827\":1}}],[\"用例计时和输出的时间单位\",{\"1\":{\"9\":1}}],[\"tctable\",{\"1\":{\"491\":3}}],[\"tcp\",{\"1\":{\"87\":1,\"154\":1,\"595\":16,\"597\":2,\"599\":17,\"820\":7}}],[\"tls\",{\"0\":{\"604\":1},\"1\":{\"594\":1,\"604\":1}}],[\"tlsservertrustcertpath\",{\"1\":{\"481\":2}}],[\"tlsserverkeypath\",{\"1\":{\"481\":2}}],[\"tlsservercertpath\",{\"1\":{\"481\":2}}],[\"tlssystemconfig\",{\"1\":{\"481\":7}}],[\"tlsmode\",{\"1\":{\"481\":2}}],[\"twice\",{\"1\":{\"406\":1,\"426\":1}}],[\"two\",{\"1\":{\"187\":1}}],[\"tbw102\",{\"1\":{\"262\":1,\"410\":1,\"484\":1,\"488\":1}}],[\"ttl\",{\"1\":{\"231\":1}}],[\"timing\",{\"1\":{\"883\":3}}],[\"timeup\",{\"1\":{\"390\":4}}],[\"timeunit\",{\"1\":{\"9\":1,\"381\":1,\"389\":1,\"435\":1,\"481\":2,\"490\":1,\"541\":1,\"568\":5,\"721\":1,\"745\":1}}],[\"timedelay\",{\"1\":{\"364\":2}}],[\"timediff\",{\"1\":{\"317\":13}}],[\"timerdelay\",{\"1\":{\"798\":2}}],[\"timertask\",{\"1\":{\"361\":1,\"364\":1}}],[\"timer\",{\"1\":{\"360\":4,\"361\":1,\"364\":4,\"365\":4,\"370\":1,\"372\":3,\"869\":1}}],[\"timeread\",{\"1\":{\"317\":4}}],[\"timematched\",{\"1\":{\"317\":2}}],[\"timemillistohumanstring\",{\"1\":{\"313\":1}}],[\"times++\",{\"1\":{\"570\":1}}],[\"timestotal\",{\"1\":{\"570\":3}}],[\"timestamp\",{\"1\":{\"487\":1,\"537\":1,\"732\":1}}],[\"times\",{\"1\":{\"31\":2,\"289\":1,\"570\":4,\"573\":1,\"718\":3,\"817\":2}}],[\"timeoutmillis\",{\"1\":{\"514\":1,\"691\":3,\"692\":3}}],[\"timeoutmills\",{\"1\":{\"490\":3}}],[\"timeout\",{\"1\":{\"11\":1,\"570\":4,\"573\":8,\"637\":1,\"690\":1,\"777\":1,\"789\":1,\"793\":2,\"795\":1,\"796\":1,\"797\":1,\"798\":1}}],[\"time\",{\"1\":{\"9\":2,\"11\":2,\"35\":1,\"82\":1,\"133\":1,\"158\":1,\"242\":3,\"307\":1,\"364\":1,\"365\":1,\"540\":1,\"573\":2,\"690\":7,\"715\":1,\"748\":2,\"750\":2,\"797\":1,\"800\":2,\"883\":3}}],[\"tick\",{\"1\":{\"451\":8}}],[\"ticktime\",{\"1\":{\"197\":1}}],[\"tx\",{\"1\":{\"196\":1}}],[\"txt\",{\"1\":{\"41\":1}}],[\"tpinfo\",{\"1\":{\"572\":11}}],[\"tps\",{\"0\":{\"430\":1},\"1\":{\"134\":1,\"135\":1,\"240\":1,\"261\":1,\"372\":2,\"374\":1,\"406\":2,\"430\":1,\"433\":2,\"435\":1,\"436\":3,\"444\":1,\"447\":1,\"455\":1}}],[\"tpl\",{\"1\":{\"111\":1}}],[\"tmpmessage\",{\"1\":{\"573\":4}}],[\"tmp\",{\"1\":{\"109\":1,\"313\":6,\"515\":3,\"787\":2}}],[\"takemessages\",{\"1\":{\"750\":1}}],[\"take\",{\"1\":{\"688\":1}}],[\"takeaways\",{\"1\":{\"125\":1}}],[\"tail=100\",{\"1\":{\"599\":1}}],[\"tasks\",{\"1\":{\"568\":1}}],[\"tag的属性名称为tags\",{\"1\":{\"828\":1}}],[\"tagfiltertest\",{\"1\":{\"826\":1,\"827\":2}}],[\"tagc\",{\"1\":{\"826\":1,\"827\":2,\"829\":1}}],[\"tagb\",{\"1\":{\"826\":1,\"827\":1,\"829\":1,\"830\":2}}],[\"taga||tagb||tagc\",{\"1\":{\"827\":1}}],[\"taga\",{\"1\":{\"504\":1,\"526\":1,\"807\":1,\"826\":1,\"827\":2,\"829\":1,\"830\":2}}],[\"tag\",{\"0\":{\"825\":1,\"834\":1,\"839\":1,\"846\":1},\"1\":{\"178\":1,\"269\":1,\"275\":1,\"287\":1,\"355\":1,\"592\":1,\"637\":1,\"690\":1,\"693\":1,\"694\":1,\"759\":1,\"793\":1,\"798\":2,\"807\":2,\"823\":3,\"825\":4,\"826\":2,\"827\":3,\"828\":2,\"834\":8,\"835\":1,\"837\":3,\"838\":3,\"839\":8,\"841\":1,\"844\":1,\"847\":4,\"848\":3,\"852\":2}}],[\"tagsstring2tagscode\",{\"1\":{\"718\":1}}],[\"tagscode\",{\"1\":{\"285\":3,\"287\":2,\"291\":4,\"345\":3,\"348\":2,\"359\":1,\"365\":8,\"380\":7,\"694\":6,\"817\":4,\"838\":2,\"847\":5,\"852\":3}}],[\"tags\",{\"0\":{\"821\":1},\"1\":{\"178\":1,\"262\":1,\"365\":1,\"380\":1,\"410\":1,\"537\":1,\"826\":5,\"829\":3,\"830\":4,\"847\":1,\"852\":1,\"884\":1}}],[\"tables\",{\"1\":{\"103\":4,\"289\":2,\"391\":2}}],[\"table\",{\"1\":{\"103\":12}}],[\"tableid\",{\"1\":{\"98\":7}}],[\"tab2list\",{\"1\":{\"98\":1}}],[\"target\",{\"1\":{\"10\":1,\"223\":1}}],[\"tuple\",{\"1\":{\"35\":2}}],[\"tutorial\",{\"1\":{\"16\":1}}],[\"triggers\",{\"1\":{\"380\":1}}],[\"triple\",{\"1\":{\"31\":2}}],[\"trust\",{\"1\":{\"481\":1}}],[\"truncatemessagequeuenotmytopic\",{\"1\":{\"662\":1}}],[\"truncatebymaxaddress\",{\"1\":{\"291\":1}}],[\"truncate\",{\"1\":{\"291\":1}}],[\"truncatedirtyfiles\",{\"1\":{\"291\":1}}],[\"true\",{\"1\":{\"21\":1,\"31\":6,\"36\":8,\"37\":1,\"38\":3,\"103\":1,\"116\":1,\"157\":1,\"158\":3,\"159\":3,\"160\":1,\"198\":2,\"217\":1,\"242\":1,\"253\":1,\"255\":1,\"262\":1,\"282\":1,\"285\":2,\"291\":1,\"313\":2,\"317\":2,\"325\":1,\"339\":1,\"364\":2,\"380\":2,\"414\":1,\"435\":2,\"481\":3,\"487\":4,\"491\":1,\"492\":1,\"503\":2,\"515\":1,\"519\":1,\"525\":1,\"526\":1,\"527\":1,\"537\":1,\"541\":1,\"570\":1,\"571\":1,\"573\":5,\"642\":1,\"664\":5,\"690\":3,\"693\":2,\"694\":1,\"695\":1,\"715\":2,\"717\":1,\"718\":1,\"720\":1,\"744\":5,\"745\":1,\"746\":2,\"748\":1,\"750\":2,\"754\":1,\"767\":5,\"789\":2,\"790\":1,\"795\":1,\"796\":2,\"797\":2,\"798\":2,\"806\":2,\"817\":1,\"819\":2,\"820\":1,\"842\":1,\"847\":8,\"851\":1,\"852\":12}}],[\"treemap\",{\"1\":{\"624\":1,\"675\":1}}],[\"treemap<string\",{\"1\":{\"515\":1}}],[\"tree\",{\"1\":{\"176\":1}}],[\"tranmsg\",{\"1\":{\"573\":2}}],[\"trantype\",{\"1\":{\"284\":2,\"314\":2,\"363\":3}}],[\"transfer\",{\"1\":{\"693\":2}}],[\"transflag\",{\"1\":{\"576\":3}}],[\"transport=dt\",{\"1\":{\"600\":1}}],[\"transbeanlist\",{\"1\":{\"541\":5}}],[\"transbeanmap\",{\"1\":{\"541\":4}}],[\"trans\",{\"1\":{\"365\":1,\"380\":1,\"484\":1,\"573\":1}}],[\"transientstorepool\",{\"0\":{\"403\":1},\"1\":{\"403\":4}}],[\"transient\",{\"1\":{\"220\":1}}],[\"transactionid\",{\"1\":{\"537\":1}}],[\"transactionstate\",{\"1\":{\"537\":1}}],[\"transaction\",{\"1\":{\"103\":7,\"257\":2,\"284\":4,\"314\":4,\"363\":2,\"573\":3,\"576\":2,\"717\":1}}],[\"traget\",{\"1\":{\"223\":1}}],[\"tracing\",{\"1\":{\"525\":1}}],[\"tracking\",{\"1\":{\"157\":1}}],[\"tracedataencoder\",{\"1\":{\"541\":1}}],[\"tracedata\",{\"1\":{\"541\":2}}],[\"tracedispatcher\",{\"1\":{\"539\":3,\"541\":1}}],[\"traceconstants\",{\"1\":{\"541\":2}}],[\"tracecontextqueue\",{\"1\":{\"541\":4}}],[\"tracecontext\",{\"1\":{\"537\":2,\"540\":14,\"541\":2}}],[\"traceproducer\",{\"1\":{\"541\":2}}],[\"traceexecutor\",{\"1\":{\"541\":3}}],[\"traceon\",{\"1\":{\"540\":3}}],[\"tracebean\",{\"1\":{\"537\":1,\"540\":12}}],[\"tracebeans\",{\"1\":{\"537\":2}}],[\"tracetransferbean\",{\"1\":{\"541\":1}}],[\"tracetopicname\",{\"1\":{\"541\":1}}],[\"tracetopicenable=true\",{\"1\":{\"525\":1}}],[\"tracetype\",{\"1\":{\"537\":2,\"540\":2}}],[\"tracer\",{\"1\":{\"111\":3}}],[\"trace\",{\"1\":{\"111\":5,\"158\":1,\"160\":1,\"522\":1,\"532\":1,\"537\":1,\"539\":1,\"540\":2,\"541\":1}}],[\"trylocklaterandreconsume\",{\"1\":{\"750\":3}}],[\"trylock\",{\"1\":{\"745\":1,\"790\":1}}],[\"trylockbatch\",{\"1\":{\"742\":1}}],[\"trytocompressmessage\",{\"1\":{\"573\":1}}],[\"trytofindtopicpublishinfo\",{\"1\":{\"559\":1,\"570\":2,\"571\":1,\"573\":1}}],[\"try\",{\"0\":{\"44\":1},\"1\":{\"30\":1,\"43\":2,\"44\":4,\"45\":10,\"46\":1,\"146\":1,\"262\":2,\"282\":1,\"285\":1,\"287\":1,\"313\":2,\"314\":1,\"317\":4,\"340\":2,\"343\":1,\"344\":1,\"345\":2,\"364\":1,\"365\":2,\"380\":1,\"381\":3,\"390\":1,\"391\":1,\"392\":1,\"400\":1,\"435\":1,\"481\":1,\"490\":2,\"491\":2,\"492\":4,\"504\":1,\"515\":1,\"519\":2,\"526\":1,\"539\":1,\"541\":1,\"568\":5,\"570\":1,\"572\":1,\"573\":1,\"662\":1,\"663\":1,\"664\":2,\"688\":2,\"690\":3,\"693\":2,\"694\":1,\"695\":1,\"714\":2,\"715\":1,\"717\":2,\"720\":1,\"721\":1,\"742\":2,\"744\":1,\"745\":2,\"746\":1,\"748\":1,\"750\":1,\"786\":1,\"790\":1,\"796\":1,\"798\":1,\"816\":1,\"817\":2,\"851\":2,\"852\":2}}],[\"t\",{\"1\":{\"21\":1,\"30\":2,\"33\":4,\"34\":3,\"37\":2,\"39\":2,\"365\":2,\"380\":2,\"481\":1,\"539\":1,\"599\":1,\"694\":2,\"767\":2,\"768\":1}}],[\"type\",{\"1\":{\"21\":5,\"262\":11,\"284\":4,\"314\":4,\"363\":2,\"402\":4,\"414\":1,\"528\":1,\"539\":1,\"540\":1,\"541\":2,\"573\":1,\"715\":1,\"750\":2,\"850\":4}}],[\"types\",{\"1\":{\"21\":1}}],[\"than\",{\"1\":{\"406\":1,\"426\":1,\"690\":1,\"721\":1,\"748\":1,\"790\":1}}],[\"that\",{\"1\":{\"287\":1,\"694\":1}}],[\"this\",{\"1\":{\"46\":1,\"103\":1,\"176\":1,\"257\":48,\"258\":1,\"262\":3,\"282\":9,\"283\":1,\"284\":2,\"285\":17,\"287\":3,\"289\":8,\"291\":8,\"313\":17,\"314\":7,\"316\":2,\"317\":39,\"339\":4,\"340\":2,\"342\":3,\"343\":3,\"344\":11,\"345\":5,\"347\":5,\"348\":1,\"355\":1,\"363\":2,\"364\":7,\"365\":20,\"380\":24,\"381\":19,\"389\":5,\"390\":11,\"391\":5,\"392\":10,\"400\":4,\"402\":6,\"406\":1,\"413\":3,\"414\":6,\"426\":1,\"433\":1,\"435\":2,\"481\":18,\"490\":1,\"491\":12,\"492\":11,\"493\":3,\"515\":1,\"516\":2,\"518\":6,\"519\":7,\"539\":6,\"541\":2,\"567\":19,\"568\":28,\"570\":10,\"571\":7,\"572\":5,\"573\":26,\"575\":9,\"576\":7,\"642\":59,\"643\":13,\"660\":5,\"662\":3,\"663\":11,\"664\":10,\"665\":9,\"688\":6,\"690\":27,\"691\":7,\"692\":2,\"693\":34,\"694\":18,\"695\":16,\"714\":5,\"715\":22,\"717\":10,\"718\":14,\"720\":12,\"721\":6,\"742\":5,\"744\":10,\"745\":5,\"746\":6,\"748\":4,\"749\":9,\"750\":45,\"755\":4,\"786\":3,\"789\":4,\"790\":13,\"791\":2,\"793\":6,\"795\":4,\"796\":1,\"797\":2,\"798\":1,\"799\":1,\"816\":1,\"817\":14,\"848\":1,\"850\":5,\"851\":2,\"852\":3,\"854\":5}}],[\"thing\",{\"1\":{\"46\":2}}],[\"things3\",{\"1\":{\"27\":1}}],[\"things2\",{\"1\":{\"27\":1}}],[\"things1=\",{\"1\":{\"27\":1}}],[\"things\",{\"1\":{\"27\":1}}],[\"these\",{\"1\":{\"406\":1}}],[\"there\",{\"1\":{\"257\":1,\"576\":1}}],[\"thenapply\",{\"1\":{\"718\":1}}],[\"then\",{\"1\":{\"139\":1,\"491\":1,\"520\":2,\"799\":2,\"800\":1}}],[\"the\",{\"1\":{\"21\":9,\"103\":8,\"157\":4,\"161\":1,\"173\":1,\"176\":2,\"223\":1,\"257\":2,\"258\":1,\"262\":11,\"317\":2,\"365\":2,\"380\":2,\"381\":1,\"390\":1,\"406\":1,\"415\":1,\"480\":3,\"481\":5,\"491\":1,\"492\":2,\"493\":1,\"503\":1,\"515\":1,\"516\":4,\"518\":1,\"520\":6,\"525\":1,\"528\":1,\"537\":1,\"540\":1,\"541\":1,\"567\":3,\"568\":2,\"573\":2,\"576\":1,\"642\":4,\"643\":2,\"663\":2,\"665\":2,\"690\":9,\"691\":2,\"693\":20,\"695\":3,\"715\":2,\"718\":2,\"720\":3,\"746\":1,\"748\":2,\"750\":7,\"786\":6,\"787\":3,\"790\":1,\"797\":1,\"816\":1}}],[\"threshold\",{\"1\":{\"690\":2}}],[\"threadlocalrandom\",{\"1\":{\"718\":2}}],[\"threadlocalindex\",{\"1\":{\"541\":2}}],[\"threadpoolexecutor\",{\"1\":{\"541\":1}}],[\"threadfactoryimpl\",{\"1\":{\"481\":1}}],[\"thread\",{\"1\":{\"11\":1,\"313\":2,\"381\":1,\"390\":1,\"391\":1,\"402\":1,\"406\":2,\"433\":2,\"505\":1,\"527\":1,\"541\":2,\"768\":1,\"797\":1,\"798\":1,\"808\":1,\"817\":2}}],[\"threads\",{\"1\":{\"11\":1}}],[\"throttle\",{\"1\":{\"157\":1}}],[\"throwable\",{\"1\":{\"262\":1,\"340\":1,\"343\":1,\"344\":1,\"345\":2,\"364\":1,\"539\":1,\"662\":1,\"663\":1,\"693\":1,\"695\":2,\"715\":1,\"721\":1,\"750\":1,\"786\":1,\"796\":1,\"798\":1,\"799\":1,\"800\":1,\"808\":1,\"851\":2,\"852\":2}}],[\"throws\",{\"1\":{\"262\":2,\"339\":2,\"340\":3,\"400\":1,\"411\":1,\"480\":3,\"481\":1,\"493\":1,\"504\":1,\"505\":1,\"567\":1,\"568\":2,\"570\":5,\"573\":1,\"642\":2,\"643\":2,\"691\":5,\"692\":1,\"693\":3,\"717\":5,\"718\":2,\"720\":1,\"768\":2,\"789\":2,\"793\":2,\"799\":1,\"800\":3}}],[\"thrown\",{\"1\":{\"43\":1,\"44\":2}}],[\"throw\",{\"1\":{\"43\":3,\"44\":2,\"158\":1,\"262\":3,\"480\":1,\"515\":1,\"518\":1,\"520\":6,\"567\":2,\"568\":1,\"570\":2,\"573\":3,\"642\":2,\"643\":1,\"691\":2,\"720\":1,\"800\":1,\"850\":1}}],[\"throughput\",{\"1\":{\"9\":1,\"11\":2}}],[\"thrpt\",{\"1\":{\"11\":3,\"261\":4}}],[\"tojsonstring\",{\"1\":{\"793\":1}}],[\"tojavalist\",{\"1\":{\"518\":2}}],[\"toset\",{\"1\":{\"768\":1}}],[\"tostring占用大量时间\",{\"1\":{\"416\":1}}],[\"tostring\",{\"1\":{\"340\":4,\"380\":1,\"381\":8,\"480\":1,\"515\":1,\"518\":1,\"541\":1,\"690\":1,\"695\":2,\"715\":2,\"717\":1,\"720\":1,\"750\":1,\"755\":1,\"789\":3,\"790\":3}}],[\"token\",{\"1\":{\"515\":2}}],[\"toipic\",{\"1\":{\"426\":1}}],[\"toarray\",{\"1\":{\"392\":1}}],[\"too\",{\"1\":{\"240\":1,\"251\":1,\"257\":2,\"690\":1,\"693\":3,\"694\":1,\"695\":1,\"790\":1,\"796\":1,\"797\":2}}],[\"tools\",{\"1\":{\"176\":1}}],[\"tool\",{\"1\":{\"15\":1}}],[\"topicname\",{\"1\":{\"767\":1}}],[\"topic下所有的messagequeue\",{\"1\":{\"663\":1}}],[\"topicsubscribeinfotable\",{\"1\":{\"653\":1,\"663\":2}}],[\"topicsysflag\",{\"1\":{\"484\":10,\"488\":2,\"718\":4}}],[\"topicwithnamespace\",{\"1\":{\"573\":3}}],[\"topicpublishinfo\",{\"1\":{\"567\":1,\"570\":6,\"571\":12,\"572\":2,\"573\":4}}],[\"topicpublishinfotable\",{\"1\":{\"567\":1,\"571\":4}}],[\"topicperms\",{\"1\":{\"503\":2}}],[\"topic0607\",{\"1\":{\"504\":1,\"505\":1}}],[\"topicc=sub\",{\"1\":{\"503\":1}}],[\"topicconfig\",{\"0\":{\"586\":1},\"1\":{\"576\":4,\"581\":2,\"693\":7,\"718\":6,\"789\":4}}],[\"topicconfig>\",{\"1\":{\"491\":2}}],[\"topicconfigwrapper\",{\"1\":{\"490\":2,\"491\":5}}],[\"topicconfigserializewrapper\",{\"1\":{\"490\":1,\"491\":1}}],[\"topicconfigtable\",{\"1\":{\"472\":1}}],[\"topicconfigmanager\",{\"1\":{\"472\":1}}],[\"topicb=pub|sub\",{\"1\":{\"503\":1}}],[\"topicqueuekey\",{\"1\":{\"816\":2}}],[\"topicqueue\",{\"1\":{\"492\":1}}],[\"topicqueuetable\",{\"0\":{\"484\":1},\"1\":{\"240\":1,\"256\":1,\"285\":2,\"464\":1,\"469\":1,\"473\":1,\"474\":1,\"477\":1,\"484\":1,\"491\":1,\"492\":4,\"493\":1}}],[\"topicrouteinfomanager\",{\"1\":{\"786\":4}}],[\"topicroutedata\",{\"1\":{\"470\":1,\"477\":3,\"488\":1,\"493\":9}}],[\"topicroutedata>\",{\"1\":{\"470\":2,\"488\":2}}],[\"topicroutetable\",{\"1\":{\"470\":1,\"476\":1,\"488\":1}}],[\"topic之类的\",{\"1\":{\"365\":1}}],[\"topicvalidator\",{\"1\":{\"363\":1,\"365\":2,\"380\":2,\"718\":1}}],[\"topica=deny\",{\"1\":{\"503\":1}}],[\"topica\",{\"1\":{\"355\":1}}],[\"topic=权限\",{\"1\":{\"503\":1}}],[\"topic=\",{\"1\":{\"343\":1,\"663\":1,\"693\":3,\"694\":1,\"798\":1,\"799\":1,\"800\":1,\"851\":2}}],[\"topictest\",{\"1\":{\"262\":1,\"410\":1,\"526\":1,\"527\":1,\"768\":1,\"807\":1,\"808\":2}}],[\"topiclength\",{\"1\":{\"257\":6}}],[\"topicdata\",{\"1\":{\"257\":6}}],[\"topic\",{\"0\":{\"424\":1,\"425\":1,\"559\":1,\"663\":1},\"1\":{\"135\":1,\"257\":2,\"262\":1,\"266\":1,\"267\":5,\"269\":2,\"271\":1,\"275\":2,\"277\":1,\"284\":1,\"285\":4,\"287\":5,\"306\":3,\"307\":1,\"309\":1,\"314\":7,\"335\":2,\"339\":2,\"342\":3,\"343\":5,\"345\":5,\"348\":2,\"354\":6,\"356\":6,\"359\":3,\"363\":10,\"365\":4,\"377\":1,\"380\":3,\"387\":1,\"397\":1,\"398\":2,\"406\":3,\"422\":2,\"424\":2,\"425\":1,\"426\":5,\"441\":1,\"445\":4,\"461\":2,\"464\":2,\"465\":6,\"469\":3,\"470\":7,\"472\":5,\"473\":1,\"476\":1,\"477\":1,\"484\":8,\"488\":4,\"490\":2,\"491\":3,\"492\":5,\"493\":6,\"498\":8,\"503\":1,\"526\":1,\"527\":1,\"532\":4,\"537\":1,\"541\":8,\"548\":4,\"549\":3,\"550\":3,\"557\":1,\"558\":1,\"559\":11,\"561\":1,\"570\":4,\"571\":7,\"573\":3,\"581\":8,\"585\":4,\"586\":1,\"587\":1,\"609\":3,\"610\":1,\"611\":2,\"614\":1,\"615\":3,\"616\":2,\"617\":2,\"620\":3,\"622\":4,\"623\":1,\"636\":2,\"637\":3,\"640\":3,\"642\":2,\"646\":2,\"650\":2,\"653\":3,\"654\":2,\"656\":3,\"657\":4,\"662\":7,\"663\":22,\"664\":3,\"665\":6,\"693\":14,\"694\":11,\"695\":1,\"700\":1,\"701\":1,\"708\":10,\"717\":3,\"718\":14,\"721\":5,\"723\":5,\"738\":1,\"744\":3,\"750\":1,\"759\":1,\"767\":3,\"768\":5,\"769\":1,\"771\":1,\"773\":6,\"775\":1,\"777\":3,\"781\":1,\"783\":6,\"786\":16,\"790\":21,\"791\":3,\"798\":2,\"799\":6,\"800\":4,\"804\":1,\"807\":2,\"810\":12,\"811\":2,\"813\":4,\"817\":4,\"835\":1,\"838\":2,\"843\":2,\"850\":6,\"851\":1,\"871\":1,\"873\":1,\"876\":5}}],[\"todo\",{\"1\":{\"41\":13}}],[\"total++\",{\"1\":{\"714\":2}}],[\"totalsize\",{\"1\":{\"257\":2}}],[\"total\",{\"1\":{\"11\":1,\"30\":3,\"33\":1,\"257\":2,\"400\":2,\"515\":2,\"694\":1,\"714\":6}}],[\"to\",{\"1\":{\"11\":1,\"21\":4,\"35\":2,\"50\":1,\"102\":1,\"103\":2,\"106\":1,\"109\":1,\"139\":1,\"157\":2,\"159\":9,\"160\":2,\"176\":4,\"178\":1,\"179\":1,\"186\":3,\"240\":3,\"242\":1,\"285\":1,\"287\":5,\"317\":2,\"340\":1,\"390\":1,\"406\":1,\"430\":1,\"433\":2,\"435\":1,\"480\":2,\"481\":1,\"490\":1,\"491\":1,\"503\":1,\"519\":2,\"541\":1,\"576\":3,\"664\":1,\"665\":4,\"690\":3,\"691\":1,\"693\":3,\"694\":5,\"715\":1,\"720\":2,\"748\":3,\"750\":4,\"767\":1,\"786\":2,\"787\":1,\"791\":1,\"797\":2,\"807\":3,\"817\":2,\"851\":1}}],[\"tempproperties\",{\"1\":{\"852\":6}}],[\"temp\",{\"1\":{\"850\":3}}],[\"templates$\",{\"1\":{\"599\":3}}],[\"templates\",{\"1\":{\"594\":3,\"595\":3,\"598\":1,\"599\":1,\"603\":1,\"604\":1}}],[\"tempdataversion\",{\"1\":{\"518\":4}}],[\"temptest\",{\"1\":{\"261\":4}}],[\"temporary\",{\"1\":{\"157\":1}}],[\"tempconvert\",{\"1\":{\"31\":3}}],[\"tencent\",{\"1\":{\"124\":1}}],[\"telecom\",{\"1\":{\"112\":1}}],[\"text=txt\",{\"1\":{\"41\":1}}],[\"text\",{\"1\":{\"41\":6}}],[\"term\",{\"1\":{\"21\":2,\"97\":1,\"109\":2,\"223\":1}}],[\"testgroup02\",{\"1\":{\"505\":1}}],[\"tester\",{\"1\":{\"122\":1}}],[\"test1\",{\"1\":{\"111\":1}}],[\"tests\",{\"1\":{\"30\":2}}],[\"testlinkedlist\",{\"1\":{\"9\":1,\"11\":3}}],[\"testarraylist\",{\"1\":{\"9\":1,\"11\":3}}],[\"test\",{\"1\":{\"9\":1,\"30\":3,\"44\":1,\"45\":9,\"98\":7,\"103\":1,\"111\":2,\"207\":1,\"433\":1,\"484\":1,\"808\":2}}],[\"teardown\",{\"1\":{\"4\":1}}],[\"=queueoffsets\",{\"1\":{\"817\":1}}],[\"=>\",{\"1\":{\"42\":14,\"98\":5,\"160\":2}}],[\"======\",{\"1\":{\"690\":6,\"693\":2}}],[\"==\",{\"1\":{\"37\":1,\"157\":1,\"159\":1,\"257\":6,\"258\":2,\"262\":2,\"282\":1,\"285\":1,\"287\":3,\"289\":2,\"291\":1,\"313\":1,\"314\":3,\"316\":1,\"317\":3,\"342\":1,\"343\":1,\"363\":2,\"364\":1,\"365\":1,\"380\":3,\"381\":2,\"390\":1,\"402\":3,\"413\":1,\"414\":1,\"480\":3,\"491\":5,\"492\":3,\"515\":1,\"516\":1,\"518\":3,\"520\":4,\"540\":6,\"541\":1,\"568\":2,\"570\":2,\"571\":1,\"572\":1,\"573\":1,\"576\":1,\"642\":1,\"643\":1,\"663\":2,\"690\":5,\"691\":1,\"693\":6,\"694\":9,\"695\":1,\"715\":5,\"718\":6,\"720\":2,\"721\":1,\"742\":2,\"749\":1,\"750\":9,\"786\":5,\"789\":3,\"790\":1,\"793\":1,\"796\":1,\"798\":5,\"799\":2,\"800\":4,\"808\":1,\"817\":2,\"847\":2,\"848\":1,\"850\":6,\"851\":3,\"852\":13}}],[\"=<\",{\"1\":{\"34\":1,\"159\":1}}],[\"=things2\",{\"1\":{\"27\":1}}],[\"=things1\",{\"1\":{\"27\":1}}],[\"=person\",{\"1\":{\"26\":1}}],[\"=是一次模式匹配操作\",{\"1\":{\"23\":1}}],[\"=\",{\"1\":{\"9\":6,\"11\":4,\"23\":4,\"26\":4,\"27\":2,\"28\":2,\"30\":2,\"31\":11,\"34\":4,\"36\":4,\"41\":18,\"42\":7,\"79\":2,\"80\":2,\"98\":2,\"103\":31,\"106\":1,\"109\":2,\"122\":1,\"157\":2,\"158\":10,\"159\":1,\"160\":1,\"198\":3,\"242\":1,\"257\":12,\"258\":8,\"262\":34,\"282\":9,\"284\":2,\"285\":10,\"287\":13,\"289\":12,\"291\":20,\"313\":18,\"314\":23,\"316\":2,\"317\":35,\"335\":1,\"339\":7,\"340\":3,\"342\":6,\"343\":4,\"344\":2,\"345\":11,\"347\":2,\"355\":1,\"363\":5,\"364\":6,\"365\":28,\"380\":30,\"381\":9,\"390\":18,\"391\":5,\"392\":9,\"400\":2,\"402\":10,\"411\":12,\"413\":1,\"414\":15,\"417\":1,\"424\":3,\"470\":1,\"480\":14,\"481\":11,\"488\":1,\"490\":10,\"491\":24,\"492\":29,\"493\":6,\"504\":6,\"505\":3,\"514\":2,\"515\":14,\"516\":2,\"517\":6,\"518\":27,\"519\":12,\"520\":9,\"526\":3,\"527\":1,\"537\":16,\"539\":6,\"540\":13,\"541\":25,\"567\":5,\"568\":2,\"570\":25,\"571\":3,\"572\":14,\"573\":35,\"575\":1,\"576\":16,\"595\":14,\"642\":14,\"643\":2,\"662\":3,\"663\":14,\"664\":15,\"665\":10,\"688\":2,\"690\":21,\"691\":9,\"692\":1,\"693\":45,\"694\":63,\"695\":7,\"714\":6,\"715\":30,\"717\":5,\"718\":29,\"720\":8,\"721\":5,\"742\":9,\"744\":15,\"746\":7,\"748\":4,\"749\":7,\"750\":24,\"755\":3,\"761\":1,\"767\":5,\"768\":6,\"775\":1,\"786\":16,\"787\":9,\"789\":25,\"790\":14,\"791\":2,\"793\":11,\"795\":2,\"796\":4,\"797\":14,\"798\":27,\"799\":7,\"800\":8,\"806\":2,\"807\":3,\"808\":5,\"816\":9,\"817\":26,\"819\":5,\"826\":4,\"827\":1,\"828\":2,\"829\":4,\"830\":1,\"843\":1,\"848\":6,\"850\":9,\"851\":10,\"852\":13,\"854\":1,\"873\":2}}],[\"秒后重新消费发回失败的消息\",{\"1\":{\"715\":1}}],[\"秒向\",{\"1\":{\"550\":2}}],[\"秒就没货了\",{\"1\":{\"447\":1}}],[\"秒的消息需要先被投递出去\",{\"1\":{\"445\":1}}],[\"秒的消息\",{\"1\":{\"445\":1}}],[\"秒之后执行\",{\"1\":{\"365\":1}}],[\"秒次\",{\"1\":{\"9\":1}}],[\"秒\",{\"1\":{\"9\":1,\"11\":2,\"771\":1}}],[\"次同样的\",{\"1\":{\"842\":1}}],[\"次重平衡策略\",{\"1\":{\"775\":1}}],[\"次后\",{\"1\":{\"761\":1}}],[\"次均失败\",{\"1\":{\"620\":1}}],[\"次时间间隔为延迟消息配置的每个延迟等级的时间\",{\"1\":{\"620\":1}}],[\"次则打印日志并跳过该消息\",{\"1\":{\"381\":1}}],[\"次以上\",{\"1\":{\"380\":1}}],[\"次失败后\",{\"1\":{\"374\":1}}],[\"次数组复制\",{\"1\":{\"261\":1}}],[\"次查询\",{\"1\":{\"220\":1}}],[\"次\",{\"1\":{\"9\":2,\"11\":2,\"220\":1,\"245\":1,\"261\":1,\"426\":1,\"552\":1,\"560\":3,\"620\":2,\"753\":1,\"761\":1,\"775\":1,\"787\":1,\"842\":1,\"843\":3}}],[\"57\",{\"1\":{\"599\":1}}],[\"58\",{\"1\":{\"599\":7}}],[\"58e1e7a5e556\",{\"1\":{\"592\":1}}],[\"54\",{\"1\":{\"593\":1}}],[\"54acff7d\",{\"1\":{\"117\":1}}],[\"5ms\",{\"1\":{\"782\":2}}],[\"5m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"5s\",{\"1\":{\"325\":1,\"326\":3,\"335\":1,\"353\":1,\"439\":1,\"445\":1,\"510\":1,\"516\":1,\"623\":2,\"702\":1,\"703\":2,\"708\":1,\"711\":1,\"714\":2,\"761\":1,\"795\":1}}],[\"5步\",{\"1\":{\"249\":1}}],[\"5个内部队列\",{\"1\":{\"223\":1}}],[\"529\",{\"1\":{\"176\":1}}],[\"521\",{\"1\":{\"176\":1}}],[\"56000000000000049738\",{\"1\":{\"80\":1}}],[\"56e\",{\"1\":{\"65\":1}}],[\"56259\",{\"1\":{\"11\":1}}],[\"55\",{\"1\":{\"35\":1}}],[\"551\",{\"1\":{\"11\":1}}],[\"5>\",{\"1\":{\"24\":1,\"30\":1,\"31\":1,\"35\":1,\"67\":1,\"105\":1}}],[\"50ms\",{\"1\":{\"679\":1}}],[\"5000\",{\"1\":{\"717\":1}}],[\"500万个\",{\"1\":{\"307\":2}}],[\"500ms\",{\"1\":{\"255\":1}}],[\"50\",{\"1\":{\"11\":1,\"30\":1,\"151\":1,\"234\":2}}],[\"530\",{\"1\":{\"11\":1}}],[\"5\",{\"0\":{\"161\":1,\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"247\":1,\"273\":1,\"279\":1,\"292\":1,\"293\":2,\"366\":1,\"367\":1,\"368\":1,\"402\":1,\"475\":1,\"476\":1,\"477\":1,\"493\":1,\"529\":1,\"536\":1,\"537\":1,\"538\":1,\"539\":1,\"540\":1,\"541\":1,\"563\":1,\"622\":1,\"639\":1,\"692\":1,\"696\":1,\"763\":1,\"799\":1,\"868\":1,\"869\":1},\"1\":{\"9\":4,\"11\":10,\"24\":3,\"26\":1,\"30\":1,\"31\":5,\"32\":1,\"34\":2,\"42\":1,\"43\":1,\"44\":2,\"45\":2,\"103\":5,\"105\":1,\"147\":2,\"150\":2,\"161\":2,\"176\":3,\"195\":1,\"221\":1,\"228\":1,\"233\":3,\"234\":1,\"236\":1,\"257\":2,\"293\":1,\"344\":2,\"355\":1,\"386\":1,\"390\":1,\"416\":1,\"422\":1,\"426\":2,\"441\":1,\"464\":1,\"469\":1,\"481\":1,\"541\":1,\"573\":1,\"610\":2,\"615\":2,\"625\":1,\"651\":1,\"696\":1,\"715\":1,\"720\":2,\"754\":1,\"765\":1,\"769\":2,\"772\":1,\"777\":1,\"778\":2,\"789\":2,\"801\":1,\"814\":2,\"815\":1,\"827\":2,\"830\":1,\"871\":1,\"872\":1,\"873\":1,\"884\":2}}],[\"类过滤模式\",{\"1\":{\"852\":1}}],[\"类过滤\",{\"1\":{\"823\":1,\"838\":1}}],[\"类保存一些重平衡需要的基本信息\",{\"1\":{\"653\":1}}],[\"类进行回调\",{\"1\":{\"622\":1}}],[\"类设计\",{\"0\":{\"584\":1}}],[\"类继承普通消息类\",{\"1\":{\"564\":1}}],[\"类的初始化和启动方法\",{\"1\":{\"480\":1}}],[\"类是\",{\"1\":{\"480\":1}}],[\"类中实现了整个重平衡流程\",{\"1\":{\"652\":1}}],[\"类中\",{\"1\":{\"376\":1,\"814\":1}}],[\"类型的过滤\",{\"1\":{\"693\":1}}],[\"类型的请求后\",{\"1\":{\"473\":1}}],[\"类型的请求用于\",{\"1\":{\"464\":1}}],[\"类型的\",{\"1\":{\"233\":1}}],[\"类型\",{\"0\":{\"71\":1},\"1\":{\"517\":1,\"834\":1}}],[\"类似\",{\"1\":{\"9\":2,\"461\":1,\"656\":1}}],[\"类变量的作用域\",{\"1\":{\"9\":1}}],[\"类\",{\"0\":{\"246\":1},\"1\":{\"9\":1,\"262\":1}}],[\"<>\",{\"1\":{\"828\":1}}],[\"<init>\",{\"1\":{\"599\":2}}],[\"<1\",{\"1\":{\"491\":1}}],[\"<h>\",{\"1\":{\"262\":1}}],[\"<g>\",{\"1\":{\"262\":1}}],[\"<groupid>org\",{\"1\":{\"8\":2}}],[\"<f>\",{\"1\":{\"262\":1}}],[\"<file>\",{\"1\":{\"21\":1}}],[\"<e>\",{\"1\":{\"262\":1}}],[\"<c>\",{\"1\":{\"262\":1}}],[\"<b>\",{\"1\":{\"262\":1}}],[\"<br>\",{\"1\":{\"258\":1}}],[\"<a>\",{\"1\":{\"262\":1}}],[\"<artifactid>jmh\",{\"1\":{\"8\":2}}],[\"<0\",{\"1\":{\"80\":2,\"491\":1}}],[\"<=\",{\"1\":{\"34\":1,\"285\":1,\"317\":7,\"345\":1,\"365\":1,\"714\":1,\"718\":1,\"787\":3,\"798\":2,\"799\":1,\"828\":2}}],[\"<t>\",{\"1\":{\"21\":1}}],[\"<d>\",{\"1\":{\"262\":1}}],[\"<dir>\",{\"1\":{\"21\":1}}],[\"<dependency>\",{\"1\":{\"8\":2}}],[\"<x\",{\"1\":{\"21\":1}}],[\"<mod>\",{\"1\":{\"21\":2}}],[\"<n>\",{\"1\":{\"21\":2}}],[\"<\",{\"0\":{\"34\":1},\"1\":{\"8\":2,\"34\":8,\"38\":1,\"44\":1,\"45\":1,\"46\":1,\"103\":11,\"158\":1,\"160\":1,\"262\":2,\"282\":1,\"285\":2,\"287\":2,\"289\":1,\"291\":2,\"314\":3,\"317\":4,\"365\":2,\"380\":2,\"390\":2,\"392\":3,\"402\":1,\"504\":1,\"518\":2,\"519\":2,\"540\":1,\"541\":1,\"570\":2,\"572\":4,\"573\":2,\"576\":1,\"690\":1,\"691\":1,\"693\":4,\"694\":4,\"695\":2,\"714\":4,\"715\":2,\"718\":1,\"721\":1,\"748\":1,\"789\":5,\"795\":2,\"796\":1,\"797\":4,\"800\":2,\"816\":1,\"817\":3,\"826\":1,\"828\":1,\"829\":1,\"850\":2}}],[\"<version>1\",{\"1\":{\"8\":2}}],[\"1分钟\",{\"1\":{\"726\":1}}],[\"1条\",{\"1\":{\"714\":1}}],[\"1l\",{\"1\":{\"664\":1,\"690\":1,\"744\":1,\"748\":1}}],[\"1ae8a853012b\",{\"1\":{\"599\":2}}],[\"1w\",{\"1\":{\"447\":1}}],[\"1g\",{\"1\":{\"386\":1,\"396\":1,\"401\":1,\"402\":1}}],[\"1h\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"1ms\",{\"1\":{\"851\":1}}],[\"1mb\",{\"1\":{\"819\":1}}],[\"1m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1,\"819\":1}}],[\"1s检查一次是否有新消息\",{\"1\":{\"693\":1}}],[\"1s~2s的延迟误差\",{\"1\":{\"442\":1}}],[\"1s再次执行投递任务\",{\"1\":{\"380\":1}}],[\"1s后重新执行该检查任务\",{\"1\":{\"365\":1}}],[\"1s\",{\"1\":{\"272\":1,\"278\":1,\"289\":1,\"325\":1,\"326\":1,\"335\":1,\"353\":1,\"361\":1,\"365\":1,\"435\":1,\"439\":1,\"442\":5,\"444\":2,\"445\":1,\"447\":2,\"448\":1,\"451\":3,\"452\":5,\"735\":1,\"745\":2,\"761\":2,\"773\":1,\"779\":1}}],[\"1被调用时\",{\"1\":{\"160\":1}}],[\"1将负责发送在credit\",{\"1\":{\"160\":1}}],[\"1会更新credit\",{\"1\":{\"160\":1}}],[\"1和put\",{\"1\":{\"157\":1}}],[\"1方法来处理新增信用值\",{\"1\":{\"159\":1}}],[\"1方法被调用时\",{\"1\":{\"157\":1}}],[\"1方法\",{\"1\":{\"157\":2,\"158\":1}}],[\"188mb\",{\"1\":{\"592\":1}}],[\"18\",{\"1\":{\"356\":1,\"372\":1,\"445\":5,\"484\":2,\"600\":3,\"872\":1,\"875\":1,\"876\":1}}],[\"1846725\",{\"1\":{\"124\":1}}],[\"1823\",{\"1\":{\"118\":1}}],[\"18>\",{\"1\":{\"28\":1,\"31\":1}}],[\"1到n的所有c值\",{\"1\":{\"34\":1}}],[\"1到n的所有b值\",{\"1\":{\"34\":1}}],[\"19\",{\"1\":{\"801\":1}}],[\"195\",{\"1\":{\"599\":1}}],[\"192\",{\"1\":{\"503\":6,\"760\":1}}],[\"1992\",{\"1\":{\"135\":1}}],[\"19>\",{\"1\":{\"28\":1,\"31\":1}}],[\"19126\",{\"1\":{\"11\":3}}],[\"172\",{\"1\":{\"600\":3}}],[\"17\",{\"1\":{\"257\":2}}],[\"17>\",{\"1\":{\"28\":1,\"31\":1}}],[\"177057\",{\"1\":{\"11\":2}}],[\"16次\",{\"1\":{\"753\":1}}],[\"16000\",{\"1\":{\"694\":1}}],[\"1623305799667\",{\"1\":{\"528\":1}}],[\"168\",{\"1\":{\"503\":6,\"760\":1}}],[\"1651564899813\",{\"1\":{\"487\":1}}],[\"1651564857610\",{\"1\":{\"487\":1}}],[\"1648606091635\",{\"1\":{\"115\":1}}],[\"16\",{\"1\":{\"32\":1,\"65\":1,\"116\":1,\"257\":2,\"258\":1,\"261\":1,\"426\":1,\"484\":2,\"528\":1,\"592\":1,\"620\":5,\"753\":2,\"761\":2}}],[\"16>\",{\"1\":{\"28\":1,\"31\":1}}],[\"169084\",{\"1\":{\"11\":1}}],[\"119\",{\"1\":{\"599\":1}}],[\"11w\",{\"1\":{\"430\":1}}],[\"118\",{\"1\":{\"261\":1}}],[\"11\",{\"1\":{\"257\":2,\"599\":7}}],[\"1156083311884992513l\",{\"1\":{\"116\":1}}],[\"115\",{\"1\":{\"28\":5}}],[\"1120\",{\"1\":{\"422\":1}}],[\"112\",{\"1\":{\"28\":4}}],[\"114\",{\"1\":{\"28\":8}}],[\"114555\",{\"1\":{\"11\":2}}],[\"117\",{\"1\":{\"28\":4}}],[\"11>\",{\"1\":{\"27\":1,\"31\":1,\"42\":1}}],[\"1>\",{\"1\":{\"22\":1,\"23\":1,\"24\":1,\"28\":1,\"30\":1,\"31\":1,\"34\":1,\"67\":1,\"74\":1,\"98\":1,\"102\":1}}],[\"138\",{\"1\":{\"599\":1}}],[\"131ms\",{\"1\":{\"528\":1}}],[\"13w\",{\"1\":{\"98\":1}}],[\"13>\",{\"1\":{\"27\":1,\"31\":1,\"42\":1}}],[\"13\",{\"0\":{\"259\":1},\"1\":{\"11\":1,\"257\":2,\"600\":1}}],[\"13048\",{\"1\":{\"11\":1}}],[\"1450880018677794\",{\"1\":{\"819\":1}}],[\"1455\",{\"1\":{\"817\":1}}],[\"1497\",{\"1\":{\"594\":1}}],[\"149509\",{\"1\":{\"11\":1}}],[\"1464\",{\"1\":{\"261\":1}}],[\"1482158310125\",{\"1\":{\"262\":1,\"410\":1}}],[\"148404\",{\"1\":{\"176\":1}}],[\"148778\",{\"1\":{\"11\":3}}],[\"14159\",{\"1\":{\"65\":1}}],[\"141579\",{\"1\":{\"11\":1}}],[\"14>\",{\"1\":{\"27\":1}}],[\"14\",{\"1\":{\"22\":1,\"80\":1,\"122\":1,\"257\":2,\"406\":1,\"426\":1,\"528\":1,\"599\":3,\"600\":1}}],[\"144\",{\"1\":{\"11\":1,\"30\":1}}],[\"147695\",{\"1\":{\"11\":1}}],[\"1500\",{\"1\":{\"795\":1,\"796\":2}}],[\"15000\",{\"1\":{\"690\":1}}],[\"1590\",{\"1\":{\"261\":1}}],[\"153046\",{\"1\":{\"178\":1}}],[\"15\",{\"0\":{\"259\":1,\"262\":1},\"1\":{\"31\":1,\"103\":1,\"257\":2,\"442\":1,\"594\":13}}],[\"15>\",{\"1\":{\"27\":1,\"31\":1}}],[\"152379\",{\"1\":{\"11\":1}}],[\"155\",{\"1\":{\"11\":1}}],[\"1279869501571105\",{\"1\":{\"819\":1}}],[\"127\",{\"1\":{\"485\":1,\"487\":1,\"488\":2,\"504\":1,\"505\":1,\"528\":1}}],[\"127890\",{\"1\":{\"11\":1}}],[\"120s\",{\"1\":{\"465\":1,\"474\":2}}],[\"128k\",{\"1\":{\"541\":1}}],[\"128\",{\"1\":{\"424\":3,\"504\":1}}],[\"1267\",{\"1\":{\"42\":1}}],[\"126507\",{\"1\":{\"11\":1}}],[\"12\",{\"0\":{\"256\":1},\"1\":{\"30\":2,\"35\":2,\"80\":1,\"103\":1,\"106\":1,\"257\":2,\"600\":1}}],[\"12>\",{\"1\":{\"27\":1,\"31\":1,\"42\":1}}],[\"12345678\",{\"1\":{\"503\":2,\"504\":1,\"505\":1}}],[\"12345l\",{\"1\":{\"116\":1}}],[\"123\",{\"1\":{\"23\":2,\"106\":1,\"807\":1,\"808\":1}}],[\"1048576\",{\"1\":{\"819\":1}}],[\"10932\",{\"1\":{\"595\":5}}],[\"10931\",{\"1\":{\"595\":5}}],[\"10909\",{\"1\":{\"595\":4,\"599\":3}}],[\"10929\",{\"1\":{\"595\":5}}],[\"10912\",{\"1\":{\"487\":1,\"595\":6,\"599\":3}}],[\"10911\",{\"1\":{\"485\":1,\"487\":1,\"488\":2,\"595\":5,\"599\":3}}],[\"103\",{\"1\":{\"503\":1}}],[\"10w\",{\"1\":{\"433\":1,\"436\":1}}],[\"10ms\",{\"1\":{\"750\":1}}],[\"10min\",{\"1\":{\"481\":1}}],[\"10m\",{\"1\":{\"353\":1,\"439\":1,\"445\":1,\"761\":1}}],[\"10s\",{\"1\":{\"353\":1,\"384\":2,\"386\":1,\"387\":1,\"388\":1,\"389\":1,\"390\":1,\"439\":1,\"445\":1,\"465\":1,\"467\":2,\"474\":1,\"481\":3,\"703\":1,\"711\":1,\"721\":1,\"753\":1,\"761\":2,\"873\":1}}],[\"1024\",{\"1\":{\"335\":1,\"484\":2,\"690\":2,\"742\":1,\"819\":2}}],[\"10倍提升本地研发效率\",{\"0\":{\"118\":1}}],[\"101\",{\"1\":{\"28\":4}}],[\"105\",{\"1\":{\"28\":4,\"176\":1}}],[\"10>\",{\"1\":{\"27\":1,\"31\":1,\"32\":1}}],[\"100s\",{\"1\":{\"876\":1}}],[\"100l\",{\"1\":{\"798\":1}}],[\"1000l\",{\"1\":{\"317\":1}}],[\"1000\",{\"1\":{\"317\":1,\"344\":2,\"381\":1,\"389\":1,\"390\":1,\"402\":1,\"435\":1,\"568\":4,\"690\":3,\"715\":1,\"720\":2,\"721\":1,\"745\":1,\"746\":1,\"750\":1,\"800\":1,\"817\":2}}],[\"10000ms\",{\"1\":{\"873\":2}}],[\"10000\",{\"1\":{\"261\":1,\"364\":1,\"695\":1,\"753\":1,\"820\":1}}],[\"1000w\",{\"1\":{\"9\":1,\"451\":2}}],[\"100\",{\"1\":{\"31\":2,\"32\":1,\"103\":1,\"381\":1,\"541\":1,\"694\":1,\"750\":1,\"789\":1,\"798\":1,\"828\":4}}],[\"100544\",{\"1\":{\"11\":2}}],[\"10\",{\"1\":{\"11\":2,\"26\":2,\"27\":8,\"30\":1,\"32\":4,\"34\":1,\"103\":2,\"105\":1,\"233\":2,\"257\":2,\"386\":2,\"390\":2,\"481\":2,\"487\":1,\"503\":2,\"528\":1,\"568\":3,\"599\":2,\"721\":1,\"750\":3,\"760\":1,\"828\":2,\"829\":1,\"873\":3}}],[\"1\",{\"0\":{\"143\":1,\"144\":2,\"145\":1,\"146\":2,\"147\":1,\"148\":1,\"149\":1,\"151\":1,\"154\":1,\"157\":1,\"175\":1,\"176\":2,\"177\":1,\"181\":1,\"184\":1,\"185\":2,\"186\":1,\"187\":1,\"190\":1,\"195\":1,\"200\":1,\"201\":2,\"202\":1,\"204\":1,\"209\":1,\"210\":3,\"211\":1,\"214\":1,\"216\":1,\"217\":2,\"218\":1,\"220\":1,\"239\":1,\"242\":1,\"265\":1,\"266\":2,\"267\":1,\"269\":1,\"275\":1,\"281\":1,\"282\":2,\"283\":1,\"284\":1,\"285\":1,\"287\":1,\"289\":1,\"291\":1,\"293\":1,\"296\":1,\"297\":2,\"298\":1,\"300\":1,\"305\":1,\"306\":2,\"307\":1,\"312\":1,\"313\":2,\"314\":1,\"315\":1,\"316\":1,\"320\":1,\"321\":2,\"322\":1,\"323\":2,\"324\":1,\"325\":1,\"328\":1,\"329\":2,\"330\":1,\"331\":1,\"334\":1,\"338\":1,\"339\":2,\"340\":1,\"342\":1,\"347\":1,\"351\":1,\"352\":2,\"353\":1,\"356\":1,\"359\":1,\"363\":1,\"365\":1,\"367\":1,\"370\":1,\"372\":1,\"374\":1,\"377\":1,\"380\":1,\"383\":1,\"386\":1,\"390\":1,\"396\":1,\"397\":2,\"398\":1,\"409\":1,\"435\":1,\"460\":1,\"461\":2,\"462\":1,\"464\":1,\"467\":1,\"469\":1,\"472\":1,\"476\":1,\"479\":1,\"480\":2,\"481\":1,\"483\":1,\"490\":1,\"496\":1,\"498\":1,\"500\":1,\"503\":1,\"507\":1,\"508\":2,\"509\":1,\"513\":1,\"514\":2,\"515\":1,\"517\":1,\"523\":1,\"525\":1,\"531\":1,\"534\":1,\"537\":1,\"539\":1,\"544\":1,\"546\":1,\"547\":2,\"548\":1,\"552\":1,\"555\":1,\"559\":1,\"566\":1,\"567\":2,\"568\":1,\"570\":1,\"575\":1,\"605\":1,\"606\":1,\"608\":1,\"609\":2,\"610\":1,\"611\":1,\"613\":1,\"617\":1,\"620\":1,\"627\":1,\"629\":1,\"631\":1,\"634\":1,\"635\":2,\"636\":1,\"637\":1,\"638\":1,\"639\":1,\"642\":1,\"645\":1,\"646\":2,\"648\":1,\"652\":1,\"653\":2,\"654\":1,\"656\":1,\"660\":1,\"662\":1,\"667\":1,\"669\":1,\"671\":1,\"675\":1,\"677\":1,\"678\":2,\"679\":1,\"680\":1,\"681\":1,\"683\":1,\"687\":1,\"688\":2,\"689\":1,\"690\":1,\"691\":1,\"692\":1,\"693\":1,\"694\":1,\"695\":1,\"697\":1,\"699\":1,\"702\":1,\"706\":1,\"707\":2,\"708\":1,\"710\":1,\"713\":1,\"714\":2,\"715\":1,\"717\":1,\"720\":1,\"723\":1,\"725\":1,\"726\":2,\"727\":1,\"729\":1,\"731\":1,\"732\":2,\"733\":1,\"734\":1,\"735\":1,\"737\":1,\"741\":1,\"742\":2,\"743\":1,\"744\":2,\"745\":1,\"746\":1,\"748\":1,\"764\":1,\"765\":2,\"766\":1,\"767\":2,\"768\":1,\"769\":1,\"771\":1,\"775\":1,\"777\":1,\"782\":1,\"785\":1,\"786\":2,\"787\":1,\"789\":1,\"793\":1,\"795\":1,\"803\":1,\"804\":2,\"805\":1,\"806\":2,\"807\":1,\"808\":1,\"810\":1,\"811\":1,\"813\":1,\"816\":1,\"822\":1,\"823\":2,\"824\":1,\"825\":2,\"828\":1,\"832\":1,\"834\":1,\"837\":1,\"841\":1,\"846\":1,\"847\":2,\"848\":1,\"850\":1,\"860\":1,\"862\":1,\"870\":1,\"871\":2,\"872\":1,\"873\":1,\"875\":1,\"876\":2,\"877\":1,\"878\":1,\"880\":1},\"1\":{\"8\":1,\"9\":8,\"11\":14,\"24\":2,\"26\":1,\"27\":6,\"28\":4,\"30\":2,\"31\":4,\"32\":6,\"34\":5,\"37\":1,\"39\":1,\"42\":5,\"43\":1,\"44\":2,\"45\":8,\"65\":1,\"98\":7,\"103\":6,\"105\":2,\"106\":1,\"111\":4,\"135\":1,\"136\":1,\"154\":1,\"157\":3,\"159\":2,\"170\":1,\"171\":1,\"176\":6,\"177\":1,\"178\":5,\"190\":2,\"207\":1,\"220\":1,\"226\":1,\"228\":1,\"233\":1,\"239\":1,\"240\":2,\"253\":1,\"257\":2,\"263\":1,\"282\":2,\"291\":1,\"294\":1,\"307\":1,\"313\":1,\"314\":1,\"317\":2,\"343\":1,\"347\":1,\"377\":1,\"386\":1,\"390\":3,\"392\":1,\"406\":2,\"422\":1,\"442\":3,\"445\":1,\"447\":3,\"448\":1,\"451\":1,\"457\":1,\"480\":1,\"481\":1,\"484\":10,\"485\":1,\"487\":2,\"488\":4,\"503\":3,\"504\":1,\"505\":1,\"527\":1,\"528\":1,\"537\":1,\"540\":1,\"541\":4,\"548\":1,\"560\":2,\"568\":3,\"570\":2,\"573\":1,\"576\":2,\"594\":7,\"597\":2,\"598\":1,\"599\":2,\"601\":1,\"605\":1,\"615\":1,\"624\":3,\"665\":5,\"691\":1,\"693\":2,\"694\":3,\"700\":1,\"708\":1,\"714\":1,\"715\":8,\"717\":1,\"718\":1,\"723\":2,\"726\":1,\"729\":1,\"732\":1,\"737\":1,\"738\":1,\"750\":2,\"755\":4,\"767\":1,\"768\":1,\"775\":2,\"787\":4,\"789\":2,\"790\":1,\"791\":2,\"793\":2,\"796\":2,\"798\":3,\"800\":3,\"816\":1,\"842\":1,\"850\":2,\"851\":1,\"878\":1,\"884\":2}}],[\"当存在大量\",{\"1\":{\"810\":1}}],[\"当定时到期\",{\"1\":{\"773\":1}}],[\"当它超过该时刻还没有被\",{\"1\":{\"771\":1}}],[\"当某些消费者僵死\",{\"1\":{\"769\":1}}],[\"当某个\",{\"1\":{\"155\":3}}],[\"当客户端升级或者下线时\",{\"1\":{\"769\":1}}],[\"当重新消费次数超过最大阈值时\",{\"1\":{\"700\":1}}],[\"当中承载\",{\"1\":{\"723\":1}}],[\"当中\",{\"1\":{\"623\":1}}],[\"当中有新的消息存入\",{\"1\":{\"326\":1}}],[\"当发生\",{\"1\":{\"621\":1}}],[\"当启动该服务后它会以\",{\"1\":{\"519\":1}}],[\"当文件变化时\",{\"1\":{\"481\":1}}],[\"当达到上限时说明有过多的异步投递任务还在执行\",{\"1\":{\"453\":1}}],[\"当达到阈值后\",{\"1\":{\"146\":1}}],[\"当投递任务结束时进行一些状态更新\",{\"1\":{\"453\":1}}],[\"当查询某个\",{\"1\":{\"447\":1}}],[\"当用户支付了订单\",{\"1\":{\"441\":1,\"871\":1}}],[\"当用整数列表表示字符串时\",{\"1\":{\"28\":1}}],[\"当消息发送失败后\",{\"1\":{\"754\":1}}],[\"当消息发送到被联邦的\",{\"1\":{\"166\":1}}],[\"当消费失败\",{\"1\":{\"771\":1}}],[\"当消费失败的时候\",{\"1\":{\"568\":1}}],[\"当消费者数量扩大到大于队列数量时\",{\"1\":{\"769\":1}}],[\"当消费者数量很多\",{\"1\":{\"648\":1}}],[\"当消费的\",{\"1\":{\"430\":1}}],[\"当没有用到\",{\"0\":{\"421\":1}}],[\"当超过大小限制的时候需要准备新的文件\",{\"1\":{\"401\":1}}],[\"当磁盘容量达到\",{\"1\":{\"386\":1}}],[\"当磁盘容量告急时\",{\"1\":{\"383\":1}}],[\"当到达每天的删除时间\",{\"1\":{\"384\":1}}],[\"当到达指定的发送时间或者延迟相应时间后\",{\"1\":{\"352\":1}}],[\"当写入\",{\"1\":{\"374\":1}}],[\"当写入的索引数超过阈值\",{\"1\":{\"272\":1}}],[\"当延迟消息被延迟等级处理线程重新投递之后\",{\"1\":{\"354\":1}}],[\"当有\",{\"1\":{\"465\":1}}],[\"当有新消息到达的时候\",{\"1\":{\"345\":1}}],[\"当有数据的时候触发请求\",{\"1\":{\"342\":1}}],[\"当有节点失效时\",{\"1\":{\"206\":1}}],[\"当有节点新增时\",{\"1\":{\"206\":1}}],[\"当远程调用发生异常\",{\"1\":{\"340\":1}}],[\"当解析请求发生异常时\",{\"1\":{\"339\":1,\"693\":1}}],[\"当保存的数据超过上限时\",{\"1\":{\"307\":1}}],[\"当时间满足flushconsumequeuethoroughinterval时\",{\"1\":{\"289\":1}}],[\"当应当保存在该\",{\"1\":{\"285\":1}}],[\"当扫描到新消息被保存到\",{\"1\":{\"276\":1}}],[\"当需要消费这个\",{\"1\":{\"267\":1}}],[\"当结果的\",{\"1\":{\"258\":1}}],[\"当集群达到内存高水位时其他队列会不会收到影响\",{\"1\":{\"235\":1}}],[\"当每个队列都变成仲裁队列\",{\"1\":{\"234\":1}}],[\"当节点重新上线时\",{\"1\":{\"229\":1}}],[\"当生产者发送一条消息\",{\"1\":{\"228\":1}}],[\"当生产者收到队列的所有镜像授予的信用时\",{\"1\":{\"197\":1}}],[\"当主\",{\"1\":{\"553\":1}}],[\"当主副本所在的节点下线\",{\"1\":{\"228\":1}}],[\"当主节点宕机\",{\"1\":{\"181\":1}}],[\"当你有多个镜像队列时\",{\"1\":{\"226\":1}}],[\"当你确实想要终止当前进程时就用它\",{\"1\":{\"43\":1}}],[\"当所有的从队列保存消息之后\",{\"1\":{\"226\":1}}],[\"当内存不足时\",{\"1\":{\"223\":1}}],[\"当内存中保存的消息数量\",{\"1\":{\"223\":1}}],[\"当负载降低时\",{\"1\":{\"223\":1}}],[\"当队列中投递任务满时触发流控\",{\"1\":{\"375\":1}}],[\"当队列负载很高时\",{\"1\":{\"223\":1}}],[\"当队列比较短的时候这通常不是什么问题\",{\"1\":{\"211\":1}}],[\"当检测到前后两个文件中的有效数据可以合并成一个文件\",{\"1\":{\"221\":1}}],[\"当一个索引文件写满后创建新索引文件时调用\",{\"1\":{\"309\":1}}],[\"当一个节点下线\",{\"1\":{\"226\":1}}],[\"当一个文件中都是垃圾数据是可以将这个文件删除\",{\"1\":{\"221\":1}}],[\"当一个新节点被添加到集群中时\",{\"1\":{\"190\":1}}],[\"当然可以\",{\"1\":{\"455\":1}}],[\"当然\",{\"1\":{\"214\":1,\"441\":1,\"544\":1,\"871\":1}}],[\"当镜像队列发生故障时\",{\"1\":{\"198\":1}}],[\"当网络恢复后\",{\"1\":{\"192\":1}}],[\"当新镜像加入时\",{\"1\":{\"191\":1}}],[\"当unblock\",{\"1\":{\"160\":1}}],[\"当morecreditafter条消息被ack\",{\"1\":{\"159\":1}}],[\"当这个节点故障\",{\"1\":{\"181\":1}}],[\"当这个\",{\"1\":{\"157\":1}}],[\"当credit\",{\"1\":{\"157\":1}}],[\"当rabbit\",{\"1\":{\"157\":1,\"159\":2}}],[\"当累计接收并\",{\"1\":{\"154\":1}}],[\"当\",{\"1\":{\"154\":1,\"160\":1,\"207\":2,\"210\":1,\"282\":1,\"329\":1,\"771\":1,\"820\":1}}],[\"当进程字典中的信用值达到\",{\"1\":{\"158\":1}}],[\"当进程字典中的信用值降为0时\",{\"1\":{\"154\":1}}],[\"当进程的信用值将为1时\",{\"1\":{\"152\":1}}],[\"当进程处理一条消息并且发给下游进程时\",{\"1\":{\"152\":1}}],[\"当分区数达到\",{\"1\":{\"135\":1}}],[\"当前痛点\",{\"0\":{\"810\":1}}],[\"当前处理消息数量大于1000\",{\"1\":{\"690\":1}}],[\"当前消费消息超过100mb\",{\"1\":{\"690\":1}}],[\"当前消费组中所有的消费者id\",{\"1\":{\"663\":1}}],[\"当前消费者id\",{\"1\":{\"663\":1}}],[\"当前topic下\",{\"1\":{\"663\":1}}],[\"当前使用\",{\"1\":{\"563\":1}}],[\"当前为字符串拼接模式\",{\"1\":{\"541\":1}}],[\"当前只有一个默认实现\",{\"1\":{\"510\":1,\"516\":1}}],[\"当前支持多配置文件\",{\"1\":{\"503\":1}}],[\"当前没有注册自定义\",{\"1\":{\"484\":1}}],[\"当前不会用到\",{\"1\":{\"464\":1}}],[\"当前不满足要求\",{\"1\":{\"345\":1}}],[\"当前的偏移量\",{\"1\":{\"814\":1}}],[\"当前的逻辑偏移量\",{\"1\":{\"814\":1}}],[\"当前的做法是在投递任务状态更新线程扫描到状态为失败的任务时就开始重新投递该消息\",{\"1\":{\"454\":1}}],[\"当前的最新逻辑偏移量\",{\"1\":{\"285\":1}}],[\"当前各大消息队列和云厂商都对定时消息和延迟消息有一定程度上的支持\",{\"1\":{\"442\":1}}],[\"当前仍未合入\",{\"1\":{\"433\":1}}],[\"当前\",{\"1\":{\"414\":1}}],[\"当前默认没有使用\",{\"1\":{\"413\":1}}],[\"当前已经使用的索引条目个数\",{\"1\":{\"307\":1}}],[\"当前分支不可能发生\",{\"1\":{\"291\":1}}],[\"当前consumequeue被写过的位置\",{\"1\":{\"285\":1}}],[\"当前consumequeue被写过的物理offset\",{\"1\":{\"285\":1}}],[\"当前版成为旧版\",{\"1\":{\"57\":1}}],[\"当前版和旧版\",{\"1\":{\"57\":1}}],[\"当前最新的版本为\",{\"1\":{\"8\":1}}],[\"当函数的参数数量能预先知道时\",{\"1\":{\"50\":1}}],[\"当遇到内部错误或显式调用时\",{\"1\":{\"43\":1}}],[\"当且仅当i\",{\"1\":{\"819\":1}}],[\"当且仅当其中任意一个\",{\"1\":{\"36\":1}}],[\"当且仅当每个\",{\"1\":{\"36\":1}}],[\"当关联一个值与一个变量时\",{\"1\":{\"23\":1}}],[\"当对一个程序的一小部分代码或者一个函数进行基准测试时\",{\"1\":{\"3\":1}}],[\"之一段时间之后才会被投递\",{\"1\":{\"872\":1}}],[\"之所以不直接存\",{\"1\":{\"839\":1}}],[\"之间使用逗号分割\",{\"1\":{\"807\":1}}],[\"之间分布不均匀的情况\",{\"1\":{\"617\":1}}],[\"之间的区别\",{\"1\":{\"248\":1}}],[\"之外另一个需要部署的服务\",{\"1\":{\"461\":1}}],[\"之后每次重试按照最大延迟等级对应的时间间隔\",{\"1\":{\"761\":1}}],[\"之后会被重试\",{\"1\":{\"718\":1}}],[\"之后会根据存储的消息构建消息的索引文件\",{\"1\":{\"359\":1}}],[\"之后默认每\",{\"1\":{\"389\":1}}],[\"之后的文件如果引用计数大于\",{\"1\":{\"386\":1}}],[\"之后的版本被废弃\",{\"1\":{\"469\":1}}],[\"之后的版本也将\",{\"1\":{\"462\":1}}],[\"之后的版本\",{\"1\":{\"181\":1}}],[\"之后的版本已经原生支持\",{\"1\":{\"8\":1}}],[\"之后\",{\"1\":{\"121\":1,\"249\":1,\"270\":1,\"301\":1,\"595\":1}}],[\"之前没有锁定\",{\"1\":{\"742\":1}}],[\"之前的消费进度\",{\"1\":{\"798\":1}}],[\"之前的所有\",{\"1\":{\"392\":1}}],[\"之前的版本需要引入依赖\",{\"1\":{\"8\":1}}],[\"之前默认为\",{\"1\":{\"255\":1}}],[\"之前\",{\"1\":{\"41\":1,\"245\":1,\"768\":1,\"814\":1}}],[\"添加所有拉取的消息的偏移量与起始偏移量的差值\",{\"1\":{\"791\":1}}],[\"添加假的消息\",{\"1\":{\"790\":1}}],[\"添加到内存\",{\"1\":{\"779\":1}}],[\"添加到请求的扩展属性中\",{\"1\":{\"515\":1}}],[\"添加起始偏移量和所有\",{\"1\":{\"779\":1}}],[\"添加成功\",{\"1\":{\"664\":1,\"744\":1}}],[\"添加处理队列并创建\",{\"1\":{\"657\":1}}],[\"添加定时任务\",{\"1\":{\"480\":1}}],[\"添加一个索引到索引文件\",{\"1\":{\"310\":1}}],[\"添加测试\",{\"1\":{\"30\":1}}],[\"添加数据的性能\",{\"1\":{\"9\":1}}],[\"添加\",{\"1\":{\"7\":1,\"53\":1,\"146\":1,\"600\":1,\"664\":1,\"744\":1,\"790\":1,\"791\":1,\"800\":1}}],[\"07\",{\"1\":{\"599\":7}}],[\"0e80d1d53112\",{\"1\":{\"599\":1}}],[\"04\",{\"1\":{\"595\":2}}],[\"01s\",{\"1\":{\"381\":1}}],[\"0l\",{\"1\":{\"364\":1,\"690\":1}}],[\"0来判断是否是定时消息\",{\"1\":{\"359\":1,\"363\":1}}],[\"0版本相比\",{\"1\":{\"240\":1}}],[\"0v5\",{\"1\":{\"176\":10}}],[\"06\",{\"1\":{\"122\":1,\"528\":1}}],[\"03\",{\"1\":{\"115\":1,\"225\":1}}],[\"0>\",{\"1\":{\"80\":2}}],[\"08jmh入门\",{\"1\":{\"15\":1}}],[\"024\",{\"1\":{\"11\":1}}],[\"000l\",{\"1\":{\"873\":2}}],[\"000\",{\"1\":{\"433\":1,\"768\":1}}],[\"00000000000000007280\",{\"1\":{\"269\":1}}],[\"00000000000000006240\",{\"1\":{\"269\":1}}],[\"00000000000000005200\",{\"1\":{\"269\":1}}],[\"00000000000000004160\",{\"1\":{\"269\":1}}],[\"00000000000000003120\",{\"1\":{\"269\":1}}],[\"00000000000000002080\",{\"1\":{\"269\":1}}],[\"00000000000000001040\",{\"1\":{\"269\":1}}],[\"00000000000000000000\",{\"1\":{\"269\":2}}],[\"00000000000000307200\",{\"1\":{\"269\":1}}],[\"00000000000000204800\",{\"1\":{\"269\":1}}],[\"00000000000000102400\",{\"1\":{\"269\":1}}],[\"00101010\",{\"1\":{\"65\":1}}],[\"00\",{\"1\":{\"11\":8}}],[\"0\",{\"0\":{\"763\":1,\"869\":1},\"1\":{\"7\":1,\"11\":2,\"24\":1,\"27\":1,\"30\":2,\"31\":3,\"33\":1,\"37\":1,\"39\":1,\"42\":1,\"45\":4,\"46\":1,\"65\":1,\"98\":1,\"103\":1,\"105\":2,\"111\":1,\"116\":3,\"157\":2,\"158\":1,\"159\":3,\"176\":24,\"186\":1,\"221\":1,\"257\":10,\"258\":1,\"262\":5,\"282\":2,\"285\":3,\"287\":2,\"289\":6,\"291\":7,\"293\":1,\"313\":5,\"314\":6,\"316\":2,\"317\":5,\"343\":1,\"361\":1,\"363\":1,\"365\":3,\"380\":2,\"386\":1,\"390\":8,\"391\":2,\"392\":2,\"400\":1,\"402\":7,\"410\":5,\"414\":4,\"435\":1,\"442\":2,\"447\":1,\"451\":3,\"452\":5,\"462\":1,\"472\":2,\"480\":1,\"484\":9,\"485\":5,\"487\":4,\"488\":8,\"490\":1,\"492\":1,\"496\":1,\"503\":3,\"504\":3,\"505\":2,\"510\":1,\"514\":2,\"516\":1,\"518\":5,\"519\":3,\"523\":1,\"528\":2,\"537\":2,\"540\":1,\"541\":4,\"570\":2,\"572\":7,\"573\":2,\"576\":2,\"595\":26,\"597\":8,\"598\":2,\"599\":20,\"600\":3,\"601\":2,\"615\":2,\"625\":1,\"651\":1,\"664\":1,\"665\":1,\"690\":4,\"691\":1,\"693\":4,\"694\":14,\"695\":2,\"714\":2,\"715\":1,\"717\":1,\"718\":10,\"744\":1,\"749\":2,\"765\":1,\"769\":2,\"775\":1,\"777\":1,\"787\":3,\"789\":7,\"797\":6,\"798\":8,\"800\":3,\"801\":1,\"808\":2,\"813\":1,\"815\":1,\"816\":1,\"817\":5,\"819\":1,\"826\":1,\"829\":1,\"830\":1,\"850\":3,\"884\":1}}],[\"dynamic\",{\"1\":{\"854\":1}}],[\"dynamically\",{\"1\":{\"481\":1}}],[\"dleger\",{\"1\":{\"601\":1}}],[\"dledger\",{\"0\":{\"373\":1,\"588\":1,\"599\":1,\"601\":1},\"1\":{\"136\":1,\"370\":2,\"373\":3,\"594\":1,\"599\":8,\"600\":14,\"601\":3,\"884\":1}}],[\"dlq\",{\"1\":{\"576\":1,\"620\":1,\"708\":1,\"718\":3}}],[\"dns\",{\"0\":{\"408\":1},\"1\":{\"406\":1,\"408\":3}}],[\"drwxrwxr\",{\"1\":{\"594\":6}}],[\"drain\",{\"1\":{\"436\":2}}],[\"drawio\",{\"1\":{\"276\":2,\"326\":2,\"332\":2}}],[\"dropped\",{\"1\":{\"690\":1,\"715\":2,\"750\":4}}],[\"drop\",{\"1\":{\"365\":1,\"715\":1}}],[\"driver\",{\"1\":{\"130\":1}}],[\"dpkg\",{\"1\":{\"176\":4,\"178\":3}}],[\"dbg\",{\"1\":{\"111\":5}}],[\"during\",{\"1\":{\"570\":1}}],[\"durable\",{\"1\":{\"217\":1}}],[\"dubbo\",{\"1\":{\"123\":1,\"461\":1}}],[\"dumping\",{\"1\":{\"109\":1}}],[\"dump\",{\"1\":{\"109\":1}}],[\"duplicated\",{\"1\":{\"240\":1,\"251\":1,\"406\":1,\"421\":1}}],[\"duplicate\",{\"1\":{\"98\":3,\"240\":1,\"567\":1,\"642\":1,\"790\":1}}],[\"d3\",{\"1\":{\"103\":2}}],[\"d2\",{\"1\":{\"103\":2}}],[\"d1\",{\"1\":{\"103\":2}}],[\"dashboard\",{\"0\":{\"529\":1,\"596\":1,\"597\":1,\"598\":1,\"601\":1},\"1\":{\"529\":1,\"596\":1,\"597\":11,\"598\":6,\"601\":5}}],[\"data=\",{\"1\":{\"851\":1}}],[\"dataconverter\",{\"1\":{\"793\":1,\"797\":2,\"798\":3,\"800\":1}}],[\"data1\",{\"1\":{\"595\":5}}],[\"datatopic\",{\"1\":{\"541\":3}}],[\"dataversions\",{\"1\":{\"518\":2}}],[\"dataversionmap是个map类型\",{\"1\":{\"517\":1}}],[\"dataversionmap\",{\"1\":{\"517\":2,\"518\":6}}],[\"dataversion>\",{\"1\":{\"517\":1,\"518\":1}}],[\"dataversion\",{\"1\":{\"472\":1,\"487\":2,\"518\":8}}],[\"database\",{\"1\":{\"103\":2,\"176\":1,\"178\":1}}],[\"data\",{\"1\":{\"91\":1,\"492\":1,\"518\":3,\"539\":1,\"541\":1,\"594\":1,\"595\":1,\"600\":9,\"693\":6,\"694\":1,\"695\":1,\"851\":1}}],[\"dartifactid=test\",{\"1\":{\"7\":1}}],[\"darchetypeartifactid=jmh\",{\"1\":{\"7\":1}}],[\"darchetypegroupid=org\",{\"1\":{\"7\":1}}],[\"doloadbalance\",{\"0\":{\"786\":1},\"1\":{\"775\":1,\"786\":1}}],[\"does\",{\"1\":{\"691\":1,\"693\":2,\"786\":2}}],[\"dorebalance\",{\"0\":{\"662\":1},\"1\":{\"624\":1,\"654\":1,\"657\":2,\"660\":1,\"662\":1,\"663\":3,\"664\":7,\"744\":5}}],[\"doreput\",{\"0\":{\"282\":1,\"347\":1},\"1\":{\"276\":1,\"281\":1,\"282\":1,\"326\":1,\"332\":1,\"334\":1,\"335\":1,\"336\":1,\"347\":2}}],[\"dobeforerpchooks\",{\"1\":{\"514\":2}}],[\"dobeforerequest\",{\"1\":{\"514\":2,\"515\":1,\"516\":1}}],[\"doafterresponse\",{\"1\":{\"514\":1,\"516\":1}}],[\"doafterrequest\",{\"1\":{\"514\":1}}],[\"doafterrpchooks\",{\"1\":{\"514\":2}}],[\"doappend\",{\"1\":{\"257\":4,\"258\":1,\"285\":2}}],[\"doflush\",{\"0\":{\"289\":1},\"1\":{\"289\":1}}],[\"doflow\",{\"1\":{\"157\":1}}],[\"dodispatchlmqqueue\",{\"1\":{\"817\":2}}],[\"dodispatch\",{\"0\":{\"283\":1},\"1\":{\"282\":1,\"283\":1,\"347\":1}}],[\"downloads\",{\"1\":{\"175\":1}}],[\"downstream\",{\"0\":{\"171\":1},\"1\":{\"163\":2}}],[\"dose\",{\"1\":{\"516\":2}}],[\"dos\",{\"1\":{\"138\":1}}],[\"docker\",{\"0\":{\"588\":2,\"592\":1,\"594\":1,\"595\":1,\"596\":1,\"597\":1,\"598\":2,\"599\":1,\"603\":1,\"604\":1},\"1\":{\"588\":1,\"589\":4,\"590\":5,\"591\":1,\"592\":2,\"593\":3,\"594\":5,\"595\":16,\"596\":1,\"597\":3,\"598\":3,\"599\":14,\"600\":4,\"601\":4,\"603\":1,\"604\":1,\"884\":2}}],[\"docs\",{\"1\":{\"545\":1}}],[\"doconfigure\",{\"1\":{\"480\":1}}],[\"doc\",{\"1\":{\"122\":2,\"212\":1}}],[\"documentation\",{\"1\":{\"21\":3}}],[\"doors\",{\"1\":{\"103\":2}}],[\"do\",{\"1\":{\"45\":1,\"46\":2,\"103\":6,\"157\":3,\"176\":1,\"516\":1,\"690\":3}}],[\"donext\",{\"1\":{\"282\":3}}],[\"doneopoffset\",{\"1\":{\"242\":1}}],[\"done\",{\"1\":{\"41\":3,\"176\":3}}],[\"dont\",{\"1\":{\"11\":1}}],[\"dog\",{\"1\":{\"31\":2,\"36\":4}}],[\"doublecanonicalname2\",{\"1\":{\"262\":1}}],[\"doublecanonicalname1\",{\"1\":{\"262\":1}}],[\"double\",{\"1\":{\"31\":2,\"262\":1,\"797\":1}}],[\"d\",{\"0\":{\"418\":1},\"1\":{\"21\":1,\"262\":3,\"406\":1,\"410\":1,\"411\":2,\"520\":1,\"597\":1,\"600\":3,\"601\":1,\"693\":2}}],[\"different\",{\"1\":{\"406\":1,\"425\":1,\"693\":2}}],[\"diff\",{\"1\":{\"285\":2,\"307\":1,\"694\":2}}],[\"diagrams\",{\"1\":{\"276\":1,\"326\":1,\"332\":1}}],[\"dict\",{\"1\":{\"157\":1}}],[\"dictionary\",{\"1\":{\"67\":1,\"157\":1,\"160\":1}}],[\"div\",{\"1\":{\"24\":2}}],[\"directly\",{\"1\":{\"768\":1}}],[\"directbuffer\",{\"1\":{\"402\":1}}],[\"directories\",{\"1\":{\"176\":1,\"178\":1}}],[\"directory\",{\"1\":{\"21\":4,\"599\":1}}],[\"direct\",{\"1\":{\"117\":1,\"820\":1}}],[\"dir\",{\"1\":{\"21\":2,\"73\":4,\"102\":1,\"313\":2}}],[\"discuss\",{\"1\":{\"819\":1}}],[\"discardcount\",{\"1\":{\"541\":1}}],[\"discard\",{\"1\":{\"365\":1,\"380\":1,\"480\":1,\"541\":1}}],[\"disruptor\",{\"1\":{\"585\":1}}],[\"dispatchtoconsume\",{\"1\":{\"695\":2,\"714\":2,\"749\":2}}],[\"dispatchpullrequest\",{\"1\":{\"654\":1,\"657\":1,\"664\":1,\"744\":1}}],[\"dispatchrequest\",{\"1\":{\"282\":14,\"283\":1,\"284\":7,\"309\":1,\"314\":5,\"347\":8,\"817\":7,\"851\":2}}],[\"dispatcherid\",{\"1\":{\"541\":1}}],[\"dispatcherlist\",{\"1\":{\"283\":1}}],[\"dispatcher\",{\"1\":{\"276\":1,\"283\":2,\"539\":3}}],[\"dispatch\",{\"0\":{\"284\":1},\"1\":{\"276\":2,\"283\":1,\"284\":1,\"807\":3,\"816\":3,\"817\":4,\"851\":1}}],[\"display\",{\"1\":{\"21\":4}}],[\"diskfallrecorded\",{\"1\":{\"694\":2}}],[\"disk\",{\"1\":{\"97\":1,\"176\":1,\"223\":5,\"390\":1,\"402\":1,\"793\":1}}],[\"distribution\",{\"1\":{\"11\":2}}],[\"disabled\",{\"1\":{\"481\":1}}],[\"disable\",{\"1\":{\"11\":1}}],[\"dinteractivemode=false\",{\"1\":{\"7\":1}}],[\"djmh\",{\"1\":{\"11\":1}}],[\"decrementandget\",{\"1\":{\"797\":2}}],[\"decodeproperties\",{\"1\":{\"852\":1}}],[\"decodes\",{\"1\":{\"848\":1}}],[\"decodesendmessageheaderv2\",{\"1\":{\"262\":1}}],[\"decode\",{\"1\":{\"406\":1,\"409\":1,\"411\":1,\"852\":1}}],[\"decodecommandcustomheader\",{\"1\":{\"262\":1,\"410\":1,\"493\":1,\"693\":1,\"718\":1,\"793\":1}}],[\"develop\",{\"1\":{\"545\":1}}],[\"developer\",{\"1\":{\"124\":1}}],[\"deny\",{\"1\":{\"498\":1,\"503\":3}}],[\"debug\",{\"1\":{\"240\":1,\"242\":1,\"693\":1,\"851\":1,\"852\":3}}],[\"deb\",{\"0\":{\"176\":1},\"1\":{\"158\":8,\"176\":3,\"177\":1,\"178\":4}}],[\"deprecated\",{\"1\":{\"656\":1,\"820\":1}}],[\"dependencies\",{\"1\":{\"176\":1}}],[\"dependency\",{\"1\":{\"176\":3,\"178\":1}}],[\"dependency>\",{\"1\":{\"8\":2}}],[\"depends\",{\"1\":{\"176\":4,\"178\":1,\"598\":1}}],[\"depiction\",{\"1\":{\"147\":2,\"154\":2}}],[\"delegated\",{\"1\":{\"816\":1}}],[\"deleting\",{\"1\":{\"390\":1}}],[\"deletewhen\",{\"1\":{\"595\":2}}],[\"deletelogicsfilesinterval\",{\"1\":{\"391\":3,\"392\":1}}],[\"deletefilesinterval\",{\"1\":{\"390\":4}}],[\"deletephysicfilesinterval\",{\"1\":{\"390\":2}}],[\"deletecount++\",{\"1\":{\"390\":1}}],[\"deletecount\",{\"1\":{\"390\":5,\"391\":2}}],[\"deleteexpiredfilebytime\",{\"1\":{\"390\":2}}],[\"deleteexpiredfiles\",{\"1\":{\"390\":1,\"391\":1,\"392\":1}}],[\"deleteexpiredfile\",{\"1\":{\"315\":1,\"390\":3,\"391\":1,\"392\":3}}],[\"delete\",{\"1\":{\"98\":1,\"103\":1,\"382\":1,\"390\":3}}],[\"delayleveltable\",{\"1\":{\"364\":1}}],[\"delaylevel2queueid\",{\"1\":{\"363\":1,\"365\":1,\"380\":1}}],[\"delaylevel\",{\"1\":{\"357\":1,\"365\":9,\"380\":3,\"381\":3,\"717\":5,\"718\":5}}],[\"delay\",{\"1\":{\"355\":1,\"363\":1,\"364\":1,\"365\":3,\"380\":5,\"381\":1,\"573\":2,\"690\":4,\"883\":3}}],[\"delta三种状态之一\",{\"1\":{\"223\":1}}],[\"delta队列是消息按序存盘后的一种逻辑队列\",{\"1\":{\"223\":1}}],[\"delta\",{\"1\":{\"223\":5}}],[\"delivertime\",{\"1\":{\"798\":3}}],[\"delivertimestamp\",{\"1\":{\"365\":2,\"380\":2}}],[\"delivermessage\",{\"1\":{\"380\":1}}],[\"deliver\",{\"1\":{\"380\":2,\"807\":1}}],[\"deliversuc\",{\"1\":{\"380\":4}}],[\"deliverpendingtable\",{\"1\":{\"377\":1,\"380\":1,\"381\":1}}],[\"deliverexecutorservice\",{\"1\":{\"377\":1}}],[\"deliverdelayedmessagetimertask\",{\"0\":{\"361\":1,\"365\":1},\"1\":{\"361\":1,\"364\":1,\"365\":5,\"377\":1}}],[\"deliverymode\",{\"1\":{\"218\":1}}],[\"delivery\",{\"1\":{\"126\":1,\"363\":1}}],[\"deliberately\",{\"1\":{\"157\":1}}],[\"deliberate\",{\"1\":{\"106\":2}}],[\"description\",{\"1\":{\"593\":1}}],[\"destroyed\",{\"1\":{\"492\":7}}],[\"destroymapedfileintervalforcibly\",{\"1\":{\"390\":2}}],[\"destroy\",{\"1\":{\"313\":1,\"390\":2,\"392\":1}}],[\"desired\",{\"1\":{\"287\":1,\"694\":1}}],[\"design\",{\"1\":{\"103\":8,\"294\":1}}],[\"desktop\",{\"1\":{\"105\":5}}],[\"determines\",{\"1\":{\"257\":1}}],[\"detectfastjson\",{\"1\":{\"480\":1}}],[\"detection\",{\"1\":{\"130\":2}}],[\"detected\",{\"1\":{\"11\":1}}],[\"dets\",{\"0\":{\"97\":1},\"1\":{\"97\":2,\"98\":1}}],[\"demo=new\",{\"1\":{\"116\":1}}],[\"demo\",{\"1\":{\"103\":4,\"116\":2,\"122\":2}}],[\"demo2\",{\"1\":{\"45\":4}}],[\"demo1\",{\"1\":{\"44\":2}}],[\"def\",{\"1\":{\"828\":2}}],[\"definition\",{\"1\":{\"185\":1,\"186\":1,\"187\":1}}],[\"defined\",{\"1\":{\"518\":1}}],[\"define\",{\"0\":{\"63\":1},\"1\":{\"21\":1,\"63\":3,\"157\":1}}],[\"deferred列表\",{\"1\":{\"160\":1}}],[\"deferred列表中保存的所有消息\",{\"1\":{\"160\":1}}],[\"deferred\",{\"1\":{\"159\":3,\"160\":1}}],[\"defaultconsumeridschangelistener\",{\"1\":{\"850\":1}}],[\"defaultcluster\",{\"1\":{\"484\":2,\"485\":1,\"486\":1,\"488\":2,\"595\":2}}],[\"defaultlitepullconsumer\",{\"1\":{\"656\":1}}],[\"defaultxxxxconsumer\",{\"1\":{\"629\":2}}],[\"defaultaclfile\",{\"1\":{\"518\":5,\"519\":4}}],[\"defaultacldir\",{\"1\":{\"518\":1,\"519\":1}}],[\"defaultappendmessagecallback\",{\"1\":{\"257\":1,\"258\":1}}],[\"defaultgroupperm\",{\"1\":{\"503\":2}}],[\"defaultrequestprocessor\",{\"1\":{\"464\":1,\"473\":1,\"477\":1,\"493\":1}}],[\"defaultmqadminext\",{\"1\":{\"768\":2}}],[\"defaultmqxxxxconsumer\",{\"1\":{\"630\":1,\"631\":1,\"632\":1,\"638\":2}}],[\"defaultmqxxxxconsumerimpl\",{\"1\":{\"629\":3,\"630\":1,\"631\":3,\"632\":2,\"638\":4}}],[\"defaultmqpushconsumerimpl\",{\"0\":{\"679\":1,\"690\":1},\"1\":{\"539\":2,\"541\":1,\"639\":1,\"640\":2,\"665\":6,\"675\":1,\"679\":1,\"695\":17,\"708\":1,\"715\":7,\"717\":2,\"745\":4,\"749\":9,\"750\":9}}],[\"defaultmqpushconsumer\",{\"1\":{\"505\":2,\"527\":2,\"539\":1,\"629\":1,\"640\":1,\"642\":20,\"656\":1,\"690\":10,\"695\":2,\"714\":1,\"715\":5,\"717\":5,\"749\":2,\"750\":5,\"768\":2}}],[\"defaultmqpullconsumer\",{\"1\":{\"325\":1,\"629\":1,\"656\":1,\"808\":14}}],[\"defaultmqproducerimpl\",{\"0\":{\"567\":1,\"642\":1},\"1\":{\"541\":1,\"556\":4,\"557\":3,\"559\":1,\"562\":1,\"567\":1,\"570\":1,\"571\":1,\"573\":1,\"642\":1}}],[\"defaultmqproducer\",{\"1\":{\"504\":2,\"526\":2,\"541\":1,\"556\":3,\"557\":1,\"567\":8,\"568\":1,\"570\":4,\"571\":1,\"573\":10,\"643\":1,\"755\":4,\"807\":2}}],[\"defaultmessagestore\",{\"0\":{\"283\":1,\"287\":1,\"331\":1,\"336\":1,\"346\":1,\"684\":1,\"694\":1},\"1\":{\"258\":1,\"276\":1,\"277\":1,\"280\":1,\"282\":7,\"284\":1,\"286\":1,\"289\":6,\"313\":1,\"314\":1,\"316\":2,\"347\":7,\"357\":1,\"363\":2,\"364\":1,\"365\":3,\"380\":4,\"381\":1,\"389\":5,\"390\":5,\"391\":3,\"392\":3,\"581\":2,\"816\":1,\"838\":1}}],[\"defaulttopicperm\",{\"1\":{\"503\":2}}],[\"defaulttopicqueuenums\",{\"1\":{\"262\":1}}],[\"defaulttopic\",{\"1\":{\"262\":1}}],[\"default\",{\"1\":{\"41\":1,\"117\":1,\"151\":1,\"157\":2,\"240\":1,\"252\":1,\"504\":1,\"520\":3,\"526\":1,\"567\":1,\"568\":1,\"570\":1,\"573\":1,\"595\":1,\"642\":2,\"643\":1,\"663\":1,\"664\":1,\"692\":1,\"693\":3,\"695\":1,\"715\":2,\"718\":1,\"744\":1,\"786\":1,\"807\":1,\"819\":5,\"826\":1,\"829\":1,\"850\":1}}],[\"dversion=1\",{\"1\":{\"7\":1}}],[\"dgroupid=org\",{\"1\":{\"7\":1}}],[\"guava\",{\"1\":{\"843\":1}}],[\"guaranteed\",{\"0\":{\"206\":1}}],[\"guard2\",{\"1\":{\"37\":1,\"38\":2,\"79\":1,\"82\":1}}],[\"guard1\",{\"1\":{\"37\":2,\"38\":3,\"79\":1,\"82\":1}}],[\"guardexprn`\",{\"1\":{\"36\":1}}],[\"guardexpr2\",{\"1\":{\"36\":1}}],[\"guard\",{\"1\":{\"36\":10}}],[\"global\",{\"1\":{\"520\":1}}],[\"globalwhiteremoteaddressstrategylist\",{\"1\":{\"518\":5}}],[\"globalwhiteremoteaddressstrategy用来缓存所有acl配置文件的全局白名单\",{\"1\":{\"517\":1}}],[\"globalwhiteremoteaddressstrategymap是个map类型\",{\"1\":{\"517\":1}}],[\"globalwhiteremoteaddressstrategymap\",{\"1\":{\"517\":2,\"518\":4}}],[\"globalwhiteremoteaddressstrategy\",{\"1\":{\"517\":2,\"518\":4,\"520\":1}}],[\"globalwhiteremoteaddresseslist\",{\"1\":{\"518\":5}}],[\"globalwhiteremoteaddresses\",{\"1\":{\"503\":3,\"518\":3}}],[\"globalctxmanager\",{\"1\":{\"116\":2}}],[\"gc\",{\"1\":{\"402\":1,\"600\":1}}],[\"git\",{\"1\":{\"370\":1,\"590\":3}}],[\"gitbook\",{\"1\":{\"294\":1}}],[\"githubusercontent\",{\"1\":{\"276\":1,\"326\":1,\"332\":1}}],[\"github\",{\"1\":{\"1\":1,\"16\":1,\"18\":1,\"113\":1,\"118\":1,\"122\":1,\"125\":1,\"137\":1,\"142\":1,\"162\":1,\"174\":1,\"178\":3,\"180\":1,\"213\":1,\"225\":1,\"239\":1,\"264\":1,\"295\":1,\"319\":1,\"350\":1,\"369\":1,\"372\":1,\"382\":1,\"393\":1,\"405\":1,\"438\":1,\"459\":1,\"495\":1,\"522\":1,\"543\":1,\"545\":1,\"573\":1,\"578\":1,\"588\":1,\"590\":1,\"605\":1,\"626\":1,\"644\":1,\"666\":1,\"696\":1,\"722\":1,\"751\":1,\"763\":1,\"802\":1,\"804\":1,\"817\":1,\"819\":1,\"821\":1,\"854\":1,\"855\":1,\"859\":1,\"869\":1}}],[\"gamma\",{\"1\":{\"223\":4}}],[\"garbage\",{\"1\":{\"221\":1}}],[\"gotchas\",{\"1\":{\"212\":1}}],[\"gm\",{\"0\":{\"206\":1},\"1\":{\"201\":1,\"205\":2,\"206\":5}}],[\"gtk3\",{\"1\":{\"176\":4}}],[\"grpc\",{\"1\":{\"615\":1,\"769\":1}}],[\"greatly\",{\"1\":{\"406\":1,\"433\":1}}],[\"greater\",{\"1\":{\"406\":1,\"426\":1,\"790\":1}}],[\"graph\",{\"1\":{\"406\":1}}],[\"gradually\",{\"1\":{\"381\":1}}],[\"grant\",{\"1\":{\"159\":2}}],[\"group2\",{\"1\":{\"755\":1}}],[\"group1\",{\"1\":{\"755\":1}}],[\"groupvalue\",{\"1\":{\"742\":6}}],[\"groupid=\",{\"1\":{\"693\":2}}],[\"groupid>\",{\"1\":{\"8\":2}}],[\"group=\",{\"1\":{\"663\":1,\"690\":1,\"693\":1,\"694\":1,\"715\":1}}],[\"group=权限\",{\"1\":{\"503\":1}}],[\"groupname\",{\"1\":{\"537\":1,\"720\":3,\"767\":1}}],[\"groupc=sub\",{\"1\":{\"503\":1}}],[\"groupcommitservice\",{\"1\":{\"240\":1,\"243\":1}}],[\"groupb=pub|sub\",{\"1\":{\"503\":1}}],[\"groupa=deny\",{\"1\":{\"503\":1}}],[\"groupperms\",{\"1\":{\"503\":2}}],[\"grouptransferservice\",{\"1\":{\"244\":1}}],[\"group\",{\"0\":{\"424\":1},\"1\":{\"206\":1,\"262\":1,\"277\":1,\"287\":3,\"406\":1,\"410\":1,\"424\":2,\"503\":1,\"541\":1,\"567\":3,\"573\":1,\"642\":2,\"662\":1,\"663\":1,\"693\":15,\"694\":5,\"695\":1,\"715\":2,\"717\":1,\"718\":5,\"720\":1,\"721\":5,\"732\":1,\"742\":6,\"750\":2,\"767\":3,\"768\":4,\"786\":5,\"790\":1,\"798\":1,\"799\":1,\"800\":1,\"807\":1,\"837\":1,\"850\":4}}],[\"g\",{\"0\":{\"425\":1},\"1\":{\"140\":1,\"262\":3,\"406\":1,\"410\":1,\"599\":1,\"767\":2,\"768\":1}}],[\"gn`\",{\"1\":{\"36\":1}}],[\"g2\",{\"1\":{\"36\":1}}],[\"gensortlist\",{\"1\":{\"799\":1}}],[\"genackuniqueid\",{\"1\":{\"793\":1}}],[\"gen\",{\"1\":{\"157\":1}}],[\"generating\",{\"1\":{\"573\":1}}],[\"generation\",{\"1\":{\"240\":3,\"256\":3}}],[\"generator\",{\"1\":{\"8\":1,\"34\":1}}],[\"generateoffsetmovedevent\",{\"1\":{\"693\":1}}],[\"generate\",{\"1\":{\"7\":1,\"21\":1,\"43\":7,\"44\":1,\"45\":2,\"843\":1,\"850\":1}}],[\"getq\",{\"1\":{\"795\":1}}],[\"getqueueoffset\",{\"1\":{\"339\":1,\"693\":8,\"695\":1,\"749\":1,\"798\":3,\"800\":1}}],[\"getqueueidbybroker\",{\"1\":{\"572\":1}}],[\"getqueueid\",{\"1\":{\"257\":2,\"282\":1,\"284\":1,\"339\":1,\"347\":1,\"363\":2,\"365\":1,\"380\":2,\"573\":1,\"576\":1,\"691\":1,\"693\":11,\"718\":2,\"720\":1,\"789\":3,\"793\":1,\"796\":1,\"798\":5,\"800\":2,\"816\":1,\"817\":1,\"851\":1}}],[\"getgroup\",{\"1\":{\"718\":6}}],[\"getgroupname\",{\"1\":{\"540\":1}}],[\"getgetmessagetimestotalmiss\",{\"1\":{\"694\":1}}],[\"getgetmessagetimestotalfound\",{\"1\":{\"694\":1}}],[\"getgetmessagetransferedmsgcount\",{\"1\":{\"694\":1}}],[\"getwhichbrokerwhenconsumeslowly\",{\"1\":{\"693\":2}}],[\"getwrotebytes\",{\"1\":{\"718\":2}}],[\"getwroteposition\",{\"1\":{\"285\":3}}],[\"getwritequeuenums\",{\"1\":{\"576\":1}}],[\"getoriginmsgid\",{\"1\":{\"718\":1}}],[\"getoriginmessageid\",{\"1\":{\"717\":1,\"718\":1}}],[\"getorcreatemqclientinstance\",{\"1\":{\"567\":1,\"642\":1}}],[\"getoffset\",{\"1\":{\"718\":2,\"793\":1}}],[\"getoffsetnew\",{\"1\":{\"693\":1}}],[\"getoffsetrequest\",{\"1\":{\"693\":1}}],[\"getoffsetstore\",{\"1\":{\"642\":2,\"715\":1,\"745\":2}}],[\"getoptionvalue\",{\"1\":{\"480\":1}}],[\"getopaque\",{\"1\":{\"340\":1,\"414\":1,\"693\":1,\"793\":1}}],[\"getjsonarray\",{\"1\":{\"518\":3}}],[\"getyamldataobject\",{\"1\":{\"518\":1}}],[\"getandincrement\",{\"1\":{\"789\":1}}],[\"getandchecknotnull\",{\"1\":{\"411\":4}}],[\"getandcreatelastindexfile\",{\"1\":{\"309\":2,\"313\":2}}],[\"getappendmessageresult\",{\"1\":{\"718\":2,\"800\":2}}],[\"getawaitterminationmilliswhenshutdown\",{\"1\":{\"642\":1}}],[\"getallclientid\",{\"1\":{\"786\":1}}],[\"getallocatemessagequeuestrategy\",{\"1\":{\"642\":1}}],[\"getallaclfiles\",{\"1\":{\"518\":1,\"519\":1}}],[\"getackoffset\",{\"1\":{\"796\":1,\"798\":1}}],[\"getackindex\",{\"1\":{\"715\":1}}],[\"getaccessmessageinmemorymaxratio\",{\"1\":{\"694\":1}}],[\"getaccesskey\",{\"1\":{\"515\":2,\"518\":4,\"520\":7}}],[\"getaclrpchook\",{\"1\":{\"504\":2,\"505\":2}}],[\"getkvconfig\",{\"1\":{\"493\":1}}],[\"getkvconfigmanager\",{\"1\":{\"493\":1}}],[\"getkey\",{\"1\":{\"364\":1,\"491\":1,\"492\":4,\"520\":1,\"541\":2,\"662\":1,\"664\":1,\"720\":1,\"744\":1}}],[\"getkeys\",{\"1\":{\"314\":1,\"540\":1}}],[\"getheartbeatbrokerinterval\",{\"1\":{\"568\":1}}],[\"gethaserveraddr\",{\"1\":{\"491\":1}}],[\"gethoststring\",{\"1\":{\"408\":1}}],[\"gethostname\",{\"1\":{\"408\":1}}],[\"getip\",{\"1\":{\"537\":1}}],[\"getiloggerfactory\",{\"1\":{\"480\":1}}],[\"getinvisibletime\",{\"1\":{\"789\":1,\"790\":2,\"793\":1}}],[\"getinstancename\",{\"1\":{\"690\":1,\"755\":1}}],[\"getinstance\",{\"1\":{\"567\":2,\"642\":1}}],[\"getinstances\",{\"1\":{\"116\":3}}],[\"getindexcount\",{\"1\":{\"317\":9}}],[\"getindexmsgtimestamp\",{\"1\":{\"313\":1}}],[\"getindexbuffer\",{\"1\":{\"287\":1,\"365\":1,\"380\":1,\"694\":1}}],[\"getint\",{\"1\":{\"287\":1,\"291\":1,\"317\":5,\"365\":1,\"380\":1,\"694\":1}}],[\"getrunningflags\",{\"1\":{\"817\":3}}],[\"getruntime\",{\"1\":{\"480\":1}}],[\"getrouteinfomanager\",{\"1\":{\"493\":1}}],[\"getrouteinforequestheader\",{\"1\":{\"493\":3}}],[\"getrouteinfobytopic\",{\"1\":{\"477\":1,\"493\":2}}],[\"getrocketmqhome\",{\"1\":{\"480\":2}}],[\"getrebalanceimpl\",{\"1\":{\"808\":1}}],[\"getreadbehind\",{\"1\":{\"798\":1}}],[\"getreadqueuenums\",{\"1\":{\"693\":2,\"789\":6}}],[\"getreviveoffset\",{\"1\":{\"799\":3}}],[\"getrevivescantime\",{\"1\":{\"798\":1}}],[\"getrevivemessage\",{\"1\":{\"798\":1}}],[\"getrevivetime\",{\"1\":{\"795\":1,\"796\":1,\"797\":1,\"798\":1,\"799\":1,\"800\":1}}],[\"getrevivequeueoffset\",{\"1\":{\"797\":2}}],[\"getrevivequeuenum\",{\"1\":{\"789\":1}}],[\"getreviveqid\",{\"1\":{\"793\":1}}],[\"getretrymaxtimes\",{\"1\":{\"718\":1}}],[\"getretryqueuenums\",{\"1\":{\"718\":3}}],[\"getretrytopic\",{\"1\":{\"717\":1,\"718\":1}}],[\"getretrytimeswhensendasyncfailed\",{\"1\":{\"573\":1}}],[\"getretrytimeswhensendfailed\",{\"1\":{\"570\":1}}],[\"getreconsumetime\",{\"1\":{\"573\":1}}],[\"getreconsumetimes\",{\"1\":{\"257\":2,\"540\":1,\"576\":2,\"715\":1,\"717\":2,\"718\":3,\"800\":2}}],[\"getrequestid\",{\"1\":{\"540\":1}}],[\"getrequestcode\",{\"1\":{\"520\":2}}],[\"getrequestcommand\",{\"1\":{\"345\":2}}],[\"getregionid\",{\"1\":{\"540\":1,\"541\":1}}],[\"getresourcepermmap\",{\"1\":{\"520\":2}}],[\"getresult\",{\"1\":{\"287\":2,\"694\":16}}],[\"getremoteaddressstrategy\",{\"1\":{\"518\":1,\"520\":1}}],[\"getremark\",{\"1\":{\"414\":1}}],[\"getversion\",{\"1\":{\"414\":1,\"718\":1}}],[\"getvalue\",{\"1\":{\"364\":1,\"491\":2,\"492\":5,\"520\":1,\"541\":1,\"664\":1,\"720\":1,\"744\":1,\"797\":1}}],[\"getdlqtopic\",{\"1\":{\"718\":1}}],[\"getdefaulttopicqueuenums\",{\"1\":{\"573\":1}}],[\"getdefaulttopicperm\",{\"1\":{\"520\":1}}],[\"getdefaultmqpullconsumerimpl\",{\"1\":{\"808\":1}}],[\"getdefaultmqpushconsumer\",{\"1\":{\"665\":6}}],[\"getdefaultmqpushconsumerimpl\",{\"1\":{\"539\":2}}],[\"getdefaultmqproducer\",{\"1\":{\"717\":1}}],[\"getdefaultmqproducerimpl\",{\"1\":{\"568\":1,\"643\":1}}],[\"getdefaultgroupperm\",{\"1\":{\"520\":1}}],[\"getdeclaredfields\",{\"1\":{\"515\":1}}],[\"getdestroymapedfileintervalforcibly\",{\"1\":{\"390\":1}}],[\"getdelivertimems\",{\"1\":{\"798\":1}}],[\"getdelaylevel\",{\"1\":{\"718\":1}}],[\"getdelaylevelwhennextconsume\",{\"1\":{\"717\":1}}],[\"getdelaytimelevel\",{\"1\":{\"363\":3}}],[\"getdeleteconsumequeuefilesinterval\",{\"1\":{\"391\":1,\"392\":1}}],[\"getdeletecommitlogfilesinterval\",{\"1\":{\"390\":1}}],[\"getdataversion\",{\"1\":{\"491\":2}}],[\"getdata\",{\"1\":{\"282\":1}}],[\"getuniqkey\",{\"1\":{\"314\":4}}],[\"getpt\",{\"1\":{\"795\":1}}],[\"getpopckstaybuffertime\",{\"1\":{\"796\":1,\"797\":2}}],[\"getpopckstaybuffertimeout\",{\"1\":{\"795\":1,\"796\":1,\"797\":1}}],[\"getpopckmaxbuffersize\",{\"1\":{\"795\":1}}],[\"getpopbuffermergeservice\",{\"1\":{\"793\":1}}],[\"getpopmessageprocessor\",{\"1\":{\"793\":1,\"800\":2}}],[\"getpoptime\",{\"1\":{\"793\":2,\"796\":2,\"797\":2,\"798\":3,\"800\":2}}],[\"getpopoffset\",{\"1\":{\"790\":2}}],[\"getpopsharequeuenum\",{\"1\":{\"786\":1}}],[\"getpollnameserverinterval\",{\"1\":{\"568\":1}}],[\"getperm\",{\"1\":{\"693\":1,\"718\":1}}],[\"getpersistconsumeroffsetinterval\",{\"1\":{\"568\":1}}],[\"getputmessagestatus\",{\"1\":{\"365\":1,\"381\":1,\"718\":2,\"793\":4}}],[\"getpullinterval\",{\"1\":{\"695\":2,\"749\":2}}],[\"getpullstatus\",{\"1\":{\"695\":1,\"749\":1,\"848\":1}}],[\"getpullbatchsize\",{\"1\":{\"690\":1}}],[\"getpullthresholdsizeforqueue\",{\"1\":{\"665\":1,\"690\":2}}],[\"getpullthresholdsizefortopic\",{\"1\":{\"665\":1}}],[\"getpullthresholdforqueue\",{\"1\":{\"665\":1,\"690\":2}}],[\"getpullthresholdfortopic\",{\"1\":{\"665\":1}}],[\"getpullmessageprocessor\",{\"1\":{\"345\":2}}],[\"getpullmessageexecutor\",{\"1\":{\"340\":1}}],[\"getpullfromthisoffset\",{\"1\":{\"345\":2}}],[\"getpullrequestholdservice\",{\"1\":{\"339\":1,\"693\":1}}],[\"getpath\",{\"1\":{\"313\":1}}],[\"getprocessqueue\",{\"1\":{\"690\":2,\"695\":1,\"715\":3,\"748\":1}}],[\"getproducergroup\",{\"1\":{\"567\":4,\"573\":2}}],[\"getprops\",{\"1\":{\"540\":1,\"715\":1,\"750\":1}}],[\"getproperty\",{\"1\":{\"540\":2,\"573\":4,\"718\":2,\"816\":1,\"819\":2}}],[\"getproperties\",{\"1\":{\"363\":1,\"573\":1,\"576\":3,\"717\":1,\"718\":3,\"793\":2,\"800\":5}}],[\"getpropertiesmap\",{\"1\":{\"282\":1,\"347\":1,\"817\":2,\"851\":2}}],[\"getpropertiesstring\",{\"1\":{\"257\":4}}],[\"getpreparedtransactionoffset\",{\"1\":{\"257\":2}}],[\"getlanguage\",{\"1\":{\"414\":1}}],[\"getlastmodifiedtimestamp\",{\"1\":{\"390\":1}}],[\"getlastmappedfile\",{\"1\":{\"285\":1}}],[\"getlastindexfile\",{\"1\":{\"313\":1}}],[\"getlogger\",{\"1\":{\"480\":2}}],[\"getlogicsmsgtimestamp\",{\"1\":{\"289\":1}}],[\"getlong\",{\"1\":{\"287\":2,\"291\":2,\"317\":1,\"365\":2,\"380\":2,\"694\":2}}],[\"getfilterbitmap\",{\"1\":{\"852\":1}}],[\"getfilereservedtime\",{\"1\":{\"390\":1}}],[\"getfilefromoffset\",{\"1\":{\"285\":1,\"291\":2}}],[\"getfilename\",{\"1\":{\"285\":1,\"291\":4}}],[\"getflushconsumeroffsetinterval\",{\"1\":{\"721\":1}}],[\"getflushconsumequeuethoroughinterval\",{\"1\":{\"289\":1}}],[\"getflushconsumequeueleastpages\",{\"1\":{\"289\":1}}],[\"getflushdelayoffsetinterval\",{\"1\":{\"364\":1}}],[\"getflagbits\",{\"1\":{\"694\":1}}],[\"getflag\",{\"1\":{\"257\":2,\"414\":1,\"573\":1,\"576\":1,\"717\":1,\"718\":1}}],[\"getescapebridge\",{\"1\":{\"793\":1,\"800\":1}}],[\"getexpression\",{\"1\":{\"852\":2}}],[\"getexpressiontype\",{\"1\":{\"690\":1,\"693\":6,\"847\":1,\"852\":2}}],[\"getextrainfo\",{\"1\":{\"793\":1}}],[\"getext\",{\"1\":{\"365\":1,\"380\":1,\"694\":1}}],[\"getextfields\",{\"1\":{\"262\":1,\"414\":1,\"693\":1}}],[\"getenqueuebehind\",{\"1\":{\"798\":1}}],[\"getendphyoffset\",{\"1\":{\"313\":1,\"314\":2,\"392\":2}}],[\"getendtimestamp\",{\"1\":{\"313\":2,\"314\":1,\"316\":1}}],[\"getencode\",{\"1\":{\"257\":1}}],[\"gettostorebits\",{\"1\":{\"797\":2}}],[\"gettopicsubscribeinfo\",{\"1\":{\"786\":2}}],[\"gettopicrouteinfomanager\",{\"1\":{\"786\":1}}],[\"gettopicconfigmanager\",{\"1\":{\"576\":1,\"693\":1,\"718\":2,\"789\":2,\"799\":1}}],[\"gettopicconfigtable\",{\"1\":{\"491\":1}}],[\"gettopic\",{\"1\":{\"257\":2,\"282\":1,\"284\":1,\"314\":1,\"339\":1,\"347\":1,\"363\":2,\"365\":3,\"380\":2,\"493\":3,\"540\":1,\"541\":1,\"570\":3,\"573\":5,\"576\":2,\"664\":1,\"690\":2,\"691\":3,\"693\":24,\"695\":3,\"715\":4,\"717\":3,\"718\":7,\"720\":2,\"744\":1,\"749\":2,\"750\":1,\"787\":1,\"789\":3,\"790\":2,\"793\":2,\"796\":1,\"798\":4,\"799\":2,\"800\":7,\"816\":1,\"817\":1,\"851\":3}}],[\"gett\",{\"1\":{\"795\":1}}],[\"gettryunlocktimes\",{\"1\":{\"745\":1}}],[\"gettransactionalmessageservice\",{\"1\":{\"576\":1}}],[\"gettransactionvalue\",{\"1\":{\"284\":1,\"314\":1,\"363\":1}}],[\"gettracebeans\",{\"1\":{\"540\":3,\"541\":2}}],[\"gettimermessagestore\",{\"1\":{\"798\":2}}],[\"gettimestamp\",{\"1\":{\"540\":1}}],[\"gettimeoutmillis\",{\"1\":{\"345\":1}}],[\"gettagsset\",{\"1\":{\"848\":2}}],[\"gettags\",{\"1\":{\"540\":1,\"718\":1,\"798\":2,\"800\":2,\"848\":2}}],[\"gettagscode\",{\"1\":{\"282\":1,\"347\":1,\"365\":1,\"380\":1,\"694\":1,\"817\":3}}],[\"gettype\",{\"1\":{\"262\":1}}],[\"getcid\",{\"1\":{\"798\":3,\"799\":3,\"800\":4}}],[\"getck\",{\"1\":{\"796\":1,\"797\":1}}],[\"getckqueueoffset\",{\"1\":{\"793\":1}}],[\"getc\",{\"1\":{\"795\":1}}],[\"getcreatetopickey\",{\"1\":{\"567\":1,\"573\":1}}],[\"getchannel\",{\"1\":{\"400\":1,\"492\":1}}],[\"getclientversion\",{\"1\":{\"693\":2}}],[\"getclientip\",{\"1\":{\"573\":1,\"755\":1}}],[\"getclientid\",{\"1\":{\"568\":1,\"643\":1,\"663\":2,\"720\":1,\"742\":1,\"746\":1}}],[\"getclientconfig\",{\"1\":{\"573\":2}}],[\"getclientchannel\",{\"1\":{\"345\":2}}],[\"getclass\",{\"1\":{\"515\":3,\"516\":1}}],[\"getclazzfields\",{\"1\":{\"262\":1}}],[\"getcleanresourceinterval\",{\"1\":{\"389\":1}}],[\"getcompiledexpression\",{\"1\":{\"851\":2,\"852\":3}}],[\"getcommercialsizepermsg\",{\"1\":{\"789\":1}}],[\"getcommercialbasecount\",{\"1\":{\"693\":1}}],[\"getcommitoffset\",{\"1\":{\"693\":1}}],[\"getcommitlog\",{\"1\":{\"365\":1,\"380\":1}}],[\"getcommitlogoffset\",{\"1\":{\"314\":3,\"817\":5,\"851\":3}}],[\"getconsumelock\",{\"1\":{\"745\":2,\"750\":2}}],[\"getconsumetimeout\",{\"1\":{\"715\":1,\"750\":1}}],[\"getconsumemessagebatchmaxsize\",{\"1\":{\"714\":1,\"750\":1}}],[\"getconsumerorderinfomanager\",{\"1\":{\"790\":2}}],[\"getconsumeroffsetmanager\",{\"1\":{\"693\":1,\"790\":3,\"798\":1,\"799\":1}}],[\"getconsumerstatsmanager\",{\"1\":{\"695\":2,\"715\":4,\"749\":2,\"750\":1}}],[\"getconsumerfiltermanager\",{\"1\":{\"693\":3,\"850\":2}}],[\"getconsumermanager\",{\"1\":{\"693\":1,\"786\":1}}],[\"getconsumergroupinfo\",{\"1\":{\"693\":1,\"786\":1}}],[\"getconsumergroup\",{\"1\":{\"540\":1,\"642\":8,\"690\":1,\"693\":24,\"695\":2,\"715\":2,\"717\":3,\"749\":2,\"750\":2,\"789\":3,\"790\":12,\"793\":2,\"796\":1,\"798\":1}}],[\"getconsumeconcurrentlymaxspan\",{\"1\":{\"690\":1}}],[\"getconsumequeueoffset\",{\"1\":{\"282\":1,\"347\":1,\"817\":1}}],[\"getcontent\",{\"1\":{\"520\":1}}],[\"getconfiguration\",{\"1\":{\"480\":1}}],[\"getcodeset\",{\"1\":{\"847\":1}}],[\"getcode\",{\"1\":{\"339\":1,\"414\":2,\"576\":1,\"693\":2}}],[\"getcanonicalname\",{\"1\":{\"262\":1}}],[\"getnum\",{\"1\":{\"797\":1,\"800\":1}}],[\"getnextbeginoffset\",{\"1\":{\"693\":3,\"695\":5,\"749\":1,\"790\":6,\"791\":2}}],[\"getnextoffset\",{\"1\":{\"381\":1,\"690\":2,\"695\":2,\"748\":1,\"749\":1}}],[\"getnotnullannotation\",{\"1\":{\"262\":1}}],[\"getnamesrvaddr\",{\"1\":{\"568\":2,\"643\":1}}],[\"getnamesrvconfig\",{\"1\":{\"493\":1}}],[\"getnameserveraddresslist\",{\"1\":{\"490\":1}}],[\"getnamespacefromresource\",{\"1\":{\"718\":1}}],[\"getnamespace\",{\"1\":{\"406\":1,\"421\":1,\"422\":1,\"423\":1,\"573\":5,\"715\":1,\"717\":1,\"750\":1}}],[\"getname\",{\"1\":{\"262\":1,\"505\":1,\"515\":1,\"527\":1,\"663\":2,\"768\":1}}],[\"getm\",{\"1\":{\"851\":1}}],[\"getmergekey\",{\"1\":{\"795\":1}}],[\"getmessagebinary\",{\"1\":{\"848\":1}}],[\"getmessagebufferlist\",{\"1\":{\"789\":1}}],[\"getmessagetmpresult\",{\"1\":{\"790\":27,\"791\":5}}],[\"getmessagemapedlist\",{\"1\":{\"789\":1,\"790\":5}}],[\"getmessagemodel\",{\"1\":{\"642\":4,\"690\":1,\"693\":1,\"715\":1}}],[\"getmessagecount\",{\"1\":{\"693\":2,\"694\":1,\"790\":2}}],[\"getmessagequeueoffset\",{\"1\":{\"790\":2,\"791\":1}}],[\"getmessagequeue\",{\"1\":{\"690\":5,\"695\":8,\"715\":5,\"717\":1,\"748\":1,\"749\":4}}],[\"getmessagequeuelist\",{\"1\":{\"572\":3}}],[\"getmessagelistenerinner\",{\"1\":{\"642\":4}}],[\"getmessagefilter\",{\"1\":{\"345\":2}}],[\"getmessagestore\",{\"1\":{\"339\":1,\"343\":1,\"345\":1,\"576\":1,\"693\":4,\"718\":2,\"790\":6,\"798\":2}}],[\"getmessagestoreconfig\",{\"1\":{\"282\":1,\"289\":2,\"314\":1,\"347\":1,\"364\":1,\"380\":1,\"390\":4,\"391\":1,\"392\":1,\"693\":4,\"816\":2,\"817\":4}}],[\"getmessagestatus\",{\"1\":{\"287\":2,\"694\":14,\"789\":2,\"790\":7}}],[\"getmessageresult\",{\"1\":{\"277\":1,\"287\":1,\"693\":24,\"694\":4,\"789\":12,\"790\":8,\"791\":1}}],[\"getmessage\",{\"0\":{\"287\":1},\"1\":{\"277\":2,\"286\":1,\"287\":2,\"693\":2,\"694\":4,\"790\":2,\"838\":3}}],[\"getmode\",{\"1\":{\"786\":1}}],[\"getmodifiers\",{\"1\":{\"262\":1}}],[\"getmqset\",{\"1\":{\"746\":1}}],[\"getmqclientfactory\",{\"1\":{\"665\":1,\"808\":1}}],[\"getmqclientapiimpl\",{\"1\":{\"573\":2,\"691\":1,\"717\":1,\"720\":2,\"746\":1}}],[\"getmqtracecontext\",{\"1\":{\"540\":1}}],[\"getminoffset\",{\"1\":{\"391\":1,\"392\":1,\"693\":2}}],[\"getminoffsetinqueue\",{\"1\":{\"365\":1,\"380\":1,\"694\":1}}],[\"getmaxoffset\",{\"1\":{\"693\":2,\"694\":1,\"790\":1}}],[\"getmaxoffsetinqueue\",{\"1\":{\"343\":1,\"345\":1,\"380\":1,\"694\":3,\"790\":4}}],[\"getmaxmsgnums\",{\"1\":{\"693\":1,\"789\":1,\"790\":3}}],[\"getmaxmsgsnumbatch\",{\"1\":{\"314\":1}}],[\"getmaxspan\",{\"1\":{\"690\":2}}],[\"getmaxreconsumetimes\",{\"1\":{\"573\":1,\"717\":2,\"718\":1}}],[\"getmaxdelaylevel\",{\"1\":{\"363\":2}}],[\"getmappedfiles\",{\"1\":{\"291\":1}}],[\"getmsgstoretime\",{\"1\":{\"852\":1}}],[\"getmsgs\",{\"1\":{\"715\":12}}],[\"getmsgsize\",{\"1\":{\"282\":1,\"690\":1,\"817\":2}}],[\"getmsgfoundlist\",{\"1\":{\"695\":6,\"749\":6,\"808\":1}}],[\"getmsgtreemap\",{\"1\":{\"690\":6}}],[\"getmsgcount4commercial\",{\"1\":{\"693\":1}}],[\"getmsgcount\",{\"1\":{\"690\":1}}],[\"getmsglist\",{\"1\":{\"540\":6}}],[\"getmsgid\",{\"1\":{\"258\":2,\"365\":1,\"380\":2,\"540\":1,\"717\":1,\"718\":1}}],[\"getso\",{\"1\":{\"795\":1}}],[\"getsystemclock\",{\"1\":{\"694\":2}}],[\"getsysflag\",{\"1\":{\"257\":4,\"258\":1,\"284\":1,\"314\":1,\"363\":1,\"693\":3,\"718\":1}}],[\"getsuggestwhichbrokerid\",{\"1\":{\"693\":2,\"848\":1}}],[\"getsuspendtimeoutmillis\",{\"1\":{\"693\":1}}],[\"getsuspendtimestamp\",{\"1\":{\"345\":1}}],[\"getsubscription\",{\"1\":{\"693\":3}}],[\"getsubscriptiongroupmanager\",{\"1\":{\"693\":1,\"718\":1,\"799\":1}}],[\"getsubscriptioninner\",{\"1\":{\"662\":1,\"690\":2}}],[\"getsubstring\",{\"1\":{\"690\":1,\"693\":1,\"847\":1}}],[\"getsubversion\",{\"1\":{\"665\":1,\"690\":1,\"693\":5}}],[\"getsignature\",{\"1\":{\"520\":1}}],[\"getsize\",{\"1\":{\"282\":1,\"287\":1,\"365\":1,\"380\":1,\"694\":1}}],[\"getsendwhichqueue\",{\"1\":{\"572\":2}}],[\"getsendstatus\",{\"1\":{\"570\":1}}],[\"getsecretkey\",{\"1\":{\"515\":1,\"520\":1}}],[\"getsecuritytoken\",{\"1\":{\"515\":3}}],[\"getserverworkerthreads\",{\"1\":{\"481\":1}}],[\"getservicename\",{\"1\":{\"344\":3,\"519\":3,\"660\":2,\"688\":2}}],[\"getscheduleasyncdelivermaxpendinglimit\",{\"1\":{\"380\":1}}],[\"getschedulemessageservice\",{\"1\":{\"363\":2}}],[\"getshortpollingtimemills\",{\"1\":{\"339\":1,\"344\":1,\"693\":1}}],[\"getstring\",{\"1\":{\"518\":1}}],[\"getstatus\",{\"1\":{\"381\":1,\"693\":2,\"789\":1,\"790\":7,\"800\":1}}],[\"getstartoffset\",{\"1\":{\"282\":1,\"796\":1,\"798\":3}}],[\"getstoresize\",{\"1\":{\"540\":1}}],[\"getstorecheckpoint\",{\"1\":{\"289\":3,\"313\":1,\"316\":2,\"817\":2}}],[\"getstorehost\",{\"1\":{\"257\":1,\"258\":1,\"576\":1,\"717\":1,\"718\":1,\"793\":2,\"800\":2}}],[\"getstorehostbytes\",{\"1\":{\"257\":1}}],[\"getstoretimestamp\",{\"1\":{\"257\":2,\"258\":1,\"282\":1,\"347\":1,\"540\":1,\"800\":1,\"817\":3}}],[\"getbloomfilterdata\",{\"1\":{\"851\":2,\"852\":3}}],[\"getbloomfilter\",{\"1\":{\"851\":2,\"852\":1}}],[\"getbatchsize\",{\"1\":{\"816\":1}}],[\"getbizmessage\",{\"1\":{\"800\":1}}],[\"getbitnum\",{\"1\":{\"852\":1}}],[\"getbit\",{\"1\":{\"797\":2,\"800\":1}}],[\"getbits\",{\"1\":{\"796\":1,\"797\":1}}],[\"getbitmap\",{\"1\":{\"282\":1,\"347\":1,\"798\":1,\"800\":1,\"817\":1}}],[\"getbroker2client\",{\"1\":{\"850\":1}}],[\"getbrokerstatsmanager\",{\"1\":{\"693\":4,\"718\":5,\"790\":3,\"793\":2}}],[\"getbrokerid\",{\"1\":{\"693\":2}}],[\"getbrokerip1\",{\"1\":{\"576\":1,\"693\":1,\"718\":1}}],[\"getbrokerpermission\",{\"1\":{\"693\":1,\"718\":1}}],[\"getbrokeraddrtable\",{\"1\":{\"768\":1}}],[\"getbrokeraddr\",{\"1\":{\"691\":1,\"720\":2,\"746\":1}}],[\"getbrokeraddrs\",{\"1\":{\"491\":3,\"492\":2}}],[\"getbrokerversion\",{\"1\":{\"691\":2}}],[\"getbrokerclustername\",{\"1\":{\"576\":1}}],[\"getbrokerconfigpath\",{\"1\":{\"854\":1}}],[\"getbrokerconfig\",{\"1\":{\"339\":2,\"344\":2,\"576\":3,\"693\":11,\"718\":2,\"786\":1,\"789\":2,\"790\":2,\"795\":5,\"796\":6,\"797\":4,\"798\":3,\"800\":1,\"850\":1}}],[\"getbrokername\",{\"1\":{\"492\":3,\"570\":3,\"572\":2,\"573\":5,\"691\":4,\"693\":1,\"717\":1,\"720\":3,\"746\":1,\"787\":1,\"790\":2,\"793\":1,\"796\":1,\"800\":1}}],[\"getbrokerrole\",{\"1\":{\"282\":1,\"347\":1,\"693\":3,\"817\":1}}],[\"getbegintimestamp\",{\"1\":{\"314\":1,\"317\":3}}],[\"getbean\",{\"1\":{\"116\":3}}],[\"getbuffertotalsize\",{\"1\":{\"287\":2,\"693\":3,\"694\":4,\"790\":1}}],[\"getbuffersize\",{\"1\":{\"282\":2}}],[\"getbytebuffer\",{\"1\":{\"282\":1,\"287\":3,\"365\":3,\"380\":3,\"694\":4}}],[\"getbytes\",{\"1\":{\"257\":4,\"355\":1,\"504\":1,\"526\":1,\"793\":1,\"807\":1,\"826\":1,\"829\":1,\"873\":1}}],[\"getbornhostnamestring\",{\"1\":{\"408\":1}}],[\"getbornhost\",{\"1\":{\"257\":1,\"718\":1}}],[\"getbornhostbytes\",{\"1\":{\"257\":1}}],[\"getborntimestamp\",{\"1\":{\"257\":2,\"576\":1,\"718\":1,\"800\":1}}],[\"getbodycrc\",{\"1\":{\"257\":2}}],[\"getbody\",{\"1\":{\"257\":6,\"573\":1,\"576\":1,\"717\":1,\"718\":1,\"798\":2,\"800\":1}}],[\"get\",{\"0\":{\"47\":1},\"1\":{\"67\":8,\"73\":1,\"103\":1,\"151\":1,\"157\":2,\"160\":2,\"176\":2,\"177\":2,\"178\":1,\"179\":2,\"258\":1,\"262\":14,\"291\":2,\"313\":1,\"314\":1,\"342\":1,\"345\":1,\"364\":2,\"380\":1,\"381\":1,\"392\":1,\"491\":4,\"515\":2,\"518\":9,\"519\":3,\"520\":4,\"540\":1,\"541\":3,\"571\":3,\"572\":2,\"576\":1,\"663\":3,\"665\":1,\"690\":4,\"693\":2,\"695\":1,\"714\":2,\"715\":2,\"720\":2,\"721\":1,\"742\":2,\"746\":1,\"749\":1,\"786\":2,\"787\":1,\"795\":2,\"796\":1,\"797\":2,\"798\":2,\"799\":2,\"800\":2,\"817\":4,\"850\":1,\"851\":1}}],[\"geometry\",{\"1\":{\"30\":11}}],[\"上只有一个\",{\"1\":{\"808\":1,\"817\":1}}],[\"上加锁\",{\"1\":{\"790\":1}}],[\"上保存和管理的分布式锁\",{\"1\":{\"732\":1}}],[\"上一篇主要介绍并发消费\",{\"1\":{\"723\":1}}],[\"上一篇重平衡篇有提到\",{\"1\":{\"672\":1}}],[\"上一次发送失败会规避上次发送的\",{\"1\":{\"572\":1}}],[\"上一次发送成功则选择下一个队列\",{\"1\":{\"572\":1}}],[\"上一次发送异常的情况下它将执行\",{\"1\":{\"561\":1}}],[\"上产生此对象\",{\"1\":{\"555\":1}}],[\"上恢复数据\",{\"1\":{\"553\":1}}],[\"上生产和消费\",{\"1\":{\"498\":1}}],[\"上报给\",{\"1\":{\"640\":1}}],[\"上报消费进度\",{\"1\":{\"637\":1}}],[\"上报的元数据中\",{\"1\":{\"813\":1}}],[\"上报的路由信息保存到\",{\"1\":{\"491\":1}}],[\"上报的路由信息为例展示\",{\"1\":{\"483\":1}}],[\"上报的路由信息存起来\",{\"1\":{\"471\":1}}],[\"上报的心跳包请求类型是\",{\"1\":{\"472\":1}}],[\"上报\",{\"1\":{\"472\":1,\"665\":1}}],[\"上报心跳和路由信息\",{\"0\":{\"472\":1,\"490\":1},\"1\":{\"490\":1}}],[\"上报路由信息\",{\"1\":{\"461\":1,\"471\":1}}],[\"上次请求偏移量\",{\"1\":{\"695\":1,\"749\":1}}],[\"上次拉取完成\",{\"1\":{\"675\":1}}],[\"上次拉取消息的时间距离现在超过设置时间\",{\"1\":{\"664\":1,\"744\":1}}],[\"上次发送失败\",{\"1\":{\"572\":1}}],[\"上次发送的\",{\"1\":{\"572\":1}}],[\"上次发送心跳时间\",{\"1\":{\"465\":1}}],[\"上次更新时间戳\",{\"1\":{\"487\":1}}],[\"上次是否是正常退出\",{\"1\":{\"313\":1}}],[\"上传\",{\"1\":{\"465\":1}}],[\"上获取属性remoteaddr\",{\"1\":{\"417\":1}}],[\"上的队列\",{\"1\":{\"658\":1}}],[\"上的队列轮流分给不同消费者\",{\"1\":{\"617\":1}}],[\"上的偏移量\",{\"1\":{\"537\":1}}],[\"上的\",{\"1\":{\"464\":1,\"469\":1,\"474\":1}}],[\"上的引用\",{\"1\":{\"390\":1}}],[\"上的这些\",{\"1\":{\"206\":1}}],[\"上面提到的\",{\"1\":{\"820\":1}}],[\"上面方法第\",{\"1\":{\"778\":1}}],[\"上面主要讲的是推模式消费者\",{\"1\":{\"656\":1}}],[\"上面的\",{\"1\":{\"514\":1,\"778\":1}}],[\"上面是一个发送消息的请求\",{\"1\":{\"410\":1}}],[\"上面是挂起的消息拉取请求容器\",{\"1\":{\"335\":1}}],[\"上面已经提到\",{\"1\":{\"306\":1}}],[\"上面说过\",{\"1\":{\"354\":1}}],[\"上面说它的逻辑结构类似\",{\"1\":{\"300\":1}}],[\"上面说到\",{\"1\":{\"158\":1,\"334\":1}}],[\"上图展示了加锁流程\",{\"1\":{\"734\":1}}],[\"上图展示的就是该方法中的逻辑\",{\"1\":{\"377\":1}}],[\"上图为\",{\"1\":{\"465\":1,\"467\":1}}],[\"上图来自艾瑞克的技术江湖\",{\"1\":{\"275\":1}}],[\"上图中标识了\",{\"1\":{\"656\":1}}],[\"上图中\",{\"1\":{\"155\":1}}],[\"上所有消息都顺序保存在\",{\"1\":{\"256\":1}}],[\"上\",{\"1\":{\"206\":1,\"417\":1,\"461\":1,\"470\":1,\"488\":1,\"491\":1,\"549\":1,\"553\":1,\"872\":1}}],[\"上接收生产者发送的消息后投递到\",{\"1\":{\"201\":1}}],[\"上游集群配置\",{\"0\":{\"170\":1}}],[\"上下游\",{\"1\":{\"168\":1}}],[\"上下文中的方法\",{\"1\":{\"122\":1}}],[\"上开启\",{\"1\":{\"168\":1}}],[\"上运行\",{\"1\":{\"87\":1}}],[\"上测试\",{\"1\":{\"7\":1}}],[\"上语言程序的性能\",{\"1\":{\"2\":1}}],[\"包装成消息放入磁盘\",{\"1\":{\"797\":1}}],[\"包中\",{\"1\":{\"347\":1}}],[\"包括从\",{\"1\":{\"557\":1}}],[\"包括该目录的子目录\",{\"1\":{\"518\":1}}],[\"包括索引文件的加载\",{\"1\":{\"309\":1}}],[\"包括\",{\"1\":{\"247\":1,\"270\":1,\"301\":1,\"321\":1,\"545\":1,\"568\":1}}],[\"包括接收消息\",{\"1\":{\"222\":1}}],[\"包括消息的存储地点\",{\"1\":{\"220\":1}}],[\"包括网络\",{\"1\":{\"195\":1}}],[\"包括网络i\",{\"1\":{\"190\":1}}],[\"包括三个部分ha\",{\"1\":{\"185\":1}}],[\"包括函数名\",{\"1\":{\"106\":1}}],[\"包括预热该文件\",{\"1\":{\"401\":1}}],[\"包括预热\",{\"1\":{\"9\":1}}],[\"包含过滤信息\",{\"1\":{\"690\":1}}],[\"包含需要拉取的消费队列信息\",{\"1\":{\"690\":1,\"748\":1}}],[\"包含队列信息\",{\"1\":{\"669\":1}}],[\"包含两种消费模式\",{\"1\":{\"637\":1}}],[\"包含消息合法性检查\",{\"1\":{\"576\":1}}],[\"包含如下\",{\"1\":{\"498\":1}}],[\"包含用户名\",{\"1\":{\"498\":1}}],[\"包含最后更新时间\",{\"1\":{\"491\":1}}],[\"包含自身\",{\"1\":{\"465\":1}}],[\"包含当前所有存活的\",{\"1\":{\"464\":1}}],[\"包含每个集群中所有的\",{\"1\":{\"464\":1}}],[\"包含其名称\",{\"1\":{\"464\":1}}],[\"包含大量字符串操作\",{\"1\":{\"420\":1}}],[\"包含配置文件持久化的函数和重新加载配置文件到内存的函数\",{\"1\":{\"360\":1}}],[\"包含索引文件的存储结构和一系列操作\",{\"1\":{\"310\":1}}],[\"包含一些基本信息\",{\"1\":{\"307\":1}}],[\"包含一个自带地址空间和进程组的完整虚拟机\",{\"1\":{\"87\":1}}],[\"包含的最大索引数量是相同的\",{\"1\":{\"300\":1}}],[\"包含\",{\"1\":{\"269\":1,\"306\":1,\"469\":1}}],[\"包含在\",{\"1\":{\"205\":1}}],[\"包含了\",{\"1\":{\"537\":1}}],[\"包含了每个\",{\"1\":{\"472\":1}}],[\"包含了许多强大的工具\",{\"1\":{\"112\":1}}],[\"包含了一组库和实现方式\",{\"1\":{\"112\":1}}],[\"包含库的头文件\",{\"1\":{\"61\":1}}],[\"包含文件的扩展名是\",{\"1\":{\"61\":1}}],[\"包含文件\",{\"0\":{\"61\":1}}],[\"包含预定义的模块属性和用户定义的属性\",{\"1\":{\"52\":1}}],[\"包十分有用\",{\"1\":{\"7\":1}}],[\"包\",{\"1\":{\"7\":1}}],[\"这体现在消息数据的存储和\",{\"1\":{\"810\":1}}],[\"这给多语言客户端的支持造成很大的阻碍\",{\"1\":{\"769\":1}}],[\"这两种消费方式的流程又比较类似\",{\"1\":{\"707\":1}}],[\"这两个参数含义如下\",{\"1\":{\"819\":1}}],[\"这两个参数在老一点的版本中为\",{\"1\":{\"151\":1}}],[\"这两个配置是\",{\"1\":{\"819\":1}}],[\"这两个方法会先初始化一个\",{\"1\":{\"783\":1}}],[\"这两个消费进度管理器都保存一个消费进度缓存表\",{\"1\":{\"711\":1}}],[\"这两个返回值都表示服务器暂时没有这个队列\",{\"1\":{\"693\":1}}],[\"这两个步骤\",{\"1\":{\"667\":1}}],[\"这两个问题可以通过精心的设计存储方案来解决\",{\"1\":{\"446\":1}}],[\"这两个指标往往不能兼得\",{\"1\":{\"444\":1}}],[\"这两个概念虽然感觉起来不同\",{\"1\":{\"440\":1}}],[\"这两个操作原理基本相同\",{\"1\":{\"243\":1}}],[\"这两个文件一定是逻辑上相邻的两个文件\",{\"1\":{\"221\":1}}],[\"这三个类\",{\"1\":{\"630\":1}}],[\"这三种发送方式中\",{\"1\":{\"547\":1}}],[\"这张图是阿里云的文章讲解消费时用到的\",{\"1\":{\"624\":1}}],[\"这多个消费同样\",{\"1\":{\"609\":1}}],[\"这边的\",{\"1\":{\"510\":1}}],[\"这几个部分\",{\"1\":{\"506\":1}}],[\"这几年国家政策大力引导下\",{\"1\":{\"126\":1}}],[\"这部分开始讲解\",{\"1\":{\"506\":1}}],[\"这其实没有太大的必要\",{\"1\":{\"462\":1}}],[\"这其实并不属于流控机制\",{\"1\":{\"148\":1}}],[\"这篇文章丢给他\",{\"1\":{\"458\":1}}],[\"这篇文章中有详细解释\",{\"1\":{\"434\":1}}],[\"这条消息重新可以被消费\",{\"1\":{\"771\":1}}],[\"这条消息对所有消费者不可见\",{\"1\":{\"771\":1}}],[\"这条定时消息就会丢失\",{\"1\":{\"454\":1}}],[\"这条语句就成立了\",{\"1\":{\"23\":1}}],[\"这么小的内存无法生产消费消息\",{\"1\":{\"600\":1}}],[\"这么多消息要投递存不下怎么办\",{\"1\":{\"451\":1}}],[\"这么设计的原因\",{\"1\":{\"356\":1}}],[\"这显然不是一个好办法\",{\"1\":{\"448\":1}}],[\"这一过程被称为重平衡机制\",{\"1\":{\"618\":1}}],[\"这一过程中整理和回收内存都需要消耗更多的时间\",{\"1\":{\"424\":1}}],[\"这一步不是必须要的\",{\"1\":{\"592\":1}}],[\"这一部分其实也是为了优化\",{\"1\":{\"433\":1}}],[\"这一批\",{\"1\":{\"240\":1}}],[\"这时会真正读一次磁盘上的文件\",{\"1\":{\"399\":1}}],[\"这时候就需要一个机制\",{\"1\":{\"441\":1,\"871\":1}}],[\"这时候操作系统会引发一个缺页中断\",{\"1\":{\"399\":1}}],[\"这时候会出现两种可能情况\",{\"1\":{\"399\":1}}],[\"这时候的处理是对失败消息进行重新投递\",{\"1\":{\"374\":1}}],[\"这时需要保证消息队列的逻辑位置和consumequeue文件的起始文件的偏移量一致\",{\"1\":{\"285\":1}}],[\"这时需要暂时限制生产者的生产速度\",{\"1\":{\"144\":1}}],[\"这次也改到锁外先生成好\",{\"1\":{\"256\":1}}],[\"这次将\",{\"1\":{\"255\":1}}],[\"这会增加内存的使用量\",{\"1\":{\"235\":1}}],[\"这会避免出现网络分区时\",{\"1\":{\"228\":1}}],[\"这\",{\"1\":{\"233\":1}}],[\"这意味着少部分比较慢的副本不会影响整个队列的性能\",{\"1\":{\"228\":1}}],[\"这意味着它们暂时耗尽了信用值\",{\"1\":{\"155\":1}}],[\"这引出了第二个致命的设计缺陷\",{\"1\":{\"226\":1}}],[\"这就决定了消费者的横向扩展能力受到\",{\"1\":{\"769\":1}}],[\"这就导致了几个问题\",{\"1\":{\"769\":1}}],[\"这就导致同步和异步方法存在大量重复代码\",{\"1\":{\"251\":1}}],[\"这就是\",{\"1\":{\"464\":1}}],[\"这就是这个优化的改动\",{\"1\":{\"426\":1}}],[\"这就是第一个致命的设计缺陷\",{\"1\":{\"226\":1}}],[\"这就意味这个\",{\"1\":{\"155\":1}}],[\"这就意味着延迟时间超过\",{\"1\":{\"877\":1}}],[\"这就意味着同样\",{\"1\":{\"307\":1}}],[\"这就意味着每个\",{\"1\":{\"300\":1}}],[\"这就意味着在消息持久化时出现了性能瓶颈\",{\"1\":{\"155\":1}}],[\"这就意味着有一个或者多个队列出现了性能瓶颈\",{\"1\":{\"155\":1}}],[\"这就意味着\",{\"1\":{\"155\":1}}],[\"这也是一个难点\",{\"1\":{\"877\":1}}],[\"这也是大部分场景下会使用到的消费模式\",{\"1\":{\"611\":1}}],[\"这也是他占用如此高\",{\"1\":{\"416\":1}}],[\"这也是\",{\"1\":{\"225\":1}}],[\"这实际会降低rabbitmq的处理性能\",{\"1\":{\"223\":1}}],[\"这将减少冗余\",{\"1\":{\"211\":1}}],[\"这将使用参数集创建一个新的消费者\",{\"1\":{\"198\":1}}],[\"这对于保证消息的fifo排序是必要的\",{\"1\":{\"193\":1}}],[\"这是由于不同的\",{\"1\":{\"834\":1}}],[\"这是由于使用了\",{\"1\":{\"237\":1}}],[\"这是一个难点\",{\"1\":{\"876\":1}}],[\"这是一个\",{\"1\":{\"356\":1}}],[\"这是关键的设计缺陷\",{\"1\":{\"210\":1}}],[\"这是常用的方法\",{\"1\":{\"193\":1}}],[\"这是默认模式\",{\"1\":{\"191\":1}}],[\"这是因为缺少一些依赖包\",{\"1\":{\"176\":1}}],[\"这是非常麻烦的事\",{\"1\":{\"120\":1}}],[\"这可能是由于将消息存入队列的过程中引起服务器\",{\"1\":{\"155\":1}}],[\"这样能够减少精确过滤的次数\",{\"1\":{\"838\":1}}],[\"这样设计的原因是\",{\"1\":{\"833\":1}}],[\"这样才能识别\",{\"1\":{\"806\":1}}],[\"这样才是一个完整的功能\",{\"1\":{\"455\":1}}],[\"这样也存在两个消费者同时消费一个队列的情况\",{\"1\":{\"728\":1}}],[\"这样不是很占用存储吗\",{\"1\":{\"708\":1}}],[\"这样的队列模型也有助于实现\",{\"1\":{\"811\":1}}],[\"这样的话消费进度存在\",{\"1\":{\"701\":1}}],[\"这样的好处是免去了一次\",{\"1\":{\"450\":1}}],[\"这样启动之后\",{\"1\":{\"597\":1}}],[\"这样可以保证每个队列最多被一个消费线程处理\",{\"1\":{\"726\":1}}],[\"这样可以保证消息的顺序\",{\"1\":{\"675\":1}}],[\"这样可以节省客户端资源\",{\"1\":{\"556\":1}}],[\"这样可以自动生成基准测试代码\",{\"1\":{\"7\":1}}],[\"这样高可靠的消息队列中\",{\"1\":{\"454\":1}}],[\"这样看来\",{\"1\":{\"451\":1}}],[\"这样消费者会马上解除挂起状态开始消费消息\",{\"1\":{\"434\":1}}],[\"这样消息才会在重启之后仍然存在\",{\"1\":{\"214\":1}}],[\"这样一个方法\",{\"1\":{\"434\":1}}],[\"这样一来\",{\"1\":{\"356\":1,\"447\":1}}],[\"这样修改之后会影响两个地方\",{\"1\":{\"432\":1}}],[\"这样做的用意是将堆中的变量复制到栈上\",{\"1\":{\"424\":1}}],[\"这样它就可以预先计算\",{\"1\":{\"417\":1}}],[\"这样虽然繁琐但是执行速度最快\",{\"1\":{\"411\":1}}],[\"这样在消费者重启或队列重平衡时可以根据消费进度继续消费\",{\"1\":{\"623\":1}}],[\"这样在消费较小的消息时只需要查询\",{\"1\":{\"220\":1}}],[\"这样在高并发时\",{\"1\":{\"403\":1}}],[\"这样操作系统会分配物理内存并且将物理地址与逻辑地址简历映射关系\",{\"1\":{\"402\":1}}],[\"这样操作会给每个页产生恰好一次的缺页中断\",{\"1\":{\"402\":1}}],[\"这样会影响读写性能\",{\"1\":{\"402\":1}}],[\"这样这个方法获得了大约\",{\"1\":{\"262\":1}}],[\"这样处理每条消息写\",{\"1\":{\"253\":1}}],[\"这样同步只会阻塞很短的时间\",{\"1\":{\"226\":1}}],[\"这样就避免了这个问题\",{\"1\":{\"876\":1}}],[\"这样就实现了为不同请求码设置对应线程池\",{\"1\":{\"575\":1}}],[\"这样就实现了内存级别的读写分离\",{\"1\":{\"403\":1}}],[\"这样就不会增加其他\",{\"1\":{\"532\":1}}],[\"这样就会造成生产方和消费方互相\",{\"1\":{\"523\":1}}],[\"这样就会造成很多额外的出入队操作\",{\"1\":{\"451\":1}}],[\"这样就会经历\",{\"1\":{\"220\":1}}],[\"这样就可能造成主从切换后丢失消息\",{\"1\":{\"450\":1}}],[\"这样就可以实现多个客户端同时拉取一个队列的效果\",{\"1\":{\"770\":1}}],[\"这样就可以像发送普通消息一样发送批量消息\",{\"1\":{\"564\":1}}],[\"这样就可以免去将投递任务加入到时间轮这个操作\",{\"1\":{\"452\":1}}],[\"这样就可以在投递完后的第二天把整个文件队列删除\",{\"1\":{\"448\":1}}],[\"这样就可以在不重新复制字节数组的情况下传递\",{\"1\":{\"250\":1}}],[\"这样就可以立即消费到最新的消息\",{\"1\":{\"323\":1}}],[\"这样就无需有内核态再往用户态的拷贝\",{\"1\":{\"400\":1}}],[\"这样就节省了从磁盘上读取数据的时间\",{\"1\":{\"399\":1}}],[\"这样就带来了较大且不稳定的内存消耗\",{\"1\":{\"214\":1}}],[\"这样就出现了数据丢失\",{\"1\":{\"192\":1}}],[\"这样数据全部保留不会丢失\",{\"1\":{\"192\":1}}],[\"这样\",{\"1\":{\"155\":2,\"166\":1,\"211\":1,\"399\":1,\"445\":1,\"708\":1,\"775\":1,\"807\":1,\"811\":1}}],[\"这里针对普通消息\",{\"1\":{\"780\":1}}],[\"这里\",{\"1\":{\"773\":1}}],[\"这里就可以用到定时消息\",{\"1\":{\"773\":1}}],[\"这里就存在并发问题\",{\"1\":{\"735\":1}}],[\"这里就存在\",{\"1\":{\"616\":1}}],[\"这里我分为\",{\"1\":{\"772\":1}}],[\"这里有引入了如下痛点\",{\"1\":{\"769\":1}}],[\"这里为\",{\"1\":{\"732\":1}}],[\"这里为0\",{\"1\":{\"402\":1}}],[\"这里讲解集群模式下消费进度的更新流程\",{\"1\":{\"711\":1}}],[\"这里都使用了内存缓存\",{\"1\":{\"710\":1}}],[\"这里用到了代理模式\",{\"1\":{\"638\":1}}],[\"这里使用了代理模式\",{\"1\":{\"629\":1}}],[\"这里所说的顺序消费指的是队列维度的顺序\",{\"1\":{\"622\":1}}],[\"这里地延迟重试采用了\",{\"1\":{\"620\":1}}],[\"这里面涉及到许多消费模式和特性\",{\"1\":{\"606\":1}}],[\"这里面存的是真正投递时间\",{\"1\":{\"365\":1}}],[\"这里以消费者为例\",{\"1\":{\"538\":1}}],[\"这里以生产者为例\",{\"1\":{\"531\":1}}],[\"这里以持久化消息为例\",{\"1\":{\"223\":1}}],[\"这里没有直接覆盖全局配置\",{\"1\":{\"518\":1}}],[\"这里没有用\",{\"1\":{\"361\":1}}],[\"这里需要注意以下几点\",{\"1\":{\"518\":1}}],[\"这里需要引入第二个线程\",{\"1\":{\"453\":1}}],[\"这里也没有多线程的情况\",{\"1\":{\"429\":1}}],[\"这里也会发送一个\",{\"1\":{\"332\":1}}],[\"这里引入了\",{\"1\":{\"411\":1}}],[\"这里引入了一个阻塞队列作为异步投递任务的容器\",{\"1\":{\"375\":1}}],[\"这里转换成小时\",{\"1\":{\"390\":1}}],[\"这里按异步讲解\",{\"1\":{\"377\":1}}],[\"这里直接纠正下一次定时任务的offset为当前定时任务队列的最小值\",{\"1\":{\"365\":1}}],[\"这里调用了\",{\"1\":{\"347\":1}}],[\"这里会加大查询消息错误的概率\",{\"1\":{\"317\":1}}],[\"这里key可以有多个\",{\"1\":{\"314\":1}}],[\"这里存在\",{\"1\":{\"306\":1}}],[\"这里不再使用共同的这个解析器\",{\"1\":{\"262\":1}}],[\"这里要注意的是ha\",{\"1\":{\"192\":1}}],[\"这里如果是\",{\"1\":{\"177\":1}}],[\"这里to是发送者\",{\"1\":{\"159\":1}}],[\"这里更新了进程字典中credit\",{\"1\":{\"158\":1}}],[\"这里是rabbit\",{\"1\":{\"157\":1,\"158\":1}}],[\"这里的处理队列指\",{\"1\":{\"657\":1}}],[\"这里的作用是\",{\"1\":{\"481\":1}}],[\"这里的优化点就是想办法把这个方法逻辑从构建消费索引的逻辑中抽离出去\",{\"1\":{\"434\":1}}],[\"这里的强制删除并不会马上删除未过期的文件\",{\"1\":{\"386\":1}}],[\"这里的\",{\"1\":{\"386\":1,\"526\":1}}],[\"这里的逻辑下标的含义跟\",{\"1\":{\"307\":1}}],[\"这里的逻辑是\",{\"1\":{\"157\":1}}],[\"这里的信用指的时发送许可\",{\"1\":{\"197\":1}}],[\"这里的pid是\",{\"1\":{\"157\":1}}],[\"这里的进程与操作系统的进程不同\",{\"1\":{\"156\":1}}],[\"这里的mfa是一个\",{\"1\":{\"111\":1}}],[\"这里指\",{\"1\":{\"9\":1}}],[\"这种情况下不能贸然释放\",{\"1\":{\"735\":1}}],[\"这种情况可以在方法中自行覆盖参数\",{\"1\":{\"123\":1}}],[\"这种发送方式性能最高\",{\"1\":{\"547\":1}}],[\"这种方式相比于同步发送\",{\"1\":{\"547\":1}}],[\"这种方式最为可靠\",{\"1\":{\"547\":1}}],[\"这种\",{\"1\":{\"293\":1}}],[\"这种高性能中间件来说\",{\"1\":{\"242\":1}}],[\"这种复杂性增加了系统状态可观测性的难度\",{\"1\":{\"126\":1}}],[\"这种调用形式要比apply好得多\",{\"1\":{\"50\":1}}],[\"这种函数式编程语言的不可变状态\",{\"1\":{\"23\":1}}],[\"这些队列的数量可能非常多\",{\"1\":{\"804\":1}}],[\"这些生产者和消费者的元数据配置是相同的\",{\"1\":{\"755\":1}}],[\"这些方法都是数据统计用的\",{\"1\":{\"428\":1}}],[\"这些特性在仲裁队列的第一个版本中不会提供\",{\"1\":{\"231\":1}}],[\"这些是\",{\"1\":{\"177\":1}}],[\"这些无不昭示着这一产业在飞速发展\",{\"1\":{\"126\":1}}],[\"这些文件\",{\"1\":{\"41\":1}}],[\"这些表达式以逗号分隔\",{\"1\":{\"36\":1}}],[\"这些问题会更频繁地出现\",{\"1\":{\"2\":1}}],[\"这符合了\",{\"1\":{\"23\":1}}],[\"这个结构里的\",{\"1\":{\"880\":1}}],[\"这个配置默认为\",{\"1\":{\"828\":1}}],[\"这个特性主要是为了支持在一些消息场景下可能存在的大量队列场景\",{\"1\":{\"804\":1}}],[\"这个过程称为\",{\"1\":{\"771\":1}}],[\"这个实现可能导致消费线程池中多个线程同时等待一把锁\",{\"1\":{\"727\":1}}],[\"这个实现方案太重了\",{\"1\":{\"462\":1}}],[\"这个线程仅仅是异步发送自动拉取请求\",{\"1\":{\"675\":1}}],[\"这个线程每\",{\"1\":{\"384\":1}}],[\"这个拉取请求中保存一个处理队列\",{\"1\":{\"624\":1}}],[\"这个脚本预留了定义额外的\",{\"1\":{\"600\":1}}],[\"这个地方\",{\"1\":{\"592\":1}}],[\"这个项目提供了\",{\"1\":{\"589\":1}}],[\"这个异步线程池批量将轨迹信息打包发送给\",{\"1\":{\"531\":1}}],[\"这个简单的场景涉及了几个概念\",{\"1\":{\"498\":1}}],[\"这个集合保存在内存中可能会造成内存泄漏\",{\"1\":{\"455\":1}}],[\"这个阻塞队列的长度就代表着同时可以的进行异步投递任务的数量\",{\"1\":{\"453\":1}}],[\"这个回调的触发可以用分布式定时任务来处理\",{\"1\":{\"441\":1,\"871\":1}}],[\"这个方案的局限性在于扫描的每个队列的消息延迟时间必须是相同的\",{\"1\":{\"876\":1}}],[\"这个方案是实际提交的优化方案\",{\"1\":{\"436\":1}}],[\"这个方法用于推模式的消费\",{\"1\":{\"707\":1}}],[\"这个方法用于创建消息的全局唯一\",{\"1\":{\"419\":1}}],[\"这个方法中包含了消息发送的核心逻辑\",{\"1\":{\"558\":1}}],[\"这个方法中根据topic和queueid查询相应的consumequeue\",{\"1\":{\"277\":1}}],[\"这个方法具体在\",{\"1\":{\"434\":1}}],[\"这个方法试图从\",{\"1\":{\"416\":1}}],[\"这个方法被客户端在发送消息时调用\",{\"1\":{\"416\":1}}],[\"这个方法占用了\",{\"1\":{\"416\":1}}],[\"这个方法会先释放\",{\"1\":{\"390\":1}}],[\"这个方法是重新唤醒拉取请求的核心方法\",{\"1\":{\"345\":1}}],[\"这个方法在两个地方被调用\",{\"1\":{\"345\":1}}],[\"这个修改将消费\",{\"1\":{\"433\":1}}],[\"这个修改可以提升\",{\"1\":{\"430\":1}}],[\"这个类仅定义了\",{\"1\":{\"509\":1}}],[\"这个类\",{\"1\":{\"417\":1}}],[\"这个类扩展了\",{\"1\":{\"360\":1}}],[\"这个提交优化了\",{\"1\":{\"414\":1}}],[\"这个读的过程就会比较慢\",{\"1\":{\"399\":1}}],[\"这个任务不是周期性任务\",{\"1\":{\"378\":1}}],[\"这个任务的\",{\"1\":{\"377\":1}}],[\"这个任务并不是周期性任务\",{\"1\":{\"377\":1}}],[\"这个改动将延迟消息的任务调度器从\",{\"1\":{\"372\":1}}],[\"这个解析\",{\"1\":{\"262\":1,\"410\":1}}],[\"这个消息\",{\"1\":{\"256\":1}}],[\"这个优化是本批次修改里面改动最大的\",{\"1\":{\"256\":1}}],[\"这个优化比较简单\",{\"1\":{\"242\":1}}],[\"这个锁里面干的事情非常的多\",{\"1\":{\"256\":1}}],[\"这个锁也就是影响\",{\"1\":{\"253\":1,\"256\":1}}],[\"这个参数改成\",{\"1\":{\"255\":1}}],[\"这个问题同样使节点的滚动升级存在很大的隐患\",{\"1\":{\"226\":1}}],[\"这个问题也引发滚动升级的问题\",{\"1\":{\"211\":1}}],[\"这个时候\",{\"1\":{\"206\":1}}],[\"这个组的信息会记录在\",{\"1\":{\"206\":1}}],[\"这个设置非常保守\",{\"1\":{\"190\":1}}],[\"这个节点上的所有队列都不再可用\",{\"1\":{\"181\":1}}],[\"这个包\",{\"1\":{\"178\":1}}],[\"这个\",{\"1\":{\"159\":1,\"251\":1,\"507\":1,\"510\":1,\"532\":1}}],[\"这个接收进程就阻塞在receive方法上\",{\"1\":{\"158\":1}}],[\"这个内置函数\",{\"1\":{\"111\":1}}],[\"这个函数的作用是指示\",{\"1\":{\"43\":1}}],[\"这个函数的作用是抛出一个调用者可能想要捕捉的异常错误\",{\"1\":{\"43\":1}}],[\"这个操作就会失败\",{\"1\":{\"42\":1}}],[\"这个操作总是成功的\",{\"1\":{\"42\":1}}],[\"这个列表包含了代表字符串里各个字符的整数字符代码\",{\"1\":{\"28\":1}}],[\"这个变量具有那个值\",{\"1\":{\"23\":1}}],[\"这个图片可以帮助快速查阅\",{\"1\":{\"12\":1}}],[\"sndbuf\",{\"1\":{\"820\":1}}],[\"snapshot\",{\"1\":{\"462\":1,\"691\":1}}],[\"sname\",{\"1\":{\"102\":1}}],[\"sb\",{\"1\":{\"755\":7}}],[\"small\",{\"1\":{\"693\":2,\"694\":1,\"695\":1,\"790\":1}}],[\"sdk\",{\"1\":{\"755\":1}}],[\"sd\",{\"1\":{\"690\":5}}],[\"ssl\",{\"1\":{\"481\":2,\"594\":1}}],[\"sslcontext\",{\"1\":{\"481\":2}}],[\"skip\",{\"1\":{\"381\":3,\"414\":1,\"540\":2,\"786\":1,\"798\":1,\"799\":2,\"800\":3}}],[\"slow\",{\"1\":{\"693\":1}}],[\"slotvalue\",{\"1\":{\"317\":10}}],[\"slotpos\",{\"1\":{\"317\":4}}],[\"slot\",{\"1\":{\"307\":3}}],[\"slice\",{\"1\":{\"402\":1,\"694\":1}}],[\"slicebytebuffer\",{\"1\":{\"291\":2}}],[\"sleep\",{\"1\":{\"381\":2,\"390\":1,\"391\":1,\"402\":1,\"798\":2,\"808\":1,\"817\":2}}],[\"slave收到数据后保存到自己的commitlog\",{\"1\":{\"249\":1}}],[\"slave\",{\"1\":{\"205\":2,\"249\":4,\"282\":1,\"347\":1,\"360\":1,\"406\":1,\"430\":1,\"432\":1,\"485\":1,\"491\":2,\"693\":3,\"720\":1,\"793\":2,\"798\":1,\"799\":1,\"800\":1,\"817\":1}}],[\"swapout\",{\"1\":{\"402\":1}}],[\"swap\",{\"1\":{\"402\":2}}],[\"swaprequests\",{\"1\":{\"245\":2}}],[\"switchpop\",{\"1\":{\"768\":3}}],[\"switch\",{\"1\":{\"284\":1,\"314\":1,\"339\":1,\"381\":1,\"491\":1,\"540\":2,\"567\":1,\"568\":1,\"570\":1,\"573\":1,\"642\":2,\"643\":1,\"663\":1,\"664\":1,\"692\":1,\"693\":4,\"695\":1,\"715\":2,\"718\":1,\"744\":1,\"749\":1,\"786\":1,\"850\":1}}],[\"svg\",{\"1\":{\"276\":1,\"326\":1,\"332\":1}}],[\"same\",{\"1\":{\"491\":1,\"693\":2}}],[\"sample\",{\"1\":{\"7\":1}}],[\"salve连接到master\",{\"1\":{\"249\":1}}],[\"save\",{\"1\":{\"240\":2,\"576\":1,\"817\":2}}],[\"soon\",{\"1\":{\"390\":1}}],[\"sortlist\",{\"1\":{\"799\":2}}],[\"sortedmap<string\",{\"1\":{\"515\":2}}],[\"sortedmap\",{\"1\":{\"515\":1}}],[\"sort\",{\"1\":{\"313\":1,\"515\":1,\"663\":2,\"786\":2}}],[\"so\",{\"1\":{\"179\":1,\"365\":1,\"380\":1,\"664\":1,\"690\":4,\"694\":2,\"745\":1,\"748\":1,\"750\":2,\"817\":1,\"820\":1}}],[\"socat\",{\"1\":{\"178\":4}}],[\"sock\",{\"1\":{\"158\":3}}],[\"socketaddress2bytebuffer\",{\"1\":{\"257\":2,\"258\":2}}],[\"socket\",{\"1\":{\"147\":1,\"154\":1,\"201\":1,\"600\":1,\"820\":1}}],[\"sources\",{\"1\":{\"177\":1}}],[\"solutions\",{\"1\":{\"175\":1,\"177\":1}}],[\"solution\",{\"1\":{\"175\":1,\"177\":1}}],[\"somefunction\",{\"1\":{\"57\":1}}],[\"somemodule\",{\"1\":{\"57\":1}}],[\"sometag\",{\"1\":{\"54\":2}}],[\"some\",{\"1\":{\"46\":1,\"58\":1,\"102\":1,\"103\":1,\"240\":4,\"252\":1,\"256\":2,\"406\":1,\"576\":1}}],[\"someexpression时\",{\"1\":{\"23\":1}}],[\"src\",{\"1\":{\"122\":1}}],[\"scantimes\",{\"1\":{\"797\":2}}],[\"scantimes++\",{\"1\":{\"797\":1}}],[\"scancommitoffset\",{\"1\":{\"797\":1}}],[\"scan\",{\"0\":{\"797\":1},\"1\":{\"782\":1,\"797\":1,\"798\":2}}],[\"scannotactivebroker\",{\"1\":{\"481\":1}}],[\"scarb\",{\"1\":{\"105\":5}}],[\"schedulenexttimertask\",{\"1\":{\"380\":5}}],[\"scheduleatfixedrate\",{\"1\":{\"364\":2,\"389\":1,\"481\":2,\"568\":5,\"721\":1}}],[\"schedulemessagetimerthread\",{\"1\":{\"364\":1}}],[\"schedulemessageservice的内部类\",{\"1\":{\"361\":1}}],[\"schedulemessageservice\",{\"0\":{\"360\":1,\"364\":1},\"1\":{\"356\":1,\"363\":1,\"364\":1,\"365\":12,\"376\":1,\"380\":7,\"381\":7}}],[\"schedule\",{\"1\":{\"356\":1,\"363\":1,\"364\":1,\"365\":7,\"380\":4,\"381\":1,\"484\":1,\"568\":1,\"718\":1,\"721\":1}}],[\"scheduledtask\",{\"1\":{\"568\":5}}],[\"scheduledexecutorservice\",{\"1\":{\"360\":1,\"370\":1,\"372\":2,\"389\":1,\"481\":3,\"568\":5,\"721\":1}}],[\"scheduled\",{\"1\":{\"350\":1,\"369\":1,\"438\":1,\"450\":2,\"873\":1}}],[\"schema\",{\"1\":{\"102\":2,\"103\":1}}],[\"screen\",{\"1\":{\"287\":1,\"694\":1}}],[\"score\",{\"1\":{\"11\":2,\"261\":1}}],[\"scope\",{\"1\":{\"9\":1}}],[\"spongecaptain\",{\"1\":{\"858\":1}}],[\"spi\",{\"1\":{\"510\":1,\"516\":1}}],[\"spend\",{\"1\":{\"851\":1}}],[\"speed\",{\"1\":{\"406\":1,\"433\":1}}],[\"specified\",{\"1\":{\"568\":1,\"643\":1,\"789\":1}}],[\"specifying\",{\"1\":{\"807\":1}}],[\"specify\",{\"1\":{\"567\":1,\"642\":1}}],[\"spec\",{\"1\":{\"73\":2,\"91\":1}}],[\"splitter\",{\"1\":{\"816\":2,\"817\":2}}],[\"splitor\",{\"1\":{\"541\":2}}],[\"split性能更好的方法\",{\"1\":{\"263\":1}}],[\"split\",{\"1\":{\"261\":2,\"314\":1,\"343\":1,\"541\":1,\"790\":2,\"793\":1,\"807\":1,\"816\":1,\"817\":2}}],[\"span\",{\"1\":{\"690\":1}}],[\"spacefull\",{\"1\":{\"390\":5}}],[\"space\",{\"1\":{\"176\":1,\"257\":3,\"285\":1,\"390\":1,\"402\":1}}],[\"spawn\",{\"1\":{\"79\":2,\"80\":2,\"85\":1}}],[\"springframework\",{\"1\":{\"116\":4}}],[\"spring\",{\"0\":{\"115\":1,\"116\":1},\"1\":{\"116\":1,\"119\":1,\"122\":7,\"123\":1,\"524\":1}}],[\"sqs\",{\"1\":{\"442\":1}}],[\"sqlfilter\",{\"1\":{\"841\":1}}],[\"sqlfiltertest\",{\"1\":{\"829\":1,\"830\":2}}],[\"sql92\",{\"0\":{\"821\":1,\"828\":1,\"835\":1,\"840\":1,\"849\":1},\"1\":{\"637\":1,\"690\":1,\"693\":1,\"823\":2,\"828\":3,\"830\":1,\"835\":3,\"837\":2,\"838\":4,\"841\":4,\"842\":1,\"847\":1,\"850\":1,\"851\":1,\"852\":4,\"884\":1}}],[\"sql\",{\"0\":{\"841\":1},\"1\":{\"103\":4,\"841\":2}}],[\"sqrt\",{\"1\":{\"46\":3}}],[\"squarerootnegativeargument\",{\"1\":{\"46\":1}}],[\"square\",{\"1\":{\"30\":4}}],[\"sure\",{\"1\":{\"787\":1}}],[\"surprise\",{\"1\":{\"28\":2}}],[\"suc\",{\"1\":{\"789\":1}}],[\"such\",{\"1\":{\"599\":1}}],[\"succeed\",{\"1\":{\"519\":1}}],[\"success\",{\"1\":{\"381\":2,\"493\":1,\"505\":1,\"527\":1,\"528\":1,\"693\":4,\"715\":5,\"718\":2,\"750\":4,\"768\":1,\"789\":1,\"793\":1}}],[\"suggestbrokerid=\",{\"1\":{\"693\":2}}],[\"suggesttodo\",{\"1\":{\"493\":1,\"567\":2,\"570\":1,\"642\":2,\"693\":4,\"718\":1}}],[\"suggested\",{\"1\":{\"176\":1}}],[\"sun\",{\"1\":{\"402\":1}}],[\"super\",{\"1\":{\"364\":1}}],[\"support\",{\"1\":{\"406\":1,\"425\":1,\"691\":1,\"693\":1,\"801\":1,\"883\":3}}],[\"supported\",{\"1\":{\"262\":1}}],[\"supplier<string>\",{\"1\":{\"258\":1}}],[\"supplier\",{\"1\":{\"258\":4}}],[\"suspendcurrentqueuetimemillis\",{\"1\":{\"761\":1}}],[\"suspend\",{\"1\":{\"690\":4,\"750\":3}}],[\"suspend=n\",{\"1\":{\"600\":1}}],[\"suspendtimeoutmillislong\",{\"1\":{\"339\":1,\"693\":2}}],[\"suspendpullrequest\",{\"0\":{\"342\":1},\"1\":{\"332\":1,\"335\":1,\"339\":1,\"342\":1,\"693\":1}}],[\"sub=\",{\"1\":{\"852\":1}}],[\"subversion\",{\"1\":{\"691\":3}}],[\"subtable\",{\"1\":{\"662\":3}}],[\"subexpression\",{\"1\":{\"637\":1,\"690\":4,\"691\":3}}],[\"subaftercontext\",{\"1\":{\"540\":10}}],[\"subafter\",{\"1\":{\"537\":1,\"540\":1}}],[\"subbeforecontext\",{\"1\":{\"540\":8}}],[\"subbefore\",{\"1\":{\"537\":1,\"540\":2}}],[\"sub\",{\"1\":{\"498\":2,\"503\":3,\"847\":1}}],[\"submitconsumerequestlater\",{\"1\":{\"714\":2,\"715\":1,\"750\":1}}],[\"submitconsumerequest\",{\"1\":{\"624\":1,\"639\":1,\"695\":1,\"707\":1,\"708\":1,\"714\":1,\"749\":1}}],[\"submit\",{\"1\":{\"340\":1,\"541\":1,\"714\":2}}],[\"subscriptiongroupconfig\",{\"1\":{\"693\":9,\"718\":7}}],[\"subscription\",{\"1\":{\"665\":2,\"690\":2,\"693\":14,\"718\":3,\"767\":1}}],[\"subscriptioninner\",{\"1\":{\"653\":1,\"665\":1}}],[\"subscriptiondatalist\",{\"1\":{\"850\":2}}],[\"subscriptiondata>\",{\"1\":{\"662\":2}}],[\"subscriptiondata\",{\"1\":{\"339\":1,\"665\":4,\"690\":6,\"693\":14,\"695\":1,\"749\":1,\"837\":1,\"847\":6,\"848\":6,\"852\":7}}],[\"subscribe\",{\"1\":{\"505\":1,\"527\":1,\"637\":1,\"656\":1,\"768\":1,\"827\":2,\"830\":2}}],[\"substring\",{\"1\":{\"261\":2}}],[\"sub系统的投递语义与推送效率\",{\"1\":{\"128\":1}}],[\"sufficient\",{\"1\":{\"257\":1}}],[\"sudo\",{\"1\":{\"176\":1,\"177\":2,\"179\":2}}],[\"summary\",{\"1\":{\"605\":1}}],[\"summer\",{\"1\":{\"136\":1}}],[\"sum\",{\"0\":{\"33\":1},\"1\":{\"33\":4}}],[\"simpleconsumer\",{\"1\":{\"830\":1}}],[\"simplified\",{\"1\":{\"147\":2,\"154\":2}}],[\"since\",{\"1\":{\"576\":1}}],[\"single\",{\"1\":{\"240\":1,\"256\":1}}],[\"signature\",{\"1\":{\"515\":3,\"520\":4}}],[\"sig后再无太大动静\",{\"1\":{\"126\":1}}],[\"side\",{\"1\":{\"30\":6,\"406\":1,\"801\":1}}],[\"size=\",{\"1\":{\"690\":2}}],[\"sizepy=\",{\"1\":{\"365\":2,\"380\":1,\"694\":1}}],[\"sizepy\",{\"1\":{\"287\":2,\"365\":5,\"380\":8,\"694\":4}}],[\"size之间有一个快速的网络\",{\"1\":{\"191\":1}}],[\"size\",{\"1\":{\"22\":1,\"257\":9,\"282\":2,\"285\":8,\"287\":2,\"291\":8,\"313\":1,\"314\":3,\"317\":5,\"365\":3,\"380\":4,\"390\":1,\"402\":3,\"490\":2,\"514\":2,\"518\":4,\"519\":2,\"540\":3,\"541\":1,\"572\":4,\"592\":1,\"663\":3,\"665\":1,\"690\":1,\"694\":4,\"695\":1,\"714\":4,\"715\":8,\"742\":2,\"749\":1,\"787\":5,\"789\":1,\"790\":3,\"795\":1,\"797\":1,\"798\":1,\"848\":1,\"851\":1,\"852\":1}}],[\"share\",{\"1\":{\"767\":1,\"787\":1}}],[\"sh\",{\"1\":{\"592\":4,\"594\":10,\"595\":5,\"597\":5,\"599\":11,\"600\":6,\"601\":2,\"603\":2,\"604\":2}}],[\"shutdownhook\",{\"1\":{\"541\":1}}],[\"shutdownhookthread\",{\"1\":{\"480\":1}}],[\"shutdown\",{\"1\":{\"190\":1,\"192\":2,\"381\":1,\"386\":2,\"480\":2,\"481\":6,\"487\":1,\"504\":1,\"567\":1,\"642\":2,\"656\":2,\"694\":2}}],[\"shouldrunpoprevive\",{\"1\":{\"798\":1,\"799\":1,\"800\":1}}],[\"should\",{\"1\":{\"503\":1,\"573\":1,\"665\":1,\"786\":2,\"797\":1,\"852\":1}}],[\"shout\",{\"1\":{\"105\":2}}],[\"shortpollingtimemills\",{\"1\":{\"325\":1}}],[\"short\",{\"1\":{\"257\":4,\"816\":3}}],[\"shorthand\",{\"1\":{\"21\":1}}],[\"shows\",{\"1\":{\"139\":2}}],[\"shop\",{\"1\":{\"30\":1,\"33\":1,\"103\":42}}],[\"shell也是一个进程\",{\"1\":{\"80\":1}}],[\"shell打印某个列表的值时\",{\"1\":{\"28\":1}}],[\"shell\",{\"0\":{\"21\":1,\"93\":1},\"1\":{\"21\":4,\"30\":1,\"41\":3,\"45\":6,\"74\":2,\"80\":1}}],[\"sys\",{\"1\":{\"363\":1,\"365\":2,\"380\":2,\"484\":1,\"532\":1,\"718\":1,\"808\":2}}],[\"sysflaginner\",{\"1\":{\"691\":5}}],[\"sysflag\",{\"1\":{\"257\":2,\"258\":2,\"262\":1,\"573\":4,\"690\":2,\"691\":3}}],[\"systemclock\",{\"1\":{\"344\":2}}],[\"system\",{\"1\":{\"21\":2,\"81\":1,\"242\":1,\"289\":1,\"313\":1,\"345\":1,\"365\":1,\"380\":1,\"390\":1,\"402\":1,\"414\":1,\"420\":1,\"480\":7,\"491\":1,\"504\":1,\"505\":2,\"526\":1,\"527\":2,\"528\":1,\"537\":1,\"539\":1,\"540\":2,\"570\":3,\"573\":4,\"665\":1,\"690\":2,\"693\":3,\"695\":1,\"715\":3,\"718\":5,\"742\":2,\"746\":1,\"749\":1,\"750\":4,\"760\":1,\"768\":2,\"789\":1,\"793\":1,\"795\":1,\"796\":1,\"797\":2,\"798\":4,\"800\":1,\"808\":1,\"819\":2,\"829\":1,\"851\":1,\"873\":1}}],[\"synchronously\",{\"1\":{\"720\":1}}],[\"synchronize\",{\"1\":{\"11\":1}}],[\"synchronized\",{\"1\":{\"2\":1,\"246\":1,\"253\":1,\"541\":1,\"568\":1,\"642\":1,\"643\":1,\"750\":1}}],[\"syncdeliver\",{\"1\":{\"380\":1}}],[\"synced\",{\"1\":{\"192\":2}}],[\"sync\",{\"1\":{\"185\":2,\"186\":1,\"187\":1,\"191\":2,\"240\":1,\"256\":1,\"373\":1,\"402\":3,\"547\":1,\"570\":2,\"573\":2,\"692\":1,\"693\":1}}],[\"search\",{\"1\":{\"593\":1}}],[\"searchliveinfo\",{\"1\":{\"116\":1}}],[\"sessioncredentials\",{\"1\":{\"504\":1,\"505\":1,\"515\":6}}],[\"second\",{\"1\":{\"599\":1,\"798\":3,\"799\":1}}],[\"seconds\",{\"1\":{\"481\":1,\"599\":11}}],[\"security\",{\"1\":{\"515\":2}}],[\"securitytoken\",{\"1\":{\"515\":5}}],[\"secure\",{\"1\":{\"21\":1}}],[\"secret\",{\"1\":{\"503\":1,\"504\":2,\"505\":2}}],[\"secretkey\",{\"1\":{\"498\":1,\"503\":3,\"507\":1}}],[\"separator\",{\"1\":{\"313\":1,\"314\":1,\"343\":1,\"721\":1}}],[\"serializetypecurrentrpc\",{\"1\":{\"413\":1,\"414\":2}}],[\"serializetypeconfiginthisserver\",{\"1\":{\"413\":1}}],[\"serializetype\",{\"1\":{\"413\":3,\"414\":2}}],[\"serialize\",{\"1\":{\"257\":2,\"414\":1}}],[\"series\",{\"1\":{\"175\":1}}],[\"serving\",{\"1\":{\"795\":1,\"796\":1,\"797\":1}}],[\"servicestate\",{\"1\":{\"567\":8,\"568\":5,\"642\":8,\"643\":5}}],[\"serviceprovider\",{\"1\":{\"516\":2}}],[\"service\",{\"1\":{\"344\":3,\"510\":1,\"516\":2,\"519\":3,\"567\":2,\"568\":3,\"595\":1,\"598\":1,\"642\":2,\"660\":2,\"688\":3}}],[\"servicethread\",{\"1\":{\"244\":1,\"435\":1,\"660\":2}}],[\"server1\",{\"1\":{\"807\":1,\"808\":1}}],[\"serverv\",{\"1\":{\"693\":1}}],[\"server=y\",{\"1\":{\"600\":1}}],[\"serverutil\",{\"1\":{\"480\":3}}],[\"server\",{\"1\":{\"178\":8,\"179\":2,\"463\":1,\"467\":4,\"469\":1,\"470\":1,\"473\":1,\"480\":10,\"481\":2,\"488\":1,\"490\":4,\"491\":2,\"493\":1,\"568\":1,\"600\":5,\"640\":1,\"643\":1,\"680\":1,\"801\":1}}],[\"server2\",{\"1\":{\"157\":2,\"807\":1,\"808\":1}}],[\"serverless设计理念也在不断被一些分布式系统设计者逐步接受\",{\"1\":{\"126\":1}}],[\"sending\",{\"1\":{\"576\":1,\"717\":1,\"718\":2}}],[\"sendprocessor\",{\"1\":{\"575\":7}}],[\"sendstatus\",{\"1\":{\"570\":1}}],[\"sendcallback\",{\"1\":{\"570\":4,\"573\":4}}],[\"sendheartbeattoallbroker\",{\"1\":{\"568\":1}}],[\"sendheartbeattoallbrokerwithlock\",{\"1\":{\"567\":1,\"568\":1,\"642\":1,\"665\":1}}],[\"sendkernelimpl\",{\"1\":{\"562\":1,\"570\":2,\"573\":3}}],[\"sendlatencyfaultenable=true\",{\"1\":{\"572\":1}}],[\"sendlatencyfaultenable=false\",{\"1\":{\"572\":1}}],[\"sendlatencyfaultenable\",{\"1\":{\"561\":1,\"572\":1,\"754\":1}}],[\"senddefaultimpl\",{\"1\":{\"558\":1,\"560\":1,\"570\":1}}],[\"sendtracedata\",{\"1\":{\"541\":2}}],[\"sendtime\",{\"1\":{\"528\":1}}],[\"sendwhichqueue\",{\"1\":{\"541\":1,\"572\":1}}],[\"sendresult\",{\"1\":{\"504\":3,\"526\":3,\"570\":8,\"573\":7,\"807\":2,\"826\":2,\"829\":3,\"873\":1}}],[\"sendmessageprossor\",{\"1\":{\"708\":1}}],[\"sendmessageprocessor\",{\"1\":{\"563\":1,\"575\":4,\"576\":2,\"581\":1,\"718\":1}}],[\"sendmessageback\",{\"1\":{\"637\":1,\"707\":1,\"708\":2,\"715\":1,\"717\":5}}],[\"sendmessageresponseheader\",{\"1\":{\"576\":2}}],[\"sendmessagerequestheader\",{\"1\":{\"573\":2,\"576\":1}}],[\"sendmessagerequestheaderv2\",{\"1\":{\"240\":1,\"262\":7,\"410\":1,\"411\":1}}],[\"sendmessagehooklist\",{\"1\":{\"575\":1}}],[\"sendmessage\",{\"1\":{\"573\":2}}],[\"sendmessagecontext\",{\"1\":{\"573\":2,\"576\":1}}],[\"sendmessagewithvipchannel=\",{\"1\":{\"567\":1}}],[\"sendmessageexecutor\",{\"1\":{\"563\":1,\"575\":5}}],[\"sendmessageasync\",{\"1\":{\"560\":1}}],[\"sendmessagetracehookimpl\",{\"1\":{\"534\":1}}],[\"sendmessagethreadpoolnums\",{\"1\":{\"240\":1,\"252\":1,\"253\":1,\"254\":2}}],[\"send\",{\"1\":{\"157\":6,\"355\":1,\"406\":1,\"425\":1,\"504\":1,\"526\":1,\"539\":1,\"543\":1,\"570\":1,\"575\":4,\"717\":1,\"807\":2,\"826\":1,\"829\":1,\"873\":1}}],[\"sent\",{\"1\":{\"21\":1,\"157\":1}}],[\"see\",{\"1\":{\"139\":1}}],[\"seldom\",{\"1\":{\"223\":1}}],[\"selectorparser\",{\"1\":{\"841\":4}}],[\"selectonemessagequeue\",{\"1\":{\"561\":1,\"570\":2,\"572\":7}}],[\"selectbrokeraddr\",{\"1\":{\"768\":1}}],[\"selecttopicconfig\",{\"1\":{\"576\":1,\"693\":1,\"789\":2,\"799\":1}}],[\"selectphyoffset\",{\"1\":{\"309\":1,\"310\":1,\"314\":1,\"317\":3}}],[\"selectresult\",{\"1\":{\"287\":2,\"694\":5}}],[\"selectmappedbufferresult\",{\"1\":{\"282\":1,\"287\":2,\"365\":1,\"380\":1,\"694\":2,\"790\":1}}],[\"selecting\",{\"1\":{\"176\":1,\"572\":1}}],[\"select\",{\"1\":{\"103\":6}}],[\"selected\",{\"1\":{\"21\":2}}],[\"self\",{\"1\":{\"80\":1,\"85\":1,\"158\":1,\"159\":2,\"160\":1,\"484\":1,\"798\":1}}],[\"seq2\",{\"1\":{\"38\":1}}],[\"seq1\",{\"1\":{\"38\":2}}],[\"sequence\",{\"1\":{\"36\":1,\"276\":1,\"332\":1,\"414\":1}}],[\"seq\",{\"1\":{\"34\":3}}],[\"setvipchannelenabled\",{\"1\":{\"808\":1}}],[\"setwaitstoremsgok\",{\"1\":{\"718\":1}}],[\"setqueueoffset\",{\"1\":{\"691\":1,\"816\":1}}],[\"setqueueid\",{\"1\":{\"363\":1,\"572\":1,\"573\":1,\"576\":1,\"691\":1,\"693\":2,\"718\":1,\"720\":1,\"793\":3,\"800\":1}}],[\"setphysicmsgtimestamp\",{\"1\":{\"817\":1}}],[\"setpoptime\",{\"1\":{\"789\":1,\"793\":1}}],[\"setpreviouslylocked\",{\"1\":{\"690\":1,\"748\":1}}],[\"setprops\",{\"1\":{\"715\":1,\"750\":1}}],[\"setproperties\",{\"1\":{\"573\":1,\"576\":1,\"717\":1,\"718\":1,\"800\":1}}],[\"setpropertiesstring\",{\"1\":{\"363\":1,\"576\":3,\"718\":2,\"793\":1,\"800\":1}}],[\"setproperty\",{\"1\":{\"414\":1,\"480\":1}}],[\"setprocessqueue\",{\"1\":{\"664\":1,\"744\":1}}],[\"setproducergroup\",{\"1\":{\"573\":2}}],[\"setproducer\",{\"1\":{\"573\":1}}],[\"setpullthresholdsizeforqueue\",{\"1\":{\"665\":1}}],[\"setpullthresholdforqueue\",{\"1\":{\"665\":1}}],[\"setnextbeginoffset\",{\"1\":{\"693\":1,\"694\":1}}],[\"setnextoffset\",{\"1\":{\"664\":1,\"690\":1,\"695\":3,\"744\":1,\"748\":1,\"749\":1}}],[\"setnamespace\",{\"1\":{\"573\":1,\"715\":1,\"750\":1}}],[\"setnamesrvaddr\",{\"1\":{\"504\":1,\"505\":1,\"526\":1,\"755\":2,\"807\":1,\"808\":1}}],[\"set<messagequeue>\",{\"1\":{\"636\":1,\"663\":3,\"664\":1,\"665\":2,\"720\":1,\"742\":4,\"744\":1,\"746\":1,\"786\":3}}],[\"set<string>>\",{\"1\":{\"492\":1}}],[\"set<string>>>\",{\"1\":{\"492\":1}}],[\"set<string>\",{\"1\":{\"491\":1,\"492\":1,\"768\":1}}],[\"set<string\",{\"1\":{\"469\":1,\"486\":1}}],[\"setunitname\",{\"1\":{\"755\":2}}],[\"setunitmode\",{\"1\":{\"573\":1}}],[\"setuniqid\",{\"1\":{\"573\":1}}],[\"setup\",{\"1\":{\"4\":1,\"9\":2,\"173\":1}}],[\"setsendmsgtimeout\",{\"1\":{\"753\":1}}],[\"setsendresult\",{\"1\":{\"573\":1}}],[\"setstartoffset\",{\"1\":{\"793\":1}}],[\"setstartoffsetinfo\",{\"1\":{\"789\":1}}],[\"setstatus\",{\"1\":{\"694\":1,\"715\":1,\"750\":1,\"789\":2}}],[\"setstorehost\",{\"1\":{\"576\":1,\"718\":1,\"793\":1,\"800\":1}}],[\"setstoretime\",{\"1\":{\"540\":1}}],[\"setsuggestpullingfromslave\",{\"1\":{\"694\":1}}],[\"setsuggestwhichbrokerid\",{\"1\":{\"693\":7}}],[\"setsubscription\",{\"1\":{\"691\":1}}],[\"setsubversion\",{\"1\":{\"665\":1,\"691\":1}}],[\"setsuspendtimeoutmillis\",{\"1\":{\"691\":1}}],[\"setsuccess\",{\"1\":{\"540\":1,\"715\":2,\"750\":2}}],[\"setsysflag\",{\"1\":{\"573\":1,\"691\":1,\"718\":1}}],[\"setregistertopics\",{\"1\":{\"808\":1}}],[\"setregionid\",{\"1\":{\"540\":2}}],[\"setreviveoffset\",{\"1\":{\"798\":1}}],[\"setreviveqid\",{\"1\":{\"789\":1}}],[\"setrestnum\",{\"1\":{\"789\":1}}],[\"setresponsecode\",{\"1\":{\"570\":2}}],[\"setreconsumetime\",{\"1\":{\"717\":1}}],[\"setreconsumetimes\",{\"1\":{\"573\":2,\"576\":1,\"715\":1,\"718\":1,\"800\":1}}],[\"setrequestid\",{\"1\":{\"540\":1}}],[\"setretrytimeswhensendasyncfailed\",{\"1\":{\"753\":1}}],[\"setretrytimeswhensendfailed\",{\"1\":{\"753\":1}}],[\"setretrytimes\",{\"1\":{\"540\":1}}],[\"setremark\",{\"1\":{\"493\":2,\"576\":1,\"693\":16,\"718\":10,\"789\":1}}],[\"setordercountinfo\",{\"1\":{\"789\":1}}],[\"setordertopicconf\",{\"1\":{\"493\":1}}],[\"setoriginmessageid\",{\"1\":{\"717\":1,\"718\":1}}],[\"setoffsetnew\",{\"1\":{\"693\":1}}],[\"setoffsetrequest\",{\"1\":{\"693\":1}}],[\"setoffsetstore\",{\"1\":{\"642\":1}}],[\"setopaque\",{\"1\":{\"340\":1,\"693\":1,\"793\":1}}],[\"setopts\",{\"1\":{\"158\":1}}],[\"settimestamp\",{\"1\":{\"540\":1}}],[\"settings\",{\"1\":{\"161\":1}}],[\"settracebeans\",{\"1\":{\"540\":2}}],[\"settracetype\",{\"1\":{\"540\":2}}],[\"settagscode\",{\"1\":{\"718\":1,\"817\":1}}],[\"settags\",{\"1\":{\"355\":1,\"540\":1,\"793\":1,\"800\":1,\"826\":2}}],[\"settopicconfigserializewrapper\",{\"1\":{\"490\":1}}],[\"settopic\",{\"1\":{\"355\":1,\"363\":1,\"540\":1,\"570\":1,\"573\":3,\"576\":1,\"691\":1,\"693\":2,\"717\":2,\"718\":1,\"720\":1,\"793\":2,\"800\":2}}],[\"setminoffset\",{\"1\":{\"693\":1,\"694\":1}}],[\"setmaxoffset\",{\"1\":{\"693\":1,\"694\":1}}],[\"setmaxmsgnums\",{\"1\":{\"691\":1}}],[\"setmaxreconsumetimes\",{\"1\":{\"573\":1,\"717\":1}}],[\"setmasteraddr\",{\"1\":{\"491\":1}}],[\"setmsgstoretime\",{\"1\":{\"817\":1}}],[\"setmsgoffsetinfo\",{\"1\":{\"789\":1}}],[\"setmsglist\",{\"1\":{\"715\":1,\"750\":1}}],[\"setmsgtype\",{\"1\":{\"573\":2}}],[\"setmsgid\",{\"1\":{\"540\":1}}],[\"setmqclientfactory\",{\"1\":{\"642\":1}}],[\"setmq\",{\"1\":{\"573\":1,\"715\":1,\"750\":1}}],[\"setmqtracecontext\",{\"1\":{\"540\":1}}],[\"setmessagebinary\",{\"1\":{\"848\":1}}],[\"setmessagerequestmoderequestbody\",{\"1\":{\"786\":5}}],[\"setmessagerequestmode\",{\"1\":{\"768\":1}}],[\"setmessagequeue\",{\"1\":{\"664\":1,\"693\":1,\"744\":1}}],[\"setmessagemodel\",{\"1\":{\"642\":1}}],[\"setmessage\",{\"1\":{\"573\":1}}],[\"setm\",{\"1\":{\"262\":1}}],[\"setlocked\",{\"1\":{\"746\":1}}],[\"setlogicsmsgtimestamp\",{\"1\":{\"289\":1,\"817\":1}}],[\"setlastlocktimestamp\",{\"1\":{\"746\":1}}],[\"setlastupdatetimestamp\",{\"1\":{\"742\":2}}],[\"setlastpulltimestamp\",{\"1\":{\"690\":1}}],[\"setlistenport\",{\"1\":{\"480\":1}}],[\"setl\",{\"1\":{\"262\":1}}],[\"setkeys\",{\"1\":{\"540\":1}}],[\"setk\",{\"1\":{\"262\":1}}],[\"setj\",{\"1\":{\"262\":1}}],[\"setinstancename\",{\"1\":{\"808\":1}}],[\"setinstanceid\",{\"1\":{\"573\":1}}],[\"setinvisibletime\",{\"1\":{\"789\":1}}],[\"setint\",{\"1\":{\"414\":3}}],[\"setindexmsgtimestamp\",{\"1\":{\"316\":1}}],[\"seti\",{\"1\":{\"262\":1}}],[\"setid\",{\"1\":{\"116\":1}}],[\"sethostconsumer\",{\"1\":{\"539\":1}}],[\"sethaserveraddr\",{\"1\":{\"490\":1,\"491\":1}}],[\"seth\",{\"1\":{\"262\":1}}],[\"setgetmessageentiretimemax\",{\"1\":{\"694\":1}}],[\"setgroupname\",{\"1\":{\"540\":2}}],[\"setg\",{\"1\":{\"262\":1}}],[\"setfilterbitmap\",{\"1\":{\"817\":1}}],[\"setfilterserverlist\",{\"1\":{\"490\":1}}],[\"setflag\",{\"1\":{\"573\":1,\"576\":1,\"717\":1,\"718\":1}}],[\"setflushedwhere\",{\"1\":{\"285\":1,\"291\":1}}],[\"setf\",{\"1\":{\"262\":1}}],[\"setexpressiontype\",{\"1\":{\"691\":1}}],[\"setendtimestamp\",{\"1\":{\"317\":1}}],[\"setendphyoffset\",{\"1\":{\"317\":1}}],[\"sete\",{\"1\":{\"262\":1}}],[\"setdropped\",{\"1\":{\"664\":2,\"695\":1,\"744\":2}}],[\"setdelaytimems\",{\"1\":{\"873\":1}}],[\"setdelaytimesec\",{\"1\":{\"873\":1}}],[\"setdelaytimelevel\",{\"1\":{\"355\":1,\"363\":1,\"717\":1,\"718\":2}}],[\"setdelivertimems\",{\"1\":{\"793\":1,\"873\":1}}],[\"setdefaulttopicqueuenums\",{\"1\":{\"573\":1}}],[\"setdefaulttopic\",{\"1\":{\"573\":1}}],[\"setdaemon\",{\"1\":{\"313\":1}}],[\"setd\",{\"1\":{\"262\":1}}],[\"setclientrebalance\",{\"1\":{\"768\":1}}],[\"setclientip\",{\"1\":{\"760\":1}}],[\"setclientid\",{\"1\":{\"742\":2,\"746\":1}}],[\"setclustername\",{\"1\":{\"490\":1}}],[\"setcosttime\",{\"1\":{\"540\":1}}],[\"setcode\",{\"1\":{\"493\":2,\"576\":1,\"693\":26,\"718\":10,\"789\":3}}],[\"setcommercialowner\",{\"1\":{\"693\":3}}],[\"setcommercialrcvsize\",{\"1\":{\"693\":1}}],[\"setcommercialrcvstats\",{\"1\":{\"693\":3}}],[\"setcommercialrcvtimes\",{\"1\":{\"693\":3}}],[\"setcommitoffset\",{\"1\":{\"691\":1,\"720\":1}}],[\"setcommittedwhere\",{\"1\":{\"285\":1,\"291\":1}}],[\"setcommunicationmode\",{\"1\":{\"573\":1}}],[\"setcompressed\",{\"1\":{\"490\":1}}],[\"setconsumertimeoutmilliswhensuspend\",{\"1\":{\"808\":1}}],[\"setconsumergroup\",{\"1\":{\"642\":1,\"664\":1,\"691\":1,\"693\":2,\"715\":1,\"720\":1,\"744\":1,\"746\":1,\"750\":1,\"793\":1,\"808\":1}}],[\"setconsumemode\",{\"1\":{\"767\":1,\"768\":1}}],[\"setconsumestarttimestamp\",{\"1\":{\"715\":1}}],[\"setconsumetimestamp\",{\"1\":{\"527\":1}}],[\"setconsumefromwhere\",{\"1\":{\"505\":1,\"527\":1,\"768\":1}}],[\"setcontextcode\",{\"1\":{\"540\":1}}],[\"setcontext\",{\"1\":{\"480\":1}}],[\"setconfigstorepath\",{\"1\":{\"480\":1}}],[\"setc\",{\"1\":{\"262\":1}}],[\"setbit\",{\"1\":{\"798\":1}}],[\"setbitmap\",{\"1\":{\"798\":1,\"851\":1}}],[\"setbatch\",{\"1\":{\"573\":1}}],[\"setborntimestamp\",{\"1\":{\"573\":1,\"576\":1,\"718\":1,\"793\":1,\"800\":1}}],[\"setbornhost\",{\"1\":{\"573\":1,\"576\":1,\"718\":1,\"793\":1,\"800\":1}}],[\"setbodylength\",{\"1\":{\"540\":1}}],[\"setbodycrc32\",{\"1\":{\"490\":1}}],[\"setbody\",{\"1\":{\"355\":1,\"493\":1,\"573\":2,\"576\":1,\"693\":1,\"718\":1,\"793\":1,\"800\":1}}],[\"setbrokersuspendmaxtimemillis\",{\"1\":{\"808\":1}}],[\"setbrokername\",{\"1\":{\"490\":1,\"572\":1,\"693\":1,\"793\":1}}],[\"setbrokerid\",{\"1\":{\"490\":1}}],[\"setbrokeraddr\",{\"1\":{\"490\":1,\"573\":1}}],[\"setbegintimestamp\",{\"1\":{\"317\":1}}],[\"setbeginphyoffset\",{\"1\":{\"317\":1}}],[\"setb\",{\"1\":{\"262\":1}}],[\"setackoffset\",{\"1\":{\"793\":1}}],[\"setaccessible\",{\"1\":{\"262\":1,\"515\":1}}],[\"setallocatemessagequeuestrategy\",{\"1\":{\"642\":1}}],[\"seta\",{\"1\":{\"262\":1}}],[\"set\",{\"1\":{\"21\":2,\"98\":6,\"99\":1,\"139\":2,\"186\":2,\"262\":2,\"435\":1,\"480\":1,\"573\":1,\"663\":1,\"786\":1,\"797\":1,\"808\":1}}],[\"styletang\",{\"1\":{\"593\":1}}],[\"stream\",{\"1\":{\"768\":1}}],[\"streaming系统的流批实时性\",{\"1\":{\"128\":1}}],[\"strategyname\",{\"1\":{\"786\":5}}],[\"strategy\",{\"1\":{\"663\":4,\"786\":2}}],[\"struct\",{\"1\":{\"626\":1}}],[\"structure\",{\"1\":{\"275\":2,\"492\":1}}],[\"str\",{\"1\":{\"411\":12,\"424\":1}}],[\"stringutils\",{\"1\":{\"541\":1,\"816\":2,\"817\":2}}],[\"string>>\",{\"1\":{\"491\":1,\"492\":1}}],[\"string>\",{\"1\":{\"262\":1,\"345\":1,\"348\":1,\"411\":1,\"414\":1,\"491\":3,\"492\":1,\"515\":3,\"518\":1,\"540\":1,\"576\":1,\"715\":1,\"750\":1,\"800\":1,\"817\":2,\"838\":2,\"852\":2}}],[\"stringcanonicalname\",{\"1\":{\"262\":1}}],[\"stringbuffer\",{\"0\":{\"427\":1},\"1\":{\"261\":1,\"406\":1,\"427\":1,\"429\":1}}],[\"stringbuilder\",{\"0\":{\"426\":1},\"1\":{\"261\":3,\"406\":1,\"420\":2,\"426\":5,\"429\":1,\"755\":2,\"790\":3}}],[\"string\",{\"0\":{\"261\":1,\"427\":1},\"1\":{\"258\":1,\"261\":3,\"262\":8,\"277\":2,\"287\":2,\"306\":4,\"309\":2,\"310\":2,\"313\":1,\"314\":8,\"317\":4,\"335\":1,\"339\":1,\"342\":2,\"343\":3,\"345\":2,\"348\":1,\"363\":2,\"380\":1,\"400\":1,\"406\":1,\"411\":1,\"414\":2,\"416\":1,\"420\":3,\"424\":1,\"427\":1,\"428\":1,\"470\":1,\"480\":2,\"481\":2,\"488\":1,\"490\":5,\"491\":6,\"492\":6,\"493\":1,\"504\":3,\"505\":3,\"514\":3,\"515\":4,\"516\":2,\"517\":1,\"518\":3,\"519\":6,\"520\":9,\"537\":13,\"539\":3,\"540\":3,\"541\":10,\"570\":3,\"571\":1,\"572\":3,\"573\":5,\"576\":3,\"636\":1,\"637\":1,\"662\":1,\"663\":1,\"664\":1,\"665\":1,\"689\":1,\"690\":1,\"691\":3,\"692\":1,\"693\":7,\"694\":3,\"715\":2,\"717\":5,\"718\":7,\"721\":6,\"742\":3,\"744\":1,\"750\":1,\"755\":1,\"761\":1,\"768\":4,\"786\":4,\"787\":2,\"790\":2,\"791\":2,\"793\":1,\"798\":4,\"799\":1,\"800\":1,\"808\":1,\"816\":4,\"817\":8,\"826\":2,\"829\":3,\"850\":5}}],[\"string2messageproperties\",{\"1\":{\"240\":2,\"261\":2,\"576\":1}}],[\"stdlib\",{\"1\":{\"103\":1}}],[\"stdev\",{\"1\":{\"11\":2}}],[\"stored\",{\"1\":{\"797\":2}}],[\"storeoffset=\",{\"1\":{\"721\":1}}],[\"storeoffset\",{\"1\":{\"721\":4}}],[\"storeoffsetenable\",{\"1\":{\"693\":6}}],[\"storeutil\",{\"1\":{\"694\":1}}],[\"storestatsservice\",{\"1\":{\"694\":4}}],[\"storetime\",{\"1\":{\"537\":1}}],[\"storetimestamp\",{\"1\":{\"257\":2,\"258\":1,\"310\":1,\"317\":5}}],[\"storecheckpoint\",{\"1\":{\"289\":1,\"313\":1}}],[\"storepath\",{\"1\":{\"269\":1,\"313\":2}}],[\"storehost\",{\"1\":{\"537\":1}}],[\"storehostlength\",{\"1\":{\"257\":1}}],[\"storehostholder\",{\"1\":{\"257\":2}}],[\"storehostaddress\",{\"1\":{\"257\":2,\"258\":2}}],[\"store\",{\"0\":{\"578\":1,\"783\":1},\"1\":{\"147\":1,\"152\":1,\"154\":2,\"213\":1,\"220\":3,\"223\":1,\"240\":1,\"269\":1,\"276\":1,\"285\":2,\"287\":1,\"291\":2,\"345\":1,\"347\":1,\"365\":3,\"380\":3,\"402\":2,\"503\":1,\"555\":1,\"576\":4,\"578\":1,\"595\":2,\"600\":6,\"693\":2,\"694\":6,\"721\":1,\"790\":3,\"797\":3,\"816\":1,\"852\":1,\"884\":1}}],[\"storage\",{\"1\":{\"97\":1,\"257\":2}}],[\"stopped\",{\"1\":{\"105\":1,\"541\":5,\"688\":1}}],[\"stop\",{\"1\":{\"21\":2,\"74\":3,\"102\":1,\"103\":1,\"105\":2,\"158\":1,\"314\":1}}],[\"standardcharsets\",{\"1\":{\"873\":1}}],[\"stayed\",{\"1\":{\"797\":1}}],[\"stay\",{\"1\":{\"796\":1,\"797\":1}}],[\"stages\",{\"1\":{\"594\":1,\"595\":3,\"598\":1,\"599\":4,\"603\":1,\"604\":1}}],[\"stage\",{\"1\":{\"594\":5}}],[\"stars\",{\"1\":{\"593\":1}}],[\"startoffsetinfo\",{\"1\":{\"789\":5,\"790\":3}}],[\"startdelivertime\",{\"1\":{\"573\":1}}],[\"startfactory\",{\"1\":{\"567\":2}}],[\"startscantime\",{\"1\":{\"798\":2}}],[\"startscheduledtask\",{\"1\":{\"476\":1,\"567\":1,\"568\":2,\"643\":1}}],[\"startswith\",{\"1\":{\"262\":1,\"573\":1,\"662\":1,\"663\":1,\"695\":1,\"786\":1,\"800\":1}}],[\"started\",{\"1\":{\"344\":1,\"364\":2,\"505\":1,\"519\":1,\"527\":1,\"567\":1,\"595\":3,\"642\":1,\"660\":1,\"688\":1,\"768\":1}}],[\"starter\",{\"1\":{\"122\":2}}],[\"starttime\",{\"1\":{\"242\":1,\"797\":1,\"851\":2}}],[\"start\",{\"0\":{\"567\":1},\"1\":{\"74\":4,\"85\":1,\"98\":3,\"103\":3,\"105\":3,\"287\":1,\"313\":1,\"360\":1,\"364\":2,\"389\":1,\"467\":2,\"472\":1,\"480\":4,\"481\":4,\"504\":1,\"505\":1,\"519\":3,\"526\":1,\"527\":1,\"557\":1,\"567\":5,\"568\":13,\"597\":3,\"601\":2,\"642\":8,\"643\":8,\"656\":1,\"694\":1,\"755\":2,\"768\":2,\"807\":2,\"808\":1}}],[\"statstype\",{\"1\":{\"693\":3}}],[\"static\",{\"1\":{\"262\":1,\"413\":1,\"414\":1,\"417\":1,\"424\":1,\"480\":2,\"504\":4,\"505\":4,\"537\":1,\"768\":4,\"819\":5}}],[\"status中出现的erlang节点名\",{\"1\":{\"190\":1}}],[\"status\",{\"1\":{\"41\":7,\"178\":2,\"287\":2,\"381\":2,\"528\":1,\"595\":1,\"597\":1,\"599\":2,\"694\":14,\"715\":13,\"750\":14}}],[\"state1\",{\"1\":{\"157\":5}}],[\"state\",{\"1\":{\"9\":1,\"147\":2,\"157\":4,\"158\":11,\"176\":1,\"223\":1,\"567\":1,\"642\":1,\"690\":1}}],[\"stackoverflow\",{\"1\":{\"179\":1}}],[\"stacktrace\",{\"0\":{\"47\":1}}],[\"stack\",{\"1\":{\"21\":1}}],[\"s\",{\"1\":{\"11\":2,\"21\":4,\"74\":4,\"109\":3,\"140\":1,\"240\":1,\"243\":1,\"256\":1,\"261\":4,\"262\":39,\"480\":2,\"492\":2,\"504\":1,\"505\":2,\"518\":1,\"520\":5,\"526\":1,\"527\":2,\"541\":1,\"599\":2,\"665\":1,\"690\":2,\"693\":18,\"715\":5,\"718\":1,\"750\":8,\"768\":2,\"829\":1}}],[\"可转化为数字的字符串也被认为是数字\",{\"1\":{\"828\":1}}],[\"可在\",{\"1\":{\"353\":1}}],[\"可想而知这种方法非常浪费网络资源\",{\"1\":{\"324\":1}}],[\"可用且当前节点为主节点\",{\"1\":{\"683\":1}}],[\"可用\",{\"1\":{\"282\":1}}],[\"可用于组合任意简单的逻辑判断\",{\"1\":{\"828\":1}}],[\"可用于比较数字和字符串\",{\"1\":{\"828\":1}}],[\"可用于函数定义的头部\",{\"1\":{\"36\":1}}],[\"可用于简单的测试和比较\",{\"1\":{\"36\":1}}],[\"可选参数\",{\"1\":{\"185\":1}}],[\"可选\",{\"1\":{\"168\":1,\"526\":1,\"527\":1}}],[\"可靠性最差\",{\"1\":{\"547\":1}}],[\"可靠性也不会降低\",{\"1\":{\"255\":1}}],[\"可靠性案例分析\",{\"0\":{\"134\":1}}],[\"可靠性\",{\"1\":{\"127\":1}}],[\"可惜的是\",{\"1\":{\"126\":1}}],[\"可能造成消息堆积\",{\"1\":{\"769\":1}}],[\"可能存在重平衡后要释放某个队列的\",{\"1\":{\"735\":1}}],[\"可能存在同时有多个同一队列的消费任务被提交到消费线程池的情况\",{\"1\":{\"727\":1}}],[\"可能存在消息可能丢失的情况\",{\"1\":{\"374\":1}}],[\"可能有多个\",{\"1\":{\"491\":1}}],[\"可能耗时较多\",{\"1\":{\"408\":1}}],[\"可能包含多个文件\",{\"1\":{\"387\":1}}],[\"可能由于流控等原因\",{\"1\":{\"375\":1}}],[\"可能导致更大的磁盘使用\",{\"1\":{\"234\":1}}],[\"可能要消耗几分钟\",{\"1\":{\"226\":1}}],[\"可能是由于故意设计成这样\",{\"1\":{\"226\":1}}],[\"可能是危险的\",{\"1\":{\"190\":1}}],[\"可能是非常简单的给定一个特定的条件\",{\"1\":{\"126\":1}}],[\"可能在较长时间内都没有授予\",{\"1\":{\"155\":1}}],[\"可能会重复且并发地消费那批没有消费完的消息\",{\"1\":{\"735\":1}}],[\"可能会出现为空的情况\",{\"1\":{\"695\":1,\"749\":1}}],[\"可能会导致生产停止\",{\"1\":{\"235\":1}}],[\"可能会导致内部进程邮箱的大小很快达到内存阈值\",{\"1\":{\"144\":1}}],[\"可能会花很长时间\",{\"1\":{\"97\":1}}],[\"可能一次也可能多次\",{\"1\":{\"4\":1}}],[\"可以仅保存消息的存储位置\",{\"1\":{\"880\":1}}],[\"可以减少比较次数\",{\"1\":{\"833\":1}}],[\"可以减少传统\",{\"1\":{\"400\":1}}],[\"可以过滤消息的属性和\",{\"1\":{\"828\":1}}],[\"可以匹配多个\",{\"1\":{\"827\":1}}],[\"可以设置\",{\"1\":{\"825\":1}}],[\"可以设置队列为种惰性队列\",{\"1\":{\"214\":1}}],[\"可以新建一个过滤类\",{\"1\":{\"823\":1}}],[\"可以加速匹配\",{\"1\":{\"782\":1}}],[\"可以修改\",{\"1\":{\"771\":1}}],[\"可以解决\",{\"1\":{\"769\":1}}],[\"可以向\",{\"1\":{\"745\":1}}],[\"可以有\",{\"1\":{\"723\":1}}],[\"可以有多个层级\",{\"1\":{\"810\":1}}],[\"可以有多个元组拥有相同的键\",{\"1\":{\"98\":1}}],[\"可以有多个子句\",{\"1\":{\"31\":1}}],[\"可以同时处理\",{\"1\":{\"707\":1}}],[\"可以进行重平衡\",{\"1\":{\"656\":1}}],[\"可以看出消费者发回消息并没有将整个消息都发回去\",{\"1\":{\"708\":1}}],[\"可以看出该拉模式消费者与推模式消费者的重平衡机制比较类似\",{\"1\":{\"656\":1}}],[\"可以看到配置文件主要分两个大项\",{\"1\":{\"503\":1}}],[\"可以看到\",{\"1\":{\"275\":1,\"442\":1,\"465\":1}}],[\"可以看到右边的代码使用了\",{\"1\":{\"261\":1}}],[\"可以看到非持久化消息的生命周期会简单很多\",{\"1\":{\"223\":1}}],[\"可以看到在rabbit\",{\"1\":{\"157\":1}}],[\"可以看到在每次测试前后\",{\"1\":{\"4\":1}}],[\"可以看到会先执行rabbit\",{\"1\":{\"157\":1}}],[\"可以做到比推模式消费者更高的拉取效率\",{\"1\":{\"656\":1}}],[\"可以多次调用该方法来订阅多个主题\",{\"1\":{\"637\":1}}],[\"可以想到消费者消费时实际是读取消费队列\",{\"1\":{\"811\":1}}],[\"可以想象一下消费时要做的操作\",{\"1\":{\"637\":1}}],[\"可以想办法进行优化\",{\"1\":{\"428\":1}}],[\"可以自动感知有组件挂掉的情况并重新调整消费者的订阅关系\",{\"1\":{\"621\":1}}],[\"可以访问\",{\"1\":{\"601\":1}}],[\"可以可视化的查看\",{\"1\":{\"596\":1}}],[\"可以预先准备好\",{\"1\":{\"591\":1}}],[\"可以很快地用\",{\"1\":{\"589\":1}}],[\"可以指定消息的属性\",{\"1\":{\"555\":1}}],[\"可以指定保存消息轨迹的\",{\"1\":{\"526\":1,\"527\":1}}],[\"可以从备\",{\"1\":{\"553\":1}}],[\"可以传入要发送的队列信息\",{\"1\":{\"549\":1}}],[\"可以分为多个队列\",{\"1\":{\"549\":1}}],[\"可以保证发送消息和另外的操作同时成功或者同时失败\",{\"1\":{\"548\":1}}],[\"可以保存任何类型的erlang数据结构\",{\"1\":{\"101\":1}}],[\"可以达成较高的可靠性和很高的性能\",{\"1\":{\"547\":1}}],[\"可以达到预取一批消息到消费者进行消费的目的\",{\"1\":{\"149\":1}}],[\"可以在\",{\"1\":{\"592\":1}}],[\"可以在消息生产\",{\"1\":{\"530\":1}}],[\"可以在rocketmq集群中选择其中一个broker节点专用于存储消息轨迹\",{\"1\":{\"524\":1}}],[\"可以在不重启服务的情况下自动生效\",{\"1\":{\"517\":1}}],[\"可以在字符串和带引号的原子里使用转义序列来输入任何不可打印的字符\",{\"1\":{\"59\":1}}],[\"可以马上定位到这个\",{\"1\":{\"447\":1}}],[\"可以马上算出索引在\",{\"1\":{\"271\":1}}],[\"可以计算投递时间到当前时间的时间差\",{\"1\":{\"440\":1}}],[\"可以实现二层过滤\",{\"1\":{\"838\":1}}],[\"可以实现延迟消息的效果\",{\"1\":{\"440\":1}}],[\"可以实现在\",{\"1\":{\"368\":1}}],[\"可以上升到\",{\"1\":{\"435\":1}}],[\"可以更大程度上提升性能\",{\"1\":{\"407\":1}}],[\"可以被共享的队列数\",{\"1\":{\"775\":1}}],[\"可以被\",{\"1\":{\"424\":1}}],[\"可以被删除\",{\"1\":{\"390\":1}}],[\"可以被多个进程共享\",{\"1\":{\"97\":1}}],[\"可以大幅度提高延迟消息处理速度\",{\"1\":{\"372\":1}}],[\"可以大幅降低对\",{\"1\":{\"255\":1}}],[\"可以唤醒挂起的请求\",{\"1\":{\"344\":1}}],[\"可以配置轮询方式\",{\"1\":{\"325\":1}}],[\"可以无限扩展\",{\"1\":{\"307\":1}}],[\"可以把不同业务的权限配置分别放在多个文件中\",{\"1\":{\"503\":1}}],[\"可以把取消消息的状态更新到该字段中存储\",{\"1\":{\"455\":1}}],[\"可以把\",{\"1\":{\"269\":1}}],[\"可以把前者看做数据生产者\",{\"1\":{\"244\":1}}],[\"可以省下进出重量锁的开销\",{\"1\":{\"253\":1}}],[\"可以直接把从\",{\"1\":{\"250\":1}}],[\"可以直接运行空测试函数\",{\"1\":{\"9\":1}}],[\"可以提供更好的消息吞吐量\",{\"1\":{\"229\":1}}],[\"可以充分利用多个节点的计算和存储资源\",{\"1\":{\"181\":1}}],[\"可以创建两种类型的\",{\"1\":{\"165\":1}}],[\"可以创建端口\",{\"1\":{\"91\":1}}],[\"可以观察到该进程的状态为黄色flow\",{\"1\":{\"147\":1}}],[\"可以对内存和磁盘使用量设置阈值\",{\"1\":{\"146\":1}}],[\"可以对某个模式里的变量执行简单的测试和比较\",{\"1\":{\"36\":1}}],[\"可以处理的速度\",{\"1\":{\"144\":1}}],[\"可以将一个消费组切换成\",{\"1\":{\"767\":1}}],[\"可以将超时时间设为\",{\"1\":{\"753\":1}}],[\"可以将消息发到其他集群\",{\"1\":{\"166\":1}}],[\"可以将意外停机时间减少50\",{\"1\":{\"126\":1}}],[\"可以将元组中的元素绑定到特定的名称\",{\"1\":{\"41\":1}}],[\"可以参考官方文档\",{\"1\":{\"545\":1}}],[\"可以参考\",{\"1\":{\"116\":1}}],[\"可以构建大规模\",{\"1\":{\"112\":1}}],[\"可以跟踪所有的函数调用\",{\"1\":{\"111\":1}}],[\"可以简单地在程序的关键位置添加\",{\"1\":{\"108\":1}}],[\"可以公布进程标识符\",{\"1\":{\"84\":1}}],[\"可以给接收语句增加一个超时设置\",{\"1\":{\"82\":1}}],[\"可以用作消息的业务标识\",{\"1\":{\"825\":1}}],[\"可以用\",{\"1\":{\"823\":1}}],[\"可以用给\",{\"1\":{\"146\":1}}],[\"可以用库模块\",{\"1\":{\"111\":1}}],[\"可以用来表示布尔值\",{\"1\":{\"56\":1}}],[\"可以用它来增加模式匹配的威力\",{\"1\":{\"36\":1}}],[\"可以改进错误信息\",{\"1\":{\"46\":1}}],[\"可以由一系列\",{\"1\":{\"36\":1}}],[\"可以与erlang节点系统中任何节点上的任何程序进行交互\",{\"1\":{\"21\":1}}],[\"可以挂接一个shell到集群里另一个erlang节点上运行的erlang系统\",{\"1\":{\"21\":1}}],[\"可以通过索引文件来辅助定时消息的查询\",{\"1\":{\"880\":1}}],[\"可以通过表达式过滤的方式设置需要过滤的\",{\"1\":{\"827\":1}}],[\"可以通过一个开关实时进行切换\",{\"1\":{\"615\":1}}],[\"可以通过映射地址加偏移量的方式直接操作\",{\"1\":{\"400\":1}}],[\"可以通过messageindexenable属性配置打开或关闭\",{\"1\":{\"297\":1}}],[\"可以通过配置故障延迟机制来指定是在本次消息发送时暂时避开发送失败的\",{\"1\":{\"552\":1}}],[\"可以通过配置\",{\"1\":{\"220\":1}}],[\"可以通过垂直或者水平扩容的方式增加\",{\"1\":{\"181\":1}}],[\"可以通过\",{\"1\":{\"10\":1,\"598\":1}}],[\"可以使用\",{\"1\":{\"7\":1}}],[\"并检查该\",{\"1\":{\"799\":1}}],[\"并作一些校验\",{\"1\":{\"780\":1}}],[\"并放到\",{\"1\":{\"773\":1}}],[\"并放入\",{\"1\":{\"640\":1}}],[\"并释放\",{\"1\":{\"744\":1}}],[\"并恢复\",{\"1\":{\"738\":1}}],[\"并更新加锁时间\",{\"1\":{\"734\":1}}],[\"并更新消费进度\",{\"1\":{\"699\":1}}],[\"并提交\",{\"1\":{\"714\":1}}],[\"并提供全面的结果报告\",{\"1\":{\"127\":1}}],[\"并对拉取到的消息进行消费处理\",{\"1\":{\"671\":1}}],[\"并实现了重分配的方法\",{\"1\":{\"649\":1}}],[\"并新建重平衡服务\",{\"1\":{\"631\":1}}],[\"并与\",{\"1\":{\"601\":1}}],[\"并置于和集群同一个网络下\",{\"1\":{\"598\":1}}],[\"并进入该仓库\",{\"1\":{\"590\":1}}],[\"并支持多种部署模式\",{\"1\":{\"589\":1}}],[\"并指定为内存存储的\",{\"1\":{\"581\":1}}],[\"并指定用户名和密码参数\",{\"1\":{\"500\":1}}],[\"并设置事务标识\",{\"1\":{\"573\":1}}],[\"并设置压缩标识\",{\"1\":{\"573\":1}}],[\"并设置了\",{\"1\":{\"198\":1}}],[\"并将没有匹配的消息重试\",{\"1\":{\"773\":1}}],[\"并将订阅关系上报到\",{\"1\":{\"650\":1}}],[\"并将该时间与\",{\"1\":{\"519\":1}}],[\"并将自身的\",{\"1\":{\"472\":1}}],[\"并调用拉消费者实现类的\",{\"1\":{\"639\":1}}],[\"并调用\",{\"1\":{\"519\":1}}],[\"并返回给客户端\",{\"1\":{\"477\":1,\"493\":1}}],[\"并没有将\",{\"1\":{\"402\":1}}],[\"并不是实际上限\",{\"1\":{\"820\":1}}],[\"并不是仅在\",{\"1\":{\"390\":1}}],[\"并不适合海量\",{\"1\":{\"810\":1}}],[\"并不负责请求处理\",{\"1\":{\"675\":1}}],[\"并不会持久化\",{\"1\":{\"464\":1}}],[\"并不会直接去读写磁盘上的文件\",{\"1\":{\"399\":1}}],[\"并不能保证服务的可用性\",{\"1\":{\"462\":1}}],[\"并从队列中移除投递任务\",{\"1\":{\"378\":1}}],[\"并为每个延迟等级设计单独的\",{\"1\":{\"356\":1}}],[\"并为架构演进提供进一步优化建议\",{\"1\":{\"128\":1}}],[\"并需要同步来恢复全部数据冗余\",{\"1\":{\"211\":1}}],[\"并考虑它们而不是经典的镜像队列\",{\"1\":{\"208\":1}}],[\"并在消费任务执行时加锁\",{\"1\":{\"737\":1}}],[\"并在生产时指定队列\",{\"1\":{\"622\":1}}],[\"并在停机时变得不同步\",{\"1\":{\"190\":1}}],[\"并在集群的两个节点上完成进行\",{\"1\":{\"186\":1}}],[\"并传到\",{\"1\":{\"176\":1}}],[\"并根据配置的并发数创建相应的客户端\",{\"1\":{\"130\":1}}],[\"并会根据需要测试的分布式基础设施找到对应的driver组件并载入\",{\"1\":{\"130\":1}}],[\"并会显著增加系统负载\",{\"1\":{\"105\":1}}],[\"并以两个实战案例展示了openchaos在实际应用场景中可以发挥的效果\",{\"1\":{\"125\":1}}],[\"并阐述了openchaos在传统混沌工程上的优化与创新\",{\"1\":{\"125\":1}}],[\"并配置好插件获取\",{\"1\":{\"122\":1}}],[\"并受防火墙保护\",{\"1\":{\"87\":1}}],[\"并管理超时\",{\"1\":{\"83\":1}}],[\"并执行\",{\"1\":{\"80\":1}}],[\"并发有两层含义\",{\"1\":{\"723\":1}}],[\"并发模式下\",{\"1\":{\"707\":1}}],[\"并发消费的消费线程池\",{\"1\":{\"726\":1}}],[\"并发消费的方式是调用消费者的指定\",{\"1\":{\"622\":1}}],[\"并发消费是比较常用的一种消费方式\",{\"1\":{\"723\":1}}],[\"并发消费服务提交消费请求\",{\"0\":{\"714\":1}}],[\"并发消费服务将消息封装成一个个消费请求\",{\"1\":{\"699\":1}}],[\"并发消费\",{\"1\":{\"699\":1}}],[\"并发消费和顺序消费\",{\"1\":{\"637\":1,\"707\":1}}],[\"并发消费与顺序消费\",{\"0\":{\"622\":1}}],[\"并发送消费者取消通知\",{\"1\":{\"198\":1}}],[\"并发生不可用时\",{\"1\":{\"134\":1}}],[\"并发程序模板\",{\"1\":{\"85\":1}}],[\"并发编程\",{\"0\":{\"78\":1}}],[\"并发和分布式程序\",{\"0\":{\"76\":1}}],[\"并祈祷它能收到并理解这个消息\",{\"1\":{\"77\":1}}],[\"并插入必要的包含文件\",{\"1\":{\"58\":1}}],[\"并修改\",{\"1\":{\"41\":1}}],[\"并且没有存入磁盘\",{\"1\":{\"797\":1}}],[\"并且本次拉取是由客户端触发\",{\"1\":{\"693\":1}}],[\"并且可以连接\",{\"1\":{\"590\":1}}],[\"并且提供了常用的\",{\"1\":{\"589\":1}}],[\"并且会将该对象进行持久化\",{\"1\":{\"464\":1}}],[\"并且先计算好长度\",{\"1\":{\"429\":1}}],[\"并且也不必再通过调用read或write方法对文件进行读写\",{\"1\":{\"400\":1}}],[\"并且从节点会定期从主节点拉去该表的最新值\",{\"1\":{\"377\":1}}],[\"并且避免多延迟等级消息同时发送时造成的阻塞\",{\"1\":{\"372\":1}}],[\"并且启动长轮询\",{\"1\":{\"334\":1,\"339\":1}}],[\"并且刷新\",{\"1\":{\"309\":1}}],[\"并且把上一个索引文件异步刷盘\",{\"1\":{\"309\":1}}],[\"并且把复制因子设置为\",{\"1\":{\"236\":1}}],[\"并且将消费者和消费队列排序的方法\",{\"1\":{\"647\":1}}],[\"并且将上一个写满的索引文件刷盘\",{\"1\":{\"303\":1}}],[\"并且将该偏移量加一\",{\"1\":{\"285\":1}}],[\"并且一并传入数据的开始位置和长度\",{\"1\":{\"250\":1}}],[\"并且一个包含镜像的节点宕机\",{\"1\":{\"190\":1}}],[\"并且复制因子为\",{\"1\":{\"234\":1}}],[\"并且有它自己的局限性\",{\"1\":{\"227\":1}}],[\"并且\",{\"1\":{\"221\":1,\"420\":1}}],[\"并且还未完成消息的同步\",{\"1\":{\"192\":1}}],[\"并且cluster\",{\"1\":{\"192\":1}}],[\"并且在\",{\"1\":{\"163\":1}}],[\"并且这个\",{\"1\":{\"155\":1}}],[\"并且控制发送消息的速度\",{\"1\":{\"148\":1}}],[\"并且依赖于观察是极其主观的\",{\"1\":{\"127\":1}}],[\"并且前后的一些操作的结果也是我不想要的\",{\"1\":{\"121\":1}}],[\"并且每个元组都有相同的结构\",{\"1\":{\"40\":1}}],[\"并且它通常会阻止\",{\"1\":{\"3\":1}}],[\"并计算该测试模式所关注的指标\",{\"1\":{\"4\":1}}],[\"在构造消息时提供了\",{\"1\":{\"873\":1}}],[\"在构建消费队列时会保存根据消息\",{\"1\":{\"834\":1}}],[\"在配置类被更新时刷新配置项\",{\"1\":{\"854\":1}}],[\"在其之上做了一些修改\",{\"1\":{\"841\":1}}],[\"在sql语法中\",{\"1\":{\"828\":1}}],[\"在此方法返回\",{\"1\":{\"819\":1}}],[\"在此处选择对应版本的\",{\"1\":{\"176\":1}}],[\"在码表上标记对应的消息为\",{\"1\":{\"783\":1}}],[\"在保存和匹配时都对应一批消息\",{\"1\":{\"778\":1}}],[\"在保留时间内\",{\"1\":{\"390\":1}}],[\"在切换\",{\"1\":{\"775\":1}}],[\"在创建\",{\"1\":{\"768\":1}}],[\"在接下来的一段时间内所有的客户端都不会向对应的\",{\"1\":{\"754\":1}}],[\"在接下来一段时间内都不再向其发送消息\",{\"1\":{\"561\":1}}],[\"在方法后面的逻辑中立即执行拉取\",{\"1\":{\"748\":1}}],[\"在步骤\",{\"1\":{\"723\":1}}],[\"在如下位置被调用\",{\"1\":{\"688\":1}}],[\"在停止时\",{\"1\":{\"656\":1}}],[\"在订阅\",{\"1\":{\"656\":1}}],[\"在启动和停止时也不会向\",{\"1\":{\"656\":1}}],[\"在启动时从磁盘中加载\",{\"1\":{\"360\":1}}],[\"在多个消费者同时消费一个\",{\"1\":{\"646\":1}}],[\"在多线程写\",{\"1\":{\"397\":1}}],[\"在系列后面的文章中会详细讲解\",{\"1\":{\"639\":1}}],[\"在图中\",{\"1\":{\"639\":1}}],[\"在拉取消息处理方法中\",{\"1\":{\"844\":1}}],[\"在拉取消息时如果没有新消息\",{\"1\":{\"324\":1}}],[\"在拉消息方法中被调用\",{\"1\":{\"844\":1}}],[\"在拉消费者背后\",{\"1\":{\"639\":1}}],[\"在首次启动前\",{\"1\":{\"631\":1}}],[\"在不同\",{\"1\":{\"617\":1}}],[\"在不下线的情况下将数据从一个集群同步到另一个集群\",{\"1\":{\"164\":1}}],[\"在集群消费模式下\",{\"1\":{\"616\":1}}],[\"在推送消息给消费者\",{\"1\":{\"614\":1}}],[\"在了解它们之前\",{\"1\":{\"608\":1}}],[\"在文件尾部添加如下配置\",{\"1\":{\"598\":1}}],[\"在正常情况下\",{\"1\":{\"561\":1}}],[\"在发送消息时\",{\"1\":{\"555\":1}}],[\"在发布\",{\"1\":{\"233\":1}}],[\"在对响应时间敏感\",{\"1\":{\"547\":1}}],[\"在使用时可以在生产者和消费者上指定消息轨迹发送的自定义\",{\"1\":{\"532\":1}}],[\"在该模式下\",{\"1\":{\"524\":1}}],[\"在该服务中会记录其监控的acl配置文件目录\",{\"1\":{\"519\":1}}],[\"在处理完请求后调用\",{\"1\":{\"516\":1}}],[\"在处理消息时性能损耗的点\",{\"1\":{\"407\":1}}],[\"在服务端接收到请求并解码后\",{\"1\":{\"516\":1}}],[\"在请求之前注册\",{\"1\":{\"510\":1}}],[\"在请求处理前后增加方法\",{\"1\":{\"510\":1}}],[\"在进行选举的时候\",{\"1\":{\"462\":1}}],[\"在进程字典中用来保存ack消息数的\",{\"1\":{\"159\":1}}],[\"在早期版本的\",{\"1\":{\"462\":1}}],[\"在第一层过滤\",{\"1\":{\"835\":1}}],[\"在第一次发送消息时\",{\"1\":{\"559\":1}}],[\"在第二节中\",{\"1\":{\"456\":1}}],[\"在第1\",{\"1\":{\"134\":1}}],[\"在遇见和解决一个一个坑之后实现了高性能高可靠的任意时间定时消息\",{\"1\":{\"454\":1}}],[\"在扫描每个延迟等级的队列时具体的逻辑是\",{\"1\":{\"452\":1}}],[\"在异步投递的情况下顺序可能与主节点不一致\",{\"1\":{\"450\":1}}],[\"在实践中这两个值往往会设置成相同的\",{\"1\":{\"758\":1}}],[\"在实际使用中\",{\"1\":{\"620\":1}}],[\"在实际使用中通常会采用多个消费者共同消费同样的\",{\"1\":{\"609\":1}}],[\"在实现\",{\"1\":{\"445\":1}}],[\"在实验中我们还会统计在不同分区个数下消息收发的吞吐量\",{\"1\":{\"135\":1}}],[\"在设计消息轨迹功能时\",{\"1\":{\"530\":1}}],[\"在设计定时消息的实现方案前\",{\"1\":{\"443\":1}}],[\"在设计上更倾向于消息被及时消费\",{\"1\":{\"214\":1}}],[\"在比如\",{\"1\":{\"441\":1,\"871\":1}}],[\"在比较坏的情况下\",{\"1\":{\"426\":1}}],[\"在开源版本中支持延迟消息的功能\",{\"1\":{\"439\":1}}],[\"在写入成功后更新checkpoint中的最新写入时间\",{\"1\":{\"817\":1}}],[\"在写\",{\"0\":{\"430\":1}}],[\"在客户端每次发送消息时会调用\",{\"1\":{\"419\":1}}],[\"在预分配的\",{\"1\":{\"402\":1}}],[\"在预热和测试执行过程中\",{\"1\":{\"4\":1}}],[\"在用户空间的应用程序无法直接访问\",{\"1\":{\"400\":1}}],[\"在整体上看都是顺序读写\",{\"1\":{\"399\":1}}],[\"在调用系统的\",{\"1\":{\"399\":1}}],[\"在删除文件时\",{\"1\":{\"390\":1}}],[\"在一些可靠性要求非常高的场景下\",{\"1\":{\"547\":1}}],[\"在一台真实的mq上查看网络和磁盘\",{\"1\":{\"399\":1}}],[\"在一次删除过程中\",{\"1\":{\"390\":1}}],[\"在一个进程中可以有多个\",{\"1\":{\"755\":1}}],[\"在一个文件写满后调用\",{\"1\":{\"316\":1}}],[\"在一个索引文件写满后调用\",{\"1\":{\"316\":1}}],[\"在磁盘上存储多份\",{\"1\":{\"810\":1}}],[\"在磁盘容量达到\",{\"1\":{\"386\":1}}],[\"在磁盘中\",{\"1\":{\"234\":1}}],[\"在老版本中使用\",{\"1\":{\"462\":1}}],[\"在老版本中\",{\"1\":{\"372\":1}}],[\"在存盘之前\",{\"1\":{\"359\":1,\"363\":1}}],[\"在存储层面查询消息的入口是\",{\"1\":{\"277\":1}}],[\"在定时消息场景下有一种极端情况\",{\"1\":{\"878\":1}}],[\"在定时消息功能中\",{\"1\":{\"356\":1}}],[\"在定义某个\",{\"1\":{\"41\":1}}],[\"在producer端设置消息为定时消息\",{\"1\":{\"355\":1}}],[\"在pullmessageprocessor的executerequestwhenwakeup\",{\"1\":{\"340\":1}}],[\"在长轮询等待时如果有新消息到达\",{\"1\":{\"334\":1}}],[\"在生产环境中建议将超时时间合重试次数设大一点\",{\"1\":{\"753\":1}}],[\"在生产者写入\",{\"1\":{\"245\":1}}],[\"在生产者确认机制中\",{\"1\":{\"196\":1}}],[\"在生成消费索引时一并生成\",{\"1\":{\"814\":1}}],[\"在生成过程中已经设置了\",{\"1\":{\"573\":1}}],[\"在生成索引之后\",{\"1\":{\"331\":1}}],[\"在链表头部插入最新的索引项\",{\"1\":{\"317\":1}}],[\"在时间上是前一条\",{\"1\":{\"306\":1}}],[\"在broker重新启动时会扫描consumequeue的目录\",{\"1\":{\"290\":1}}],[\"在backingqueue中\",{\"1\":{\"223\":1}}],[\"在doreput方法中被调用\",{\"1\":{\"283\":1}}],[\"在disk和ram之间置换\",{\"1\":{\"223\":1}}],[\"在收到客户端的请求之后\",{\"1\":{\"277\":1}}],[\"在返回时将结果复制到\",{\"1\":{\"261\":1}}],[\"在消费者注册时根据消费者名称和订阅的\",{\"1\":{\"843\":1}}],[\"在消费者上报心跳\",{\"1\":{\"839\":1}}],[\"在消费者启动时创建\",{\"1\":{\"711\":1}}],[\"在消费者端处理拉取结果的方法\",{\"1\":{\"839\":1}}],[\"在消费者端需要处理拉取请求的发送和\",{\"1\":{\"675\":1}}],[\"在消费者端用一个固定的分配策略将所有的消费队列分配给所有的消费者\",{\"1\":{\"647\":1}}],[\"在消费者端也有一组锁\",{\"1\":{\"622\":1}}],[\"在消费者数量变化时\",{\"1\":{\"646\":1}}],[\"在消费者客户端消费时\",{\"1\":{\"622\":1}}],[\"在消费时\",{\"1\":{\"813\":1,\"827\":1}}],[\"在消费时使用\",{\"1\":{\"537\":1}}],[\"在消费时可能由多条数据\",{\"1\":{\"537\":1}}],[\"在消费消息时\",{\"1\":{\"220\":1}}],[\"在消息生产时在\",{\"1\":{\"843\":1}}],[\"在消息生产时用布隆过滤器计算二进制数组的操作和构造消费队列扩展存储的操作默认都是关闭的\",{\"1\":{\"835\":1}}],[\"在消息生产时构造消费队列的过程当中\",{\"1\":{\"835\":1}}],[\"在消息拉取和顺序消费服务每消费一批消息前\",{\"1\":{\"729\":1}}],[\"在消息队列中\",{\"1\":{\"455\":1}}],[\"在消息存入\",{\"1\":{\"326\":1,\"814\":1}}],[\"在消息传输时用字符串存储一个\",{\"1\":{\"260\":1}}],[\"在主从同步复制的场景下\",{\"1\":{\"255\":1}}],[\"在主从复制逻辑中被用到\",{\"1\":{\"246\":1}}],[\"在同一消费组中的不同消费者会根据负载机制来平均地订阅\",{\"1\":{\"611\":1}}],[\"在同一个测试类中共享\",{\"1\":{\"9\":1}}],[\"在同步方法中调用异步方法的等待方法\",{\"1\":{\"251\":1}}],[\"在commitlog保存消息之后\",{\"1\":{\"246\":1}}],[\"在分析如何优化之前需要学习一些前置指示\",{\"1\":{\"243\":1}}],[\"在分区数达到450+时\",{\"1\":{\"135\":1}}],[\"在分区数量达到\",{\"1\":{\"135\":1}}],[\"在仲裁队列中\",{\"1\":{\"237\":1}}],[\"在节点挂掉或重启时提供高可用的能力\",{\"1\":{\"228\":1}}],[\"在rabbitmq中\",{\"1\":{\"222\":1}}],[\"在队列索引中建立消息索引\",{\"1\":{\"220\":1}}],[\"在内存中移除\",{\"1\":{\"797\":1}}],[\"在内存中时间大于阈值\",{\"1\":{\"797\":1}}],[\"在内存中停留太久没有被匹配\",{\"1\":{\"781\":1}}],[\"在内存中\",{\"1\":{\"711\":1}}],[\"在内存中异步投递\",{\"1\":{\"453\":1}}],[\"在内存中也会保留一份备份\",{\"1\":{\"214\":1}}],[\"在内部数据库的路由表中\",{\"1\":{\"201\":1}}],[\"在许多情况下\",{\"1\":{\"208\":1}}],[\"在镜像队列的情况下\",{\"1\":{\"201\":1}}],[\"在事务机制中\",{\"1\":{\"196\":1}}],[\"在每个\",{\"1\":{\"808\":1,\"817\":1}}],[\"在每个节点上都有一个副本是不必要的\",{\"1\":{\"195\":1}}],[\"在每次拉取消息时\",{\"1\":{\"656\":1}}],[\"在每次调用测试方法之前执行\",{\"1\":{\"9\":1}}],[\"在每条消息中有一个字段来存储消息的\",{\"1\":{\"455\":1}}],[\"在大多数情况下\",{\"1\":{\"195\":1}}],[\"在之前的\",{\"1\":{\"820\":1}}],[\"在之前的命令完成后执行\",{\"1\":{\"74\":1}}],[\"在之后的版本中镜像队列将被移除\",{\"1\":{\"181\":1}}],[\"在上述逻辑的基础上\",{\"1\":{\"727\":1}}],[\"在上下游集群的队列都可以收到消息\",{\"1\":{\"172\":2}}],[\"在上游集群向\",{\"1\":{\"172\":2}}],[\"在下一次重平衡时尝试加锁\",{\"1\":{\"744\":1}}],[\"在下游节点配置\",{\"1\":{\"169\":2}}],[\"在下图中\",{\"1\":{\"155\":1}}],[\"在两个\",{\"1\":{\"168\":1}}],[\"在将队列中的消息存入磁盘的过程中引起服务器\",{\"1\":{\"155\":1}}],[\"在管理\",{\"1\":{\"155\":1}}],[\"在初始化时\",{\"1\":{\"152\":1}}],[\"在1秒之内\",{\"1\":{\"147\":1}}],[\"在这之前还上报心跳让\",{\"1\":{\"648\":1}}],[\"在这显得有些多余\",{\"1\":{\"636\":1}}],[\"在这篇文章中我将解析消息发送流程中生产者和\",{\"1\":{\"544\":1}}],[\"在这期间的任何时刻\",{\"1\":{\"207\":1}}],[\"在这期间\",{\"1\":{\"207\":1}}],[\"在这里就用来判断这个消息是否可能匹配某个消费组的过滤规则\",{\"1\":{\"835\":1}}],[\"在这里\",{\"1\":{\"159\":1}}],[\"在这样的背景下\",{\"1\":{\"126\":1,\"127\":1}}],[\"在这种情况下\",{\"1\":{\"43\":1,\"160\":1}}],[\"在已有的生产环境中\",{\"1\":{\"126\":1}}],[\"在要调用的方法上选择复制static\",{\"1\":{\"123\":1}}],[\"在爱立信内部用于构建容错式系统\",{\"1\":{\"112\":1}}],[\"在活动系统上运行它会增加\",{\"1\":{\"105\":1}}],[\"在运行于两台物理隔离计算机上的两个不同\",{\"1\":{\"88\":1}}],[\"在运行于同一台计算机上的两个不同\",{\"1\":{\"88\":1}}],[\"在常规非分布式会话里编写和测试程序\",{\"1\":{\"88\":1}}],[\"在执行中抛出了异常错误\",{\"1\":{\"44\":1}}],[\"在中间插入\",{\"1\":{\"34\":1}}],[\"在打印列表时也要选择正确的格式惯例\",{\"1\":{\"28\":1}}],[\"在erlang里\",{\"1\":{\"22\":1,\"23\":1}}],[\"在\",{\"0\":{\"93\":1},\"1\":{\"4\":1,\"8\":2,\"10\":1,\"30\":1,\"80\":2,\"146\":1,\"147\":1,\"156\":1,\"181\":2,\"201\":2,\"205\":2,\"206\":1,\"208\":1,\"225\":1,\"244\":1,\"261\":1,\"285\":1,\"293\":1,\"307\":1,\"317\":1,\"323\":1,\"347\":1,\"356\":1,\"360\":2,\"370\":3,\"373\":1,\"386\":1,\"403\":1,\"406\":3,\"410\":1,\"414\":1,\"423\":1,\"426\":1,\"428\":1,\"445\":1,\"452\":2,\"454\":1,\"462\":1,\"467\":1,\"469\":1,\"480\":2,\"487\":1,\"498\":1,\"508\":1,\"514\":1,\"523\":1,\"524\":1,\"525\":1,\"534\":2,\"555\":2,\"559\":1,\"592\":1,\"601\":1,\"614\":1,\"623\":1,\"624\":1,\"685\":1,\"689\":1,\"711\":1,\"729\":1,\"755\":1,\"771\":1,\"791\":1,\"804\":1,\"810\":3,\"820\":2,\"827\":1,\"834\":1,\"838\":1,\"839\":1,\"841\":1,\"872\":2,\"873\":1}}],[\"每页包装可消费消息数量\",{\"1\":{\"714\":1}}],[\"每批次消费消息数量\",{\"1\":{\"714\":1}}],[\"每端都有一个消费进度管理器\",{\"1\":{\"703\":1}}],[\"每等待\",{\"1\":{\"656\":1}}],[\"每等待一段时间就调用\",{\"1\":{\"335\":1}}],[\"每等待一段时间\",{\"1\":{\"330\":1}}],[\"每60s调整线程池\",{\"1\":{\"568\":1}}],[\"每5s把消费者的offset持久化\",{\"1\":{\"568\":1}}],[\"每5s判断一次消息是否到达\",{\"1\":{\"344\":1}}],[\"每30s向broker端发送心跳\",{\"1\":{\"568\":1}}],[\"每\",{\"1\":{\"475\":1,\"481\":2,\"550\":1,\"623\":1,\"624\":1,\"702\":1,\"703\":2,\"711\":2,\"721\":1}}],[\"每当配置更新一次\",{\"1\":{\"472\":1}}],[\"每当调用\",{\"1\":{\"57\":1}}],[\"每小时加载下一个小时要投递的消息索引就好了\",{\"1\":{\"451\":1}}],[\"每秒可以处理数十万的消息\",{\"1\":{\"394\":1}}],[\"每秒执行次数\",{\"1\":{\"9\":1}}],[\"每执行一次删除方法减少一次\",{\"1\":{\"390\":1}}],[\"每1s判断一次消息是否到达\",{\"1\":{\"344\":1}}],[\"每创建一个新文件\",{\"1\":{\"313\":1}}],[\"每隔分区内的消息遵循先生产先消费的顺序\",{\"1\":{\"548\":1}}],[\"每隔一定的时间\",{\"1\":{\"324\":1}}],[\"每隔1s检查一次\",{\"1\":{\"288\":1}}],[\"每隔\",{\"1\":{\"272\":1,\"289\":1,\"387\":1,\"388\":1,\"465\":3,\"472\":1,\"474\":1,\"476\":1,\"559\":1,\"618\":1,\"660\":1}}],[\"每一次移动称为一个\",{\"1\":{\"451\":1}}],[\"每一个\",{\"1\":{\"266\":1,\"397\":1,\"662\":1}}],[\"每一个属性\",{\"1\":{\"262\":1}}],[\"每一轮测试称为一个迭代\",{\"1\":{\"4\":1}}],[\"每条消息都会被大量的客户端重复处理\",{\"1\":{\"610\":1}}],[\"每条消息都会分别被存储\",{\"1\":{\"234\":1}}],[\"每条消息都需要被相同订阅逻辑的多台机器处理\",{\"1\":{\"610\":1}}],[\"每条消息会被调用\",{\"1\":{\"426\":1}}],[\"每条消息的写入放大是\",{\"1\":{\"234\":1}}],[\"每条消息还会有额外的确认消息在集群间进行发送\",{\"1\":{\"201\":1}}],[\"每发一条消息就会将自己的信用值减一\",{\"1\":{\"157\":1}}],[\"每次运算都需要传入这个数组运算函数\",{\"1\":{\"843\":1}}],[\"每次从处理队列获取的一批消息数量\",{\"1\":{\"750\":1}}],[\"每次拉取到的消息\",{\"1\":{\"714\":1}}],[\"每次拉取完一次后将拉取请求重新放入拉取服务的等待队列\",{\"1\":{\"657\":1}}],[\"每次重试消费失败后延迟等级会增加\",{\"1\":{\"700\":1}}],[\"每次重新消费的时间间隔将会逐渐增加\",{\"1\":{\"700\":1}}],[\"每次更新\",{\"1\":{\"487\":1}}],[\"每次扫描\",{\"1\":{\"474\":1}}],[\"每次收到心跳包时会替换该信息\",{\"1\":{\"469\":1}}],[\"每次投递时查询该集来判断是否要投递该消息\",{\"1\":{\"455\":1}}],[\"每次启动一个定时任务\",{\"1\":{\"452\":1}}],[\"每次写入较大数据长度时\",{\"1\":{\"437\":1}}],[\"每次发消息时\",{\"1\":{\"424\":1}}],[\"每次发送消息都会调用到这个方法\",{\"1\":{\"416\":1}}],[\"每次调用都会创建\",{\"1\":{\"420\":1}}],[\"每次插入新的消息\",{\"1\":{\"307\":1}}],[\"每次加解锁都只有\",{\"1\":{\"245\":1}}],[\"每次代码变更都要重启一次项目\",{\"1\":{\"120\":1}}],[\"每次测试执行耗时\",{\"1\":{\"11\":1}}],[\"每次预热耗时\",{\"1\":{\"11\":1}}],[\"每次执行测试方法的超时时间为\",{\"1\":{\"11\":1}}],[\"每次\",{\"1\":{\"9\":2,\"11\":2,\"793\":1}}],[\"每次迭代前后\",{\"1\":{\"4\":1}}],[\"每个拉取请求对应拉取一个消息队列的消息\",{\"1\":{\"678\":1}}],[\"每个消息队列都可能会有一个锁\",{\"1\":{\"732\":1}}],[\"每个消息队列会对应创建一个处理队列\",{\"1\":{\"672\":1}}],[\"每个消费任务都持续消费一个队列\",{\"1\":{\"737\":1}}],[\"每个消费任务消费\",{\"1\":{\"624\":1}}],[\"每个消费组的消费应该隔离\",{\"1\":{\"732\":1}}],[\"每个消费组中的消费者都收到全部的\",{\"1\":{\"610\":1}}],[\"每个消费线程也最大程度上被使用\",{\"1\":{\"726\":1}}],[\"每个消费请求将消费一批消息\",{\"1\":{\"699\":1}}],[\"每个消费者分配\",{\"1\":{\"787\":1}}],[\"每个消费者能消费所有队列\",{\"1\":{\"787\":1}}],[\"每个消费者被负载了\",{\"1\":{\"775\":1}}],[\"每个消费者都会有一个消费进度管理器\",{\"1\":{\"711\":1}}],[\"每个消费者都要消费全量消息\",{\"1\":{\"701\":1}}],[\"每个消费者都有一个消费线程池\",{\"1\":{\"624\":1,\"737\":1}}],[\"每个消费者持有一个重平衡实现\",{\"1\":{\"649\":1}}],[\"每个消费者实例会收到全量的消息\",{\"1\":{\"610\":1}}],[\"每个客户端进程一般只有一个\",{\"1\":{\"649\":1}}],[\"每个客户端进程一般只有一个这玩意\",{\"1\":{\"629\":1,\"638\":1}}],[\"每个步骤都会用一篇文章来讲解\",{\"1\":{\"606\":1}}],[\"每个角色有相应的权限集\",{\"1\":{\"496\":1}}],[\"每个指令都不一样\",{\"1\":{\"410\":1}}],[\"每个线程的消费任务是\",{\"1\":{\"726\":1}}],[\"每个线程执行\",{\"1\":{\"378\":1,\"575\":1}}],[\"每个线程中先执行预热\",{\"1\":{\"4\":1}}],[\"每个该类对应一个延迟等级的\",{\"1\":{\"361\":1}}],[\"每个延迟等级在\",{\"1\":{\"378\":1}}],[\"每个延迟等级都分配一个线程\",{\"1\":{\"375\":1}}],[\"每个延迟等级都有一个\",{\"1\":{\"354\":1}}],[\"每个延迟等级扫描的逻辑\",{\"1\":{\"360\":1}}],[\"每个类型的请求码对应一个业务处理器\",{\"1\":{\"575\":1}}],[\"每个类关于定时消息的具体逻辑\",{\"0\":{\"358\":1}}],[\"每个类的具体逻辑\",{\"0\":{\"333\":1}}],[\"每个hash槽的值是最新写入的索引文件的逻辑下标\",{\"1\":{\"317\":1}}],[\"每个索引项包含如下信息\",{\"1\":{\"307\":1}}],[\"每个索引的长度也是固定的\",{\"1\":{\"307\":1}}],[\"每个索引的大小也更大\",{\"1\":{\"293\":1}}],[\"每个索引文件被设计为定长的\",{\"1\":{\"307\":1}}],[\"每个索引文件以其创建的时间命名\",{\"1\":{\"307\":1}}],[\"每个数组元素是一个索引项\",{\"1\":{\"275\":1}}],[\"每个文件也不宜太大\",{\"1\":{\"839\":1}}],[\"每个文件删除间隔\",{\"1\":{\"390\":1}}],[\"每个文件有一个过期时间\",{\"1\":{\"386\":1}}],[\"每个文件的大小是固定的\",{\"1\":{\"300\":1}}],[\"每个文件大小固定\",{\"1\":{\"269\":1}}],[\"每个文件由大小和格式相同的索引项构成\",{\"1\":{\"266\":1}}],[\"每个副本都在不通的\",{\"1\":{\"228\":1}}],[\"每个仲裁队列都有多个副本\",{\"1\":{\"228\":1}}],[\"每个节点会占用\",{\"1\":{\"600\":1}}],[\"每个节点存储\",{\"1\":{\"233\":1}}],[\"每个节点可以承载多个主队列和从队列\",{\"1\":{\"226\":1}}],[\"每个节点都会监控位于自己左右两边的节点\",{\"1\":{\"206\":1}}],[\"每个\",{\"1\":{\"220\":1,\"275\":1,\"356\":2,\"387\":1,\"401\":1,\"402\":1,\"451\":1,\"461\":1,\"614\":1,\"688\":1}}],[\"每个队列代表一个延迟等级\",{\"1\":{\"876\":1}}],[\"每个队列也会被分配给多个消费者\",{\"1\":{\"787\":1}}],[\"每个队列被\",{\"1\":{\"775\":1}}],[\"每个队列就会被多个消费者消费\",{\"1\":{\"775\":1}}],[\"每个队列都可以被一个消费者消费\",{\"1\":{\"723\":1}}],[\"每个队列只会新建一个\",{\"1\":{\"657\":1}}],[\"每个队列可能分布在不同\",{\"1\":{\"549\":1}}],[\"每个队列元素是一个消息的索引\",{\"1\":{\"356\":1}}],[\"每个队列单独存储\",{\"1\":{\"220\":1}}],[\"每个队列仍只存在于一个节点\",{\"1\":{\"181\":1}}],[\"每个镜像队列都包含一个主节点\",{\"1\":{\"182\":1}}],[\"每个rabbitmq\",{\"1\":{\"154\":1}}],[\"每个进程都保存为一个\",{\"1\":{\"156\":1}}],[\"每个进程都有自己的进程邮箱\",{\"1\":{\"144\":1}}],[\"每个进程都有它自己的内存\",{\"1\":{\"77\":1}}],[\"每个进程都带有一个进程邮箱\",{\"1\":{\"79\":1}}],[\"每个erlang进程都有一个被称为进程字典\",{\"1\":{\"67\":1}}],[\"每个迭代中会根据基准测试的模式\",{\"1\":{\"4\":1}}],[\"如上图粉色部分所示\",{\"1\":{\"733\":1}}],[\"如上图所示\",{\"1\":{\"275\":1}}],[\"如消费者异常退出\",{\"1\":{\"732\":1}}],[\"如消息轨迹的处理逻辑就在这里进行处理\",{\"1\":{\"562\":1}}],[\"如刷新应用中的缓存\",{\"1\":{\"610\":1}}],[\"如发生变化\",{\"1\":{\"516\":1}}],[\"如发送消息\",{\"1\":{\"410\":1}}],[\"如此一来\",{\"1\":{\"496\":1}}],[\"如下所示\",{\"1\":{\"464\":1}}],[\"如下图所示\",{\"1\":{\"345\":1,\"610\":1,\"876\":1}}],[\"如下图\",{\"1\":{\"244\":1}}],[\"如图所示\",{\"1\":{\"449\":1,\"550\":1}}],[\"如图1所示\",{\"1\":{\"130\":1}}],[\"如定时任务调度服务\",{\"1\":{\"443\":1}}],[\"如定时任务触发\",{\"1\":{\"441\":1,\"871\":1}}],[\"如\",{\"1\":{\"437\":1,\"444\":1,\"810\":1}}],[\"如没有real\",{\"1\":{\"365\":1}}],[\"如1ms\",{\"1\":{\"324\":1}}],[\"如找到消息\",{\"1\":{\"282\":1}}],[\"如apache\",{\"1\":{\"136\":1}}],[\"如是否符合\",{\"1\":{\"133\":1}}],[\"如pub\",{\"1\":{\"128\":1}}],[\"如何使用\",{\"0\":{\"766\":1}}],[\"如何将轨迹数据发送至存储\",{\"1\":{\"530\":1}}],[\"如何存储轨迹数据\",{\"1\":{\"530\":1}}],[\"如何采集轨迹数据\",{\"1\":{\"530\":1}}],[\"如何在不重启的情况下感知\",{\"1\":{\"461\":1}}],[\"如何在mq中实现支持任意延迟的消息\",{\"1\":{\"458\":1}}],[\"如何知道要从哪个\",{\"1\":{\"461\":1}}],[\"如何解决某一时刻投递消息量太大导致的内存问题\",{\"1\":{\"452\":1}}],[\"如何解决排序问题\",{\"1\":{\"445\":1}}],[\"如何处理索引的加载和投递的触发就成为需要深思熟虑的问题\",{\"1\":{\"450\":1}}],[\"如何实现高性能消息读写\",{\"0\":{\"393\":1},\"1\":{\"884\":1}}],[\"如何保证能够立刻消费到\",{\"1\":{\"326\":1}}],[\"如何进行轮询\",{\"0\":{\"324\":1}}],[\"如何查询消息\",{\"0\":{\"302\":1}}],[\"如何构建\",{\"0\":{\"301\":1}}],[\"如何停止信息接收\",{\"1\":{\"158\":1}}],[\"如何通过flow状态识别进程的性能瓶颈\",{\"1\":{\"155\":1}}],[\"如何识别性能瓶颈\",{\"0\":{\"155\":1}}],[\"如何与外部程序通信\",{\"0\":{\"91\":1}}],[\"如何工作\",{\"0\":{\"4\":1}}],[\"如调试某个有问题的宏时\",{\"1\":{\"58\":1}}],[\"如果返回\",{\"1\":{\"852\":1}}],[\"如果返回false\",{\"1\":{\"317\":1}}],[\"如果开关开启\",{\"1\":{\"851\":1}}],[\"如果开启了一些配置则也会用到\",{\"1\":{\"838\":1}}],[\"如果开启则会在一段时间内都规避发送失败的\",{\"1\":{\"549\":1}}],[\"如果开启消息轨迹\",{\"1\":{\"539\":1}}],[\"如果开启监听\",{\"1\":{\"517\":1}}],[\"如果开启\",{\"1\":{\"309\":1}}],[\"如果带有\",{\"1\":{\"841\":1}}],[\"如果过滤的\",{\"1\":{\"848\":1}}],[\"如果过滤匹配的\",{\"1\":{\"839\":1}}],[\"如果过滤规则\",{\"1\":{\"834\":1}}],[\"如果过滤模式为类过滤\",{\"1\":{\"691\":1}}],[\"如果只是调用\",{\"1\":{\"820\":1}}],[\"如果只是想要记录里的单个字段\",{\"1\":{\"41\":1}}],[\"如果属性中有\",{\"1\":{\"814\":1}}],[\"如果将\",{\"1\":{\"810\":1}}],[\"如果前面拉取普通消息之后\",{\"1\":{\"789\":1}}],[\"如果找到对应的\",{\"1\":{\"782\":1}}],[\"如果找到消息\",{\"1\":{\"683\":1}}],[\"如果放入内存失败\",{\"1\":{\"780\":1}}],[\"如果放入队列失败\",{\"1\":{\"377\":1}}],[\"如果成功则直接返回\",{\"1\":{\"779\":1,\"780\":1}}],[\"如果匹配成功则更新\",{\"1\":{\"773\":1}}],[\"如果匹配则放行\",{\"1\":{\"511\":1,\"520\":1}}],[\"如果匹配则直接放行\",{\"1\":{\"511\":1,\"520\":1}}],[\"如果订阅关系不一致会造成消息丢失\",{\"1\":{\"759\":1}}],[\"如果获取的这批消息不为空\",{\"1\":{\"750\":1}}],[\"如果获取不到\",{\"1\":{\"417\":1}}],[\"如果本次消费任务执行时长超过\",{\"1\":{\"750\":1}}],[\"如果处理队列没有被锁定\",{\"1\":{\"748\":1}}],[\"如果处理队列已经被锁定\",{\"1\":{\"748\":1}}],[\"如果之前没有被锁定过\",{\"1\":{\"748\":1}}],[\"如果加锁失败则跳过\",{\"1\":{\"744\":1}}],[\"如果请求到锁才开始拉取\",{\"1\":{\"729\":1}}],[\"如果未开启内存匹配\",{\"1\":{\"796\":1}}],[\"如果未被消费完则跳过拉取操作\",{\"1\":{\"727\":1}}],[\"如果未找到消息则挂起\",{\"1\":{\"339\":1,\"693\":1}}],[\"如果重试次数超过\",{\"1\":{\"718\":1}}],[\"如果重试队列数量为\",{\"1\":{\"718\":1}}],[\"如果重试的消息仍发往同一个\",{\"1\":{\"552\":1}}],[\"如果知道\",{\"1\":{\"717\":1}}],[\"如果发生变化\",{\"1\":{\"850\":1}}],[\"如果发回失败\",{\"1\":{\"715\":1}}],[\"如果发现到投递时间的消息\",{\"1\":{\"356\":1}}],[\"如果丢弃则不处理结果\",{\"1\":{\"715\":1}}],[\"如果丢弃\",{\"1\":{\"715\":1}}],[\"如果到期则投递\",{\"1\":{\"708\":1}}],[\"如果到达则投递到它本该去的\",{\"1\":{\"445\":1}}],[\"如果到达\",{\"1\":{\"381\":1}}],[\"如果在则表示该消息可能符合过滤条件\",{\"1\":{\"839\":1}}],[\"如果在写缓冲区中排队的字节数先超过了高水位线\",{\"1\":{\"819\":1}}],[\"如果在写缓冲区中排队的字节数超过了高水位线\",{\"1\":{\"819\":1}}],[\"如果在内存中找不到对应的\",{\"1\":{\"773\":1}}],[\"如果在一段时间\",{\"1\":{\"773\":1}}],[\"如果在重新消费次数阈值之内\",{\"1\":{\"708\":1}}],[\"如果在声明队列时列表中的节点都不在线\",{\"1\":{\"190\":1}}],[\"如果仍然消费失败\",{\"1\":{\"700\":1}}],[\"如果msgfoundlist为空\",{\"1\":{\"695\":1,\"749\":1}}],[\"如果mappedfilequeue中的mappedfile列表被删除\",{\"1\":{\"285\":1}}],[\"如果commitlog可用且当前节点为主节点\",{\"1\":{\"693\":1}}],[\"如果consumer请求达到了超时时间\",{\"1\":{\"345\":1}}],[\"如果允许从slave拉数据\",{\"1\":{\"693\":1}}],[\"如果为空\",{\"1\":{\"690\":1}}],[\"如果为空表示上次发送成功\",{\"1\":{\"572\":1}}],[\"如果当前没有消息\",{\"1\":{\"693\":1}}],[\"如果当前消费者被挂起\",{\"1\":{\"690\":1}}],[\"如果当前发送次数小于异步发送重试次数\",{\"1\":{\"560\":1}}],[\"如果拉取请求没有指定队列\",{\"1\":{\"789\":1}}],[\"如果拉取成功才执行下述操作\",{\"1\":{\"685\":1}}],[\"如果拉取远程镜像\",{\"1\":{\"595\":1}}],[\"如果查不到则请求\",{\"1\":{\"680\":1}}],[\"如果查询不到\",{\"1\":{\"550\":1}}],[\"如果查询失败\",{\"1\":{\"381\":1}}],[\"如果需要分发到\",{\"1\":{\"814\":1}}],[\"如果需要流控则延迟\",{\"1\":{\"679\":1}}],[\"如果需要构建对象\",{\"1\":{\"116\":1}}],[\"如果reblance之后的mq集合包含该messagequeue\",{\"1\":{\"664\":1,\"744\":1}}],[\"如果新分配到的消息队列集合中不含有老的消息队列\",{\"1\":{\"664\":1,\"744\":1}}],[\"如果新提升为主节点的这个副本与原有的主节点并未完成数据的同步\",{\"1\":{\"192\":1}}],[\"如果变化则丢弃老队列\",{\"1\":{\"650\":1}}],[\"如果变化则触发消费队列重平衡\",{\"1\":{\"618\":1}}],[\"如果二次调用\",{\"1\":{\"642\":1}}],[\"如果二阶段的处理速度跟不上一阶段\",{\"1\":{\"254\":1}}],[\"如果路由信息有变化\",{\"1\":{\"640\":1}}],[\"如果路由信息没有找到\",{\"1\":{\"571\":1}}],[\"如果我们自己来设计拉\",{\"1\":{\"637\":1}}],[\"如果正常消费和重试\",{\"1\":{\"620\":1}}],[\"如果正常消费失败\",{\"1\":{\"620\":1}}],[\"如果修改延迟等级时间的配置\",{\"1\":{\"620\":1}}],[\"如果消费请求被消费成功\",{\"1\":{\"711\":1}}],[\"如果消费失败\",{\"1\":{\"699\":1,\"708\":1,\"738\":1}}],[\"如果消费的\",{\"1\":{\"665\":1}}],[\"如果消费成功则会更新消费进度\",{\"1\":{\"704\":1}}],[\"如果消费成功\",{\"1\":{\"624\":1,\"699\":1,\"708\":1}}],[\"如果消费进度文件丢失\",{\"1\":{\"610\":1}}],[\"如果消息之前没有重新消费过\",{\"1\":{\"718\":1}}],[\"如果消息消费失败\",{\"1\":{\"700\":1}}],[\"如果消息通过了\",{\"1\":{\"694\":1}}],[\"如果消息重试次数超过最大重试次数\",{\"1\":{\"576\":1}}],[\"如果消息重试次数超过允许的最大重试次数\",{\"1\":{\"563\":1}}],[\"如果消息投递失败了且不做任何处理\",{\"1\":{\"454\":1}}],[\"如果消息到期则直接投递\",{\"1\":{\"452\":1}}],[\"如果消息到期\",{\"1\":{\"377\":1}}],[\"如果用本地打包的镜像\",{\"1\":{\"599\":1}}],[\"如果你拉取的版本没有改\",{\"1\":{\"595\":1}}],[\"如果自己修改了\",{\"1\":{\"592\":1}}],[\"如果注册了发送钩子函数\",{\"1\":{\"573\":2}}],[\"如果第一次没有查询到\",{\"1\":{\"571\":1}}],[\"如果已经启动\",{\"1\":{\"567\":1}}],[\"如果已经使用\",{\"1\":{\"8\":1}}],[\"如果状态为\",{\"1\":{\"567\":1}}],[\"如果上一次发送失败\",{\"1\":{\"561\":1}}],[\"如果上一次发送成功\",{\"1\":{\"561\":1}}],[\"如果上一次是异常退出\",{\"1\":{\"313\":1}}],[\"如果最终都没有拉取到\",{\"1\":{\"559\":1}}],[\"如果最后一个文件存在并且未满\",{\"1\":{\"309\":1}}],[\"如果同步发送则等待消息保存成功后返回\",{\"1\":{\"550\":1}}],[\"如果把一个\",{\"1\":{\"548\":1}}],[\"如果相差大于\",{\"1\":{\"474\":1}}],[\"如果连接的\",{\"1\":{\"461\":1}}],[\"如果多次投递失败会阻塞其他消息的投递\",{\"1\":{\"454\":1}}],[\"如果还未到期则该任务结束\",{\"1\":{\"452\":1}}],[\"如果继续优化时间轮的方案未尝不可\",{\"1\":{\"451\":1}}],[\"如果此时流控还没有解除\",{\"1\":{\"451\":1}}],[\"如果直接投递到\",{\"1\":{\"450\":1}}],[\"如果要开启则需要设置一下配置项\",{\"1\":{\"835\":1}}],[\"如果要开启布隆过滤器进行双层过滤\",{\"1\":{\"828\":1}}],[\"如果要使用\",{\"1\":{\"828\":1}}],[\"如果要做到\",{\"1\":{\"723\":1}}],[\"如果要再次消费\",{\"1\":{\"708\":1}}],[\"如果要用\",{\"1\":{\"599\":1}}],[\"如果要单独存储\",{\"1\":{\"448\":1}}],[\"如果要同步消息\",{\"1\":{\"211\":1}}],[\"如果按照上述方案\",{\"1\":{\"451\":1}}],[\"如果按\",{\"1\":{\"447\":1}}],[\"如果定时消息和普通消息存在一起\",{\"1\":{\"446\":1}}],[\"如果可以取消定时消息\",{\"1\":{\"441\":1,\"871\":1}}],[\"如果想要固定时间投递\",{\"1\":{\"440\":1}}],[\"如果长轮询被启用\",{\"1\":{\"426\":1}}],[\"如果文件过期\",{\"1\":{\"390\":1}}],[\"如果文件列表为空或者最后一个文件写满了\",{\"1\":{\"313\":1}}],[\"如果该队列被丢弃\",{\"1\":{\"690\":1}}],[\"如果该\",{\"1\":{\"585\":1}}],[\"如果该主题为顺序消息\",{\"1\":{\"477\":1,\"493\":2}}],[\"如果该文件被其他线程占用\",{\"1\":{\"390\":1}}],[\"如果该hash槽的值有效则查找\",{\"1\":{\"317\":1}}],[\"如果超过消息总大小阈值\",{\"1\":{\"585\":1}}],[\"如果超过\",{\"1\":{\"447\":1,\"465\":1,\"750\":1}}],[\"如果超过那么也会直接返回消费者\",{\"1\":{\"326\":1}}],[\"如果超出该时间\",{\"1\":{\"390\":1}}],[\"如果删了之后磁盘容量小于\",{\"1\":{\"386\":1}}],[\"如果符合删除条件\",{\"1\":{\"384\":1}}],[\"如果符号x在b里只出现了k次\",{\"1\":{\"62\":1}}],[\"如果阻塞队列中元素数量大于阈值则触发流控\",{\"1\":{\"380\":1}}],[\"如果全部投递成功\",{\"1\":{\"377\":1}}],[\"如果投递速度跟不上\",{\"1\":{\"452\":1}}],[\"如果投递速度能跟上\",{\"1\":{\"452\":1}}],[\"如果投递错误\",{\"1\":{\"378\":1}}],[\"如果投递中\",{\"1\":{\"378\":1}}],[\"如果投递成功\",{\"1\":{\"378\":1}}],[\"如果投递异常\",{\"1\":{\"375\":1}}],[\"如果投递任务已完成\",{\"1\":{\"375\":1}}],[\"如果某个任务处理慢了\",{\"1\":{\"372\":1}}],[\"如果所有消息都已经被投递\",{\"1\":{\"365\":1}}],[\"如果所有模式都不匹配\",{\"1\":{\"37\":1}}],[\"如果现在还没到投递时间点\",{\"1\":{\"365\":2,\"380\":1}}],[\"如果现在已经到了投递时间点\",{\"1\":{\"365\":2,\"380\":1}}],[\"如果从消费队列中未找到新的可以拉取的消息\",{\"1\":{\"339\":1}}],[\"如果从存储中没有查询到消息\",{\"1\":{\"334\":1,\"339\":1}}],[\"如果条件成立则说明有新消息达到broker端\",{\"1\":{\"335\":1}}],[\"如果确实有新消息\",{\"1\":{\"332\":1}}],[\"如果被调用\",{\"1\":{\"332\":1}}],[\"如果被更新的映射组不包含键k\",{\"1\":{\"42\":1}}],[\"如果检查到有新消息可以拉取\",{\"1\":{\"332\":1}}],[\"如果一致\",{\"1\":{\"834\":1}}],[\"如果一条消息消费不成功会一直重试\",{\"1\":{\"761\":1}}],[\"如果一个消费组内两个消费者的\",{\"1\":{\"760\":1}}],[\"如果一个\",{\"1\":{\"622\":1}}],[\"如果一次轮询没有找到消息\",{\"1\":{\"326\":1}}],[\"如果一直没有新消息\",{\"1\":{\"324\":1}}],[\"如果支持挂起\",{\"1\":{\"326\":1}}],[\"如果能被\",{\"1\":{\"777\":1}}],[\"如果能够拉取消息\",{\"1\":{\"326\":1}}],[\"如果能匹配\",{\"1\":{\"44\":1}}],[\"如果小于\",{\"1\":{\"392\":1}}],[\"如果小于则直接退出\",{\"1\":{\"317\":1}}],[\"如果小于等于\",{\"1\":{\"289\":1}}],[\"如果创建了新文件\",{\"1\":{\"313\":1}}],[\"如果存在\",{\"1\":{\"313\":1}}],[\"如果集群负载较高\",{\"1\":{\"754\":1}}],[\"如果集群中有多个计数节点\",{\"1\":{\"190\":1}}],[\"如果集群中的可用节点数少于count\",{\"1\":{\"190\":1}}],[\"如果集合为空或者最后一个文件写满了\",{\"1\":{\"313\":2}}],[\"如果不进行流控直接写入\",{\"1\":{\"878\":1}}],[\"如果不进行一些检查和监控\",{\"1\":{\"235\":1}}],[\"如果不启用长轮询\",{\"1\":{\"693\":1}}],[\"如果不是类过滤模式\",{\"1\":{\"690\":1}}],[\"如果不是\",{\"1\":{\"581\":2,\"693\":1}}],[\"如果不手动修改\",{\"1\":{\"556\":1}}],[\"如果不为空则需要注意删除文件原有数据\",{\"1\":{\"518\":1}}],[\"如果不在则返回错误\",{\"1\":{\"511\":1,\"520\":1}}],[\"如果不使用\",{\"1\":{\"423\":1}}],[\"如果不用\",{\"1\":{\"423\":1}}],[\"如果不满足以上两个条件\",{\"1\":{\"345\":1}}],[\"如果不存在则跳过\",{\"1\":{\"799\":1}}],[\"如果不存在则需要填入\",{\"1\":{\"317\":1}}],[\"如果不存在或者最后一个文件写满\",{\"1\":{\"313\":1}}],[\"如果不存在或者已经满了\",{\"1\":{\"309\":1}}],[\"如果不存在\",{\"1\":{\"309\":1}}],[\"如果=0\",{\"1\":{\"289\":1}}],[\"如果期望写入的位置\",{\"1\":{\"285\":1}}],[\"如果有的话\",{\"1\":{\"640\":1}}],[\"如果有需要的话对于消费失败的消息还需要发回\",{\"1\":{\"637\":1}}],[\"如果有人再问你怎么实现分布式延时消息\",{\"1\":{\"458\":1}}],[\"如果有一个投递任务重试\",{\"1\":{\"380\":1}}],[\"如果有还未投递的消息\",{\"1\":{\"365\":1,\"380\":1}}],[\"如果有\",{\"1\":{\"354\":1}}],[\"如果有则解析该属性\",{\"1\":{\"814\":1}}],[\"如果有则传输回客户端\",{\"1\":{\"777\":1}}],[\"如果有则根据消费队列中的索引项\",{\"1\":{\"673\":1}}],[\"如果有则将真正\",{\"1\":{\"708\":1}}],[\"如果有则将到期的消息一个个同步投递\",{\"1\":{\"375\":1}}],[\"如果有则将到期消息都投递到\",{\"1\":{\"361\":1}}],[\"如果有则将消息真正的\",{\"1\":{\"354\":1}}],[\"如果有则将这条消息查出来\",{\"1\":{\"270\":1,\"301\":1}}],[\"如果有则执行拉取请求操作\",{\"1\":{\"343\":1}}],[\"如果有数据满足要求\",{\"1\":{\"335\":1,\"343\":1}}],[\"如果有新消息\",{\"1\":{\"326\":1}}],[\"如果有值说明这个hash\",{\"1\":{\"317\":1}}],[\"如果有镜像没有授予生产者信用\",{\"1\":{\"197\":1}}],[\"如果没有被过滤\",{\"1\":{\"851\":1}}],[\"如果没有到\",{\"1\":{\"799\":1}}],[\"如果没有指定队列\",{\"1\":{\"777\":1}}],[\"如果没有消息则不处理\",{\"1\":{\"715\":1}}],[\"如果没有这个队列\",{\"1\":{\"683\":1}}],[\"如果没有找到\",{\"1\":{\"572\":1,\"683\":1}}],[\"如果没有可用的\",{\"1\":{\"572\":1}}],[\"如果没有拉取到\",{\"1\":{\"559\":1}}],[\"如果没有拉取到消息\",{\"1\":{\"326\":1}}],[\"如果没有填充值\",{\"1\":{\"402\":1}}],[\"如果没有则挂起轮询\",{\"1\":{\"777\":1}}],[\"如果没有则进行结果处理\",{\"1\":{\"708\":1}}],[\"如果没有则从服务端\",{\"1\":{\"838\":1}}],[\"如果没有则从\",{\"1\":{\"562\":1}}],[\"如果没有则等待\",{\"1\":{\"361\":1}}],[\"如果没有则继续循环扫描\",{\"1\":{\"354\":1}}],[\"如果没有则继续等待\",{\"1\":{\"326\":1}}],[\"如果没有查询到消息\",{\"1\":{\"332\":1}}],[\"如果没有新消息不会马上返回\",{\"1\":{\"434\":1}}],[\"如果没有新消息到达\",{\"1\":{\"326\":1}}],[\"如果没有新消息则立刻返回\",{\"1\":{\"324\":1}}],[\"如果没有索引文件或者最后一个索引文件满了\",{\"1\":{\"309\":1}}],[\"如果没有数据则调用\",{\"1\":{\"246\":1}}],[\"如果没有流控\",{\"1\":{\"144\":1}}],[\"如果日志中涉及字符串拼接等操作\",{\"1\":{\"242\":1}}],[\"如果仲裁队列超过半数的副本永久丢失\",{\"1\":{\"236\":1}}],[\"如果生产和消费的速度能够基本匹配\",{\"1\":{\"226\":1}}],[\"如果生产者和消费者连接的是从节点\",{\"1\":{\"202\":1}}],[\"如果选择同步\",{\"1\":{\"226\":1}}],[\"如果希望消息直接被保存到磁盘中\",{\"1\":{\"214\":1}}],[\"如果b节点将消息发送给c后\",{\"1\":{\"207\":1}}],[\"如果节点c收到b发送的消息还未发送给d时异常结束了\",{\"1\":{\"207\":1}}],[\"如果节点a节点成为赢家\",{\"1\":{\"192\":1}}],[\"如果是类过滤模式\",{\"1\":{\"847\":1,\"852\":1}}],[\"如果是slave\",{\"1\":{\"817\":1}}],[\"如果是第一次锁定\",{\"1\":{\"748\":1}}],[\"如果是顺序消费\",{\"1\":{\"744\":1,\"745\":1}}],[\"如果是单元化模式\",{\"1\":{\"718\":1}}],[\"如果是重试消息且第一次重试\",{\"1\":{\"708\":1}}],[\"如果是集群模式\",{\"1\":{\"708\":1}}],[\"如果是集群消费模式\",{\"1\":{\"623\":1}}],[\"如果是广播模式\",{\"1\":{\"708\":1,\"750\":1}}],[\"如果是子节点\",{\"1\":{\"691\":1}}],[\"如果是启动状态\",{\"1\":{\"688\":1}}],[\"如果是push\",{\"1\":{\"664\":1,\"744\":1}}],[\"如果是才继续走启动流程\",{\"1\":{\"640\":1}}],[\"如果是内存较小的机器则可以通过定义环境变量修改内存占用\",{\"1\":{\"600\":1}}],[\"如果是采用远程拉取的镜像\",{\"1\":{\"595\":1}}],[\"如果是异步发送则直接返回\",{\"1\":{\"550\":1}}],[\"如果是异步刷盘\",{\"1\":{\"285\":1}}],[\"如果是定时消息\",{\"1\":{\"359\":1,\"363\":1}}],[\"如果是\",{\"1\":{\"357\":1,\"414\":1,\"491\":1,\"581\":2,\"718\":1,\"798\":2}}],[\"如果是则会发送一个通知\",{\"1\":{\"326\":1}}],[\"如果是事务消息的回滚消息\",{\"1\":{\"314\":1}}],[\"如果是这样\",{\"1\":{\"198\":1}}],[\"如果是性能瓶颈\",{\"1\":{\"155\":1}}],[\"如果队列的堆积少\",{\"1\":{\"226\":1}}],[\"如果队列为非持久化\",{\"1\":{\"217\":1}}],[\"如果队列很小\",{\"1\":{\"191\":1}}],[\"如果队列名称符合\",{\"1\":{\"188\":1}}],[\"如果主队列挂掉\",{\"1\":{\"226\":1}}],[\"如果主队列在所有未同步的消息耗尽之前失败\",{\"1\":{\"191\":1}}],[\"如果主节点不可用\",{\"1\":{\"190\":1}}],[\"如果这批消息数量大于每批次可以消费的消息\",{\"1\":{\"714\":1}}],[\"如果这\",{\"1\":{\"326\":1}}],[\"如果这些节点名中有任何一个不是集群的一部分\",{\"1\":{\"190\":1}}],[\"如果这个异常错误没有被捕捉到\",{\"1\":{\"43\":1}}],[\"如果运行队列主服务器的节点变得不可用\",{\"1\":{\"190\":1}}],[\"如果信用值大于0\",{\"1\":{\"159\":1}}],[\"如果通过\",{\"1\":{\"121\":1}}],[\"如果模式匹配\",{\"1\":{\"111\":1}}],[\"如果省略了exceptiontype\",{\"1\":{\"44\":1}}],[\"如果执行过程没有抛出异常错误\",{\"1\":{\"44\":1}}],[\"如果\",{\"1\":{\"38\":1,\"44\":1,\"367\":1,\"422\":1,\"426\":1,\"436\":2,\"462\":1,\"474\":2,\"498\":1,\"573\":1,\"683\":1,\"718\":1,\"735\":1,\"777\":2,\"781\":1,\"797\":1,\"798\":1}}],[\"如果得到的值为\",{\"1\":{\"38\":1}}],[\"如果shell将某个整数列表打印成字符串\",{\"1\":{\"28\":1}}],[\"如果列表内的所有整数都代表可打印字符\",{\"1\":{\"28\":1}}],[\"如果t是一个列表\",{\"1\":{\"27\":1}}],[\"如果大于重新消费次数阈值\",{\"1\":{\"708\":1}}],[\"如果大于0\",{\"1\":{\"289\":1}}],[\"如果大于\",{\"1\":{\"9\":1}}],[\"如果使用\",{\"1\":{\"7\":1}}],[\"如果设置用多个进程执行\",{\"1\":{\"4\":1}}],[\"fetch\",{\"1\":{\"789\":1}}],[\"fetchlockobject\",{\"1\":{\"750\":1}}],[\"fetchconsumeoffset\",{\"1\":{\"637\":1}}],[\"fetchsubscribemessagequeues\",{\"1\":{\"636\":1}}],[\"fetchnameserveraddr\",{\"1\":{\"568\":3,\"643\":1}}],[\"feature\",{\"1\":{\"225\":1}}],[\"federate\",{\"1\":{\"169\":1}}],[\"federation\",{\"0\":{\"162\":1,\"165\":1,\"166\":1,\"167\":1,\"169\":1},\"1\":{\"162\":1,\"163\":4,\"165\":3,\"166\":1,\"167\":1,\"168\":2,\"169\":1,\"171\":4,\"173\":3,\"238\":1}}],[\"f2c488\",{\"1\":{\"116\":3,\"117\":1}}],[\"fprof\",{\"1\":{\"105\":1}}],[\"fprof显示调用和被调用函数的时间\",{\"1\":{\"105\":1}}],[\"flexable\",{\"1\":{\"438\":1}}],[\"flame\",{\"1\":{\"406\":1}}],[\"flag\",{\"1\":{\"257\":2,\"258\":1,\"262\":2,\"410\":1,\"414\":1,\"455\":1,\"525\":1,\"555\":1,\"573\":1}}],[\"flaglist\",{\"1\":{\"111\":3}}],[\"flip\",{\"1\":{\"257\":1,\"258\":1,\"285\":1}}],[\"flowcontroltimes=\",{\"1\":{\"690\":3}}],[\"flow模块来追踪它已经向rabbit\",{\"1\":{\"157\":1}}],[\"flows\",{\"1\":{\"147\":2,\"154\":2}}],[\"flow\",{\"0\":{\"142\":1},\"1\":{\"142\":1,\"147\":3,\"151\":1,\"154\":2,\"156\":1,\"157\":12,\"158\":2,\"159\":5,\"160\":3,\"161\":4,\"238\":1,\"380\":2,\"690\":6,\"693\":1}}],[\"floor\",{\"1\":{\"103\":2}}],[\"flushdata\",{\"1\":{\"541\":1}}],[\"flushdisktype\",{\"1\":{\"402\":3,\"595\":2}}],[\"flushindexfilethread\",{\"1\":{\"313\":1}}],[\"flushthread\",{\"1\":{\"313\":3}}],[\"flushthisfile\",{\"1\":{\"313\":2}}],[\"flushconsumequeueleastpages\",{\"1\":{\"289\":5}}],[\"flushconsumequeueservice\",{\"0\":{\"289\":1},\"1\":{\"288\":1}}],[\"flushconsumequeuethoroughinterval\",{\"1\":{\"278\":1,\"289\":2}}],[\"flushcommitlogtimed\",{\"1\":{\"240\":1,\"252\":1,\"255\":2}}],[\"flush\",{\"1\":{\"21\":2,\"289\":2,\"309\":1,\"313\":1,\"316\":4,\"364\":1,\"402\":8,\"595\":2,\"793\":2,\"820\":3}}],[\"fallbehind\",{\"1\":{\"694\":2}}],[\"false\",{\"1\":{\"31\":6,\"36\":3,\"37\":1,\"122\":1,\"158\":1,\"159\":1,\"160\":1,\"198\":1,\"255\":1,\"262\":2,\"282\":2,\"285\":1,\"289\":1,\"317\":2,\"339\":1,\"340\":1,\"364\":1,\"380\":2,\"410\":1,\"414\":2,\"435\":3,\"481\":2,\"487\":3,\"491\":1,\"492\":1,\"503\":2,\"540\":2,\"541\":2,\"568\":1,\"570\":2,\"573\":4,\"587\":1,\"642\":1,\"643\":1,\"648\":1,\"664\":1,\"690\":2,\"691\":2,\"692\":2,\"693\":5,\"694\":2,\"695\":1,\"715\":2,\"717\":1,\"718\":2,\"720\":1,\"744\":1,\"745\":1,\"746\":1,\"750\":3,\"754\":1,\"768\":1,\"789\":2,\"790\":1,\"795\":5,\"796\":7,\"797\":2,\"808\":1,\"817\":3,\"819\":3,\"820\":2,\"828\":1,\"850\":2,\"852\":2}}],[\"fastlistenport=10929\",{\"1\":{\"595\":1}}],[\"fastencodeheader\",{\"1\":{\"414\":2}}],[\"fastjson\",{\"1\":{\"413\":2}}],[\"fastcodesheader\",{\"1\":{\"411\":1,\"414\":3}}],[\"fault\",{\"1\":{\"399\":1}}],[\"fanout\",{\"1\":{\"233\":1,\"234\":1}}],[\"factory\",{\"1\":{\"568\":2,\"643\":2}}],[\"factor\",{\"1\":{\"228\":1}}],[\"fail\",{\"1\":{\"796\":3,\"797\":1,\"817\":1}}],[\"failscheduleoffset\",{\"1\":{\"365\":3}}],[\"failed\",{\"1\":{\"317\":2,\"340\":2,\"343\":1,\"345\":2,\"365\":1,\"390\":1,\"519\":1,\"520\":1,\"539\":1,\"567\":2,\"568\":3,\"642\":2,\"643\":3,\"663\":1,\"664\":4,\"690\":2,\"693\":4,\"694\":1,\"715\":4,\"718\":1,\"744\":4,\"746\":1,\"748\":1,\"750\":1,\"786\":1,\"817\":2}}],[\"failover\",{\"1\":{\"198\":2}}],[\"failure设置为always\",{\"1\":{\"192\":2}}],[\"failure\",{\"1\":{\"192\":2}}],[\"faqurl\",{\"1\":{\"493\":2,\"567\":4,\"570\":2,\"642\":4,\"693\":8,\"718\":2}}],[\"faq\",{\"1\":{\"173\":1}}],[\"farmer\",{\"1\":{\"103\":2}}],[\"f4\",{\"1\":{\"42\":1}}],[\"f4=f1\",{\"1\":{\"42\":1}}],[\"f3\",{\"1\":{\"42\":2}}],[\"f1\",{\"1\":{\"42\":2}}],[\"firstrt\",{\"1\":{\"798\":4}}],[\"firstmsgoffset\",{\"1\":{\"695\":5,\"749\":2}}],[\"firstkey\",{\"1\":{\"690\":3}}],[\"firstelement\",{\"1\":{\"518\":2}}],[\"firstprocess\",{\"1\":{\"380\":4}}],[\"first\",{\"1\":{\"364\":1,\"491\":1,\"505\":1,\"527\":1,\"690\":2,\"693\":1,\"748\":2,\"800\":2}}],[\"finish\",{\"1\":{\"797\":3}}],[\"finished\",{\"1\":{\"402\":1}}],[\"finally\",{\"1\":{\"313\":1,\"314\":1,\"317\":2,\"365\":1,\"380\":1,\"392\":1,\"435\":1,\"490\":1,\"491\":1,\"492\":2,\"573\":1,\"694\":1,\"717\":1,\"742\":1,\"745\":1,\"750\":1,\"790\":1}}],[\"final\",{\"1\":{\"257\":16,\"258\":4,\"277\":6,\"284\":1,\"285\":5,\"287\":6,\"291\":1,\"309\":1,\"310\":8,\"313\":2,\"314\":1,\"316\":1,\"317\":16,\"334\":1,\"339\":1,\"340\":3,\"342\":3,\"343\":1,\"345\":4,\"363\":2,\"390\":4,\"400\":2,\"402\":2,\"417\":1,\"424\":1,\"480\":4,\"490\":16,\"491\":8,\"493\":2,\"504\":2,\"505\":2,\"514\":1,\"516\":1,\"537\":1,\"539\":3,\"541\":6,\"567\":1,\"570\":4,\"571\":1,\"572\":5,\"573\":7,\"576\":3,\"636\":1,\"637\":2,\"662\":3,\"663\":2,\"664\":3,\"688\":2,\"690\":4,\"691\":12,\"692\":5,\"693\":10,\"694\":9,\"714\":5,\"715\":3,\"717\":3,\"718\":3,\"720\":1,\"721\":9,\"742\":5,\"744\":3,\"746\":1,\"748\":2,\"750\":4,\"768\":2,\"786\":7,\"787\":2,\"789\":1,\"791\":10,\"793\":2,\"816\":1,\"817\":1,\"819\":3,\"848\":3,\"850\":5}}],[\"findsubscriptiondata\",{\"1\":{\"693\":1}}],[\"findsubscriptiongroupconfig\",{\"1\":{\"693\":1,\"718\":1,\"799\":1}}],[\"findbrokeraddressinsubscribe\",{\"1\":{\"691\":2,\"720\":2,\"746\":1}}],[\"findbrokeraddressinpublish\",{\"1\":{\"573\":2,\"717\":1}}],[\"findbrokerresult\",{\"1\":{\"691\":9,\"720\":7,\"746\":4}}],[\"findconsumeridlist\",{\"1\":{\"663\":1}}],[\"findconsumequeue\",{\"1\":{\"284\":1,\"287\":1,\"365\":1,\"380\":1,\"694\":2,\"817\":1}}],[\"finding\",{\"1\":{\"161\":1}}],[\"find\",{\"1\":{\"103\":2,\"365\":2,\"380\":2,\"690\":1,\"694\":3,\"798\":2}}],[\"fieldcache\",{\"1\":{\"515\":2}}],[\"fieldname\",{\"1\":{\"262\":5}}],[\"field\",{\"1\":{\"123\":1,\"262\":19,\"515\":10}}],[\"fields\",{\"1\":{\"103\":3,\"262\":18,\"411\":5,\"515\":7}}],[\"fib\",{\"1\":{\"111\":7}}],[\"fixme\",{\"1\":{\"798\":1}}],[\"fixed\",{\"1\":{\"664\":1}}],[\"fix\",{\"1\":{\"41\":5,\"240\":1,\"256\":1,\"420\":1,\"573\":1,\"665\":1,\"690\":1,\"693\":1,\"695\":1,\"748\":1}}],[\"fill\",{\"1\":{\"285\":1}}],[\"fillpreblank\",{\"1\":{\"285\":1}}],[\"filter=\",{\"1\":{\"852\":1}}],[\"filterdatas\",{\"1\":{\"851\":5}}],[\"filterdatabytopic\",{\"1\":{\"850\":2}}],[\"filterdatamapbytopic\",{\"1\":{\"850\":8}}],[\"filterdata\",{\"1\":{\"843\":3,\"851\":9}}],[\"filterexpressiontype\",{\"1\":{\"827\":1,\"830\":1}}],[\"filterexpression\",{\"1\":{\"827\":4,\"830\":4}}],[\"filterapi\",{\"1\":{\"693\":1}}],[\"filtermessagehooklist\",{\"1\":{\"642\":1}}],[\"filterserverlist\",{\"1\":{\"490\":2,\"491\":4}}],[\"filterserver\",{\"1\":{\"464\":1,\"469\":1,\"470\":1,\"488\":1,\"491\":1,\"853\":1}}],[\"filterservertable\",{\"1\":{\"464\":1,\"469\":1,\"470\":1,\"473\":1,\"477\":1,\"488\":3,\"491\":3,\"492\":1,\"493\":1}}],[\"filterbitmap\",{\"1\":{\"345\":2,\"348\":2,\"851\":4,\"852\":4}}],[\"filter\",{\"0\":{\"821\":1},\"1\":{\"31\":3,\"34\":1,\"37\":4,\"287\":1,\"469\":1,\"470\":1,\"488\":1,\"491\":1,\"690\":1,\"691\":1,\"693\":6,\"694\":2,\"821\":1,\"838\":1,\"851\":3,\"852\":2,\"884\":1}}],[\"fileregion\",{\"1\":{\"693\":3}}],[\"filereservedtime\",{\"1\":{\"386\":1,\"390\":4,\"595\":2}}],[\"filenotfoundexception\",{\"1\":{\"599\":1}}],[\"filename应当包含一个绝对或相对路径\",{\"1\":{\"61\":1}}],[\"filename\",{\"1\":{\"61\":1,\"313\":2,\"400\":1,\"519\":5}}],[\"fileabsolutepath\",{\"1\":{\"519\":3}}],[\"filehome\",{\"1\":{\"518\":2}}],[\"filefullpath\",{\"1\":{\"517\":4}}],[\"filefromoffset\",{\"1\":{\"257\":2,\"258\":2}}],[\"filewatchservice\",{\"1\":{\"481\":10,\"510\":1,\"516\":1}}],[\"fileinputstream\",{\"1\":{\"480\":1,\"599\":7}}],[\"filelastmodifiedtime中记录的时间进行比较\",{\"1\":{\"519\":1}}],[\"filelastmodifiedtime\",{\"1\":{\"519\":7}}],[\"filelist\",{\"1\":{\"392\":3,\"518\":10,\"519\":8}}],[\"filelock\",{\"1\":{\"317\":13}}],[\"file\",{\"1\":{\"21\":7,\"45\":8,\"61\":2,\"63\":1,\"106\":1,\"109\":4,\"291\":5,\"313\":7,\"317\":1,\"365\":1,\"380\":1,\"382\":1,\"390\":2,\"400\":1,\"480\":6,\"518\":3,\"519\":4,\"599\":1,\"694\":1}}],[\"filesize\",{\"1\":{\"400\":3,\"402\":3}}],[\"files\",{\"1\":{\"16\":1,\"21\":2,\"176\":1,\"178\":1,\"313\":4,\"390\":6,\"392\":5,\"400\":1,\"518\":2,\"521\":1}}],[\"filechannel\",{\"0\":{\"430\":1},\"1\":{\"2\":1,\"16\":4,\"317\":2,\"390\":1,\"400\":5,\"403\":1,\"406\":1,\"430\":1,\"431\":1,\"432\":1,\"437\":2}}],[\"free\",{\"1\":{\"257\":1}}],[\"fred\",{\"1\":{\"103\":1}}],[\"fraction\",{\"1\":{\"221\":1}}],[\"frame\",{\"1\":{\"157\":9}}],[\"fruit\",{\"1\":{\"31\":2}}],[\"fromtransactioncheck\",{\"1\":{\"537\":1}}],[\"from表示消息接受者的进程号\",{\"1\":{\"157\":1}}],[\"from\",{\"1\":{\"21\":2,\"42\":2,\"103\":4,\"157\":7,\"158\":3,\"159\":6,\"160\":3,\"287\":1,\"406\":1,\"433\":1,\"492\":6,\"505\":1,\"527\":1,\"541\":1,\"568\":1,\"576\":1,\"643\":1,\"665\":2,\"690\":2,\"694\":1,\"748\":1,\"768\":1,\"800\":2,\"852\":1}}],[\"foxiswho\",{\"1\":{\"593\":1}}],[\"found\",{\"1\":{\"334\":1,\"339\":4,\"381\":1,\"528\":1,\"570\":1,\"693\":7,\"694\":4,\"695\":2,\"749\":1,\"789\":1,\"790\":2,\"848\":1}}],[\"focus\",{\"1\":{\"225\":1}}],[\"focal\",{\"1\":{\"176\":3,\"177\":2}}],[\"follower\",{\"1\":{\"182\":1,\"201\":7,\"205\":3,\"206\":2,\"207\":3}}],[\"following\",{\"1\":{\"176\":2,\"787\":1}}],[\"foldl\",{\"1\":{\"42\":1}}],[\"foo\",{\"1\":{\"63\":2}}],[\"footsize\",{\"1\":{\"26\":2}}],[\"forbidden\",{\"1\":{\"576\":1,\"693\":2,\"694\":2,\"718\":2}}],[\"force\",{\"1\":{\"402\":4}}],[\"foreach\",{\"1\":{\"98\":1,\"103\":2,\"414\":1}}],[\"formatting\",{\"1\":{\"406\":1,\"427\":1}}],[\"format\",{\"0\":{\"108\":1},\"1\":{\"28\":2,\"74\":1,\"80\":1,\"85\":1,\"98\":1,\"108\":1,\"109\":2,\"116\":1,\"428\":1,\"518\":1,\"520\":6,\"693\":4,\"715\":1,\"718\":1,\"750\":1}}],[\"for\",{\"0\":{\"32\":1},\"1\":{\"21\":3,\"32\":6,\"103\":1,\"161\":1,\"240\":6,\"256\":2,\"262\":2,\"282\":2,\"283\":1,\"287\":1,\"289\":3,\"291\":1,\"313\":1,\"314\":2,\"317\":1,\"343\":1,\"345\":1,\"364\":1,\"365\":5,\"380\":6,\"381\":1,\"390\":1,\"391\":2,\"392\":1,\"402\":1,\"406\":2,\"426\":1,\"490\":1,\"491\":1,\"493\":1,\"504\":1,\"514\":2,\"515\":2,\"516\":1,\"518\":3,\"519\":2,\"520\":8,\"528\":1,\"540\":2,\"541\":3,\"570\":1,\"572\":2,\"573\":1,\"576\":2,\"593\":2,\"595\":1,\"598\":1,\"662\":1,\"664\":1,\"691\":1,\"694\":1,\"714\":3,\"715\":3,\"720\":2,\"742\":2,\"744\":1,\"745\":1,\"746\":1,\"750\":1,\"768\":1,\"786\":4,\"787\":2,\"789\":3,\"790\":1,\"791\":1,\"796\":1,\"797\":1,\"798\":1,\"799\":1,\"800\":1,\"808\":1,\"816\":2,\"817\":3,\"826\":1,\"829\":1,\"848\":1,\"850\":1}}],[\"forget\",{\"1\":{\"21\":2}}],[\"fork\",{\"1\":{\"4\":1,\"9\":1,\"11\":2}}],[\"future\",{\"1\":{\"340\":4,\"693\":3}}],[\"fun2ms\",{\"1\":{\"111\":1}}],[\"fun<erl\",{\"1\":{\"31\":7,\"80\":1}}],[\"fun\",{\"0\":{\"31\":1},\"1\":{\"31\":11,\"32\":2,\"33\":1,\"37\":1,\"42\":1,\"60\":2,\"79\":2,\"80\":1,\"98\":1,\"103\":8,\"111\":1}}],[\"funcorexpressionseq\",{\"1\":{\"44\":1}}],[\"funcorexpessionseq\",{\"1\":{\"44\":1}}],[\"function\",{\"1\":{\"21\":4,\"35\":1,\"42\":1,\"105\":1,\"106\":3,\"111\":1}}],[\"func\",{\"1\":{\"21\":2,\"46\":1,\"50\":1,\"63\":1,\"79\":2}}],[\"fully\",{\"1\":{\"176\":1}}],[\"full\",{\"1\":{\"11\":1,\"390\":1,\"789\":3}}],[\"f\",{\"0\":{\"34\":1,\"424\":1},\"1\":{\"21\":7,\"31\":6,\"32\":8,\"33\":3,\"34\":2,\"46\":1,\"50\":1,\"80\":2,\"103\":14,\"158\":2,\"176\":1,\"262\":3,\"313\":5,\"314\":6,\"316\":6,\"392\":3,\"406\":1,\"410\":1,\"820\":1}}],[\"和过滤信息\",{\"1\":{\"832\":1}}],[\"和每隔一段时间\",{\"1\":{\"832\":1}}],[\"和属性\",{\"1\":{\"823\":1}}],[\"和其逻辑偏移量\",{\"1\":{\"814\":1}}],[\"和其他跑在\",{\"1\":{\"2\":1}}],[\"和被存到磁盘\",{\"1\":{\"782\":1}}],[\"和队列\",{\"1\":{\"773\":1,\"838\":1}}],[\"和队列的设计\",{\"1\":{\"723\":1}}],[\"和重平衡线程\",{\"1\":{\"649\":1}}],[\"和重载一个文件的配置\",{\"1\":{\"518\":1}}],[\"和普通消息\",{\"1\":{\"780\":1}}],[\"和普通\",{\"1\":{\"615\":1}}],[\"和广播消费\",{\"1\":{\"608\":1}}],[\"和大多数消息队列一样\",{\"1\":{\"608\":1}}],[\"和一个\",{\"1\":{\"595\":1}}],[\"和多种特殊消息\",{\"1\":{\"545\":1}}],[\"和消息存储在\",{\"1\":{\"537\":1}}],[\"和消息的\",{\"1\":{\"287\":1}}],[\"和用户权限accounts\",{\"1\":{\"518\":1}}],[\"和用户权限\",{\"1\":{\"518\":1}}],[\"和用户名密码参数打包\",{\"1\":{\"509\":1,\"515\":1}}],[\"和处理线程池\",{\"1\":{\"467\":1,\"480\":1}}],[\"和它们最后一次上报心跳的时间\",{\"1\":{\"464\":1}}],[\"和偏移量\",{\"1\":{\"419\":1}}],[\"和当前已经投递的\",{\"1\":{\"388\":1}}],[\"和统计数据\",{\"1\":{\"378\":2}}],[\"和延迟等级对应的\",{\"1\":{\"354\":1}}],[\"和延迟情况\",{\"1\":{\"135\":1}}],[\"和短轮询\",{\"1\":{\"324\":1}}],[\"和内存映射\",{\"1\":{\"248\":1}}],[\"和内存的规格\",{\"1\":{\"181\":1}}],[\"和主从复制的流程\",{\"1\":{\"247\":1}}],[\"和4\",{\"1\":{\"240\":1}}],[\"和接收一次消息的\",{\"1\":{\"201\":1}}],[\"和所有\",{\"1\":{\"201\":1}}],[\"和磁盘空间的使用\",{\"1\":{\"195\":1}}],[\"和若干个从节点\",{\"1\":{\"182\":1}}],[\"和rabbit\",{\"1\":{\"156\":1}}],[\"和对应规模下集群的性能\",{\"1\":{\"135\":1}}],[\"和文档\",{\"1\":{\"121\":1}}],[\"和\",{\"0\":{\"96\":1,\"97\":1,\"261\":1,\"430\":1,\"588\":1},\"1\":{\"4\":2,\"9\":2,\"43\":1,\"44\":1,\"45\":1,\"62\":1,\"97\":1,\"98\":1,\"133\":1,\"135\":2,\"138\":1,\"155\":1,\"165\":1,\"166\":1,\"170\":2,\"192\":1,\"206\":1,\"246\":1,\"261\":2,\"270\":1,\"271\":1,\"276\":1,\"284\":1,\"287\":1,\"301\":1,\"306\":1,\"307\":2,\"331\":1,\"335\":1,\"336\":1,\"345\":1,\"354\":3,\"356\":3,\"359\":4,\"363\":4,\"377\":1,\"384\":2,\"389\":2,\"397\":1,\"398\":1,\"399\":1,\"400\":2,\"404\":1,\"414\":1,\"420\":1,\"426\":1,\"435\":1,\"437\":1,\"452\":1,\"461\":1,\"464\":1,\"467\":1,\"471\":1,\"480\":1,\"481\":1,\"498\":2,\"507\":1,\"508\":2,\"514\":3,\"517\":1,\"518\":1,\"541\":1,\"556\":2,\"557\":1,\"560\":1,\"592\":1,\"622\":1,\"629\":1,\"630\":1,\"637\":1,\"639\":1,\"664\":2,\"667\":1,\"723\":1,\"744\":2,\"765\":1,\"773\":1,\"779\":1,\"781\":1,\"783\":1,\"799\":1,\"819\":1,\"838\":2,\"868\":1,\"884\":1}}],[\"和硬件在基准测试时执行优化\",{\"1\":{\"3\":1}}],[\"你需要多少个仲裁队列\",{\"1\":{\"235\":1}}],[\"你就可以在不同的集群多次消费消息\",{\"1\":{\"166\":1}}],[\"你可能看到\",{\"1\":{\"155\":1}}],[\"你可以在消费消息时判断一下订单的状态以确定是否需要关闭\",{\"1\":{\"441\":1,\"871\":1}}],[\"你可以指定集群cpu平均占用的预期值为\",{\"1\":{\"135\":1}}],[\"你可以使用`self`获取当前\",{\"1\":{\"80\":1}}],[\"你可以使用pid向进程发送消息\",{\"1\":{\"80\":1}}],[\"你可以使用它提供的一系列注解轻松地编写基准测试代码\",{\"1\":{\"3\":1}}],[\"你在写\",{\"1\":{\"2\":1}}],[\"但任意时间定时消息不可能无限制地增加延迟时长对应的队列数量\",{\"1\":{\"876\":1}}],[\"但在体现的效果上确实相同的\",{\"1\":{\"872\":1}}],[\"但现在已经被标记为\",{\"1\":{\"820\":1}}],[\"但保证消费线程池顺序消费就可以实现顺序消费了吗\",{\"1\":{\"728\":1}}],[\"但同时最多只有一个线程真正在执行消费\",{\"1\":{\"727\":1}}],[\"但即便延迟等级时间间隔配置不足\",{\"1\":{\"620\":1}}],[\"但下次发送消息时还会继续尝试\",{\"1\":{\"561\":1}}],[\"但可靠性不如同步发送\",{\"1\":{\"547\":1}}],[\"但也要考虑大消息量和高\",{\"1\":{\"455\":1}}],[\"但也有人用户不同步镜像\",{\"1\":{\"211\":1}}],[\"但也有局限\",{\"0\":{\"127\":1}}],[\"但不期望这条消息马上被投递\",{\"1\":{\"440\":2}}],[\"但整体还是从旧到新有序读\",{\"1\":{\"398\":1}}],[\"但整个实验中没有出现数据丢失\",{\"1\":{\"134\":1}}],[\"但实际没有命令能调用\",{\"1\":{\"386\":1}}],[\"但实践往往要比理论复杂得多\",{\"1\":{\"256\":1}}],[\"但目前还并未解决\",{\"1\":{\"306\":1}}],[\"但这带来了另一个问题\",{\"1\":{\"435\":1}}],[\"但这并不表示消息会被立刻持久化到磁盘中\",{\"1\":{\"288\":1}}],[\"但这个\",{\"1\":{\"155\":1}}],[\"但它只负责触发\",{\"1\":{\"649\":1}}],[\"但它内部新建了一个\",{\"1\":{\"261\":1}}],[\"但它的逻辑其实很简单\",{\"1\":{\"256\":1}}],[\"但每次处理消息都会触发一个异步的刷盘请求\",{\"1\":{\"255\":1}}],[\"但队列中的消息会消失\",{\"1\":{\"217\":1}}],[\"但当队列很长或者消息总大小很大的时候\",{\"1\":{\"211\":1}}],[\"但当这部分代码作为较大程序的一部分时可能无法应用这些优化\",{\"1\":{\"3\":1}}],[\"但为空\",{\"1\":{\"210\":1}}],[\"但镜像队列存在很大的局限性\",{\"1\":{\"181\":1}}],[\"但没有任何一个对应的队列处于flow状态时\",{\"1\":{\"155\":1}}],[\"但有了\",{\"1\":{\"121\":1}}],[\"但我们想使用一个表达式序列\",{\"1\":{\"55\":1}}],[\"但大多数是用erlang虚拟机里的底层操作实现的\",{\"1\":{\"35\":1}}],[\"但是无法确定\",{\"1\":{\"842\":1}}],[\"但是无法消费消息\",{\"1\":{\"769\":1}}],[\"但是对消费者来说看到的是多个消费队列\",{\"1\":{\"811\":1}}],[\"但是我们在可见之前提前使用\",{\"1\":{\"771\":1}}],[\"但是我运行时三个\",{\"1\":{\"599\":1}}],[\"但是processqueue已经太久没有拉取数据\",{\"1\":{\"664\":1,\"744\":1}}],[\"但是由\",{\"1\":{\"650\":1}}],[\"但是由于线程池内部为无界队列\",{\"1\":{\"758\":1}}],[\"但是由于第二个提交依赖第一个所以只能放到一起\",{\"1\":{\"409\":1}}],[\"但是由于\",{\"1\":{\"360\":1}}],[\"但是并不会重投消费失败的消息\",{\"1\":{\"610\":1}}],[\"但是并不是每条消息都会经历所有的子队列以及对应的生命周期\",{\"1\":{\"223\":1}}],[\"但是与集群的网络不通\",{\"1\":{\"597\":1}}],[\"但是发送性能最差\",{\"1\":{\"547\":1}}],[\"但是为取消消息专门创建一个文件来存储又太多余\",{\"1\":{\"455\":1}}],[\"但是会有很多工作量\",{\"1\":{\"451\":1}}],[\"但是要实现高性能的定时消息投递\",{\"1\":{\"450\":1}}],[\"但是如果上一次发送失败\",{\"1\":{\"549\":1}}],[\"但是如果队列的消息堆积量很大\",{\"1\":{\"226\":1}}],[\"但是如何删除已经投递的定时消息成为一个问题\",{\"1\":{\"448\":1}}],[\"但是一直存着不删也不行\",{\"1\":{\"448\":1}}],[\"但是往往在精度\",{\"1\":{\"442\":1}}],[\"但是更好的方法可以是使用消息队列发送一个延迟消息\",{\"1\":{\"441\":1,\"871\":1}}],[\"但是更安全\",{\"1\":{\"87\":1}}],[\"但是这个队列仍有消息正在被消费\",{\"1\":{\"735\":1}}],[\"但是这个订单也不可能一直开着\",{\"1\":{\"441\":1,\"871\":1}}],[\"但是这种方案在主从同步时会有消息顺序不同的问题\",{\"1\":{\"450\":1}}],[\"但是这样做会有一次额外的数据库操作\",{\"1\":{\"441\":1,\"871\":1}}],[\"但是这样的话会让消息丢失的风险增加\",{\"1\":{\"226\":1}}],[\"但是在内存中匹配\",{\"1\":{\"779\":1}}],[\"但是在容器中获取的是容器的\",{\"1\":{\"595\":1}}],[\"但是在实际使用中效果是完全相同的\",{\"1\":{\"440\":1}}],[\"但是在写\",{\"1\":{\"432\":1}}],[\"但是仅支持几个固定的延迟时间\",{\"1\":{\"439\":1}}],[\"但是当\",{\"1\":{\"430\":1}}],[\"但是当遇到更复杂\",{\"1\":{\"2\":1}}],[\"但是其中有一个\",{\"1\":{\"410\":1}}],[\"但是又无法删除文件\",{\"1\":{\"390\":1}}],[\"但是原本并没有复用代码\",{\"1\":{\"251\":1}}],[\"但是延迟也可能更高\",{\"1\":{\"237\":1}}],[\"但是仍有这样的危险存在\",{\"1\":{\"236\":1}}],[\"但是相对的\",{\"1\":{\"227\":1}}],[\"但是上游生产者仍然不停生产消息\",{\"1\":{\"226\":1}}],[\"但是有时有些队列有时会存在大量堆积\",{\"1\":{\"226\":1}}],[\"但是有没有更\",{\"1\":{\"2\":1}}],[\"但是它仍存在一个致命的问题\",{\"1\":{\"445\":1}}],[\"但是它是空的\",{\"1\":{\"226\":1}}],[\"但是它有一些设计上的缺陷\",{\"1\":{\"225\":1}}],[\"但是\",{\"1\":{\"214\":1}}],[\"但是多节点的集群并不意味着有更好的可靠性\",{\"1\":{\"181\":1}}],[\"但是此处仍处于rabbit\",{\"1\":{\"157\":1}}],[\"但是此时并不会直接让上游进程的信用值加一\",{\"1\":{\"152\":1}}],[\"但是通过生产者确认的方式可以让发送消息不丢失\",{\"1\":{\"148\":1}}],[\"但是也有长至几分钟的\",{\"1\":{\"147\":1}}],[\"的延迟\",{\"1\":{\"876\":1}}],[\"的延迟消息的原理简单来说是\",{\"1\":{\"876\":1}}],[\"的延迟消息是两套实现机制\",{\"1\":{\"872\":1}}],[\"的延迟消息性能被优化\",{\"1\":{\"872\":1}}],[\"的延迟消息有很大的局限性\",{\"1\":{\"872\":1}}],[\"的延迟消息\",{\"1\":{\"620\":1}}],[\"的客户端中\",{\"1\":{\"873\":1}}],[\"的创建\",{\"0\":{\"862\":1}}],[\"的底层存储实现\",{\"0\":{\"859\":1}}],[\"的底层都是\",{\"1\":{\"400\":1}}],[\"的不太一样\",{\"1\":{\"843\":1}}],[\"的不同队列按照算法尽可能平均地分配给消费者组中的所有消费者\",{\"1\":{\"617\":1}}],[\"的布隆过滤器实现与\",{\"1\":{\"843\":1}}],[\"的二层过滤中\",{\"1\":{\"842\":1}}],[\"的判断\",{\"1\":{\"838\":2}}],[\"的有过滤条件的消费组\",{\"1\":{\"835\":1}}],[\"的在\",{\"1\":{\"820\":1}}],[\"的包\",{\"1\":{\"820\":1}}],[\"的发送缓冲区\",{\"1\":{\"820\":1}}],[\"的对象封装为任务放入\",{\"1\":{\"820\":1}}],[\"的对应关系\",{\"1\":{\"556\":1}}],[\"的大小到达这个值后\",{\"1\":{\"820\":1}}],[\"的大小由\",{\"1\":{\"820\":1}}],[\"的大致流程\",{\"1\":{\"820\":1}}],[\"的大部分准备工作\",{\"1\":{\"256\":1}}],[\"的水位线\",{\"1\":{\"820\":1}}],[\"的文档\",{\"1\":{\"819\":2}}],[\"的文件\",{\"1\":{\"392\":1}}],[\"的文件结构可以看作是一个可以无限扩展的数组\",{\"1\":{\"275\":1}}],[\"的文件里\",{\"1\":{\"30\":1}}],[\"的配置项\",{\"1\":{\"828\":1}}],[\"的配置\",{\"1\":{\"819\":1}}],[\"的元数据会上报到\",{\"1\":{\"810\":1}}],[\"的场景\",{\"1\":{\"810\":1}}],[\"的多级主题和\",{\"1\":{\"804\":1}}],[\"的多种流控机制\",{\"0\":{\"145\":1}}],[\"的位\",{\"1\":{\"798\":1}}],[\"的唤醒时间差大于\",{\"1\":{\"798\":1}}],[\"的唤醒时间与第一个\",{\"1\":{\"798\":1}}],[\"的起始偏移量\",{\"1\":{\"790\":1}}],[\"的概率拉取重试消息\",{\"1\":{\"789\":1}}],[\"的概念\",{\"1\":{\"422\":1,\"820\":1}}],[\"的开关默认是关闭的\",{\"1\":{\"779\":1}}],[\"的随机整数\",{\"1\":{\"777\":1}}],[\"的磁盘存储实际上就是\",{\"1\":{\"773\":1}}],[\"的存在目的是与\",{\"1\":{\"773\":1}}],[\"的存储项是定长结构\",{\"1\":{\"839\":1}}],[\"的存储\",{\"1\":{\"450\":1}}],[\"的存储文件主要分三种\",{\"1\":{\"383\":1}}],[\"的存储模型\",{\"1\":{\"234\":1}}],[\"的存储可以被分为两个部分\",{\"1\":{\"220\":1}}],[\"的存储设计与\",{\"1\":{\"214\":1}}],[\"的机制\",{\"1\":{\"771\":1}}],[\"的心跳未断\",{\"1\":{\"769\":1}}],[\"的一个队列\",{\"1\":{\"779\":1}}],[\"的一个消费组可以订阅多个\",{\"1\":{\"759\":1}}],[\"的一些验证和匹配逻辑\",{\"1\":{\"423\":1}}],[\"的情况\",{\"1\":{\"757\":1}}],[\"的状态\",{\"1\":{\"739\":1}}],[\"的做法是如果队列有消息正被消费\",{\"1\":{\"735\":1}}],[\"的做成了懒初始化\",{\"1\":{\"256\":1}}],[\"的后面的数据都是处理失败的\",{\"1\":{\"715\":1}}],[\"的哈希码过滤\",{\"1\":{\"694\":1}}],[\"的变量\",{\"1\":{\"688\":1}}],[\"的变量的方法\",{\"1\":{\"122\":1}}],[\"的映射关系\",{\"1\":{\"664\":1,\"744\":1}}],[\"的订阅信息\",{\"1\":{\"662\":1}}],[\"的订阅信息添加到\",{\"1\":{\"640\":1,\"642\":1}}],[\"的地方\",{\"1\":{\"664\":1,\"744\":1}}],[\"的地方只有一个\",{\"1\":{\"657\":1}}],[\"的地址列表\",{\"1\":{\"470\":1,\"488\":1}}],[\"的地址及文件长度\",{\"1\":{\"402\":1}}],[\"的基础上新实现了推模式和拉模式的重平衡实现\",{\"1\":{\"649\":1}}],[\"的重平衡触发流程\",{\"1\":{\"656\":1}}],[\"的重平衡在客户端\",{\"1\":{\"651\":1}}],[\"的重平衡在消费端完成\",{\"1\":{\"648\":1}}],[\"的重平衡流程在消费者端完成\",{\"1\":{\"650\":1}}],[\"的重平衡大致实现方式为\",{\"1\":{\"647\":1}}],[\"的重要组件之一\",{\"1\":{\"461\":1}}],[\"的容器中\",{\"1\":{\"642\":1}}],[\"的启动流程如下\",{\"1\":{\"640\":1}}],[\"的启动方法执行的动作如下\",{\"1\":{\"640\":1}}],[\"的启动方法\",{\"1\":{\"640\":1}}],[\"的启动方法内部实际是调用其代理类\",{\"1\":{\"640\":1}}],[\"的启动类\",{\"1\":{\"480\":1}}],[\"的代理\",{\"1\":{\"638\":1}}],[\"的代码并不多\",{\"1\":{\"464\":1}}],[\"的默认实现\",{\"1\":{\"638\":1}}],[\"的拉取偏移量更新后再次调用\",{\"1\":{\"639\":1}}],[\"的拉取请求唤醒\",{\"1\":{\"334\":1}}],[\"的拉\",{\"1\":{\"637\":1}}],[\"的轻量化\",{\"1\":{\"615\":1}}],[\"的业务逻辑中最复杂的一块\",{\"1\":{\"606\":1}}],[\"的控制台\",{\"1\":{\"596\":1}}],[\"的监听端口\",{\"1\":{\"595\":1}}],[\"的源码为例\",{\"1\":{\"815\":1}}],[\"的源码\",{\"1\":{\"592\":1,\"755\":1}}],[\"的镜像\",{\"1\":{\"591\":1}}],[\"的部署和配置较为复杂\",{\"1\":{\"589\":1}}],[\"的网络地址\",{\"1\":{\"573\":1}}],[\"的sendmessageasync\",{\"1\":{\"560\":1}}],[\"的三个组件\",{\"1\":{\"550\":1}}],[\"的具体队列\",{\"1\":{\"549\":1}}],[\"的具体使用方式\",{\"1\":{\"545\":1}}],[\"的停止状态\",{\"1\":{\"541\":1}}],[\"的负载\",{\"1\":{\"532\":1}}],[\"的负载过高从而导致了此种情形\",{\"1\":{\"155\":1}}],[\"的官方\",{\"1\":{\"529\":1}}],[\"的现象\",{\"1\":{\"523\":1}}],[\"的字段含义\",{\"0\":{\"517\":1}}],[\"的字节\",{\"1\":{\"402\":1}}],[\"的属性进行排序\",{\"1\":{\"515\":1}}],[\"的逻辑\",{\"0\":{\"509\":1,\"515\":1}}],[\"的逻辑会把这个\",{\"1\":{\"508\":1,\"514\":1}}],[\"的逻辑是\",{\"1\":{\"399\":1}}],[\"的抽象基类\",{\"1\":{\"508\":1,\"514\":1}}],[\"的访问权限配置\",{\"1\":{\"499\":1}}],[\"的操作\",{\"1\":{\"498\":1}}],[\"的权限控制由客户端和\",{\"1\":{\"499\":1}}],[\"的权限\",{\"1\":{\"498\":1}}],[\"的返回体\",{\"1\":{\"493\":1}}],[\"的初始化\",{\"1\":{\"480\":1}}],[\"的连接\",{\"1\":{\"474\":1,\"492\":1}}],[\"的过滤信息\",{\"1\":{\"843\":1,\"850\":1}}],[\"的过滤语法规则如下\",{\"1\":{\"828\":1}}],[\"的过滤器\",{\"1\":{\"473\":1,\"491\":1}}],[\"的过期文件清理也由\",{\"1\":{\"392\":1}}],[\"的过期文件删除逻辑由一个线程统一处理\",{\"1\":{\"384\":1}}],[\"的过期文件删除机制会定期删除已经过期的存储文件\",{\"1\":{\"383\":1}}],[\"的所有消息\",{\"1\":{\"799\":1,\"800\":1}}],[\"的所有消息队列\",{\"1\":{\"657\":1}}],[\"的所有\",{\"1\":{\"650\":1}}],[\"的所有队列给第一个消费者\",{\"1\":{\"617\":1}}],[\"的所有队列信息\",{\"1\":{\"472\":1}}],[\"的所有实现类\",{\"1\":{\"510\":1,\"516\":1}}],[\"的所有表达式都应该有值\",{\"1\":{\"38\":1}}],[\"的请求\",{\"1\":{\"471\":1,\"498\":1}}],[\"的请求处理器\",{\"1\":{\"464\":1}}],[\"的名称\",{\"1\":{\"469\":1}}],[\"的核心控制器\",{\"1\":{\"467\":1}}],[\"的实例\",{\"1\":{\"467\":1}}],[\"的实现思想是减少数据的重复存储\",{\"1\":{\"811\":1}}],[\"的实现非常轻量级\",{\"1\":{\"462\":1}}],[\"的实现\",{\"1\":{\"394\":1}}],[\"的实现类\",{\"1\":{\"249\":1}}],[\"的数据版本号发生变更\",{\"1\":{\"465\":1}}],[\"的数据不会丢失\",{\"1\":{\"403\":1}}],[\"的路由表\",{\"1\":{\"469\":1}}],[\"的路由信息\",{\"1\":{\"465\":2,\"492\":1,\"549\":1,\"573\":1}}],[\"的路径\",{\"1\":{\"122\":1}}],[\"的队列上锁\",{\"1\":{\"778\":1}}],[\"的队列数设为\",{\"1\":{\"723\":1}}],[\"的队列数量设为\",{\"1\":{\"548\":1}}],[\"的队列进行重平衡\",{\"1\":{\"662\":1}}],[\"的队列和它们所在的\",{\"1\":{\"549\":1}}],[\"的队列\",{\"1\":{\"474\":1,\"492\":2,\"791\":1,\"804\":1}}],[\"的队列列表\",{\"1\":{\"470\":1}}],[\"的队列信息\",{\"1\":{\"464\":1}}],[\"的队列消费消息\",{\"1\":{\"202\":1}}],[\"的依赖移除\",{\"1\":{\"462\":1}}],[\"的动态注册与发现\",{\"1\":{\"461\":1}}],[\"的动作是同步的\",{\"1\":{\"370\":1}}],[\"的信息集\",{\"1\":{\"455\":1}}],[\"的信用值也将会耗尽\",{\"1\":{\"155\":1}}],[\"的信用值就会先一步耗尽\",{\"1\":{\"155\":1}}],[\"的普通消息存储\",{\"1\":{\"450\":1}}],[\"的和延迟\",{\"1\":{\"448\":1}}],[\"的精度我认为太差\",{\"1\":{\"447\":1}}],[\"的形式存储了每个消息\",{\"1\":{\"447\":1}}],[\"的选择\",{\"1\":{\"437\":1}}],[\"的修改\",{\"1\":{\"433\":1}}],[\"的调用从\",{\"0\":{\"433\":1}}],[\"的写是不可扩展的\",{\"1\":{\"462\":1}}],[\"的写入\",{\"0\":{\"863\":1},\"1\":{\"432\":1}}],[\"的写入和\",{\"1\":{\"432\":1}}],[\"的写法是\",{\"1\":{\"34\":1}}],[\"的长度\",{\"1\":{\"426\":1}}],[\"的扩容\",{\"1\":{\"426\":1}}],[\"的生成方法和使用可以看丁威老师的\",{\"1\":{\"419\":1}}],[\"的生成涉及很多编解码和数据复制工作\",{\"1\":{\"256\":1}}],[\"的零拷贝\",{\"1\":{\"414\":1}}],[\"的性能\",{\"0\":{\"418\":1},\"1\":{\"414\":1}}],[\"的性能表现\",{\"1\":{\"394\":1}}],[\"的协议\",{\"1\":{\"413\":1}}],[\"的火焰图采样\",{\"1\":{\"407\":1}}],[\"的压力会比较大\",{\"1\":{\"403\":1}}],[\"的压力\",{\"1\":{\"403\":1}}],[\"的手段\",{\"0\":{\"395\":1}}],[\"的几种设计和原理\",{\"1\":{\"394\":1}}],[\"的设计\",{\"1\":{\"394\":1}}],[\"的投递时间提前\",{\"1\":{\"773\":1}}],[\"的投递\",{\"1\":{\"391\":1}}],[\"的条件检查逻辑\",{\"1\":{\"390\":1}}],[\"的清理方法\",{\"1\":{\"389\":1}}],[\"的内部类\",{\"1\":{\"389\":1}}],[\"的每个\",{\"1\":{\"387\":1,\"410\":1,\"777\":1}}],[\"的删除比较复杂\",{\"1\":{\"384\":1}}],[\"的检查每\",{\"1\":{\"384\":1}}],[\"的消费位点\",{\"1\":{\"773\":1}}],[\"的消费者的消费模式为\",{\"1\":{\"768\":1}}],[\"的消费者组成了消费者组\",{\"1\":{\"609\":1}}],[\"的消费还分并发消费和顺序消费\",{\"1\":{\"697\":1}}],[\"的消费主要分推和拉两个模式\",{\"1\":{\"667\":1}}],[\"的消费进度\",{\"1\":{\"664\":1,\"744\":1}}],[\"的消费流程大致分成\",{\"1\":{\"606\":1}}],[\"的消费可以算是\",{\"1\":{\"606\":1}}],[\"的消费队列中专门开辟了\",{\"1\":{\"839\":1}}],[\"的消费队列\",{\"1\":{\"356\":1}}],[\"的消息是有老化时间的\",{\"1\":{\"877\":1}}],[\"的消息过滤逻辑\",{\"1\":{\"838\":1}}],[\"的消息过滤接口messagefilter\",{\"1\":{\"833\":1}}],[\"的消息分发构建消费索引时会构建\",{\"1\":{\"813\":1}}],[\"的消息也作为\",{\"1\":{\"797\":1}}],[\"的消息找到内存\",{\"1\":{\"796\":1}}],[\"的消息偏移量\",{\"1\":{\"790\":1}}],[\"的消息数量\",{\"1\":{\"790\":1}}],[\"的消息数达到morecreditafter\",{\"1\":{\"154\":1}}],[\"的消息的逻辑偏移量\",{\"1\":{\"790\":1}}],[\"的消息没有满\",{\"1\":{\"777\":1}}],[\"的消息匹配\",{\"1\":{\"773\":2}}],[\"的消息只要被消费者组中的一个消费者消费即可\",{\"1\":{\"623\":1}}],[\"的消息进行重试\",{\"1\":{\"783\":1}}],[\"的消息进行匹配和重试\",{\"1\":{\"783\":1}}],[\"的消息进行\",{\"1\":{\"573\":1}}],[\"的消息体中\",{\"1\":{\"564\":1}}],[\"的消息执行\",{\"1\":{\"562\":1}}],[\"的消息发送流程图如下图所示\",{\"1\":{\"558\":1}}],[\"的消息时\",{\"1\":{\"447\":1}}],[\"的消息不是连续的\",{\"1\":{\"398\":1}}],[\"的消息重新转发\",{\"1\":{\"331\":1}}],[\"的消息在\",{\"1\":{\"267\":1}}],[\"的消息都保存在\",{\"1\":{\"267\":1}}],[\"的消息以队列维度存储\",{\"1\":{\"214\":1}}],[\"的消息\",{\"1\":{\"196\":1,\"207\":1,\"275\":1,\"441\":1,\"708\":1,\"771\":1,\"790\":1,\"799\":1,\"800\":2,\"827\":1,\"871\":1}}],[\"的消息给rabbit\",{\"1\":{\"159\":1}}],[\"的定时消息实现为我们提供了很好的参照\",{\"1\":{\"452\":1}}],[\"的定时消息也是取舍之后的产物\",{\"1\":{\"445\":1}}],[\"的定时消息之前\",{\"1\":{\"445\":1}}],[\"的定时消息受到\",{\"1\":{\"353\":1}}],[\"的定义\",{\"1\":{\"41\":1}}],[\"的最大\",{\"1\":{\"332\":1,\"392\":1}}],[\"的索引文件\",{\"1\":{\"447\":1,\"880\":1}}],[\"的索引\",{\"1\":{\"309\":1,\"314\":1}}],[\"的索引和消息\",{\"1\":{\"309\":1,\"314\":1}}],[\"的时间间隔来执行其核心逻辑\",{\"1\":{\"519\":1}}],[\"的时间跨度\",{\"1\":{\"447\":1}}],[\"的时间占比大大减少\",{\"1\":{\"432\":1}}],[\"的时间\",{\"1\":{\"307\":1,\"773\":1}}],[\"的时候效率就很高了\",{\"1\":{\"417\":1}}],[\"的时候直接就指定好\",{\"1\":{\"261\":1}}],[\"的时候是一个线程在写\",{\"1\":{\"253\":1}}],[\"的时候\",{\"1\":{\"249\":1,\"771\":1}}],[\"的时候性能达到最优\",{\"1\":{\"135\":1}}],[\"的结构\",{\"1\":{\"306\":1}}],[\"的格式\",{\"1\":{\"293\":1}}],[\"的新消息被保存到\",{\"1\":{\"285\":1}}],[\"的物理偏移量\",{\"1\":{\"285\":1}}],[\"的保存方法\",{\"1\":{\"284\":1}}],[\"的构建入口是reputmessageservice\",{\"1\":{\"281\":1}}],[\"的某个\",{\"1\":{\"267\":1}}],[\"的目的主要是适应消息的检索需求\",{\"1\":{\"267\":1}}],[\"的作用是在收到消息时提醒消费者\",{\"1\":{\"434\":1}}],[\"的作用\",{\"0\":{\"267\":1}}],[\"的通信协议定义了各种指令\",{\"1\":{\"262\":1,\"410\":1}}],[\"的计算方法\",{\"1\":{\"258\":1}}],[\"的引用\",{\"1\":{\"244\":1}}],[\"的中断或者变慢可能导致多个队列消息堆积\",{\"1\":{\"235\":1}}],[\"的仲裁队列将会有\",{\"1\":{\"228\":1}}],[\"的进程中\",{\"1\":{\"201\":1}}],[\"的进程\",{\"1\":{\"201\":1}}],[\"的进程号\",{\"1\":{\"157\":1,\"159\":1}}],[\"的标志\",{\"1\":{\"198\":1}}],[\"的匹配规则\",{\"1\":{\"188\":1}}],[\"的吞吐量\",{\"1\":{\"181\":1}}],[\"的版本\",{\"1\":{\"177\":1}}],[\"的版本代号\",{\"1\":{\"177\":1}}],[\"的组件单独创建用户\",{\"1\":{\"168\":1}}],[\"的组织将实施混沌工程实践\",{\"1\":{\"126\":1}}],[\"的效果是消息的负载均衡\",{\"1\":{\"167\":1}}],[\"的阻塞解除\",{\"1\":{\"160\":1}}],[\"的处理线程池中处理异步请求完成的回调\",{\"1\":{\"685\":1}}],[\"的处理流程\",{\"1\":{\"544\":1}}],[\"的处理\",{\"1\":{\"256\":1}}],[\"的处理进程\",{\"1\":{\"154\":4}}],[\"的处理能够跟上生产速度\",{\"1\":{\"144\":1}}],[\"的分区从\",{\"1\":{\"135\":1}}],[\"的上下文进行调用才是我们想要的\",{\"1\":{\"122\":1}}],[\"的触发入口一层一层调用过来\",{\"1\":{\"120\":1}}],[\"的前身\",{\"1\":{\"105\":1}}],[\"的系统负载\",{\"1\":{\"105\":1}}],[\"的方法\",{\"1\":{\"435\":1,\"656\":1,\"707\":1}}],[\"的方法将客户端\",{\"1\":{\"419\":1}}],[\"的方法中\",{\"1\":{\"250\":1}}],[\"的方法会被进行基准测试\",{\"1\":{\"9\":1}}],[\"的方式来触发定时消息的取消\",{\"1\":{\"455\":1}}],[\"的方式来指定消息整体大小小于某个值时会只保存到队列索引中\",{\"1\":{\"220\":1}}],[\"的方式再次哈希\",{\"1\":{\"317\":1}}],[\"的方式可以将消息设置为持久化的\",{\"1\":{\"218\":1}}],[\"的方式可以将队列设置为持久化\",{\"1\":{\"217\":1}}],[\"的方式指定\",{\"1\":{\"193\":1}}],[\"的方式监听阻塞和阻塞解除的事件\",{\"1\":{\"146\":1}}],[\"的方式启动项目\",{\"1\":{\"123\":1}}],[\"的方式启动\",{\"1\":{\"74\":1}}],[\"的键\",{\"1\":{\"67\":1}}],[\"的私有数据存储区域\",{\"1\":{\"67\":1}}],[\"的表达式时会展开这个宏\",{\"1\":{\"63\":1}}],[\"的副本\",{\"1\":{\"41\":1}}],[\"的简称\",{\"1\":{\"41\":1}}],[\"的函数\",{\"1\":{\"31\":1}}],[\"的模式相匹配\",{\"1\":{\"23\":1}}],[\"的值超过\",{\"1\":{\"221\":1}}],[\"的值就通过执行匹配模式之后的表达式序列得出\",{\"1\":{\"44\":1}}],[\"的值\",{\"1\":{\"23\":1}}],[\"的真正意思是\",{\"1\":{\"23\":1}}],[\"的\",{\"0\":{\"604\":1},\"1\":{\"10\":1,\"102\":1,\"116\":1,\"121\":1,\"169\":2,\"171\":1,\"246\":1,\"248\":1,\"266\":1,\"275\":1,\"276\":1,\"306\":1,\"307\":1,\"313\":1,\"317\":2,\"325\":2,\"332\":1,\"334\":1,\"360\":1,\"370\":1,\"391\":1,\"397\":1,\"398\":1,\"407\":1,\"410\":1,\"414\":5,\"416\":1,\"417\":1,\"455\":1,\"461\":1,\"462\":1,\"472\":1,\"473\":1,\"474\":1,\"491\":2,\"496\":1,\"503\":1,\"508\":1,\"510\":1,\"511\":2,\"514\":1,\"537\":2,\"545\":1,\"549\":1,\"563\":1,\"573\":1,\"589\":1,\"597\":1,\"601\":1,\"639\":1,\"646\":1,\"675\":1,\"708\":3,\"711\":3,\"715\":1,\"723\":1,\"773\":1,\"791\":1,\"797\":1,\"798\":1,\"804\":1,\"820\":4,\"837\":1,\"838\":1,\"839\":2,\"850\":1}}],[\"的注解\",{\"1\":{\"6\":1}}],[\"的意义\",{\"0\":{\"3\":1}}],[\"的缩写\",{\"1\":{\"2\":1}}],[\"的工具\",{\"1\":{\"2\":1}}],[\"是时间戳\",{\"1\":{\"880\":1}}],[\"是主要的解析器类\",{\"1\":{\"841\":1}}],[\"是因为\",{\"1\":{\"839\":1}}],[\"是资源密集型的\",{\"1\":{\"810\":1}}],[\"是第一次拉取\",{\"1\":{\"748\":1}}],[\"是在\",{\"1\":{\"732\":1}}],[\"是定时消息\",{\"1\":{\"708\":1}}],[\"是消息在队列中的逻辑偏移量\",{\"1\":{\"675\":1}}],[\"是消费队列文件\",{\"1\":{\"387\":1}}],[\"是拉取到的消息\",{\"1\":{\"675\":1}}],[\"是拉取请求的队列\",{\"1\":{\"335\":1}}],[\"是拉消费者接口\",{\"1\":{\"638\":1}}],[\"是不可能达成\",{\"1\":{\"622\":1}}],[\"是需要构建的\",{\"1\":{\"592\":1}}],[\"是发送消息处理线程池\",{\"1\":{\"575\":1}}],[\"是为自动创建主题运用的\",{\"1\":{\"559\":1}}],[\"是为了修复在slave中consumequeue异常恢复慢的问题\",{\"1\":{\"817\":1}}],[\"是为了防止全局配置在未解析完全的情况下被读取\",{\"1\":{\"518\":1}}],[\"是为了提供按照\",{\"1\":{\"298\":1}}],[\"是与\",{\"1\":{\"556\":1}}],[\"是存储内部使用的\",{\"1\":{\"555\":1}}],[\"是专门用来异步发送轨迹消息的异步转发器\",{\"1\":{\"541\":1}}],[\"是最佳的选择\",{\"1\":{\"530\":1}}],[\"是文件中包含的权限配置\",{\"1\":{\"517\":1}}],[\"是文件路径\",{\"1\":{\"517\":1}}],[\"是用来管理配置的\",{\"1\":{\"710\":1}}],[\"是用来监听文件变化执行回调函数的\",{\"1\":{\"481\":1}}],[\"是用来与\",{\"1\":{\"470\":1}}],[\"是用于列表添加和移除的中缀操作符\",{\"1\":{\"62\":1}}],[\"是用于增强模式匹配的结构\",{\"1\":{\"36\":1}}],[\"是除了\",{\"1\":{\"461\":1}}],[\"是组成\",{\"1\":{\"461\":1}}],[\"是有机会在其投递之前\",{\"1\":{\"455\":1}}],[\"是阿里孵化的\",{\"1\":{\"439\":1}}],[\"是弱一致的\",{\"1\":{\"435\":1}}],[\"是利用\",{\"1\":{\"432\":1}}],[\"是完全自定义的\",{\"1\":{\"410\":1}}],[\"是完全合理的\",{\"1\":{\"195\":1}}],[\"是协议头\",{\"1\":{\"410\":1}}],[\"是操作系统的特性\",{\"1\":{\"399\":1}}],[\"是由一组\",{\"1\":{\"396\":1}}],[\"是如何做到这么高的性能的呢\",{\"1\":{\"394\":1}}],[\"是满足删除文件的时间\",{\"1\":{\"390\":1}}],[\"是该队列挂起的所有拉取请求\",{\"1\":{\"335\":1}}],[\"是索引文件操作的入口\",{\"1\":{\"309\":1}}],[\"是类似\",{\"1\":{\"306\":1}}],[\"是数量可无限扩展的映射文件\",{\"1\":{\"269\":1}}],[\"是非常低效的\",{\"1\":{\"267\":1}}],[\"是什么\",{\"0\":{\"266\":1,\"461\":1}}],[\"是个拼接出来的字符串\",{\"1\":{\"256\":1}}],[\"是异步刷盘\",{\"1\":{\"255\":1}}],[\"是事务消息二阶段处理线程大小\",{\"1\":{\"254\":1}}],[\"是内存映射文件\",{\"1\":{\"248\":1,\"839\":1}}],[\"是执行的流程的基本单元\",{\"1\":{\"130\":1}}],[\"是否通过过滤\",{\"1\":{\"852\":1}}],[\"是否需要分发\",{\"1\":{\"817\":1}}],[\"是否要从内存中移除\",{\"1\":{\"797\":1}}],[\"是否要将数据同步到这个队列\",{\"1\":{\"226\":1}}],[\"是否匹配成功\",{\"1\":{\"796\":1}}],[\"是否添加成功\",{\"1\":{\"795\":1}}],[\"是否是重试\",{\"1\":{\"790\":1}}],[\"是否是内存\",{\"1\":{\"581\":2,\"586\":1}}],[\"是否继续本次消费请求的消费任务\",{\"1\":{\"750\":1}}],[\"是否锁定成功\",{\"1\":{\"746\":1}}],[\"是否顺序消费\",{\"1\":{\"744\":1}}],[\"是否仍由该消费者负载该队列\",{\"1\":{\"738\":1}}],[\"是否丢弃\",{\"1\":{\"715\":1}}],[\"是否挂起\",{\"1\":{\"693\":1}}],[\"是否启动内存\",{\"1\":{\"587\":1}}],[\"是否存在\",{\"1\":{\"550\":1,\"718\":1,\"799\":1}}],[\"是否发生变化\",{\"1\":{\"519\":1}}],[\"是否监听\",{\"1\":{\"517\":1}}],[\"是否在用户维度的白名单中\",{\"1\":{\"511\":1,\"520\":1}}],[\"是否在全局白名单中\",{\"1\":{\"511\":1,\"520\":1}}],[\"是否管理员账户\",{\"1\":{\"503\":1}}],[\"是否还存活\",{\"1\":{\"461\":1}}],[\"是否支持取消\",{\"1\":{\"442\":1}}],[\"是否支持挂起和是否开启长轮询来判断是否要进行轮询以及进行哪种轮询\",{\"1\":{\"326\":1}}],[\"是否合法\",{\"1\":{\"424\":1,\"567\":1}}],[\"是否使用\",{\"1\":{\"423\":1}}],[\"是否初始化\",{\"1\":{\"423\":1}}],[\"是否强制删除文件\",{\"1\":{\"390\":1}}],[\"是否立即强制删除文件\",{\"1\":{\"390\":1}}],[\"是否有\",{\"1\":{\"357\":1}}],[\"是否有一种更为现代化的工具\",{\"1\":{\"126\":1}}],[\"是否成立\",{\"1\":{\"335\":1}}],[\"是否成功\",{\"1\":{\"285\":1}}],[\"是否写满\",{\"1\":{\"313\":1}}],[\"是否已被消费者\",{\"1\":{\"220\":1}}],[\"是否已被交付给消费者\",{\"1\":{\"220\":1}}],[\"是否已被注册\",{\"1\":{\"84\":1}}],[\"是否同步镜像\",{\"1\":{\"210\":1}}],[\"是两个系统模块\",{\"1\":{\"97\":1}}],[\"是指单一或一系列的关卡\",{\"1\":{\"36\":1}}],[\"是值才为\",{\"1\":{\"36\":1}}],[\"是自动导入的\",{\"1\":{\"35\":1}}],[\"是那些作为erlang语言定义一部分的函数\",{\"1\":{\"35\":1}}],[\"是中缀插入操作符\",{\"1\":{\"34\":1}}],[\"是任一表达式\",{\"1\":{\"34\":1}}],[\"是无需使用fun\",{\"1\":{\"34\":1}}],[\"是函数式编程语言\",{\"1\":{\"31\":1}}],[\"是一种轻量级进程\",{\"1\":{\"152\":1}}],[\"是一种全局唯一的erlang数据类型\",{\"1\":{\"68\":1}}],[\"是一种结构\",{\"1\":{\"36\":1}}],[\"是一个能生成语法和词法分析器的生成程序\",{\"1\":{\"841\":1}}],[\"是一个简单的\",{\"1\":{\"461\":1}}],[\"是一个低延迟\",{\"1\":{\"394\":1,\"860\":1}}],[\"是一个\",{\"1\":{\"266\":1}}],[\"是一个可以动态增加自身数据长度的类\",{\"1\":{\"261\":1}}],[\"是一个由多个\",{\"1\":{\"386\":1}}],[\"是一个由\",{\"1\":{\"156\":1}}],[\"是一个3节点\",{\"1\":{\"134\":1}}],[\"是一个开启或关闭跟踪的布尔值\",{\"1\":{\"111\":1}}],[\"是一个空列表\",{\"1\":{\"27\":1}}],[\"是一个模式匹配操作符\",{\"1\":{\"23\":1}}],[\"是一次性赋值变量\",{\"1\":{\"23\":1}}],[\"是\",{\"1\":{\"2\":2,\"157\":1,\"159\":1,\"249\":1,\"256\":1,\"266\":1,\"297\":1,\"556\":1,\"585\":2,\"615\":1,\"688\":1,\"820\":1}}],[\"闪亮登场\",{\"1\":{\"2\":1}}],[\"独特的场景时可能就需要自己进行性能压测\",{\"1\":{\"2\":1}}],[\"a<>\",{\"1\":{\"828\":1}}],[\"aynscconsumersendmsgback\",{\"1\":{\"708\":1}}],[\"a210d64eddb5\",{\"1\":{\"595\":1}}],[\"a7d0e64c5335\",{\"1\":{\"595\":1}}],[\"ago\",{\"1\":{\"592\":1,\"595\":3,\"597\":1,\"599\":10}}],[\"again\",{\"1\":{\"345\":1,\"789\":1}}],[\"ak\",{\"1\":{\"515\":2,\"797\":2}}],[\"await\",{\"1\":{\"435\":1,\"490\":1}}],[\"a为master节点\",{\"1\":{\"207\":1}}],[\"a需要重启\",{\"1\":{\"192\":1}}],[\"amend\",{\"1\":{\"798\":1}}],[\"amazon\",{\"1\":{\"442\":1}}],[\"amd64\",{\"1\":{\"176\":3}}],[\"amqqueue\",{\"1\":{\"154\":1,\"204\":2,\"205\":2}}],[\"amqpqueue\",{\"1\":{\"222\":1}}],[\"amqp\",{\"1\":{\"154\":2,\"168\":1,\"804\":2,\"810\":2,\"811\":1}}],[\"adjustthreadpool\",{\"1\":{\"568\":2}}],[\"admintools\",{\"1\":{\"768\":1}}],[\"adminbrokerprocessor\",{\"1\":{\"734\":1}}],[\"admin\",{\"1\":{\"123\":1,\"503\":4,\"520\":2}}],[\"addbuffersuc\",{\"1\":{\"791\":2}}],[\"addblockedlistener\",{\"1\":{\"146\":1}}],[\"adddiff\",{\"1\":{\"791\":1}}],[\"addckjustoffset\",{\"1\":{\"791\":1}}],[\"addckmock\",{\"1\":{\"790\":1}}],[\"addck\",{\"0\":{\"795\":1},\"1\":{\"782\":1,\"791\":1,\"795\":1}}],[\"addmessage\",{\"1\":{\"694\":1,\"790\":1}}],[\"addak\",{\"0\":{\"796\":1},\"1\":{\"782\":1,\"793\":1,\"796\":1}}],[\"addall\",{\"1\":{\"518\":1,\"663\":2,\"786\":2,\"787\":1}}],[\"addandget\",{\"1\":{\"400\":1}}],[\"addextfield\",{\"1\":{\"515\":3}}],[\"addshutdownhook\",{\"1\":{\"480\":1}}],[\"addscheduletask\",{\"1\":{\"389\":1}}],[\"addretrytopicifnoexit\",{\"1\":{\"800\":1}}],[\"address=9555\",{\"1\":{\"600\":1}}],[\"address\",{\"1\":{\"402\":3,\"537\":3,\"568\":1,\"643\":1}}],[\"addr\",{\"1\":{\"417\":1,\"514\":6,\"520\":2,\"692\":3}}],[\"addr=namesrv\",{\"1\":{\"595\":1,\"598\":1,\"600\":3,\"601\":1}}],[\"addr=\",{\"1\":{\"365\":1,\"380\":1,\"694\":1}}],[\"addpullrequest\",{\"1\":{\"342\":1,\"345\":1}}],[\"addlistener\",{\"1\":{\"340\":1,\"693\":1}}],[\"additional\",{\"1\":{\"176\":2}}],[\"add\",{\"1\":{\"9\":2,\"73\":2,\"103\":2,\"242\":1,\"313\":2,\"317\":1,\"335\":1,\"345\":1,\"380\":1,\"390\":1,\"392\":1,\"490\":1,\"491\":2,\"514\":1,\"515\":1,\"518\":2,\"519\":1,\"540\":1,\"541\":2,\"664\":4,\"694\":3,\"714\":2,\"715\":1,\"720\":1,\"742\":4,\"744\":4,\"746\":1,\"787\":1,\"791\":1,\"795\":3,\"796\":4,\"848\":1}}],[\"alpine\",{\"1\":{\"592\":3,\"603\":1}}],[\"alpha\",{\"1\":{\"223\":2}}],[\"already\",{\"1\":{\"567\":1,\"642\":1,\"664\":1,\"744\":1,\"797\":1}}],[\"almost\",{\"1\":{\"406\":1,\"796\":1}}],[\"always\",{\"1\":{\"190\":1,\"192\":2}}],[\"also\",{\"1\":{\"157\":1,\"665\":1,\"694\":1}}],[\"aliyun\",{\"1\":{\"122\":2}}],[\"alibaba\",{\"1\":{\"118\":1}}],[\"allwaitforrunning\",{\"1\":{\"246\":1}}],[\"allocate4pop\",{\"0\":{\"787\":1},\"1\":{\"786\":1,\"787\":1}}],[\"allocateresultset\",{\"1\":{\"663\":6}}],[\"allocateresult\",{\"1\":{\"663\":4,\"786\":5,\"787\":7}}],[\"allocaterequest\",{\"1\":{\"401\":2}}],[\"allocatemessagequeuebymachineroom\",{\"1\":{\"658\":1}}],[\"allocatemessagequeuebyconfig\",{\"1\":{\"658\":1}}],[\"allocatemessagequeueconsistenthash\",{\"1\":{\"658\":1}}],[\"allocatemessagequeuestrategyname=\",{\"1\":{\"663\":2}}],[\"allocatemessagequeuestrategy\",{\"1\":{\"539\":4,\"653\":1,\"663\":3,\"786\":5,\"787\":5}}],[\"allocatemessagequeueaveragelybycircle\",{\"1\":{\"658\":1}}],[\"allocatemessagequeueaveragely\",{\"1\":{\"505\":1,\"658\":1}}],[\"allocatemappedfileservice\",{\"1\":{\"401\":2}}],[\"allocatedirect\",{\"1\":{\"403\":1}}],[\"allocate\",{\"1\":{\"258\":1,\"663\":2,\"786\":2,\"787\":3}}],[\"allocation\",{\"1\":{\"21\":2}}],[\"allow\",{\"1\":{\"157\":1}}],[\"allowed\",{\"1\":{\"21\":1}}],[\"all\",{\"1\":{\"21\":9,\"80\":1,\"85\":1,\"103\":1,\"111\":1,\"151\":1,\"178\":3,\"185\":1,\"190\":1,\"480\":1,\"492\":1,\"503\":1,\"786\":1,\"787\":1,\"789\":2,\"847\":1}}],[\"appendcheckpoint\",{\"0\":{\"791\":1},\"1\":{\"790\":1,\"791\":1}}],[\"appenderqueue\",{\"1\":{\"541\":1}}],[\"appenders\",{\"1\":{\"528\":1}}],[\"append\",{\"1\":{\"540\":2,\"755\":5}}],[\"appendmessagecallback\",{\"1\":{\"816\":1}}],[\"appendmessages\",{\"1\":{\"816\":1}}],[\"appendmessagestatus\",{\"1\":{\"257\":2,\"258\":1,\"800\":1}}],[\"appendmessage\",{\"1\":{\"285\":1,\"288\":1}}],[\"appendmessageresult\",{\"1\":{\"257\":3,\"258\":4}}],[\"appears\",{\"1\":{\"223\":1}}],[\"application\",{\"1\":{\"151\":1}}],[\"applicationcontextprovider\",{\"1\":{\"122\":1}}],[\"applicationcontext\",{\"1\":{\"116\":3,\"122\":1}}],[\"apply\",{\"0\":{\"50\":1},\"1\":{\"45\":1,\"50\":1,\"79\":1,\"186\":3,\"493\":1,\"693\":2}}],[\"apple1\",{\"1\":{\"103\":2}}],[\"apples\",{\"1\":{\"27\":7,\"103\":1}}],[\"apple\",{\"1\":{\"27\":1,\"31\":4,\"103\":6}}],[\"apt\",{\"0\":{\"177\":1},\"1\":{\"176\":1,\"177\":4,\"178\":1,\"179\":2}}],[\"apacherocketmq\",{\"1\":{\"592\":1,\"593\":1,\"595\":1,\"597\":3,\"598\":1,\"599\":1,\"601\":1}}],[\"apache\",{\"1\":{\"136\":1,\"263\":1,\"372\":1,\"402\":2,\"439\":1,\"510\":1,\"516\":2,\"545\":1,\"573\":1,\"590\":1,\"593\":5,\"595\":6,\"599\":9,\"600\":3,\"804\":1,\"817\":1}}],[\"api\",{\"0\":{\"187\":1,\"573\":1},\"1\":{\"98\":1,\"187\":1,\"399\":1,\"514\":1,\"545\":2,\"547\":1,\"549\":1,\"556\":1,\"573\":1,\"614\":1,\"656\":1,\"680\":1,\"708\":1,\"746\":1,\"872\":1,\"873\":1}}],[\"acl实现机制\",{\"1\":{\"521\":1}}],[\"acl使用指南\",{\"1\":{\"521\":1}}],[\"aclwatcherservice\",{\"1\":{\"519\":1}}],[\"acl配置文件的数量\",{\"1\":{\"519\":1}}],[\"aclfilename\",{\"1\":{\"519\":2,\"520\":2}}],[\"aclfilesnum和filelist\",{\"1\":{\"519\":1}}],[\"aclfilesnum\",{\"1\":{\"519\":9}}],[\"aclfilewatchservice\",{\"1\":{\"519\":8}}],[\"aclfilepath\",{\"1\":{\"518\":2,\"519\":2}}],[\"aclexception\",{\"1\":{\"518\":1,\"520\":6}}],[\"aclenable=true\",{\"1\":{\"503\":1}}],[\"aclpath\",{\"1\":{\"519\":3}}],[\"aclplainaccessresourcemap是个map类型\",{\"1\":{\"517\":1}}],[\"aclplainaccessresourcemap\",{\"1\":{\"517\":2,\"518\":4,\"520\":1}}],[\"aclproducertest\",{\"1\":{\"504\":1}}],[\"aclutils\",{\"1\":{\"515\":2,\"518\":1,\"520\":1}}],[\"aclconstants\",{\"1\":{\"518\":2}}],[\"aclconsumertest\",{\"1\":{\"505\":1}}],[\"aclclienthook\",{\"1\":{\"504\":2,\"505\":2}}],[\"aclclientrpchook\",{\"0\":{\"507\":1,\"508\":1,\"509\":1,\"513\":1,\"514\":1,\"515\":1},\"1\":{\"500\":2,\"501\":1,\"504\":2,\"505\":1,\"506\":1,\"507\":1,\"508\":2,\"514\":1}}],[\"acl\",{\"0\":{\"495\":1,\"510\":1,\"516\":1},\"1\":{\"495\":1,\"496\":5,\"498\":3,\"499\":1,\"500\":1,\"503\":3,\"504\":5,\"505\":4,\"506\":2,\"507\":1,\"510\":5,\"516\":7,\"517\":4,\"518\":9,\"519\":2,\"520\":1,\"521\":3,\"884\":1}}],[\"ackoffsetbyindex\",{\"1\":{\"800\":1}}],[\"acktimeinterval\",{\"1\":{\"798\":1,\"799\":1}}],[\"acked\",{\"1\":{\"783\":1}}],[\"ackmessagerequestheader\",{\"1\":{\"793\":3}}],[\"ackmessageprocessor\",{\"0\":{\"793\":1},\"1\":{\"780\":1}}],[\"ackmsg\",{\"0\":{\"781\":1,\"794\":1},\"1\":{\"779\":2,\"781\":1,\"783\":2,\"793\":14,\"796\":15,\"798\":10}}],[\"ackindex\",{\"1\":{\"715\":15}}],[\"acknowledge\",{\"1\":{\"204\":1}}],[\"ack了多少条消息\",{\"1\":{\"159\":1}}],[\"ack\",{\"0\":{\"780\":1,\"792\":1},\"1\":{\"154\":3,\"159\":2,\"201\":2,\"207\":3,\"220\":1,\"771\":3,\"772\":1,\"773\":7,\"778\":1,\"780\":6,\"781\":1,\"782\":3,\"783\":2,\"790\":1,\"791\":1,\"793\":8,\"796\":10,\"797\":5,\"798\":13,\"799\":3,\"800\":3}}],[\"ac\",{\"1\":{\"136\":1}}],[\"activity\",{\"1\":{\"326\":1}}],[\"activemq\",{\"1\":{\"841\":1}}],[\"actively\",{\"1\":{\"664\":1,\"744\":1}}],[\"active\",{\"1\":{\"158\":3,\"487\":1}}],[\"action\",{\"1\":{\"116\":3}}],[\"actor并发模型\",{\"1\":{\"80\":1}}],[\"accounts\",{\"1\":{\"503\":2,\"518\":6}}],[\"accesschannel\",{\"1\":{\"541\":3}}],[\"accessskey\",{\"1\":{\"518\":1}}],[\"accessvalidatormap\",{\"1\":{\"516\":1}}],[\"accessvalidators\",{\"1\":{\"516\":4}}],[\"accessvalidator文件中配置的访问验证器plainaccessvalidator\",{\"1\":{\"516\":1}}],[\"accessvalidator\",{\"1\":{\"510\":2,\"516\":8}}],[\"accesskey=\",{\"1\":{\"520\":2}}],[\"accesskeytable是个map类型\",{\"1\":{\"517\":1}}],[\"accesskeytable\",{\"1\":{\"517\":2,\"518\":5,\"520\":2}}],[\"accesskey\",{\"1\":{\"498\":1,\"503\":3,\"507\":1,\"515\":3,\"517\":3,\"518\":2,\"520\":2}}],[\"access\",{\"1\":{\"496\":1,\"503\":2,\"504\":2,\"505\":2,\"515\":2,\"694\":1}}],[\"accessing\",{\"1\":{\"157\":1}}],[\"acc\",{\"1\":{\"39\":5}}],[\"af6bfa23\",{\"1\":{\"65\":1}}],[\"after\",{\"1\":{\"44\":1,\"82\":1,\"176\":1,\"508\":1,\"514\":1,\"534\":1}}],[\"a+10\",{\"1\":{\"63\":2}}],[\"attributekey<string>\",{\"1\":{\"417\":1}}],[\"attributekey\",{\"1\":{\"417\":5}}],[\"attributes\",{\"1\":{\"54\":1,\"103\":3}}],[\"at\",{\"1\":{\"133\":1,\"158\":1,\"492\":1,\"599\":6,\"797\":1}}],[\"atomicboolean\",{\"1\":{\"246\":1,\"541\":2,\"778\":1}}],[\"atomic\",{\"1\":{\"103\":1}}],[\"atomiclong>\",{\"1\":{\"720\":1}}],[\"atomiclong\",{\"1\":{\"2\":1,\"541\":1,\"720\":1}}],[\"atomtag\",{\"1\":{\"52\":1}}],[\"atom\",{\"1\":{\"36\":2,\"50\":1,\"84\":1}}],[\"author\",{\"1\":{\"54\":1}}],[\"automated\",{\"1\":{\"593\":1}}],[\"automatic\",{\"1\":{\"185\":2,\"186\":1,\"187\":1,\"191\":1}}],[\"autodetect=false\",{\"1\":{\"11\":1}}],[\"auto\",{\"1\":{\"11\":1,\"179\":2,\"406\":1,\"426\":1,\"559\":1}}],[\"aslist\",{\"1\":{\"808\":1}}],[\"asyncconsumersendmsgback\",{\"1\":{\"718\":1}}],[\"asyncpreparemessage\",{\"1\":{\"576\":1}}],[\"asyncputmessages\",{\"1\":{\"251\":2,\"816\":1}}],[\"asyncputmessage\",{\"0\":{\"257\":1},\"1\":{\"240\":2,\"251\":2,\"256\":2,\"359\":1,\"363\":2,\"576\":1,\"718\":1}}],[\"asyncsendmessage\",{\"1\":{\"563\":1,\"576\":2}}],[\"async\",{\"1\":{\"547\":1,\"570\":1,\"573\":2,\"595\":4,\"690\":1,\"692\":1,\"693\":1}}],[\"asyncrunnable\",{\"1\":{\"541\":1}}],[\"asyncappenderrequest\",{\"1\":{\"541\":4}}],[\"asynctracedispatcher处理\",{\"1\":{\"535\":1}}],[\"asynctracedispatcher\",{\"1\":{\"534\":1,\"539\":2,\"541\":5}}],[\"asyncnettyrequestprocessor\",{\"1\":{\"464\":1}}],[\"asynchronous\",{\"1\":{\"380\":2}}],[\"asyncdeliver\",{\"1\":{\"380\":2}}],[\"ascending\",{\"1\":{\"313\":1}}],[\"ascii\",{\"1\":{\"65\":1}}],[\"assignlmqoffset\",{\"1\":{\"816\":1}}],[\"assigner\",{\"1\":{\"816\":1}}],[\"assignedqueueset\",{\"1\":{\"786\":6}}],[\"assigned\",{\"1\":{\"786\":2,\"787\":2}}],[\"assignoffset\",{\"1\":{\"816\":1}}],[\"assignqueueoffset\",{\"1\":{\"814\":1,\"816\":2}}],[\"assignmentmanager\",{\"1\":{\"787\":1}}],[\"assignment\",{\"1\":{\"786\":4}}],[\"assignnewone\",{\"1\":{\"518\":2}}],[\"assert\",{\"1\":{\"573\":1,\"692\":2,\"693\":4}}],[\"assembler\",{\"1\":{\"157\":1}}],[\"assumes\",{\"1\":{\"11\":2}}],[\"astate\",{\"1\":{\"157\":2}}],[\"as\",{\"1\":{\"42\":1,\"541\":1,\"807\":1}}],[\"able\",{\"1\":{\"715\":1,\"750\":4}}],[\"abs\",{\"1\":{\"572\":2,\"789\":1}}],[\"absindexpos\",{\"1\":{\"317\":10}}],[\"absslotpos\",{\"1\":{\"317\":8}}],[\"abort\",{\"1\":{\"98\":1,\"103\":1}}],[\"about\",{\"1\":{\"21\":17,\"595\":6}}],[\"abc为字符串\",{\"1\":{\"828\":1}}],[\"abc\",{\"1\":{\"28\":1,\"106\":1,\"828\":3}}],[\"another\",{\"1\":{\"567\":1,\"595\":1,\"642\":1,\"693\":1}}],[\"annotation\",{\"1\":{\"262\":3}}],[\"annprocess<\",{\"1\":{\"8\":1}}],[\"an\",{\"1\":{\"240\":1,\"520\":1}}],[\"analyse\",{\"1\":{\"105\":1}}],[\"anatom\",{\"1\":{\"84\":7}}],[\"any\",{\"1\":{\"21\":1,\"85\":2,\"157\":1,\"498\":1}}],[\"andalso\",{\"1\":{\"69\":1,\"159\":1}}],[\"and\",{\"1\":{\"21\":2,\"36\":1,\"39\":6,\"56\":1,\"103\":2,\"157\":1,\"161\":1,\"176\":2,\"178\":1,\"240\":2,\"365\":2,\"406\":2,\"427\":1,\"430\":1,\"481\":1,\"492\":1,\"520\":1,\"568\":1,\"573\":1,\"576\":1,\"626\":1,\"643\":1,\"693\":2,\"694\":1,\"786\":1,\"789\":1,\"797\":1,\"807\":2,\"817\":2,\"828\":13,\"830\":5}}],[\"a\",{\"0\":{\"408\":1},\"1\":{\"21\":9,\"28\":2,\"34\":6,\"36\":12,\"42\":6,\"43\":5,\"44\":5,\"45\":5,\"62\":2,\"63\":4,\"98\":10,\"106\":5,\"147\":4,\"154\":2,\"157\":1,\"160\":3,\"207\":3,\"262\":3,\"355\":1,\"365\":4,\"380\":5,\"381\":1,\"406\":1,\"410\":1,\"411\":2,\"481\":1,\"595\":7,\"599\":1,\"664\":2,\"744\":2,\"745\":1,\"750\":3,\"807\":1,\"828\":16,\"829\":1,\"830\":2}}],[\"available\",{\"1\":{\"694\":1,\"793\":1}}],[\"avoid\",{\"1\":{\"390\":1,\"406\":1,\"427\":1}}],[\"avg\",{\"1\":{\"11\":2,\"611\":1,\"617\":3}}],[\"average\",{\"1\":{\"11\":2}}],[\"arbitrary\",{\"1\":{\"883\":3}}],[\"arriving\",{\"0\":{\"348\":1},\"1\":{\"282\":1,\"347\":2,\"348\":1}}],[\"arrayblockingqueue<runnable>\",{\"1\":{\"541\":1}}],[\"arrayblockingqueue<tracecontext>\",{\"1\":{\"541\":1}}],[\"arraycopy\",{\"1\":{\"420\":1}}],[\"arrays\",{\"1\":{\"313\":1,\"808\":1}}],[\"array\",{\"1\":{\"240\":1,\"247\":1,\"258\":1,\"285\":1}}],[\"arraylist<popcheckpoint>\",{\"1\":{\"799\":1}}],[\"arraylist<pullrequest>\",{\"1\":{\"345\":1,\"664\":1,\"744\":1}}],[\"arraylist<messageext>\",{\"1\":{\"714\":1,\"715\":1,\"848\":1}}],[\"arraylist<messagequeue>\",{\"1\":{\"663\":1,\"786\":1}}],[\"arraylist<mappedfile>\",{\"1\":{\"390\":1}}],[\"arraylist<tracetransferbean>\",{\"1\":{\"541\":1}}],[\"arraylist<tracecontext>\",{\"1\":{\"541\":1}}],[\"arraylist<tracebean>\",{\"1\":{\"540\":1}}],[\"arraylist<rpchook>\",{\"1\":{\"514\":1}}],[\"arraylist<long>\",{\"1\":{\"314\":1}}],[\"arraylist<indexfile>\",{\"1\":{\"309\":1,\"392\":1}}],[\"arraylist<integer>\",{\"1\":{\"9\":1}}],[\"arraylist<string>\",{\"1\":{\"261\":2}}],[\"arraylist<>\",{\"1\":{\"9\":1,\"517\":1,\"518\":2,\"787\":1}}],[\"arraylist\",{\"1\":{\"2\":1,\"9\":5,\"261\":1,\"335\":1}}],[\"article\",{\"1\":{\"124\":1}}],[\"articles\",{\"1\":{\"115\":1}}],[\"artifactid>\",{\"1\":{\"8\":2}}],[\"arthas\",{\"0\":{\"113\":1,\"114\":1},\"1\":{\"113\":1,\"118\":1,\"121\":1,\"122\":7,\"123\":5,\"141\":1}}],[\"armstring\",{\"1\":{\"54\":1}}],[\"armstrong\",{\"1\":{\"26\":1}}],[\"args\",{\"1\":{\"74\":1,\"79\":2,\"111\":1,\"198\":3,\"480\":2,\"504\":1,\"505\":1,\"768\":1,\"850\":7}}],[\"argn这些参数上\",{\"1\":{\"50\":1}}],[\"argn\",{\"1\":{\"50\":2}}],[\"arg2\",{\"1\":{\"50\":3}}],[\"arg1\",{\"1\":{\"50\":2}}],[\"argument\",{\"1\":{\"42\":1}}],[\"area\",{\"1\":{\"30\":11,\"80\":1}}],[\"are\",{\"1\":{\"21\":2,\"157\":2,\"160\":1}}],[\"arity2\",{\"1\":{\"53\":1}}],[\"arity1\",{\"1\":{\"53\":1}}],[\"arity\",{\"1\":{\"21\":7,\"60\":2}}],[\"archives\",{\"1\":{\"176\":1}}],[\"archetype\",{\"1\":{\"7\":2}}],[\"archtype\",{\"0\":{\"7\":1},\"1\":{\"7\":3,\"8\":1,\"9\":1,\"10\":1}}],[\"更适用于\",{\"1\":{\"617\":1}}],[\"更具体一点\",{\"1\":{\"611\":1}}],[\"更详细的消息轨迹使用方法请参考官方文档\",{\"1\":{\"524\":1}}],[\"更高的可靠性意味着消息同步投递\",{\"1\":{\"444\":1}}],[\"更多思考\",{\"0\":{\"292\":1,\"366\":1}}],[\"更容易进行节点的滚动升级\",{\"1\":{\"229\":1}}],[\"更容易理解\",{\"1\":{\"34\":1}}],[\"更好的数据安全性\",{\"1\":{\"229\":1}}],[\"更新过滤信息\",{\"1\":{\"850\":1}}],[\"更新下次从哪个节点拉取消息\",{\"1\":{\"848\":1}}],[\"更新下一次拉取的偏移量\",{\"1\":{\"695\":1,\"749\":1}}],[\"更新和存储消费者的过滤信息\",{\"1\":{\"832\":1}}],[\"更新偏移量\",{\"1\":{\"790\":1}}],[\"更新加锁时间和客户端\",{\"1\":{\"734\":1}}],[\"更新消费进度\",{\"1\":{\"715\":1}}],[\"更新消费进度缓存\",{\"1\":{\"711\":1}}],[\"更新消息消费偏移量\",{\"1\":{\"637\":1}}],[\"更新消息中间件的源码解析和最新动态\",{\"1\":{\"0\":1,\"15\":1,\"16\":1,\"112\":1,\"124\":1,\"136\":1,\"140\":1,\"161\":1,\"173\":1,\"179\":1,\"212\":1,\"224\":1,\"237\":1,\"263\":1,\"294\":1,\"318\":1,\"349\":1,\"368\":1,\"381\":1,\"392\":1,\"404\":1,\"437\":1,\"458\":1,\"494\":1,\"521\":1,\"542\":1,\"577\":1,\"587\":1,\"604\":1,\"625\":1,\"643\":1,\"665\":1,\"695\":1,\"721\":1,\"750\":1,\"762\":1,\"801\":1,\"818\":1,\"820\":1,\"853\":1,\"854\":1,\"858\":1,\"868\":1,\"883\":1}}],[\"更新内存缓存表\",{\"1\":{\"703\":1}}],[\"更新统计数据\",{\"1\":{\"685\":1,\"708\":1,\"715\":1,\"750\":1,\"790\":1,\"800\":1}}],[\"更新队列订阅关系\",{\"1\":{\"657\":1}}],[\"更新订阅数据版本号\",{\"1\":{\"657\":1}}],[\"更新自己需要拉取的处理队列\",{\"1\":{\"657\":1}}],[\"更新失败条目\",{\"1\":{\"570\":1}}],[\"更新主备信息\",{\"1\":{\"491\":1}}],[\"更新之后保存到\",{\"1\":{\"476\":1}}],[\"更新路由信息\",{\"1\":{\"476\":1,\"642\":1}}],[\"更新集群信息表\",{\"1\":{\"491\":1}}],[\"更新集群信息\",{\"1\":{\"473\":1,\"491\":1}}],[\"更新为当前投递消息的\",{\"1\":{\"377\":1}}],[\"更新索引文件头\",{\"1\":{\"317\":1}}],[\"更新文件头\",{\"1\":{\"317\":1}}],[\"更新checkpoint中consumequeue最新刷盘时间\",{\"1\":{\"289\":1}}],[\"更新分发的偏移量为当前分发消息的起始偏移量\",{\"1\":{\"282\":1}}],[\"更新最大可用偏移量\",{\"1\":{\"273\":1}}],[\"更新\",{\"1\":{\"159\":1,\"289\":1,\"378\":1,\"465\":1,\"472\":1,\"473\":8,\"491\":12,\"640\":2,\"691\":1,\"798\":1,\"799\":1}}],[\"更新或设值\",{\"1\":{\"42\":1}}],[\"更快\",{\"1\":{\"2\":2,\"403\":1}}],[\"lday\",{\"1\":{\"858\":1}}],[\"llight\",{\"1\":{\"818\":1}}],[\"lru\",{\"1\":{\"399\":1}}],[\"lksctp\",{\"1\":{\"176\":1}}],[\"lazy\",{\"1\":{\"694\":2}}],[\"larger\",{\"1\":{\"690\":1,\"748\":1}}],[\"lastkey\",{\"1\":{\"690\":3}}],[\"lastbrokername\",{\"1\":{\"570\":2,\"572\":7}}],[\"lastmodified\",{\"1\":{\"519\":2}}],[\"lastphysicalminoffset\",{\"1\":{\"391\":2,\"392\":1}}],[\"lastfile\",{\"1\":{\"314\":3}}],[\"lastflushtimestamp\",{\"1\":{\"289\":2}}],[\"lastupdatetimestamp\",{\"1\":{\"474\":1,\"487\":2}}],[\"lastupdateindextimestamp\",{\"1\":{\"313\":3}}],[\"lastupdateendphyoffset\",{\"1\":{\"313\":3}}],[\"lastexitok\",{\"1\":{\"313\":3}}],[\"last\",{\"1\":{\"291\":2,\"541\":1,\"768\":1,\"800\":2}}],[\"launches\",{\"1\":{\"287\":1,\"694\":1}}],[\"launchedurlclassloader\",{\"1\":{\"116\":1}}],[\"languagecode\",{\"1\":{\"414\":1}}],[\"language\",{\"1\":{\"262\":1,\"410\":1,\"414\":1}}],[\"latest\",{\"1\":{\"693\":6}}],[\"latencyfaulttolerance\",{\"1\":{\"572\":3}}],[\"later\",{\"1\":{\"257\":2,\"576\":2,\"690\":2,\"715\":3,\"748\":1,\"750\":2}}],[\"latch\",{\"1\":{\"146\":1}}],[\"lf用符号\",{\"1\":{\"138\":1}}],[\"lf\",{\"1\":{\"138\":2}}],[\"less\",{\"1\":{\"721\":1}}],[\"lead\",{\"1\":{\"665\":1}}],[\"leader\",{\"1\":{\"182\":1,\"201\":5,\"205\":4,\"206\":4,\"207\":4,\"210\":1}}],[\"leaving\",{\"1\":{\"176\":1}}],[\"least\",{\"1\":{\"133\":1}}],[\"length=\",{\"1\":{\"257\":2}}],[\"length\",{\"1\":{\"257\":10,\"314\":3,\"343\":1,\"390\":1,\"392\":1,\"406\":1,\"414\":2,\"426\":2,\"492\":1,\"541\":1,\"816\":2,\"817\":5,\"826\":2,\"829\":1,\"850\":3,\"852\":1}}],[\"len\",{\"1\":{\"158\":1}}],[\"level\",{\"1\":{\"9\":2,\"240\":1,\"242\":1,\"360\":1,\"364\":3,\"573\":1}}],[\"lhs\",{\"1\":{\"23\":2}}],[\"ls\",{\"1\":{\"21\":2,\"102\":1,\"594\":1}}],[\"liaoxuefeng\",{\"1\":{\"819\":1}}],[\"light\",{\"0\":{\"802\":1},\"1\":{\"802\":1,\"804\":1,\"817\":2,\"884\":1}}],[\"lightweight\",{\"1\":{\"801\":1}}],[\"limit\",{\"1\":{\"242\":2,\"285\":1}}],[\"livemaxtimestamp\",{\"1\":{\"390\":2}}],[\"liveinfoparam\",{\"1\":{\"116\":1}}],[\"live\",{\"1\":{\"116\":2,\"852\":1}}],[\"livecoreservice\",{\"1\":{\"116\":1}}],[\"libc\",{\"1\":{\"402\":3}}],[\"libc继承自com\",{\"1\":{\"402\":1}}],[\"libtinfo5\",{\"1\":{\"176\":2}}],[\"libsctp1\",{\"1\":{\"176\":4}}],[\"libwxgtk3\",{\"1\":{\"176\":8}}],[\"libwxgtk2\",{\"1\":{\"176\":2}}],[\"libwxbase3\",{\"1\":{\"176\":6}}],[\"libwxbase2\",{\"1\":{\"176\":2}}],[\"libncurses5\",{\"1\":{\"176\":4}}],[\"library\",{\"1\":{\"61\":1,\"402\":1}}],[\"lib\",{\"1\":{\"32\":2,\"61\":1,\"103\":1,\"106\":2}}],[\"listener\",{\"1\":{\"481\":2,\"519\":3,\"624\":1,\"637\":1,\"715\":2}}],[\"listenport=10931\",{\"1\":{\"595\":1}}],[\"listenport\",{\"1\":{\"480\":1}}],[\"listexp\",{\"1\":{\"34\":1}}],[\"listexpr\",{\"1\":{\"34\":1}}],[\"listfiles\",{\"1\":{\"313\":1}}],[\"list<channel>\",{\"1\":{\"850\":2}}],[\"list<tracetransferbean>\",{\"1\":{\"541\":1}}],[\"list<tracetransferbean>>\",{\"1\":{\"541\":3}}],[\"list<tracecontext>\",{\"1\":{\"541\":2}}],[\"list<tracebean>\",{\"1\":{\"537\":1,\"540\":1}}],[\"list<dataversion>\",{\"1\":{\"518\":1}}],[\"list<plainaccessconfig>\",{\"1\":{\"518\":1}}],[\"list<pullrequest>\",{\"1\":{\"345\":2,\"664\":1,\"744\":1}}],[\"list<accessvalidator>\",{\"1\":{\"516\":1}}],[\"list<remoteaddressstrategy>>\",{\"1\":{\"517\":1,\"518\":1}}],[\"list<remoteaddressstrategy>\",{\"1\":{\"517\":1,\"518\":2}}],[\"list<registerbrokerresult>\",{\"1\":{\"490\":2}}],[\"list<rpchook>\",{\"1\":{\"514\":1}}],[\"list<message\",{\"1\":{\"880\":1}}],[\"list<messagequeue>\",{\"1\":{\"663\":2,\"786\":2,\"787\":4}}],[\"list<message>\",{\"1\":{\"564\":1}}],[\"list<messageext>\",{\"1\":{\"505\":1,\"527\":1,\"714\":2,\"715\":1,\"750\":1,\"798\":1,\"808\":1,\"848\":2}}],[\"list<mappedfile>\",{\"1\":{\"291\":1,\"390\":1}}],[\"list<brokerdata>\",{\"1\":{\"470\":1,\"488\":1}}],[\"list<queuedata>\",{\"1\":{\"470\":1,\"488\":1,\"492\":1}}],[\"list<queuedata>>>\",{\"1\":{\"492\":1}}],[\"list<queuedata>>\",{\"1\":{\"469\":1,\"492\":1}}],[\"list<string>\",{\"1\":{\"469\":1,\"470\":1,\"488\":1,\"490\":2,\"491\":1,\"663\":1,\"786\":1,\"787\":1}}],[\"list<indexfile>\",{\"1\":{\"392\":1}}],[\"list<long>\",{\"1\":{\"310\":1,\"314\":1,\"317\":2}}],[\"lists\",{\"1\":{\"31\":5,\"34\":3,\"42\":2,\"98\":1,\"103\":1,\"106\":1,\"176\":1}}],[\"list\",{\"1\":{\"21\":4,\"34\":1,\"35\":1,\"50\":1,\"98\":2,\"106\":1,\"139\":2,\"177\":1,\"496\":1,\"663\":1,\"786\":1,\"787\":1,\"808\":4}}],[\"links\",{\"1\":{\"595\":1,\"598\":1}}],[\"linkedblockingqueue<pullrequest>\",{\"1\":{\"688\":2}}],[\"linkedblockingqueue<putresultprocess>\",{\"1\":{\"381\":1}}],[\"linkedlist<>\",{\"1\":{\"9\":1}}],[\"linkedlist<integer>\",{\"1\":{\"9\":1}}],[\"linkedlist\",{\"1\":{\"2\":1,\"9\":5}}],[\"link\",{\"1\":{\"285\":1,\"541\":1,\"600\":3,\"601\":1,\"689\":1}}],[\"linebreaker\",{\"1\":{\"137\":1}}],[\"line\",{\"1\":{\"42\":2,\"45\":8,\"63\":1,\"103\":1}}],[\"linux内核page\",{\"1\":{\"858\":1}}],[\"linux中普通文件和块设备文件的区别\",{\"1\":{\"858\":1}}],[\"linux\",{\"1\":{\"7\":1,\"138\":1,\"594\":1,\"858\":1}}],[\"lc$^0\",{\"1\":{\"45\":2}}],[\"lc\",{\"1\":{\"21\":1,\"480\":3}}],[\"lmq\",{\"0\":{\"814\":1,\"816\":1,\"817\":1},\"1\":{\"694\":1,\"804\":2,\"806\":3,\"807\":8,\"808\":5,\"811\":1,\"813\":8,\"814\":15,\"816\":1,\"818\":2}}],[\"lm\",{\"1\":{\"21\":1}}],[\"l\",{\"0\":{\"34\":1},\"1\":{\"21\":1,\"27\":1,\"31\":4,\"33\":2,\"34\":4,\"39\":2,\"116\":1,\"262\":2,\"594\":1}}],[\"low\",{\"1\":{\"819\":3,\"820\":1}}],[\"look\",{\"1\":{\"718\":1}}],[\"looking\",{\"1\":{\"568\":1,\"643\":1}}],[\"lookup\",{\"1\":{\"406\":1,\"408\":1}}],[\"lookmessagebyoffset\",{\"1\":{\"365\":1,\"380\":1,\"381\":1,\"718\":1}}],[\"loop\",{\"1\":{\"45\":1,\"85\":4,\"261\":1}}],[\"logs\",{\"1\":{\"595\":2,\"599\":1,\"600\":6}}],[\"logger\",{\"1\":{\"480\":1,\"528\":2,\"790\":2,\"793\":1,\"795\":3,\"796\":5,\"797\":2,\"798\":7,\"799\":3,\"800\":4}}],[\"loggerfactory\",{\"1\":{\"480\":1}}],[\"loggercontext\",{\"1\":{\"480\":2}}],[\"loggername\",{\"1\":{\"480\":2}}],[\"logback\",{\"1\":{\"480\":2}}],[\"logicoffset\",{\"1\":{\"348\":2}}],[\"logicsmsgtimestamp\",{\"1\":{\"289\":4}}],[\"logical\",{\"1\":{\"287\":1,\"694\":1}}],[\"logic\",{\"1\":{\"285\":1,\"391\":2,\"693\":1,\"694\":5,\"695\":1,\"786\":1,\"790\":1}}],[\"log\",{\"1\":{\"240\":1,\"242\":3,\"257\":4,\"285\":4,\"291\":5,\"307\":1,\"313\":1,\"314\":4,\"317\":5,\"340\":7,\"343\":1,\"344\":4,\"345\":2,\"364\":1,\"365\":5,\"380\":7,\"381\":8,\"390\":2,\"392\":1,\"406\":1,\"435\":1,\"480\":4,\"481\":3,\"490\":2,\"491\":2,\"492\":9,\"516\":2,\"518\":2,\"519\":7,\"539\":1,\"541\":1,\"567\":1,\"568\":6,\"572\":1,\"642\":2,\"643\":1,\"660\":2,\"662\":1,\"663\":6,\"664\":7,\"665\":3,\"688\":4,\"690\":12,\"693\":15,\"694\":5,\"695\":5,\"715\":5,\"717\":2,\"720\":3,\"721\":2,\"742\":1,\"744\":5,\"745\":2,\"746\":2,\"748\":4,\"750\":8,\"786\":5,\"791\":1,\"817\":9,\"851\":6,\"852\":6,\"854\":1}}],[\"lockkey\",{\"1\":{\"790\":6}}],[\"lockok\",{\"1\":{\"746\":3}}],[\"lockbatchmq\",{\"1\":{\"746\":2}}],[\"lockbatchrequestbody\",{\"1\":{\"746\":2}}],[\"lockentry>\",{\"1\":{\"742\":1}}],[\"lockentry>>\",{\"1\":{\"742\":2}}],[\"lockentry\",{\"1\":{\"732\":1,\"734\":3,\"742\":13}}],[\"lockedmq\",{\"1\":{\"746\":3}}],[\"lockedmqs\",{\"1\":{\"742\":5}}],[\"locked\",{\"1\":{\"690\":1,\"748\":1,\"750\":1}}],[\"lockinterruptibly\",{\"1\":{\"491\":1,\"492\":2,\"742\":1}}],[\"lock\",{\"1\":{\"240\":7,\"243\":3,\"256\":4,\"310\":1,\"313\":2,\"314\":1,\"317\":8,\"392\":1,\"491\":2,\"492\":4,\"664\":2,\"737\":1,\"742\":4,\"744\":2,\"746\":2,\"750\":2}}],[\"locks\",{\"1\":{\"16\":1}}],[\"location\",{\"1\":{\"480\":1}}],[\"locator\",{\"1\":{\"193\":4}}],[\"localfileoffsetstore\",{\"1\":{\"623\":1,\"640\":1,\"642\":1,\"710\":1}}],[\"localfunc\",{\"1\":{\"60\":1}}],[\"localdispatcher\",{\"1\":{\"540\":2}}],[\"localtransactionstate\",{\"1\":{\"537\":1}}],[\"local\",{\"1\":{\"193\":1,\"484\":19,\"485\":2,\"486\":1,\"488\":4,\"537\":3,\"541\":1,\"799\":1}}],[\"localhost\",{\"1\":{\"123\":1}}],[\"loadsslcontext\",{\"1\":{\"481\":1}}],[\"loadconsumequeue\",{\"1\":{\"279\":1}}],[\"loader\",{\"1\":{\"116\":1}}],[\"loaded\",{\"1\":{\"21\":1}}],[\"load\",{\"0\":{\"518\":1},\"1\":{\"21\":5,\"313\":3,\"364\":1,\"402\":1,\"480\":2,\"481\":2,\"516\":3,\"518\":6,\"519\":6,\"642\":1,\"786\":1}}],[\"long>\",{\"1\":{\"364\":1,\"519\":1,\"721\":2}}],[\"longpollingenable=true\",{\"1\":{\"325\":1}}],[\"longpollingenable=false\",{\"1\":{\"325\":1}}],[\"longpollingenable\",{\"1\":{\"325\":1}}],[\"longpolling\",{\"1\":{\"319\":1}}],[\"longcanonicalname2\",{\"1\":{\"262\":1}}],[\"longcanonicalname1\",{\"1\":{\"262\":1}}],[\"longadder\",{\"1\":{\"2\":1}}],[\"long\",{\"1\":{\"2\":1,\"242\":1,\"257\":3,\"258\":2,\"262\":3,\"277\":1,\"285\":5,\"287\":3,\"289\":2,\"291\":5,\"309\":2,\"310\":4,\"313\":2,\"314\":7,\"315\":1,\"316\":1,\"317\":13,\"326\":1,\"332\":1,\"339\":2,\"343\":1,\"344\":2,\"345\":4,\"348\":3,\"360\":1,\"364\":2,\"365\":9,\"380\":10,\"390\":4,\"391\":1,\"392\":3,\"402\":2,\"435\":1,\"490\":1,\"491\":1,\"492\":1,\"514\":1,\"519\":1,\"537\":2,\"570\":6,\"573\":4,\"664\":1,\"665\":1,\"689\":1,\"690\":6,\"691\":5,\"692\":1,\"693\":4,\"694\":20,\"695\":4,\"715\":3,\"720\":1,\"721\":3,\"744\":1,\"748\":1,\"749\":4,\"750\":4,\"789\":2,\"790\":4,\"791\":3,\"795\":3,\"796\":2,\"797\":4,\"798\":9,\"799\":1,\"800\":1,\"808\":1,\"816\":3,\"817\":5,\"834\":1,\"838\":2,\"847\":1,\"850\":1,\"851\":2,\"852\":1}}],[\"ignore\",{\"1\":{\"798\":1}}],[\"ignored\",{\"1\":{\"391\":1,\"688\":1}}],[\"img\",{\"1\":{\"820\":1,\"842\":1}}],[\"immediately\",{\"1\":{\"693\":6}}],[\"images\",{\"1\":{\"592\":1}}],[\"image\",{\"1\":{\"398\":1,\"408\":1,\"416\":1,\"417\":1,\"419\":1,\"420\":3,\"422\":1,\"423\":1,\"424\":1,\"426\":1,\"429\":1,\"432\":4,\"592\":6,\"593\":2,\"595\":3,\"597\":1,\"598\":1,\"599\":2,\"838\":1,\"841\":1}}],[\"implements\",{\"1\":{\"262\":1,\"348\":1,\"537\":1,\"541\":2}}],[\"improve\",{\"1\":{\"240\":2,\"243\":1,\"256\":1,\"369\":1,\"406\":3,\"409\":1,\"412\":1,\"418\":1}}],[\"improvements\",{\"1\":{\"406\":1}}],[\"improvement\",{\"1\":{\"239\":1,\"405\":1}}],[\"important\",{\"1\":{\"103\":1}}],[\"import\",{\"1\":{\"53\":1,\"103\":1}}],[\"i++\",{\"1\":{\"289\":1,\"314\":1,\"390\":1,\"392\":1,\"504\":1,\"518\":1,\"519\":2,\"541\":1,\"572\":2,\"714\":1,\"715\":2,\"787\":1,\"789\":3,\"797\":1,\"816\":1,\"817\":3,\"826\":1,\"829\":1}}],[\"illegalargumentexception\",{\"1\":{\"480\":1}}],[\"illegalaccessexception\",{\"1\":{\"262\":1}}],[\"illegal\",{\"1\":{\"257\":1,\"693\":1,\"695\":2}}],[\"itqueuedata\",{\"1\":{\"492\":4}}],[\"ittopicqueuetable\",{\"1\":{\"492\":4}}],[\"itbrokeraddrtable\",{\"1\":{\"492\":4}}],[\"itbrokerlivetable\",{\"1\":{\"492\":3}}],[\"it\",{\"1\":{\"365\":2,\"491\":4,\"492\":9,\"503\":2,\"520\":1,\"540\":2,\"576\":3,\"597\":1,\"664\":6,\"715\":2,\"744\":5,\"745\":1,\"750\":4,\"786\":1,\"787\":1,\"790\":1,\"807\":1}}],[\"itself\",{\"1\":{\"223\":1,\"816\":1}}],[\"iterator<consumerfilterdata>\",{\"1\":{\"851\":1}}],[\"iterator<map\",{\"1\":{\"797\":1}}],[\"iterator<queuedata>\",{\"1\":{\"492\":1}}],[\"iterator<entry<messagequeue\",{\"1\":{\"664\":1,\"744\":1}}],[\"iterator<entry<string\",{\"1\":{\"492\":4}}],[\"iterator<entry<long\",{\"1\":{\"491\":1,\"492\":1}}],[\"iterator\",{\"1\":{\"491\":1,\"492\":6,\"664\":1,\"744\":1,\"797\":6,\"851\":4}}],[\"iterations\",{\"1\":{\"9\":2,\"11\":3}}],[\"iteration\",{\"1\":{\"4\":1,\"9\":2,\"11\":21}}],[\"item=name\",{\"1\":{\"103\":1}}],[\"item\",{\"1\":{\"103\":13,\"275\":2,\"307\":1,\"491\":3}}],[\"id作为处理依据\",{\"1\":{\"757\":1}}],[\"id对应的消息内容可能相同\",{\"1\":{\"757\":1}}],[\"idle\",{\"1\":{\"492\":1}}],[\"id=a表示消息的发送者为节点\",{\"1\":{\"207\":1}}],[\"id\",{\"1\":{\"103\":4,\"256\":1,\"287\":1,\"363\":1,\"419\":9,\"455\":1,\"491\":3,\"516\":1,\"528\":1,\"537\":3,\"562\":1,\"567\":1,\"573\":5,\"592\":1,\"595\":1,\"597\":1,\"599\":2,\"640\":1,\"657\":2,\"663\":2,\"693\":3,\"694\":1,\"708\":1,\"718\":2,\"720\":2,\"732\":1,\"734\":1,\"742\":1,\"746\":1,\"786\":1,\"787\":2,\"790\":3,\"791\":2,\"793\":1,\"813\":1}}],[\"idea\",{\"0\":{\"114\":1},\"1\":{\"6\":1,\"7\":2,\"10\":1,\"121\":1,\"122\":2}}],[\"iptoipv4str\",{\"1\":{\"537\":1}}],[\"ipv6\",{\"1\":{\"240\":1,\"256\":2}}],[\"ip\",{\"1\":{\"87\":1,\"419\":1,\"491\":3,\"496\":1,\"498\":2,\"503\":1,\"511\":2,\"517\":2,\"518\":1,\"520\":2,\"537\":6,\"595\":7,\"600\":3,\"760\":1,\"807\":2,\"808\":2}}],[\"ismsginlive\",{\"1\":{\"852\":1}}],[\"ismatchedbycommitlog的调用层级\",{\"1\":{\"838\":1}}],[\"ismatchedbycommitlog\",{\"1\":{\"345\":1,\"694\":1,\"838\":3,\"844\":1,\"852\":1}}],[\"ismatchedbyconsumequeue\",{\"1\":{\"287\":1,\"345\":1,\"694\":1,\"838\":5,\"839\":1,\"844\":1,\"847\":1,\"852\":1}}],[\"isnotifyconsumeridschangedenable\",{\"1\":{\"850\":1}}],[\"ishit\",{\"1\":{\"843\":1,\"852\":1}}],[\"ishavetopicrouterinfo\",{\"1\":{\"571\":1}}],[\"isjustoffset\",{\"1\":{\"796\":1,\"797\":2}}],[\"isindisk\",{\"1\":{\"694\":2}}],[\"isdiskfallrecorded\",{\"1\":{\"694\":1}}],[\"isdropped\",{\"1\":{\"690\":1,\"715\":3,\"750\":4}}],[\"islmqconsumequeuenumexceeded\",{\"1\":{\"694\":1}}],[\"islmq\",{\"1\":{\"694\":1,\"816\":1,\"817\":1}}],[\"islockexpired\",{\"1\":{\"750\":2}}],[\"islocked\",{\"1\":{\"690\":1,\"742\":2,\"748\":1,\"750\":2}}],[\"islongpollingenable\",{\"1\":{\"282\":1,\"339\":1,\"344\":1,\"347\":1,\"693\":1}}],[\"isoneway\",{\"1\":{\"720\":2}}],[\"isoffsetcheckinslave\",{\"1\":{\"693\":1}}],[\"isorder\",{\"1\":{\"662\":2,\"663\":3,\"664\":3,\"744\":3,\"789\":4,\"790\":4}}],[\"isordermessageenable\",{\"1\":{\"493\":1}}],[\"ispostsubscriptionwhenpull\",{\"1\":{\"690\":1}}],[\"ispreviouslylocked\",{\"1\":{\"690\":1,\"748\":1}}],[\"ispause\",{\"1\":{\"690\":1}}],[\"ispullexpired\",{\"1\":{\"664\":1,\"744\":1}}],[\"isreadable\",{\"1\":{\"693\":2,\"694\":1}}],[\"isrejecttransactionmessage\",{\"1\":{\"576\":1}}],[\"isretry\",{\"1\":{\"790\":6}}],[\"isretryanotherbrokerwhennotstoreok\",{\"1\":{\"570\":1}}],[\"isretrytopic\",{\"1\":{\"520\":1}}],[\"isunitmode=\",{\"1\":{\"642\":1}}],[\"isunitmode\",{\"1\":{\"573\":1,\"642\":2,\"718\":1}}],[\"isblank\",{\"1\":{\"541\":1,\"717\":1,\"718\":2,\"755\":1,\"816\":1,\"817\":2}}],[\"isbrokertopicconfigchanged\",{\"1\":{\"491\":1}}],[\"isgroup\",{\"1\":{\"520\":4}}],[\"isavailable\",{\"1\":{\"572\":1}}],[\"isadmin\",{\"1\":{\"520\":2}}],[\"isaclenable\",{\"1\":{\"516\":1}}],[\"iswritable\",{\"1\":{\"819\":3}}],[\"iswriteable\",{\"1\":{\"718\":2,\"820\":2}}],[\"iswritefull\",{\"1\":{\"313\":1,\"316\":1}}],[\"iswaitstoremsgok\",{\"1\":{\"576\":1}}],[\"iswatchstart\",{\"1\":{\"517\":1,\"519\":1}}],[\"iscqwriteable\",{\"1\":{\"817\":2}}],[\"isckdoneforfinish\",{\"1\":{\"797\":2}}],[\"isckdone\",{\"1\":{\"797\":2}}],[\"isckstored\",{\"1\":{\"797\":4}}],[\"isconsumeorderly\",{\"1\":{\"745\":1}}],[\"isconsumebroadcastenable\",{\"1\":{\"693\":1}}],[\"isconsumeenable\",{\"1\":{\"693\":1}}],[\"iscommitlogavailable\",{\"1\":{\"282\":1}}],[\"isclassfiltermode\",{\"1\":{\"690\":2,\"847\":1,\"848\":1,\"852\":2}}],[\"iscleanfileforciblyenable\",{\"1\":{\"390\":1}}],[\"isthebatchfull\",{\"1\":{\"694\":1}}],[\"istagtype\",{\"1\":{\"691\":1,\"693\":3,\"847\":1,\"850\":1,\"852\":2}}],[\"istagscodelegal\",{\"1\":{\"287\":1,\"694\":3}}],[\"istransfermsgbyheap\",{\"1\":{\"693\":1}}],[\"istrans\",{\"1\":{\"573\":3}}],[\"istimetodelete\",{\"1\":{\"390\":1}}],[\"istimematched\",{\"1\":{\"314\":1}}],[\"isenablecalcfilterbitmap\",{\"1\":{\"842\":1,\"851\":1}}],[\"isenabledlegercommitlog\",{\"1\":{\"817\":1}}],[\"isenablelmq\",{\"1\":{\"816\":1,\"817\":1}}],[\"isenablemultidispatch\",{\"1\":{\"816\":1,\"817\":1}}],[\"isenablepoplog\",{\"1\":{\"795\":2,\"796\":3,\"797\":1,\"798\":2,\"800\":1}}],[\"isenablepopbuffermerge\",{\"1\":{\"795\":1,\"796\":1}}],[\"isenablepropertyfilter\",{\"1\":{\"693\":1}}],[\"isexpired\",{\"1\":{\"742\":1}}],[\"isextwriteenable\",{\"1\":{\"817\":1}}],[\"isextreadenable\",{\"1\":{\"291\":1}}],[\"isextaddr\",{\"1\":{\"291\":1,\"365\":1,\"380\":1,\"694\":1,\"817\":1}}],[\"isempty\",{\"1\":{\"291\":1,\"313\":1,\"314\":1,\"345\":1,\"392\":1,\"414\":2,\"491\":1,\"492\":3,\"516\":1,\"518\":5,\"540\":2,\"541\":1,\"695\":1,\"715\":3,\"720\":2,\"742\":1,\"749\":1,\"750\":1,\"789\":1,\"790\":1,\"798\":1,\"808\":1,\"817\":1,\"848\":1,\"851\":1}}],[\"isfiltersupportretry\",{\"1\":{\"693\":1}}],[\"isfirstcreateinqueue\",{\"1\":{\"285\":1}}],[\"isfruit\",{\"1\":{\"31\":4}}],[\"isserverloadbalancerenable\",{\"1\":{\"786\":1}}],[\"issendmessagewithvipchannel\",{\"1\":{\"567\":1,\"573\":1}}],[\"isslavereadenable\",{\"1\":{\"693\":2}}],[\"isslave\",{\"1\":{\"691\":1}}],[\"issynthetic\",{\"1\":{\"515\":1}}],[\"isspacetodelete\",{\"1\":{\"390\":1}}],[\"isstarted\",{\"1\":{\"380\":1,\"381\":2,\"541\":1}}],[\"isstatic\",{\"1\":{\"262\":1}}],[\"isstopped\",{\"1\":{\"344\":1,\"519\":1,\"660\":1,\"688\":1}}],[\"issuggestpullingfromslave\",{\"1\":{\"693\":2}}],[\"issuccess\",{\"1\":{\"282\":1,\"340\":1,\"537\":1,\"540\":1,\"693\":1}}],[\"issue\",{\"1\":{\"240\":1,\"306\":1,\"406\":1,\"819\":2}}],[\"issues\",{\"1\":{\"118\":1,\"372\":1,\"573\":1}}],[\"is\",{\"1\":{\"36\":10,\"173\":1,\"176\":9,\"178\":1,\"257\":1,\"262\":11,\"345\":1,\"355\":1,\"365\":1,\"380\":1,\"402\":1,\"406\":2,\"421\":1,\"426\":1,\"480\":1,\"503\":1,\"515\":1,\"518\":3,\"520\":5,\"525\":1,\"540\":2,\"576\":2,\"664\":1,\"665\":2,\"690\":1,\"693\":6,\"694\":4,\"715\":1,\"718\":3,\"720\":1,\"745\":1,\"787\":1,\"790\":5,\"797\":1,\"798\":3,\"799\":1,\"800\":4,\"807\":1,\"828\":12,\"830\":3,\"852\":1}}],[\"ifconfig\",{\"1\":{\"93\":1}}],[\"ifndef\",{\"1\":{\"64\":1}}],[\"ifdef\",{\"1\":{\"64\":1}}],[\"if表达式必须至少有一个关卡的执行结果为true\",{\"1\":{\"38\":1}}],[\"if\",{\"0\":{\"38\":1},\"1\":{\"30\":1,\"36\":1,\"38\":3,\"103\":2,\"139\":1,\"157\":1,\"159\":2,\"242\":2,\"257\":8,\"258\":1,\"262\":16,\"282\":4,\"285\":6,\"287\":7,\"289\":4,\"291\":7,\"313\":7,\"314\":12,\"316\":3,\"317\":17,\"339\":2,\"340\":2,\"342\":2,\"343\":1,\"344\":2,\"345\":8,\"347\":1,\"363\":3,\"364\":4,\"365\":11,\"380\":13,\"381\":4,\"390\":10,\"391\":2,\"392\":5,\"402\":4,\"411\":4,\"413\":1,\"414\":6,\"435\":2,\"480\":7,\"481\":7,\"490\":2,\"491\":12,\"492\":12,\"493\":2,\"503\":1,\"514\":3,\"515\":6,\"516\":2,\"518\":10,\"519\":4,\"520\":13,\"525\":1,\"539\":1,\"540\":10,\"541\":7,\"567\":3,\"568\":3,\"570\":7,\"571\":2,\"572\":8,\"573\":19,\"576\":6,\"642\":5,\"643\":2,\"662\":2,\"663\":8,\"664\":9,\"665\":3,\"690\":17,\"691\":5,\"693\":31,\"694\":25,\"695\":5,\"714\":2,\"715\":17,\"718\":17,\"720\":7,\"721\":2,\"742\":6,\"744\":9,\"745\":2,\"746\":2,\"748\":4,\"749\":3,\"750\":19,\"755\":1,\"786\":9,\"787\":3,\"789\":12,\"790\":10,\"791\":1,\"793\":3,\"795\":7,\"796\":10,\"797\":15,\"798\":15,\"799\":6,\"800\":10,\"807\":1,\"808\":1,\"816\":3,\"817\":11,\"847\":5,\"848\":4,\"850\":7,\"851\":6,\"852\":14}}],[\"ih\",{\"1\":{\"21\":1}}],[\"i\",{\"0\":{\"427\":1},\"1\":{\"16\":1,\"21\":4,\"28\":1,\"32\":6,\"44\":2,\"45\":3,\"155\":2,\"176\":2,\"178\":2,\"179\":1,\"195\":2,\"240\":1,\"242\":3,\"262\":3,\"287\":3,\"289\":2,\"291\":4,\"314\":8,\"365\":5,\"380\":5,\"390\":4,\"392\":3,\"399\":1,\"402\":6,\"406\":1,\"410\":1,\"437\":1,\"444\":1,\"504\":2,\"518\":8,\"519\":6,\"528\":1,\"541\":2,\"572\":4,\"694\":5,\"714\":2,\"715\":6,\"787\":2,\"789\":9,\"797\":6,\"807\":1,\"816\":4,\"817\":10,\"820\":1,\"826\":4,\"829\":5,\"858\":2,\"873\":1}}],[\"inner\",{\"1\":{\"567\":1,\"807\":3,\"816\":2,\"817\":4}}],[\"inputshutdown\",{\"1\":{\"487\":1}}],[\"inputstream\",{\"1\":{\"480\":1}}],[\"inetaddress\",{\"1\":{\"408\":1}}],[\"incgroupacknums\",{\"1\":{\"793\":1}}],[\"incgroupgetlatency\",{\"1\":{\"693\":1}}],[\"incgroupgetsize\",{\"1\":{\"693\":1,\"790\":1}}],[\"incgroupgetnums\",{\"1\":{\"693\":1,\"790\":1}}],[\"incbrokeracknums\",{\"1\":{\"793\":1}}],[\"incbrokergetnums\",{\"1\":{\"693\":1,\"790\":1}}],[\"inctryunlocktimes\",{\"1\":{\"745\":1}}],[\"inctopicputsize\",{\"1\":{\"718\":1}}],[\"inctopicputnums\",{\"1\":{\"718\":1}}],[\"incsendbacknums\",{\"1\":{\"718\":1}}],[\"incqueueputsize\",{\"1\":{\"718\":1}}],[\"incqueueputnums\",{\"1\":{\"718\":1}}],[\"incconsumefailedtps\",{\"1\":{\"715\":2}}],[\"incconsumeoktps\",{\"1\":{\"715\":1}}],[\"incconsumert\",{\"1\":{\"715\":1,\"750\":1}}],[\"incpulltps\",{\"1\":{\"695\":1,\"749\":1}}],[\"incpullrt\",{\"1\":{\"695\":1,\"749\":1}}],[\"incvalue\",{\"1\":{\"693\":2}}],[\"inconsistency\",{\"1\":{\"665\":1}}],[\"incompatible\",{\"1\":{\"515\":1}}],[\"incrementandget\",{\"1\":{\"400\":1,\"572\":3,\"795\":1}}],[\"increase\",{\"1\":{\"381\":1}}],[\"incindexcount\",{\"1\":{\"317\":1}}],[\"inchashslotcount\",{\"1\":{\"317\":1}}],[\"included\",{\"1\":{\"103\":1}}],[\"include\",{\"1\":{\"41\":1,\"61\":3,\"103\":2}}],[\"invisibletime\",{\"1\":{\"771\":1}}],[\"invalid\",{\"1\":{\"365\":1,\"380\":2,\"786\":1,\"796\":1,\"798\":1}}],[\"invalidindex\",{\"1\":{\"317\":5}}],[\"invoked\",{\"1\":{\"576\":2,\"852\":1}}],[\"invokeid\",{\"1\":{\"570\":1}}],[\"invokesync\",{\"1\":{\"514\":1}}],[\"invoke\",{\"1\":{\"4\":1,\"123\":1}}],[\"indexsize\",{\"1\":{\"317\":2}}],[\"indexservice\",{\"0\":{\"309\":1,\"312\":1},\"1\":{\"306\":1,\"313\":1,\"392\":1}}],[\"indexlastupdatephyoffset\",{\"1\":{\"314\":3}}],[\"indexlastupdatetimestamp\",{\"1\":{\"314\":3}}],[\"indexheader\",{\"1\":{\"313\":1,\"317\":22}}],[\"indexnum\",{\"1\":{\"313\":2,\"317\":2}}],[\"indexmsgtimestamp\",{\"1\":{\"309\":2,\"313\":1,\"316\":4}}],[\"indexcount\",{\"1\":{\"307\":1}}],[\"indexkeyhashmethod\",{\"1\":{\"306\":2,\"317\":2}}],[\"index++\",{\"1\":{\"291\":1,\"572\":1,\"787\":1}}],[\"indexfile是消息索引文件\",{\"1\":{\"388\":1}}],[\"indexfile和indexservice\",{\"1\":{\"318\":1}}],[\"indexfilelist\",{\"1\":{\"309\":2,\"313\":5,\"314\":4,\"392\":3}}],[\"indexfile\",{\"0\":{\"295\":1,\"310\":1,\"317\":1,\"388\":1,\"392\":1},\"1\":{\"270\":1,\"276\":1,\"295\":1,\"297\":2,\"300\":1,\"301\":1,\"305\":2,\"306\":3,\"309\":3,\"313\":15,\"314\":12,\"316\":1,\"331\":1,\"336\":1,\"359\":1,\"383\":1,\"384\":2,\"388\":2,\"389\":1,\"391\":1,\"392\":6,\"447\":2,\"600\":1,\"880\":1,\"884\":1}}],[\"indexofack\",{\"1\":{\"796\":4,\"798\":4}}],[\"indexof\",{\"1\":{\"261\":2,\"787\":1}}],[\"index\",{\"0\":{\"293\":1},\"1\":{\"220\":2,\"223\":1,\"275\":2,\"291\":6,\"307\":2,\"314\":2,\"317\":7,\"368\":1,\"572\":3,\"715\":4,\"787\":5,\"796\":1,\"798\":1}}],[\"instead\",{\"1\":{\"406\":1,\"430\":1}}],[\"instancename=\",{\"1\":{\"690\":1}}],[\"instancename\",{\"1\":{\"556\":1,\"567\":1}}],[\"instanceof\",{\"1\":{\"414\":2,\"573\":2,\"642\":2,\"851\":1,\"852\":1}}],[\"instance\",{\"1\":{\"402\":2,\"807\":1}}],[\"instances\",{\"1\":{\"116\":3}}],[\"instantiationexception\",{\"1\":{\"262\":1}}],[\"installation\",{\"1\":{\"177\":1,\"480\":1}}],[\"installed\",{\"1\":{\"176\":14,\"178\":2}}],[\"install\",{\"1\":{\"174\":1,\"176\":2,\"177\":1,\"178\":1}}],[\"insert\",{\"1\":{\"98\":4}}],[\"info=\",{\"1\":{\"380\":1,\"381\":4}}],[\"info\",{\"1\":{\"21\":1,\"81\":1,\"103\":3,\"242\":1,\"285\":1,\"291\":5,\"344\":3,\"381\":6,\"390\":1,\"481\":2,\"490\":1,\"491\":1,\"492\":7,\"493\":1,\"516\":2,\"518\":1,\"519\":5,\"567\":1,\"568\":1,\"570\":2,\"642\":2,\"643\":1,\"660\":2,\"663\":2,\"664\":4,\"665\":3,\"688\":2,\"690\":4,\"693\":5,\"715\":1,\"720\":2,\"744\":3,\"746\":1,\"748\":3,\"795\":1,\"797\":1,\"798\":6,\"799\":1,\"800\":2,\"817\":2}}],[\"information\",{\"1\":{\"21\":16,\"176\":1}}],[\"in\",{\"1\":{\"21\":12,\"35\":1,\"41\":5,\"42\":3,\"147\":2,\"157\":1,\"240\":10,\"243\":4,\"247\":1,\"251\":1,\"256\":4,\"261\":1,\"339\":1,\"390\":1,\"406\":6,\"408\":1,\"424\":1,\"426\":1,\"433\":1,\"480\":4,\"491\":2,\"492\":1,\"493\":1,\"518\":2,\"573\":1,\"576\":1,\"690\":1,\"693\":1,\"694\":2,\"695\":1,\"748\":1,\"767\":1,\"787\":4,\"789\":1,\"790\":3,\"797\":1,\"828\":2,\"830\":2,\"851\":2,\"852\":3}}],[\"initresult\",{\"1\":{\"480\":2}}],[\"initial\",{\"1\":{\"790\":1}}],[\"initialacl\",{\"1\":{\"516\":1}}],[\"initialize\",{\"1\":{\"467\":1,\"480\":1,\"481\":2,\"528\":1,\"721\":1}}],[\"initialization\",{\"1\":{\"257\":2}}],[\"initialcredit\",{\"1\":{\"151\":1,\"157\":2,\"159\":1}}],[\"init\",{\"1\":{\"21\":2,\"74\":3,\"102\":1,\"400\":1,\"539\":1,\"626\":1,\"694\":2,\"750\":1}}],[\"inline\",{\"1\":{\"11\":1}}],[\"intvalue\",{\"1\":{\"847\":1}}],[\"integercanonicalname2\",{\"1\":{\"262\":1}}],[\"integercanonicalname1\",{\"1\":{\"262\":1}}],[\"integer\",{\"1\":{\"262\":13,\"300\":1,\"317\":2,\"343\":1,\"364\":1,\"411\":1,\"480\":1,\"573\":2,\"715\":1,\"718\":1,\"761\":1,\"793\":1,\"819\":2}}],[\"interrupted\",{\"1\":{\"435\":1}}],[\"interruptedexception\",{\"1\":{\"146\":1,\"381\":1,\"390\":1,\"391\":1,\"435\":1,\"490\":1,\"541\":1,\"570\":2,\"573\":1,\"688\":2,\"691\":2,\"692\":1,\"717\":2,\"720\":1,\"742\":1,\"817\":2}}],[\"intervalforcibly\",{\"1\":{\"386\":1,\"390\":3}}],[\"interval\",{\"1\":{\"381\":1,\"435\":2,\"519\":2,\"750\":2}}],[\"interface\",{\"1\":{\"21\":1}}],[\"interpreter\",{\"1\":{\"21\":1}}],[\"internalloggerfactory\",{\"1\":{\"480\":2}}],[\"internallogger\",{\"1\":{\"480\":1}}],[\"internals\",{\"1\":{\"161\":1}}],[\"internal\",{\"1\":{\"21\":1,\"117\":1,\"528\":1}}],[\"introduced\",{\"1\":{\"157\":1,\"240\":1,\"256\":1}}],[\"introduce\",{\"1\":{\"157\":1}}],[\"int\",{\"1\":{\"2\":1,\"149\":1,\"257\":9,\"258\":3,\"277\":2,\"282\":2,\"284\":1,\"285\":1,\"287\":3,\"289\":4,\"291\":4,\"309\":1,\"310\":1,\"314\":5,\"317\":16,\"335\":1,\"339\":1,\"342\":1,\"343\":1,\"345\":1,\"348\":1,\"363\":2,\"365\":2,\"380\":5,\"390\":8,\"391\":2,\"392\":2,\"400\":1,\"402\":5,\"414\":13,\"420\":4,\"490\":2,\"504\":1,\"518\":2,\"519\":3,\"537\":4,\"540\":2,\"541\":4,\"570\":2,\"572\":7,\"573\":1,\"576\":1,\"665\":5,\"690\":1,\"691\":3,\"693\":4,\"694\":6,\"714\":3,\"715\":5,\"717\":2,\"718\":4,\"721\":2,\"750\":1,\"787\":3,\"789\":12,\"790\":3,\"791\":3,\"793\":1,\"795\":1,\"796\":2,\"797\":2,\"798\":2,\"800\":1,\"816\":1,\"817\":8,\"819\":4,\"826\":1,\"829\":1,\"843\":3}}],[\"iot\",{\"1\":{\"804\":1,\"810\":1}}],[\"ioexception\",{\"1\":{\"317\":2,\"400\":1,\"480\":1}}],[\"io\",{\"0\":{\"16\":1,\"108\":1,\"395\":1},\"1\":{\"1\":1,\"16\":3,\"18\":1,\"28\":2,\"74\":1,\"80\":1,\"85\":1,\"98\":1,\"108\":1,\"109\":2,\"113\":1,\"117\":2,\"125\":1,\"137\":1,\"142\":1,\"162\":1,\"174\":1,\"180\":1,\"213\":1,\"225\":1,\"239\":1,\"248\":2,\"255\":1,\"264\":1,\"295\":1,\"319\":1,\"350\":1,\"369\":1,\"382\":1,\"393\":2,\"394\":2,\"400\":1,\"405\":1,\"437\":1,\"438\":1,\"459\":1,\"495\":1,\"522\":1,\"524\":1,\"528\":1,\"532\":2,\"543\":1,\"578\":1,\"588\":1,\"599\":5,\"605\":1,\"626\":1,\"644\":1,\"666\":1,\"696\":1,\"722\":1,\"751\":1,\"763\":1,\"802\":1,\"819\":1,\"821\":1,\"854\":1,\"855\":1,\"859\":1,\"869\":1}}],[\"背景\",{\"0\":{\"2\":1,\"126\":1,\"138\":1,\"181\":1,\"214\":1,\"383\":1,\"394\":1,\"439\":1,\"496\":1,\"523\":1,\"544\":1,\"579\":1,\"589\":1,\"606\":1,\"627\":1,\"645\":1,\"667\":1,\"697\":1,\"723\":1,\"764\":1,\"803\":1,\"822\":1,\"856\":1,\"860\":1,\"870\":1}}],[\"hub\",{\"1\":{\"590\":1,\"591\":1,\"592\":1,\"599\":2}}],[\"hurting\",{\"1\":{\"157\":1}}],[\"host\",{\"1\":{\"597\":1,\"598\":1,\"717\":1,\"790\":1,\"799\":1}}],[\"hostconsumer\",{\"1\":{\"541\":1}}],[\"hostproducer\",{\"1\":{\"541\":1}}],[\"hostname\",{\"1\":{\"190\":1}}],[\"hook\",{\"1\":{\"539\":1}}],[\"hours\",{\"1\":{\"390\":1,\"592\":1}}],[\"house\",{\"1\":{\"103\":2}}],[\"hold\",{\"1\":{\"317\":1,\"334\":1,\"343\":1,\"344\":1}}],[\"hof\",{\"1\":{\"157\":1}}],[\"home\",{\"1\":{\"102\":1,\"480\":1,\"503\":1,\"595\":5,\"597\":1,\"600\":6,\"810\":1}}],[\"however\",{\"1\":{\"176\":4,\"178\":1}}],[\"how\",{\"1\":{\"21\":3,\"111\":2,\"179\":1}}],[\"hrl\",{\"1\":{\"41\":1,\"61\":2,\"103\":1}}],[\"hrl`的文件中\",{\"1\":{\"41\":1}}],[\"h|evens\",{\"1\":{\"39\":1}}],[\"h|odds\",{\"1\":{\"39\":1}}],[\"h|filter\",{\"1\":{\"37\":1}}],[\"h|t\",{\"1\":{\"27\":1,\"37\":1,\"39\":1}}],[\"here\",{\"1\":{\"157\":2,\"720\":1,\"798\":1}}],[\"heading\",{\"1\":{\"116\":1}}],[\"headersize\",{\"1\":{\"414\":5}}],[\"headerencode\",{\"1\":{\"413\":1}}],[\"header\",{\"0\":{\"259\":1,\"409\":1},\"1\":{\"61\":1,\"262\":4,\"307\":4,\"317\":4,\"406\":1,\"409\":1,\"410\":5,\"413\":1,\"414\":3,\"509\":1,\"515\":9}}],[\"hello\",{\"1\":{\"27\":1,\"28\":3,\"35\":2,\"50\":2,\"74\":10,\"504\":1,\"526\":1,\"807\":1,\"826\":1,\"829\":1,\"873\":1}}],[\"help\",{\"1\":{\"21\":14}}],[\"height\",{\"1\":{\"26\":1,\"30\":4}}],[\"hcb\",{\"1\":{\"21\":3}}],[\"high\",{\"1\":{\"393\":1,\"819\":3,\"820\":1}}],[\"hicode\",{\"1\":{\"115\":1}}],[\"history\",{\"1\":{\"21\":2}}],[\"hint\",{\"1\":{\"11\":1}}],[\"h\",{\"0\":{\"426\":1},\"1\":{\"21\":7,\"33\":4,\"37\":1,\"39\":1,\"80\":2,\"262\":3,\"406\":1,\"410\":1,\"442\":1}}],[\"hanged\",{\"1\":{\"745\":1}}],[\"hang\",{\"1\":{\"615\":1,\"651\":1,\"769\":1,\"770\":1}}],[\"handling设置为autoheal\",{\"1\":{\"192\":1}}],[\"handling处理策略的影响\",{\"1\":{\"192\":1}}],[\"handler\",{\"1\":{\"820\":1}}],[\"handleretryanddlq\",{\"1\":{\"576\":1}}],[\"handleresult\",{\"1\":{\"381\":1}}],[\"handleputmessageresultfuture\",{\"1\":{\"576\":1}}],[\"handleputresulttask\",{\"1\":{\"378\":2,\"381\":3}}],[\"handleexecutorservice\",{\"1\":{\"378\":1,\"381\":1}}],[\"handle\",{\"1\":{\"157\":2,\"159\":2,\"850\":1}}],[\"handled\",{\"1\":{\"21\":1}}],[\"haclient\",{\"1\":{\"249\":2}}],[\"hasexception\",{\"1\":{\"715\":3,\"750\":3}}],[\"haserver\",{\"1\":{\"491\":1}}],[\"haserveraddr\",{\"1\":{\"487\":2,\"490\":2,\"491\":3}}],[\"haservice\",{\"1\":{\"240\":1,\"243\":1}}],[\"hasconsumemessagehook\",{\"1\":{\"693\":1,\"718\":1}}],[\"hascommitoffsetflag\",{\"1\":{\"693\":3}}],[\"hasclassfilterflag\",{\"1\":{\"691\":1}}],[\"hassubscriptionflag\",{\"1\":{\"693\":3}}],[\"hassuspendflag\",{\"1\":{\"339\":1,\"693\":4}}],[\"hassendmessagehook\",{\"1\":{\"573\":2}}],[\"hasnext\",{\"1\":{\"491\":1,\"492\":6,\"664\":1,\"744\":1,\"797\":1,\"851\":1}}],[\"hasnotified\",{\"1\":{\"246\":2,\"435\":3}}],[\"hasoption\",{\"1\":{\"480\":2}}],[\"has\",{\"1\":{\"240\":2,\"242\":2,\"251\":1,\"344\":1,\"519\":1,\"567\":1,\"568\":1,\"573\":1,\"642\":1,\"643\":1,\"694\":1,\"851\":2}}],[\"hashto\",{\"1\":{\"843\":2,\"851\":1}}],[\"hashook\",{\"1\":{\"715\":3,\"750\":3}}],[\"hashset<>\",{\"1\":{\"808\":1}}],[\"hashset<messagequeue>\",{\"1\":{\"663\":1,\"720\":2,\"742\":2,\"786\":1}}],[\"hashset<string>\",{\"1\":{\"491\":1}}],[\"hashslotsize\",{\"1\":{\"317\":6}}],[\"hashslotnum\",{\"1\":{\"313\":2,\"317\":5}}],[\"hashslotcount\",{\"1\":{\"307\":1}}],[\"hash值计算\",{\"1\":{\"317\":1}}],[\"hash槽中存储的索引逻辑下标\",{\"1\":{\"317\":1}}],[\"hash槽的绝对位置\",{\"1\":{\"317\":1}}],[\"hash槽的值\",{\"1\":{\"317\":1}}],[\"hash槽指向最新创建的索引的逻辑下标\",{\"1\":{\"317\":1}}],[\"hash槽对应的链表头部插入索引\",{\"1\":{\"317\":1}}],[\"hash槽对应的最新的索引的逻辑下标\",{\"1\":{\"317\":1}}],[\"hash槽绝对位置\",{\"1\":{\"317\":1}}],[\"hash槽\",{\"1\":{\"307\":1}}],[\"hash冲突时\",{\"1\":{\"300\":1}}],[\"hashmap<>\",{\"1\":{\"517\":4,\"518\":5,\"519\":1}}],[\"hashmap<long\",{\"1\":{\"491\":1}}],[\"hashmap<string\",{\"1\":{\"198\":1,\"262\":1,\"411\":1,\"414\":1,\"469\":5,\"470\":1,\"484\":1,\"485\":1,\"486\":1,\"487\":1,\"488\":1,\"541\":1,\"715\":1,\"750\":1,\"798\":1,\"800\":1}}],[\"hashmap\",{\"1\":{\"297\":1,\"300\":2,\"306\":1,\"447\":1,\"464\":2,\"469\":1,\"585\":1,\"798\":2}}],[\"hashcode\",{\"1\":{\"275\":1,\"287\":1,\"317\":1,\"417\":1}}],[\"hash\",{\"1\":{\"116\":1,\"269\":1,\"300\":1,\"306\":4,\"307\":7,\"317\":1,\"834\":4,\"838\":1,\"839\":4,\"842\":2,\"843\":3,\"851\":1}}],[\"halistenport=10932\",{\"1\":{\"595\":1}}],[\"half\",{\"1\":{\"240\":1,\"242\":2,\"365\":1,\"380\":1,\"484\":1,\"573\":1}}],[\"halt\",{\"1\":{\"21\":1}}],[\"have\",{\"1\":{\"240\":1,\"406\":1,\"491\":1}}],[\"ha\",{\"1\":{\"185\":6,\"186\":3,\"187\":5,\"190\":3,\"191\":1,\"192\":4,\"198\":2,\"240\":1,\"247\":1,\"487\":1,\"491\":1}}],[\"harness\",{\"1\":{\"2\":1,\"15\":2}}],[\"ht\",{\"1\":{\"21\":3}}],[\"html\",{\"1\":{\"1\":1,\"16\":1,\"18\":1,\"113\":1,\"115\":1,\"122\":2,\"125\":1,\"137\":1,\"142\":1,\"162\":1,\"174\":1,\"175\":1,\"180\":1,\"187\":1,\"213\":1,\"225\":2,\"239\":1,\"264\":1,\"295\":1,\"319\":1,\"350\":1,\"369\":1,\"382\":1,\"393\":1,\"405\":1,\"438\":1,\"459\":1,\"495\":1,\"522\":1,\"543\":1,\"578\":1,\"588\":1,\"605\":1,\"626\":1,\"644\":1,\"666\":1,\"696\":1,\"722\":1,\"751\":1,\"763\":1,\"802\":1,\"819\":1,\"821\":1,\"854\":1,\"855\":1,\"859\":1,\"869\":1}}],[\"https\",{\"1\":{\"114\":1,\"115\":1,\"116\":1,\"118\":1,\"122\":3,\"124\":2,\"136\":1,\"175\":2,\"177\":1,\"178\":2,\"179\":1,\"187\":1,\"225\":1,\"276\":1,\"326\":1,\"332\":1,\"372\":1,\"545\":1,\"573\":1,\"590\":1,\"804\":1,\"817\":1,\"819\":1}}],[\"http\",{\"0\":{\"187\":1},\"1\":{\"1\":1,\"16\":1,\"18\":1,\"113\":1,\"120\":1,\"121\":1,\"123\":1,\"125\":1,\"137\":1,\"142\":1,\"162\":1,\"174\":1,\"180\":1,\"213\":1,\"225\":1,\"239\":1,\"264\":1,\"295\":1,\"319\":1,\"350\":1,\"369\":1,\"382\":1,\"393\":1,\"405\":1,\"416\":1,\"417\":1,\"438\":1,\"459\":1,\"495\":1,\"522\":1,\"543\":1,\"578\":1,\"588\":1,\"605\":1,\"626\":1,\"644\":1,\"666\":1,\"696\":1,\"722\":1,\"751\":1,\"763\":1,\"802\":1,\"819\":1,\"821\":1,\"854\":1,\"855\":1,\"859\":1,\"869\":1}}],[\"hscarb\",{\"1\":{\"1\":1,\"16\":1,\"18\":1,\"113\":1,\"125\":1,\"137\":1,\"142\":1,\"162\":1,\"174\":1,\"180\":1,\"213\":1,\"225\":1,\"239\":1,\"264\":1,\"276\":1,\"295\":1,\"319\":1,\"326\":1,\"332\":1,\"350\":1,\"369\":1,\"382\":1,\"393\":1,\"405\":1,\"438\":1,\"459\":1,\"495\":1,\"522\":1,\"543\":1,\"578\":1,\"588\":1,\"605\":1,\"626\":1,\"644\":1,\"666\":1,\"696\":1,\"722\":1,\"751\":1,\"763\":1,\"802\":1,\"819\":1,\"821\":1,\"854\":1,\"855\":1,\"859\":1,\"869\":1}}],[\"jj\",{\"1\":{\"841\":3}}],[\"jit\",{\"1\":{\"424\":1}}],[\"jna\",{\"1\":{\"402\":2}}],[\"j++\",{\"1\":{\"402\":1,\"518\":1,\"800\":1}}],[\"jdk\",{\"1\":{\"306\":1}}],[\"jdk中\",{\"1\":{\"297\":1}}],[\"jdk9\",{\"1\":{\"8\":2}}],[\"j\",{\"0\":{\"430\":1},\"1\":{\"262\":3,\"402\":2,\"406\":1,\"410\":1,\"433\":2,\"518\":3,\"800\":4}}],[\"jrebel\",{\"1\":{\"121\":2,\"123\":2}}],[\"jsonarray\",{\"1\":{\"518\":3}}],[\"jsonobject\",{\"1\":{\"518\":2}}],[\"json\",{\"1\":{\"116\":1,\"410\":1,\"413\":1,\"793\":1,\"798\":2}}],[\"jodie\",{\"1\":{\"527\":1,\"768\":1}}],[\"joranconfigurator\",{\"1\":{\"480\":2}}],[\"joranexception\",{\"1\":{\"480\":1}}],[\"job\",{\"1\":{\"123\":2}}],[\"join\",{\"1\":{\"103\":1,\"816\":1}}],[\"joe\",{\"1\":{\"26\":3,\"41\":5,\"102\":3,\"103\":1}}],[\"jeo\",{\"1\":{\"54\":1}}],[\"jul\",{\"1\":{\"594\":13}}],[\"just\",{\"1\":{\"557\":1,\"567\":4,\"568\":1,\"642\":2,\"643\":1,\"797\":2,\"817\":1}}],[\"juejin\",{\"1\":{\"116\":1,\"124\":1}}],[\"juc学习笔记\",{\"1\":{\"15\":1}}],[\"junit\",{\"1\":{\"9\":2}}],[\"jane\",{\"1\":{\"103\":1}}],[\"jar\",{\"1\":{\"7\":2,\"10\":3}}],[\"javacc\",{\"1\":{\"841\":3}}],[\"java\",{\"0\":{\"1\":1,\"16\":1,\"17\":1},\"1\":{\"1\":1,\"2\":3,\"7\":1,\"10\":1,\"15\":4,\"16\":3,\"17\":1,\"122\":2,\"146\":1,\"257\":2,\"258\":1,\"262\":1,\"360\":1,\"400\":2,\"410\":1,\"411\":1,\"413\":1,\"414\":3,\"432\":1,\"437\":1,\"490\":1,\"514\":3,\"517\":1,\"519\":2,\"540\":1,\"545\":1,\"567\":1,\"570\":1,\"571\":1,\"572\":2,\"573\":1,\"576\":1,\"597\":1,\"599\":10,\"600\":23,\"643\":1,\"665\":1,\"695\":1,\"714\":1,\"715\":2,\"717\":2,\"718\":1,\"720\":2,\"744\":1,\"745\":1,\"746\":1,\"750\":1,\"768\":1,\"816\":1,\"819\":2,\"841\":3,\"847\":1,\"848\":1,\"850\":2,\"851\":1,\"852\":1}}],[\"jvm\",{\"1\":{\"2\":2,\"3\":2,\"467\":1,\"480\":3}}],[\"jmh<\",{\"1\":{\"8\":2}}],[\"jmh\",{\"0\":{\"1\":1,\"3\":1,\"4\":1},\"1\":{\"1\":1,\"2\":3,\"3\":1,\"4\":2,\"6\":2,\"7\":1,\"8\":1,\"11\":1,\"12\":1,\"15\":6,\"17\":1}}],[\"md\",{\"1\":{\"545\":1}}],[\"mlock\",{\"1\":{\"402\":5}}],[\"mfslength\",{\"1\":{\"390\":3}}],[\"mfs\",{\"1\":{\"390\":5}}],[\"mfa\",{\"1\":{\"111\":1}}],[\"mpr\",{\"1\":{\"342\":6,\"345\":4}}],[\"mb\",{\"1\":{\"176\":1}}],[\"moment\",{\"1\":{\"750\":3}}],[\"moved\",{\"1\":{\"484\":1,\"693\":7}}],[\"move\",{\"1\":{\"406\":1,\"433\":1,\"798\":1}}],[\"most\",{\"1\":{\"240\":1,\"576\":1}}],[\"morecredit\",{\"1\":{\"159\":4}}],[\"morecreditafter\",{\"1\":{\"151\":1,\"157\":1,\"159\":4}}],[\"months\",{\"1\":{\"599\":2}}],[\"monotonic\",{\"1\":{\"158\":1}}],[\"monkey\",{\"1\":{\"126\":1}}],[\"modifier\",{\"1\":{\"262\":1}}],[\"modified\",{\"1\":{\"21\":2}}],[\"modulename\",{\"1\":{\"53\":1}}],[\"modules\",{\"1\":{\"21\":4}}],[\"module\",{\"0\":{\"30\":1},\"1\":{\"21\":22,\"30\":2,\"53\":1,\"58\":1,\"63\":1,\"80\":1,\"85\":2,\"98\":1,\"103\":1,\"111\":1}}],[\"mod\",{\"1\":{\"21\":11,\"50\":1,\"53\":1,\"60\":2,\"79\":2}}],[\"mode模式需要用到的参数\",{\"1\":{\"185\":1}}],[\"model\",{\"1\":{\"130\":5}}],[\"mode\",{\"1\":{\"9\":1,\"11\":4,\"98\":3,\"185\":4,\"186\":2,\"187\":2,\"190\":1,\"191\":1,\"240\":1,\"243\":1,\"256\":1,\"261\":1,\"767\":3,\"787\":1}}],[\"must\",{\"1\":{\"103\":1,\"491\":1,\"787\":1,\"807\":1}}],[\"multiqueueoffset\",{\"1\":{\"817\":4}}],[\"multidispatchqueue\",{\"1\":{\"816\":3,\"817\":4}}],[\"multidispatchlmqqueue\",{\"1\":{\"814\":1,\"817\":2}}],[\"multidispatch\",{\"1\":{\"814\":2}}],[\"multi\",{\"1\":{\"807\":3,\"816\":4,\"817\":6}}],[\"multiple\",{\"1\":{\"518\":2,\"521\":1,\"807\":1}}],[\"multicast\",{\"0\":{\"206\":1}}],[\"mult\",{\"1\":{\"31\":2}}],[\"mnesia的速度极快\",{\"1\":{\"101\":1}}],[\"mnesia是一种用erlang编写的数据库\",{\"1\":{\"101\":1}}],[\"mnesia\",{\"0\":{\"101\":1},\"1\":{\"102\":6,\"103\":37,\"105\":4,\"206\":1}}],[\"my\",{\"1\":{\"46\":1,\"198\":1}}],[\"mybenchmark\",{\"1\":{\"9\":2,\"11\":6}}],[\"mmqq\",{\"1\":{\"746\":2}}],[\"mmap\",{\"0\":{\"400\":1,\"430\":1},\"1\":{\"248\":2,\"400\":4,\"402\":1,\"406\":1,\"432\":2,\"437\":2}}],[\"mm\",{\"1\":{\"21\":1}}],[\"m\",{\"1\":{\"21\":6,\"24\":2,\"50\":1,\"240\":1,\"243\":1,\"256\":1,\"262\":2,\"767\":2,\"768\":1}}],[\"means\",{\"1\":{\"786\":2}}],[\"measurement\",{\"1\":{\"4\":2,\"9\":1,\"11\":1,\"130\":1}}],[\"mergeandrevive\",{\"0\":{\"799\":1},\"1\":{\"783\":2,\"799\":1}}],[\"me\",{\"1\":{\"365\":2,\"693\":2,\"817\":2}}],[\"metainf\",{\"1\":{\"510\":1,\"516\":1}}],[\"metrics\",{\"1\":{\"130\":2}}],[\"methods\",{\"1\":{\"406\":1}}],[\"method\",{\"1\":{\"123\":1,\"157\":7,\"240\":1,\"251\":1,\"406\":1,\"426\":1,\"599\":1,\"688\":1}}],[\"messageevaluationcontext\",{\"1\":{\"851\":2,\"852\":2}}],[\"messageextbatch\",{\"1\":{\"816\":4}}],[\"messageextbrokerinner\",{\"1\":{\"257\":3,\"258\":1,\"363\":1,\"365\":1,\"380\":2,\"381\":1,\"555\":1,\"576\":2,\"585\":1,\"718\":3,\"793\":2,\"800\":2,\"816\":1}}],[\"messageexts\",{\"1\":{\"798\":5}}],[\"messageext\",{\"0\":{\"408\":1},\"1\":{\"258\":1,\"365\":1,\"380\":1,\"381\":1,\"406\":1,\"408\":2,\"540\":1,\"555\":1,\"715\":3,\"717\":2,\"718\":1,\"798\":12,\"800\":17,\"808\":3,\"848\":1}}],[\"messagenum\",{\"1\":{\"816\":3}}],[\"messagerequestmode\",{\"1\":{\"768\":1,\"786\":1}}],[\"messagemodel\",{\"1\":{\"642\":1,\"663\":1,\"690\":1,\"693\":1,\"745\":2,\"750\":6,\"786\":4}}],[\"messagemodel=\",{\"1\":{\"642\":1}}],[\"messagelistener\",{\"1\":{\"639\":2,\"707\":1,\"708\":1,\"715\":1,\"750\":1}}],[\"messagelistenerorderly\",{\"1\":{\"622\":1,\"642\":2}}],[\"messagelistenerconcurrently\",{\"1\":{\"505\":1,\"527\":1,\"622\":1,\"642\":2,\"715\":1,\"768\":1}}],[\"messagebatch\",{\"1\":{\"564\":2,\"573\":3}}],[\"messagetotalsize\",{\"1\":{\"585\":1}}],[\"messagetype\",{\"1\":{\"537\":1,\"573\":2}}],[\"messagetimeup\",{\"1\":{\"365\":2,\"380\":2,\"381\":1}}],[\"messagecloned\",{\"1\":{\"573\":4}}],[\"messageclientidsetter\",{\"1\":{\"537\":1,\"573\":1}}],[\"messageconst\",{\"1\":{\"314\":1,\"363\":2,\"540\":2,\"573\":5,\"576\":5,\"717\":2,\"718\":3,\"793\":1,\"800\":2,\"816\":2,\"817\":4}}],[\"messageaccessor\",{\"1\":{\"363\":2,\"573\":6,\"576\":2,\"715\":1,\"717\":7,\"718\":4,\"800\":1,\"816\":1}}],[\"messagearrivinglistener\",{\"1\":{\"282\":2,\"347\":2,\"348\":1}}],[\"messagedelaylevel\",{\"1\":{\"353\":1,\"761\":1}}],[\"messagedecoder\",{\"1\":{\"240\":1,\"257\":4,\"363\":1,\"573\":1,\"576\":3,\"718\":2,\"793\":1,\"800\":1,\"848\":1,\"852\":1}}],[\"messageindexsafe\",{\"1\":{\"309\":1}}],[\"messageid\",{\"0\":{\"258\":1},\"1\":{\"256\":1,\"258\":3}}],[\"messagekey\",{\"1\":{\"306\":1}}],[\"messagefilter\",{\"1\":{\"277\":2,\"287\":5,\"339\":1,\"693\":6,\"694\":7,\"789\":4,\"790\":4,\"838\":1}}],[\"messagequeues\",{\"1\":{\"786\":1,\"787\":1}}],[\"messagequeuelock\",{\"1\":{\"750\":1}}],[\"messagequeuelistener\",{\"1\":{\"637\":1}}],[\"messagequeuelist\",{\"1\":{\"572\":3}}],[\"messagequeue=\",{\"1\":{\"715\":1}}],[\"messagequeuechanged\",{\"0\":{\"665\":1},\"1\":{\"657\":1,\"663\":3,\"665\":1}}],[\"messagequeuechange\",{\"1\":{\"654\":1}}],[\"messagequeuemap\",{\"1\":{\"585\":1}}],[\"messagequeue\",{\"1\":{\"242\":1,\"561\":1,\"570\":2,\"572\":7,\"573\":3,\"637\":1,\"663\":2,\"664\":7,\"665\":1,\"688\":1,\"689\":3,\"691\":1,\"693\":2,\"714\":5,\"715\":7,\"720\":3,\"742\":2,\"744\":7,\"745\":1,\"746\":2,\"750\":16,\"787\":5,\"808\":2,\"848\":1}}],[\"messageproperties2string\",{\"1\":{\"240\":1,\"261\":2,\"363\":1,\"573\":1,\"576\":2,\"718\":2,\"793\":1,\"800\":1}}],[\"message\",{\"0\":{\"802\":1},\"1\":{\"79\":2,\"147\":3,\"152\":1,\"154\":2,\"223\":3,\"240\":4,\"256\":1,\"257\":12,\"277\":1,\"286\":1,\"287\":3,\"293\":2,\"298\":2,\"300\":2,\"302\":1,\"307\":2,\"309\":1,\"339\":1,\"350\":1,\"355\":3,\"365\":1,\"369\":1,\"381\":4,\"388\":1,\"406\":2,\"425\":1,\"426\":1,\"438\":1,\"504\":2,\"526\":2,\"528\":1,\"541\":2,\"543\":1,\"555\":4,\"564\":1,\"570\":1,\"572\":1,\"573\":4,\"575\":3,\"576\":2,\"666\":1,\"688\":1,\"690\":5,\"691\":1,\"692\":1,\"693\":8,\"694\":10,\"695\":2,\"696\":1,\"715\":2,\"717\":3,\"718\":3,\"746\":1,\"748\":3,\"750\":6,\"772\":1,\"786\":1,\"789\":1,\"790\":2,\"793\":1,\"802\":1,\"804\":1,\"807\":8,\"816\":2,\"817\":2,\"818\":1,\"826\":2,\"829\":2,\"852\":4,\"873\":8,\"880\":1,\"884\":1}}],[\"messagestore\",{\"1\":{\"783\":1,\"816\":2,\"817\":10,\"838\":1}}],[\"messagestoreconfig\",{\"1\":{\"309\":1,\"389\":1,\"694\":2,\"854\":1}}],[\"messageselector\",{\"1\":{\"637\":2,\"830\":1}}],[\"messagesysflag\",{\"1\":{\"258\":1,\"284\":5,\"314\":5,\"363\":3,\"573\":2}}],[\"messages\",{\"1\":{\"21\":1,\"157\":1,\"287\":2,\"505\":1,\"527\":1,\"540\":1,\"564\":1,\"665\":1,\"690\":1,\"694\":3,\"768\":1,\"790\":1,\"883\":3}}],[\"member\",{\"1\":{\"31\":1}}],[\"memorytopicenable\",{\"1\":{\"587\":1}}],[\"memorymessagestore\",{\"0\":{\"585\":1},\"1\":{\"581\":2,\"585\":1}}],[\"memory\",{\"0\":{\"578\":1},\"1\":{\"16\":1,\"21\":4,\"400\":1,\"578\":1,\"586\":1,\"690\":1,\"694\":3,\"884\":1}}],[\"msglistfilteragain\",{\"1\":{\"848\":3}}],[\"msglist\",{\"1\":{\"848\":4}}],[\"msglen\",{\"1\":{\"257\":10,\"258\":1}}],[\"msgoffset\",{\"1\":{\"800\":3}}],[\"msgoffsetinfo\",{\"1\":{\"789\":5,\"790\":3}}],[\"msgqueueoffset\",{\"1\":{\"791\":2}}],[\"msgbuffer\",{\"1\":{\"838\":2,\"852\":4}}],[\"msgbackfailed\",{\"1\":{\"715\":5}}],[\"msgbody\",{\"1\":{\"573\":1}}],[\"msgbodycompressed\",{\"1\":{\"573\":3}}],[\"msgthis\",{\"1\":{\"714\":4}}],[\"msgtype\",{\"1\":{\"537\":1}}],[\"msgfoundlist为空的情况\",{\"1\":{\"695\":1,\"749\":1}}],[\"msg=\",{\"1\":{\"365\":1,\"380\":1}}],[\"msgext=\",{\"1\":{\"365\":1}}],[\"msgext里面的内容不完整\",{\"1\":{\"365\":1}}],[\"msgext\",{\"1\":{\"365\":6,\"380\":5,\"381\":3,\"718\":25}}],[\"msginner\",{\"1\":{\"257\":36,\"258\":4,\"365\":5,\"380\":8,\"381\":2,\"576\":21,\"718\":23,\"793\":14,\"800\":19}}],[\"msgid与offsetmsgid释疑\",{\"1\":{\"419\":1}}],[\"msgid懒加载\",{\"1\":{\"258\":1}}],[\"msgidbuffer\",{\"1\":{\"258\":5}}],[\"msgidlen\",{\"1\":{\"258\":3}}],[\"msgidsupplier\",{\"1\":{\"258\":4}}],[\"msgid\",{\"1\":{\"240\":2,\"256\":2,\"258\":3,\"309\":1,\"314\":2,\"365\":1,\"380\":2,\"537\":1}}],[\"msgs=\",{\"1\":{\"715\":1}}],[\"msgstoretime\",{\"1\":{\"345\":2,\"348\":2,\"365\":2,\"380\":2}}],[\"msgstoreitemmemory\",{\"1\":{\"257\":21}}],[\"msgs\",{\"1\":{\"220\":1,\"505\":2,\"527\":2,\"714\":9,\"715\":11,\"750\":10,\"768\":2}}],[\"msg\",{\"1\":{\"79\":2,\"154\":1,\"159\":5,\"160\":2,\"220\":3,\"257\":5,\"314\":7,\"355\":6,\"363\":16,\"365\":2,\"380\":2,\"504\":2,\"525\":1,\"526\":2,\"539\":1,\"540\":12,\"570\":8,\"573\":33,\"575\":1,\"576\":3,\"694\":1,\"695\":2,\"715\":9,\"717\":21,\"791\":1,\"793\":1,\"798\":1,\"800\":5,\"807\":2,\"816\":7,\"826\":3,\"829\":3,\"848\":4}}],[\"ms\",{\"1\":{\"11\":24,\"344\":1,\"851\":1}}],[\"mvn\",{\"1\":{\"7\":1,\"10\":1}}],[\"mib\",{\"1\":{\"690\":3}}],[\"miss\",{\"1\":{\"665\":1}}],[\"misc\",{\"1\":{\"32\":2,\"106\":2}}],[\"mixall\",{\"1\":{\"480\":8,\"491\":3,\"540\":1,\"567\":1,\"573\":2,\"662\":1,\"663\":1,\"693\":3,\"694\":1,\"695\":1,\"715\":1,\"717\":1,\"718\":2,\"720\":2,\"746\":1,\"750\":1,\"786\":1,\"800\":1,\"816\":3,\"817\":3}}],[\"middle\",{\"1\":{\"390\":1}}],[\"middleware\",{\"1\":{\"0\":1,\"15\":1,\"16\":1,\"112\":1,\"124\":1,\"136\":1,\"140\":1,\"161\":1,\"173\":1,\"179\":1,\"212\":1,\"224\":1,\"237\":1,\"263\":1,\"294\":1,\"318\":1,\"349\":1,\"368\":1,\"381\":1,\"392\":1,\"404\":1,\"437\":1,\"458\":1,\"494\":1,\"521\":1,\"542\":1,\"577\":1,\"587\":1,\"604\":1,\"625\":1,\"643\":1,\"665\":1,\"695\":1,\"721\":1,\"750\":1,\"762\":1,\"801\":1,\"818\":1,\"820\":1,\"853\":1,\"854\":1,\"858\":1,\"868\":1,\"883\":1}}],[\"mirrored\",{\"1\":{\"212\":1}}],[\"mirror位于节点b上\",{\"1\":{\"192\":1}}],[\"mirroring\",{\"1\":{\"181\":1,\"212\":1}}],[\"mirror\",{\"1\":{\"180\":1,\"185\":1,\"186\":1,\"188\":2,\"205\":3,\"225\":1}}],[\"might\",{\"1\":{\"157\":1}}],[\"millis\",{\"1\":{\"690\":2}}],[\"milliseconds\",{\"1\":{\"9\":1,\"381\":1,\"389\":1,\"435\":1,\"490\":1,\"541\":1,\"568\":4,\"721\":1,\"745\":1}}],[\"mills\",{\"1\":{\"690\":4}}],[\"milk\",{\"1\":{\"27\":7}}],[\"minute\",{\"1\":{\"595\":6}}],[\"minutes\",{\"1\":{\"481\":1,\"568\":1,\"597\":2}}],[\"minoffset=\",{\"1\":{\"690\":3}}],[\"minoffset\",{\"1\":{\"391\":4,\"392\":3,\"694\":9}}],[\"minlogicoffset\",{\"1\":{\"285\":1}}],[\"min\",{\"1\":{\"11\":3,\"193\":2,\"253\":1,\"314\":1,\"381\":1,\"694\":3}}],[\"microbenchmark\",{\"1\":{\"2\":1,\"15\":2}}],[\"may\",{\"1\":{\"665\":1,\"693\":1,\"852\":1}}],[\"maybe\",{\"1\":{\"285\":2,\"539\":1,\"567\":1,\"642\":1,\"695\":1,\"745\":1,\"790\":1}}],[\"massage\",{\"1\":{\"573\":1}}],[\"masteraddr\",{\"1\":{\"491\":4}}],[\"master将查找到的数据发送给slave\",{\"1\":{\"249\":1}}],[\"master查询开始位置对应的mappedfile\",{\"1\":{\"249\":1}}],[\"master收到后确认给slave发送数据的开始位置\",{\"1\":{\"249\":1}}],[\"master发布的消息是依次经过所有slave节点\",{\"1\":{\"207\":1}}],[\"masters\",{\"1\":{\"193\":2}}],[\"master\",{\"1\":{\"122\":1,\"193\":4,\"205\":1,\"249\":2,\"250\":1,\"373\":1,\"485\":1,\"491\":5,\"595\":2,\"693\":5,\"720\":3,\"746\":1}}],[\"mark\",{\"0\":{\"820\":1},\"1\":{\"819\":6,\"820\":5}}],[\"markbitcas\",{\"1\":{\"796\":1,\"797\":1}}],[\"markprotocoltype\",{\"1\":{\"414\":1}}],[\"markresponsetype\",{\"1\":{\"340\":1}}],[\"madv\",{\"1\":{\"402\":1}}],[\"madvise\",{\"1\":{\"402\":2}}],[\"magic\",{\"1\":{\"257\":2}}],[\"magiccode\",{\"1\":{\"257\":2}}],[\"manager\",{\"1\":{\"467\":1,\"481\":1,\"851\":2}}],[\"manualdeletefileseveraltimes\",{\"1\":{\"390\":4}}],[\"manualdelete\",{\"1\":{\"390\":3}}],[\"manual\",{\"1\":{\"191\":1}}],[\"manually\",{\"1\":{\"185\":2}}],[\"manymessagetransfer\",{\"1\":{\"693\":1}}],[\"manypullrequest\",{\"1\":{\"335\":2,\"342\":3,\"345\":1}}],[\"many\",{\"1\":{\"21\":2,\"240\":1,\"251\":1,\"693\":2}}],[\"machine\",{\"1\":{\"693\":1}}],[\"mac\",{\"1\":{\"138\":1}}],[\"macro\",{\"1\":{\"64\":3,\"157\":1}}],[\"macro1\",{\"1\":{\"63\":2}}],[\"macronname\",{\"1\":{\"63\":1}}],[\"match\",{\"1\":{\"345\":5,\"406\":1,\"424\":1,\"480\":1,\"520\":2}}],[\"matched\",{\"1\":{\"287\":1,\"693\":2,\"694\":4,\"695\":2,\"790\":2,\"852\":1}}],[\"matchspec是一个模式\",{\"1\":{\"111\":1}}],[\"matchspec\",{\"1\":{\"111\":1}}],[\"math\",{\"1\":{\"46\":1,\"314\":1,\"381\":1,\"572\":2,\"665\":2,\"694\":1,\"789\":1}}],[\"makelogicsqueueerror\",{\"1\":{\"817\":1}}],[\"makesurestateok\",{\"1\":{\"570\":1,\"690\":1}}],[\"makecustomheadertonet\",{\"1\":{\"413\":1,\"414\":2}}],[\"makefile\",{\"0\":{\"75\":1}}],[\"make\",{\"1\":{\"68\":1,\"787\":1}}],[\"maketest\",{\"1\":{\"31\":2}}],[\"mapedbuffer\",{\"1\":{\"790\":2}}],[\"map类型\",{\"1\":{\"519\":1}}],[\"map<long\",{\"1\":{\"491\":1,\"880\":1}}],[\"map<string\",{\"1\":{\"198\":1,\"345\":1,\"348\":1,\"484\":1,\"517\":5,\"518\":6,\"519\":1,\"520\":2,\"540\":1,\"541\":1,\"576\":1,\"662\":1,\"817\":2,\"838\":2,\"852\":2}}],[\"maplenindex\",{\"1\":{\"414\":3}}],[\"mapmode\",{\"1\":{\"400\":1}}],[\"map的key如果为空\",{\"1\":{\"342\":1}}],[\"maps\",{\"1\":{\"42\":2,\"289\":2,\"391\":2}}],[\"map或filter就能创建列表的表达式\",{\"1\":{\"34\":1}}],[\"map\",{\"0\":{\"33\":1,\"40\":1,\"42\":1,\"261\":1},\"1\":{\"31\":3,\"33\":5,\"40\":1,\"42\":2,\"67\":1,\"260\":2,\"261\":3,\"262\":1,\"345\":1,\"364\":1,\"400\":2,\"414\":4,\"424\":2,\"491\":1,\"515\":6,\"517\":1,\"520\":1,\"541\":2,\"640\":1,\"662\":1,\"720\":1,\"721\":6,\"732\":1,\"768\":1,\"773\":2,\"783\":4,\"797\":1,\"798\":7,\"851\":4,\"852\":1}}],[\"mappedfileoffset\",{\"1\":{\"291\":6}}],[\"mappedfilesize\",{\"1\":{\"291\":1}}],[\"mappedfilesizelogics\",{\"1\":{\"291\":3}}],[\"mappedfiles\",{\"1\":{\"291\":6}}],[\"mappedfile\",{\"0\":{\"859\":1,\"862\":1,\"863\":1,\"864\":1},\"1\":{\"285\":11,\"288\":1,\"291\":11,\"307\":1,\"310\":3,\"317\":2,\"390\":8,\"400\":2,\"402\":5,\"432\":1,\"816\":1,\"859\":1}}],[\"mappedfilequeue\",{\"0\":{\"859\":1},\"1\":{\"266\":1,\"285\":3,\"291\":4,\"390\":1}}],[\"mapped\",{\"1\":{\"16\":1,\"291\":1,\"400\":2}}],[\"mappedbytebuffer的一点优化\",{\"1\":{\"16\":1}}],[\"mappedbytebuffer\",{\"1\":{\"2\":1,\"16\":3,\"256\":1,\"317\":11,\"400\":1,\"402\":5,\"430\":1}}],[\"maxretries\",{\"1\":{\"817\":9}}],[\"maxreconsumetimes\",{\"1\":{\"573\":3,\"718\":4}}],[\"maxlmqconsumequeuenum\",{\"1\":{\"694\":1}}],[\"maxspan=\",{\"1\":{\"690\":1}}],[\"maxdirectmemorysize=15g\",{\"1\":{\"600\":1}}],[\"maxpendinglimit=\",{\"1\":{\"380\":1}}],[\"maxpendinglimit\",{\"1\":{\"380\":3}}],[\"maxphyoffsetpulling\",{\"1\":{\"287\":1,\"694\":4}}],[\"maxphysicoffset=\",{\"1\":{\"285\":1}}],[\"maxphysicoffset\",{\"1\":{\"285\":3,\"291\":1}}],[\"maxoffsetpy\",{\"1\":{\"694\":4}}],[\"maxoffset=\",{\"1\":{\"690\":3}}],[\"maxoffset\",{\"1\":{\"345\":3,\"694\":9,\"808\":1}}],[\"maxnums\",{\"1\":{\"637\":1,\"691\":3}}],[\"maxnum\",{\"1\":{\"309\":1,\"310\":1,\"314\":8,\"317\":4,\"684\":1}}],[\"maxindexnum\",{\"1\":{\"307\":1}}],[\"maximum\",{\"1\":{\"257\":2,\"287\":1,\"694\":1}}],[\"maxhashslotnum\",{\"1\":{\"307\":1}}],[\"maxextaddr\",{\"1\":{\"291\":4}}],[\"maxfiltermessagecount\",{\"1\":{\"287\":1,\"694\":2}}],[\"maxmsgsize\",{\"1\":{\"541\":1}}],[\"maxmsgnums\",{\"1\":{\"277\":1,\"287\":2,\"694\":5}}],[\"maxmessagesize\",{\"1\":{\"257\":6}}],[\"maxblank\",{\"1\":{\"257\":1,\"258\":1}}],[\"max=\",{\"1\":{\"242\":1}}],[\"max\",{\"1\":{\"11\":2,\"32\":5,\"36\":2,\"38\":1,\"242\":2,\"257\":2,\"291\":1,\"317\":3,\"390\":1,\"573\":1,\"665\":2,\"690\":1,\"693\":1,\"694\":1,\"695\":1,\"715\":1,\"749\":1,\"750\":1,\"761\":1,\"795\":1}}],[\"maven\",{\"0\":{\"7\":1},\"1\":{\"7\":2}}],[\"mainloop\",{\"1\":{\"158\":3}}],[\"main\",{\"1\":{\"2\":1,\"74\":1,\"122\":2,\"276\":1,\"326\":1,\"332\":1,\"467\":1,\"504\":1,\"505\":1,\"599\":1,\"768\":1}}],[\"mqtt\",{\"1\":{\"804\":3,\"810\":1,\"811\":1}}],[\"mqtracecontext\",{\"1\":{\"576\":3}}],[\"mqtrace\",{\"1\":{\"539\":1}}],[\"mqlocktable\",{\"1\":{\"732\":1,\"734\":1,\"742\":3}}],[\"mqs\",{\"1\":{\"720\":5,\"742\":5}}],[\"mqset\",{\"1\":{\"663\":13,\"664\":4,\"744\":4,\"786\":4}}],[\"mqselected\",{\"1\":{\"570\":3}}],[\"mqdivided\",{\"1\":{\"665\":2}}],[\"mqallsize=\",{\"1\":{\"663\":1}}],[\"mqall\",{\"1\":{\"663\":4,\"665\":2,\"786\":5,\"787\":8}}],[\"mqadminext\",{\"1\":{\"768\":4}}],[\"mqadmin\",{\"0\":{\"528\":1},\"1\":{\"528\":1,\"556\":1,\"636\":2,\"767\":1,\"768\":1}}],[\"mqxxxxconsumer\",{\"1\":{\"638\":1}}],[\"mqpushconsumer\",{\"1\":{\"637\":1}}],[\"mqpullconsumer\",{\"1\":{\"637\":1}}],[\"mqproducerimpl\",{\"1\":{\"558\":1}}],[\"mqconsumerinner\",{\"1\":{\"638\":1}}],[\"mqconsumer\",{\"1\":{\"636\":2}}],[\"mqclientmanager\",{\"1\":{\"567\":1,\"642\":1}}],[\"mqclientfactory\",{\"1\":{\"567\":4,\"571\":2,\"573\":7,\"638\":1,\"642\":10,\"660\":1,\"663\":3,\"691\":4,\"717\":3,\"720\":6,\"746\":3}}],[\"mqclientapiipml\",{\"1\":{\"560\":1}}],[\"mqclientapiimpl\",{\"0\":{\"681\":1},\"1\":{\"556\":1,\"562\":2,\"568\":3,\"640\":1,\"643\":2,\"734\":1}}],[\"mqclientinstnace\",{\"1\":{\"556\":1,\"629\":1,\"630\":1,\"638\":1}}],[\"mqclientinstance\",{\"0\":{\"643\":1,\"692\":1},\"1\":{\"470\":2,\"476\":2,\"556\":4,\"557\":5,\"562\":1,\"567\":5,\"568\":6,\"573\":1,\"631\":1,\"632\":2,\"638\":1,\"640\":2,\"643\":1,\"711\":1,\"755\":3}}],[\"mqclientexception\",{\"0\":{\"568\":1},\"1\":{\"504\":1,\"505\":1,\"567\":3,\"568\":3,\"570\":5,\"573\":2,\"642\":4,\"643\":3,\"690\":1,\"691\":4,\"717\":2,\"720\":2}}],[\"mqbroker\",{\"1\":{\"595\":3,\"599\":4,\"600\":3}}],[\"mqbrokerexception\",{\"1\":{\"570\":2,\"573\":1,\"691\":2,\"692\":1,\"717\":2,\"720\":1}}],[\"mqfaultstrategy\",{\"1\":{\"561\":1,\"572\":1}}],[\"mqnamesrv\",{\"1\":{\"480\":1,\"595\":1,\"599\":2}}],[\"mqversion\",{\"1\":{\"480\":1,\"691\":1,\"718\":1}}],[\"mq\",{\"1\":{\"0\":1,\"15\":1,\"16\":1,\"112\":1,\"124\":1,\"136\":1,\"140\":1,\"161\":1,\"173\":1,\"179\":1,\"212\":1,\"224\":1,\"237\":1,\"263\":1,\"294\":1,\"318\":1,\"349\":1,\"368\":1,\"381\":1,\"392\":1,\"404\":1,\"437\":1,\"458\":1,\"494\":1,\"521\":1,\"542\":1,\"544\":1,\"570\":7,\"572\":10,\"573\":10,\"577\":1,\"587\":1,\"604\":1,\"625\":1,\"643\":1,\"664\":25,\"665\":1,\"691\":12,\"693\":5,\"695\":1,\"715\":2,\"720\":17,\"721\":1,\"737\":1,\"742\":9,\"744\":21,\"745\":7,\"746\":7,\"750\":3,\"762\":1,\"787\":3,\"801\":1,\"808\":3,\"818\":1,\"820\":1,\"848\":3,\"853\":1,\"854\":1,\"858\":1,\"868\":1,\"883\":1}}],[\"欢迎关注公众号\",{\"1\":{\"0\":1,\"15\":1,\"16\":1,\"112\":1,\"124\":1,\"136\":1,\"140\":1,\"161\":1,\"173\":1,\"179\":1,\"212\":1,\"224\":1,\"237\":1,\"263\":1,\"294\":1,\"318\":1,\"349\":1,\"368\":1,\"381\":1,\"392\":1,\"404\":1,\"437\":1,\"458\":1,\"494\":1,\"521\":1,\"542\":1,\"577\":1,\"587\":1,\"604\":1,\"625\":1,\"643\":1,\"665\":1,\"695\":1,\"721\":1,\"750\":1,\"762\":1,\"801\":1,\"818\":1,\"820\":1,\"853\":1,\"854\":1,\"858\":1,\"868\":1,\"883\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
