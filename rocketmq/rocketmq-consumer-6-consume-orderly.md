# RocketMQ 消费者（6）顺序消费 流程详解 & 源码解析

## 1. 背景

本文是 RocketMQ 消费者系列的第六篇，上一篇主要介绍并发消费，而本片主要介绍 RocketMQ 顺序消费的设计和流程。

我把 RocketMQ 消费分成如下几个步骤

1. 重平衡
2. 消费者拉取消息
3. Broker 接收拉取请求后从存储中查询消息并返回
4. 消费者消费消息

顺序消息逻辑主要在步骤 4 当中承载，然而为了能够实现顺序的消费，在步骤 1 和 2 中就需要有相应的操作以锁定消费队列，确保顺序消费。

---

RocketMQ 支持 2 种消费方式，即并发消费和顺序消费。

并发消费是比较常用的一种消费方式。并发有两层含义：

1. 队列间并发消费：一个 Topic 可以有 N 个队列，每个队列都可以被一个消费者消费，最多可以有 N 个消费者同时进行消费
2. 队列中的多个消息并发消费：消费者执行消费逻辑时，使用一个消费线程池进行消费，该线程池默认有 20 个线程同时进行消费，所以也有可能并发消费一个队列中的多个消息

由于 RocketMQ 的 Topic 和队列的设计，让同一 Topic 下的并发消费无法避免，因为只要有多个队列让多个消费者同时消费，就必定存在并发消费。所以 RocketMQ 仅支持单个队列中的消息的顺序消费。

如果要做到 Topic 维度严格的顺序，那么需要将 Topic 的队列数设为 1。

## 2. 概要设计

上面讲过，RocketMQ 的顺序消费，需要保证单个队列中的消息顺序消费。我们不妨思考一下如何将并发消费的逻辑改成能够实现顺序消费。

由于并发消费是用一个消费线程池并发消费，那么要改进的第一个问题很容易就能想到

1. 执行消费逻辑时，避免多线程并行消费同一个队列

### 2.1 顺序消费 消费线程池逻辑

顺序消费消费线程池的逻辑需要保证同一个队列同时只有一个线程去消费。最简单的想法就是将其改为单线程消费，那么绝对可以保证顺序消费。但是如此一来，只要有一个消息的消费逻辑阻塞，这个消费者就整个被阻塞了，完全失去了并行性，对于 CPU 资源的利用率和很低。

#### 2.1.1 消费线程池顺序消费逻辑

RocketMQ 的做法是，不再让消费线程池以消息批的维度去消费，而是让每个消费线程都去消费一个消息队列，并持续消费一段时间。消费时间限制是为了防止某些消息很多的队列一直占用消费线程池，导致其他队列没有机会被消费。

某个消息队列拉取到消息，不会将消息直接提交给消费线程池，而是存在这个消息队列的处理队列中，然后将这个处理队列提交给一个消费线程去消费。消费线程每次从处理队列中取一批消息（默认一条）进行消费，然后判断消费时间是否超过阈值（1分钟）。如果队列中消息已被消费完或者消费时间已到，则退出这个消费任务，此时其他队列的消费请求被提交到消费线程，其他队列有机会被消费。

#### 2.1.2 保证一个队列同时仅被一个消费线程消费

在上述逻辑的基础上，可能存在同时有多个同一队列的消费请求被提交到消费线程池的情况，需要保证一个队列最多仅被一个线程消费。

RocketMQ 为每个消息队列都初始化一把锁（**消息队列锁**），消费任务开始时获取锁，消费任务结束时释放锁，用这把锁来保证就算有多个线程同时消费一个队列，但同时最多只有一个线程真正在执行消费（其他线程都在等待锁释放）。

> 这个实现可能导致消费线程池中多个线程同时等待一把锁，似乎是一个可以优化的点。比如通过修改消息拉取线程， 保证该队列消费完之前不拉取新的消息（拉取消息前判断该队列的消息是否被消费完，如果未被消费完则跳过拉取操作，将该拉取请求放入拉取队列末尾）

---

保证线程池顺序消费就可以实现顺序消费了吗？NO。顺序消费还有一个敌人——重平衡，也就是需要改进的第二个问题。

2. 重平衡时可能会将一个队列的消费负载从一个消费者切换到另一个消费者。一个消费任务持续 1 分钟，老消费者的消费任务可能还没有结束，新消费者开始消费，这样也存在两个消费者同时消费一个队列的情况。

### 2.2 重平衡时顺序消费

这个问题也可以通过加锁来解决，要让两个互不相连的消费者互斥，锁要由 Broker 来保存和管理。我们姑且把这个锁叫做 **Broker锁**。

消费者在重平衡后，对于新分配到的队列，会尝试向 Broker 请求 **Broker锁** ；丢弃的队列则向 Broker 释放锁。如果请求到锁才开始拉取，请求不到则等到下次重平衡再次请求。

**Broker锁** 在 Broker 端被设了过期时间，1 分钟不更新则过期。顺序消费服务的定时任务会每 20s 向 Broker 发送请求，请求和更新自己负载的消费队列的 **Broker锁**。

在消息拉取和顺序消费服务每消费一批消息前，都会判断是否持有 **Broker锁**，来保证没有多个消费者在重平衡后同时消费一个队列。

还有一个**消费锁**，用来保证在有消息正在被顺序消费时，不能释放 **Broker锁**。

## 3. 详细设计



## 4. 源码解析